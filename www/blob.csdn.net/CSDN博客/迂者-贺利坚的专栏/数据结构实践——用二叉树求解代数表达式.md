
# 数据结构实践——用二叉树求解代数表达式 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月01日 11:51:22[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：9564


本文是针对[数据结构基础系列(6)：树和二叉树](http://edu.csdn.net/course/detail/1553)的配套实践。
【项目 - 用二叉树求解代数表达式】
用二叉树来表示代数表达式，树的每一个分支节点代表一个运算符，每一个叶子节点代表一个运算数（为简化，只支持二目运算的+、-、*、/，不加括号，运算数也只是一位的数字字符。本项目只考虑输入合乎以上规则的情况）。请设计算法，（1）根据形如“$1+2*3-4/5$”的字符串代表的表达式，构造出对应的二叉树（如图），用后序遍历的思路计算表达式的值时，能体现出先乘除后加减的规则；（2）对构造出的二叉树，计算出表达式的值。
![这里写图片描述](https://img-blog.csdn.net/20151101114950696)
[参考解答] 程序中的btree.h，见[二叉树算法库](http://blog.csdn.net/sxhelijian/article/details/49250581)。
```python
#include <stdio.h>
```
```python
#include <string.h>
```
```python
#include <malloc.h>
```
```python
#include "btree.h"
```
```python
//用s[i]到s[j]之间的字符串，构造二叉树的表示形式
```
```python
BTNode *CRTree(
```
```python
char
```
```python
s[],
```
```python
int
```
```python
i,
```
```python
int
```
```python
j)
{
    BTNode *p;
```
```python
int
```
```python
k,plus=
```
```python
0
```
```python
,posi;
```
```python
if
```
```python
(i==j)
```
```python
//i和j相同，意味着只有一个字符，构造的是一个叶子节点
```
```python
{
        p=(BTNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(BTNode));
```
```python
//分配存储空间
```
```python
p->data=s[i];
```
```python
//值为s[i]
```
```python
p->lchild=NULL;
        p->rchild=NULL;
```
```python
return
```
```python
p;
    }
```
```python
//以下为i!=j的情况
```
```python
for
```
```python
(k=i; k<=j; k++)
```
```python
if
```
```python
(s[k]==
```
```python
'+'
```
```python
|| s[k]==
```
```python
'-'
```
```python
)
        {
            plus++;
            posi=k;
```
```python
//最后一个+或-的位置
```
```python
}
```
```python
if
```
```python
(plus==
```
```python
0
```
```python
)
```
```python
//没有+或-的情况(因为若有+、-，前面必会执行plus++)
```
```python
for
```
```python
(k=i; k<=j; k++)
```
```python
if
```
```python
(s[k]==
```
```python
'*'
```
```python
|| s[k]==
```
```python
'/'
```
```python
)
            {
                plus++;
                posi=k;
            }
```
```python
//以上的处理考虑了优先将+、-放到二叉树较高的层次上
```
```python
//由于将来计算时，运用的是后序遍历的思路
```
```python
//处于较低层的乘除会优先运算
```
```python
//从而体现了“先乘除后加减”的运算法则
```
```python
//创建一个分支节点，用检测到的运算符作为节点值
```
```python
if
```
```python
(plus!=
```
```python
0
```
```python
)
    {
        p=(BTNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(BTNode));
        p->data=s[posi];
```
```python
//节点值是s[posi]
```
```python
p->lchild=CRTree(s,i,posi-
```
```python
1
```
```python
);
```
```python
//左子树由s[i]至s[posi-1]构成
```
```python
p->rchild=CRTree(s,posi+
```
```python
1
```
```python
,j);
```
```python
//右子树由s[poso+1]到s[j]构成
```
```python
return
```
```python
p;
    }
```
```python
else
```
```python
//若没有任何运算符，返回NULL
```
```python
return
```
```python
NULL;
}
```
```python
double
```
```python
Comp(BTNode *b)
{
```
```python
double
```
```python
v1,v2;
```
```python
if
```
```python
(b==NULL)
```
```python
return
```
```python
0
```
```python
;
```
```python
if
```
```python
(b->lchild==NULL && b->rchild==NULL)
```
```python
//叶子节点，应该是一个数字字符（本项目未考虑非法表达式）
```
```python
return
```
```python
b->data-
```
```python
'0'
```
```python
;
```
```python
//叶子节点直接返回节点值，结点中保存的数字用的是字符形式，所以要-'0'
```
```python
v1=Comp(b->lchild);
```
```python
//先计算左子树
```
```python
v2=Comp(b->rchild);
```
```python
//再计算右子树
```
```python
switch
```
```python
(b->data)
```
```python
//将左、右子树运算的结果再进行运算，运用的是后序遍历的思路
```
```python
{
```
```python
case
```
```python
'+'
```
```python
:
```
```python
return
```
```python
v1+v2;
```
```python
case
```
```python
'-'
```
```python
:
```
```python
return
```
```python
v1-v2;
```
```python
case
```
```python
'*'
```
```python
:
```
```python
return
```
```python
v1*v2;
```
```python
case
```
```python
'/'
```
```python
:
```
```python
if
```
```python
(v2!=
```
```python
0
```
```python
)
```
```python
return
```
```python
v1/v2;
```
```python
else
```
```python
abort
```
```python
();
    }
}
```
```python
int
```
```python
main()
{
    BTNode *b;
```
```python
char
```
```python
s[MaxSize]=
```
```python
"1+2*3-4/5"
```
```python
;
```
```python
printf
```
```python
(
```
```python
"代数表达式%s\n"
```
```python
,s);
    b=CRTree(s,
```
```python
0
```
```python
,
```
```python
strlen
```
```python
(s)-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"对应二叉树:"
```
```python
);
    DispBTNode(b);
```
```python
printf
```
```python
(
```
```python
"\n表达式的值:%g\n"
```
```python
,Comp(b));
    DestroyBTNode(b);
```
```python
return
```
```python
0
```
```python
;
}
```

