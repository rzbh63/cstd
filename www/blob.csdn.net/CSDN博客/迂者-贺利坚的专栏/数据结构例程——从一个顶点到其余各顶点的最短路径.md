
# 数据结构例程——从一个顶点到其余各顶点的最短路径 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月07日 10:37:18[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：4937


本文是[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]中第13课时[[从一个顶点到其余各顶点的最短路径](http://edu.csdn.net/course/detail/1595/24603)]的例程。
（程序中graph.h是图存储结构的“算法库”中的头文件，详情请[单击链接…](http://blog.csdn.net/sxhelijian/article/details/49591419)）
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
#define MaxSize 100
```
```python
void
```
```python
Ppath(
```
```python
int
```
```python
path[],
```
```python
int
```
```python
i,
```
```python
int
```
```python
v)
```
```python
//前向递归查找路径上的顶点
```
```python
{
```
```python
int
```
```python
k;
    k=path[i];
```
```python
if
```
```python
(k==v)
```
```python
return
```
```python
;
```
```python
//找到了起点则返回
```
```python
Ppath(path,k,v);
```
```python
//找顶点k的前一个顶点
```
```python
printf
```
```python
(
```
```python
"%d,"
```
```python
,k);
```
```python
//输出顶点k
```
```python
}
```
```python
void
```
```python
Dispath(
```
```python
int
```
```python
dist[],
```
```python
int
```
```python
path[],
```
```python
int
```
```python
s[],
```
```python
int
```
```python
n,
```
```python
int
```
```python
v)
{
```
```python
int
```
```python
i;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
if
```
```python
(s[i]==
```
```python
1
```
```python
)
        {
```
```python
printf
```
```python
(
```
```python
"  从%d到%d的最短路径长度为:%d\t路径为:"
```
```python
,v,i,dist[i]);
```
```python
printf
```
```python
(
```
```python
"%d,"
```
```python
,v);
```
```python
//输出路径上的起点
```
```python
Ppath(path,i,v);
```
```python
//输出路径上的中间点
```
```python
printf
```
```python
(
```
```python
"%d\n"
```
```python
,i);
```
```python
//输出路径上的终点
```
```python
}
```
```python
else
```
```python
printf
```
```python
(
```
```python
"从%d到%d不存在路径\n"
```
```python
,v,i);
}
```
```python
void
```
```python
Dijkstra(MGraph g,
```
```python
int
```
```python
v)
{
```
```python
int
```
```python
dist[MAXV],path[MAXV];
```
```python
int
```
```python
s[MAXV];
```
```python
int
```
```python
mindis,i,j,u;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
    {
        dist[i]=g.edges[v][i];
```
```python
//距离初始化
```
```python
s[i]=
```
```python
0
```
```python
;
```
```python
//s[]置空
```
```python
if
```
```python
(g.edges[v][i]<INF)
```
```python
//路径初始化
```
```python
path[i]=v;
```
```python
else
```
```python
path[i]=-
```
```python
1
```
```python
;
    }
    s[v]=
```
```python
1
```
```python
;
    path[v]=
```
```python
0
```
```python
;
```
```python
//源点编号v放入s中
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//循环直到所有顶点的最短路径都求出
```
```python
{
        mindis=INF;
```
```python
//mindis置最小长度初值
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
```
```python
//选取不在s中且具有最小距离的顶点u
```
```python
if
```
```python
(s[j]==
```
```python
0
```
```python
&& dist[j]<mindis)
            {
                u=j;
                mindis=dist[j];
            }
        s[u]=
```
```python
1
```
```python
;
```
```python
//顶点u加入s中
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
```
```python
//修改不在s中的顶点的距离
```
```python
if
```
```python
(s[j]==
```
```python
0
```
```python
)
```
```python
if
```
```python
(g.edges[u][j]<INF && dist[u]+g.edges[u][j]<dist[j])
                {
                    dist[j]=dist[u]+g.edges[u][j];
                    path[j]=u;
                }
    }
    Dispath(dist,path,s,g.n,v);
```
```python
//输出最短路径
```
```python
}
```
```python
int
```
```python
main()
{
    MGraph g;
```
```python
int
```
```python
A[
```
```python
7
```
```python
][
```
```python
7
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
4
```
```python
,
```
```python
6
```
```python
,
```
```python
6
```
```python
,INF,INF,INF},
        {INF,
```
```python
0
```
```python
,
```
```python
1
```
```python
,INF,
```
```python
7
```
```python
,INF,INF},
        {INF,INF,
```
```python
0
```
```python
,INF,
```
```python
6
```
```python
,
```
```python
4
```
```python
,INF},
        {INF,INF,
```
```python
2
```
```python
,
```
```python
0
```
```python
,INF,
```
```python
5
```
```python
,INF},
        {INF,INF,INF,INF,
```
```python
0
```
```python
,INF,
```
```python
6
```
```python
},
        {INF,INF,INF,INF,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
8
```
```python
},
        {INF,INF,INF,INF,INF,INF,
```
```python
0
```
```python
}
    };
    ArrayToMat(A[
```
```python
0
```
```python
],
```
```python
7
```
```python
, g);
    Dijkstra(g,
```
```python
0
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试用图结构
![这里写图片描述](https://img-blog.csdn.net/20151107103647234)

