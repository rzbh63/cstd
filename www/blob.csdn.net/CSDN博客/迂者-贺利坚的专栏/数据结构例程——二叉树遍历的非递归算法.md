
# 数据结构例程——二叉树遍历的非递归算法 - 迂者-贺利坚的专栏 - CSDN博客

2015年10月19日 21:35:03[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：1976


本文是[数据结构基础系列(6)：树和二叉树](http://edu.csdn.net/course/detail/1553)中第11课时[二叉树遍历非递归算法](http://edu.csdn.net/course/detail/1553/24076)的例程。
【二叉树遍历的非递归算法】
实现二叉树的先序、中序、后序遍历的非递归算法，并对用”A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))”创建的二叉树进行测试。
请利用[二叉树算法库](http://blog.csdn.net/sxhelijian/article/details/49250581)。
［参考解答］（btreee.h见[算法库](http://blog.csdn.net/sxhelijian/article/details/49250581)）
```python
#include <stdio.h>
```
```python
#include "btree.h"
```
```python
void
```
```python
PreOrder1(BTNode *b)
{
    BTNode *St[MaxSize],*p;
```
```python
int
```
```python
top=-
```
```python
1
```
```python
;
```
```python
if
```
```python
(b!=NULL)
    {
        top++;
```
```python
//根节点入栈
```
```python
St[top]=b;
```
```python
while
```
```python
(top>-
```
```python
1
```
```python
)
```
```python
//栈不为空时循环
```
```python
{
            p=St[top];
```
```python
//退栈并访问该节点
```
```python
top--;
```
```python
printf
```
```python
(
```
```python
"%c "
```
```python
,p->data);
```
```python
if
```
```python
(p->rchild!=NULL)
```
```python
//右孩子入栈
```
```python
{
                top++;
                St[top]=p->rchild;
            }
```
```python
if
```
```python
(p->lchild!=NULL)
```
```python
//左孩子入栈
```
```python
{
                top++;
                St[top]=p->lchild;
            }
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
void
```
```python
InOrder1(BTNode *b)
{
    BTNode *St[MaxSize],*p;
```
```python
int
```
```python
top=-
```
```python
1
```
```python
;
```
```python
if
```
```python
(b!=NULL)
    {
        p=b;
```
```python
while
```
```python
(top>-
```
```python
1
```
```python
|| p!=NULL)
        {
```
```python
while
```
```python
(p!=NULL)
            {
                top++;
                St[top]=p;
                p=p->lchild;
            }
```
```python
if
```
```python
(top>-
```
```python
1
```
```python
)
            {
                p=St[top];
                top--;
```
```python
printf
```
```python
(
```
```python
"%c "
```
```python
,p->data);
                p=p->rchild;
            }
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
void
```
```python
PostOrder1(BTNode *b)
{
    BTNode *St[MaxSize];
    BTNode *p;
```
```python
int
```
```python
flag,top=-
```
```python
1
```
```python
;
```
```python
//栈指针置初值
```
```python
if
```
```python
(b!=NULL)
    {
```
```python
do
```
```python
{
```
```python
while
```
```python
(b!=NULL)
```
```python
//将t的所有左节点入栈
```
```python
{
                top++;
                St[top]=b;
                b=b->lchild;
            }
            p=NULL;
```
```python
//p指向当前节点的前一个已访问的节点
```
```python
flag=
```
```python
1
```
```python
;
```
```python
while
```
```python
(top!=-
```
```python
1
```
```python
&& flag)
            {
                b=St[top];
```
```python
//取出当前的栈顶元素
```
```python
if
```
```python
(b->rchild==p)
```
```python
//右子树不存在或已被访问,访问之
```
```python
{
```
```python
printf
```
```python
(
```
```python
"%c "
```
```python
,b->data);
```
```python
//访问*b节点
```
```python
top--;
                    p=b;
```
```python
//p指向则被访问的节点
```
```python
}
```
```python
else
```
```python
{
                    b=b->rchild;
```
```python
//t指向右子树
```
```python
flag=
```
```python
0
```
```python
;
                }
            }
        }
```
```python
while
```
```python
(top!=-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
int
```
```python
main()
{
    BTNode *b;
    CreateBTNode(b,
```
```python
"A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"二叉树b: "
```
```python
);
    DispBTNode(b);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"先序遍历序列:\n"
```
```python
);
    PreOrder1(b);
```
```python
printf
```
```python
(
```
```python
"中序遍历序列:\n"
```
```python
);
    InOrder1(b);
```
```python
printf
```
```python
(
```
```python
"后序遍历序列:\n"
```
```python
);
    PostOrder1(b);
    DestroyBTNode(b);
```
```python
return
```
```python
0
```
```python
;
}
```
注：在main函数中，创建的用于测试的二叉树如下——
![这里写图片描述](https://img-blog.csdn.net/20151019153602522)

