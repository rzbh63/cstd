
# 使用栈来实现二叉树的反转(invert) - Multiangle's Notepad - CSDN博客


2016年04月06日 16:51:42[multiangle](https://me.csdn.net/u014595019)阅读数：1399


最近在刷leetcode,碰到这样一道题
![这里写图片描述](https://img-blog.csdn.net/20160406164427331)
这题并不难，如果用递归的话半分钟就能搞定。不过感觉递归效率比较低，因为递归可以用栈来实现，于是琢磨能不能用栈来搞定。
这是用递归的解法:
```python
// 递归算法
```
```python
public
```
```python
TreeNode
```
```python
invertTree
```
```python
(TreeNode root) {
```
```python
if
```
```python
(root==
```
```python
null
```
```python
)
```
```python
return
```
```python
null
```
```python
;
        TreeNode temp = root.left ;
        root.left = root.right ;
        root.right = temp ;
        invertTree(root.left) ;
        invertTree(root.right) ;
```
```python
return
```
```python
root ;
    }这里写代码片
```
下面是使用栈实现的解法
```python
// 用栈实现的算法
```
```python
public
```
```python
TreeNode invertTree(TreeNode root){
```
```python
if
```
```python
(root
```
```python
==
```
```python
null
```
```python
)
```
```python
return
```
```python
null
```
```python
;
```
```python
Stack
```
```python
<
```
```python
TreeNode
```
```python
>
```
```python
stack
```
```python
=
```
```python
new
```
```python
Stack
```
```python
<
```
```python
TreeNode
```
```python
>
```
```python
() ;
```
```python
stack
```
```python
.
```
```python
push(root) ;
        TreeNode latestNode
```
```python
=
```
```python
null
```
```python
;
```
```python
while
```
```python
(
```
```python
!
```
```python
stack
```
```python
.
```
```python
isEmpty()){
            TreeNode node
```
```python
=
```
```python
stack
```
```python
.
```
```python
peek() ;
```
```python
if
```
```python
(node
```
```python
.
```
```python
left
```
```python
==
```
```python
null
```
```python
){
```
```python
if
```
```python
(node
```
```python
.
```
```python
right
```
```python
==
```
```python
null
```
```python
){
```
```python
// 左右为空，这是个叶节点
```
```python
latestNode
```
```python
=
```
```python
stack
```
```python
.
```
```python
pop() ;
                }
```
```python
else
```
```python
if
```
```python
(node
```
```python
.
```
```python
right
```
```python
==
```
```python
latestNode){
```
```python
// 如果右边不为空，且刚出栈，表示该节点处理完毕
```
```python
// 交换左右，并出栈
```
```python
node
```
```python
.
```
```python
left
```
```python
=
```
```python
node
```
```python
.
```
```python
right ;
                    node
```
```python
.
```
```python
right
```
```python
=
```
```python
null
```
```python
;
                    latestNode
```
```python
=
```
```python
stack
```
```python
.
```
```python
pop() ;
                }
```
```python
else
```
```python
{
```
```python
// 否则将右节点压入栈中
```
```python
stack
```
```python
.
```
```python
push(node
```
```python
.
```
```python
right) ;
                }
            }
```
```python
else
```
```python
if
```
```python
(node
```
```python
.
```
```python
right
```
```python
==
```
```python
null
```
```python
){
```
```python
// 这里描述的是左节点不为空，右节点为空的情况
```
```python
if
```
```python
(node
```
```python
.
```
```python
left
```
```python
==
```
```python
latestNode){
```
```python
// 如果左节点刚出栈
```
```python
// 则交换顺序，然后自己也出栈
```
```python
node
```
```python
.
```
```python
right
```
```python
=
```
```python
node
```
```python
.
```
```python
left ;
                    node
```
```python
.
```
```python
left
```
```python
=
```
```python
null
```
```python
;
                    latestNode
```
```python
=
```
```python
stack
```
```python
.
```
```python
pop() ;
                }
```
```python
else
```
```python
{
```
```python
stack
```
```python
.
```
```python
push(node
```
```python
.
```
```python
left) ;
                }
            }
```
```python
else
```
```python
{
```
```python
// 当左右节点均不为空时
```
```python
if
```
```python
(node
```
```python
.
```
```python
right
```
```python
==
```
```python
latestNode){
```
```python
// 右节点刚出栈
```
```python
TreeNode temp
```
```python
=
```
```python
node
```
```python
.
```
```python
left ;
                    temp
```
```python
=
```
```python
node
```
```python
.
```
```python
left ;
                    node
```
```python
.
```
```python
left
```
```python
=
```
```python
node
```
```python
.
```
```python
right ;
                    node
```
```python
.
```
```python
right
```
```python
=
```
```python
temp ;
                    latestNode
```
```python
=
```
```python
stack
```
```python
.
```
```python
pop();
                }
```
```python
else
```
```python
if
```
```python
(node
```
```python
.
```
```python
left
```
```python
==
```
```python
latestNode) {
```
```python
stack
```
```python
.
```
```python
push(node
```
```python
.
```
```python
right) ;
                }
```
```python
else
```
```python
{
```
```python
stack
```
```python
.
```
```python
push(node
```
```python
.
```
```python
left) ;
                }
            }
        }
```
```python
return
```
```python
root ;
    }
```
一个悲伤的消息是。。。改成用栈实现后。。。运行效率更低了=。= 看来java对递归的优化还不错

