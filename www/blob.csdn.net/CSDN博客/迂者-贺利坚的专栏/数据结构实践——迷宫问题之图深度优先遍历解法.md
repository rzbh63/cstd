
# 数据结构实践——迷宫问题之图深度优先遍历解法 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月08日 15:36:59[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：9937


本文是针对[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]的实践项目。
【项目 - 迷宫问题之图深度优先遍历解法】
设计一个程序，采用深度优先遍历算法的思路，解决迷宫问题。
（1）建立迷宫对应的图数据结构，并建立其邻接表表示。
（2）采用深度优先遍历的思路设计算法，输出从入口(1,1)点到出口(M,N)的所有迷宫路径。
[模型建立]
将迷宫中的每一格作为一个顶点，相邻格子可以到达，则对应的顶点之间存在边相连。
例如，下面的迷宫
![这里写图片描述](https://img-blog.csdn.net/20151108152346516)[ ](https://img-blog.csdn.net/20151108152346516)
在使用数组表示时，用０表示格子是空地，用１表示格子处是墙，对应的矩阵是：
[

](https://img-blog.csdn.net/20151108152346516)
```python
int mg[M+
```
```python
2
```
```python
][
```
```python
N
```
```python
+
```
```python
2
```
```python
]=   //迷宫数组
```
```python
{
        {1,1,1,1,1,1}
```
```python
,
```
```python
{1,0,0,0,1,1}
```
```python
,
```
```python
{1,0,1,0,0,1}
```
```python
,
```
```python
{1,0,0,0,1,1}
```
```python
,
```
```python
{1,1,0,0,0,1}
```
```python
,
```
```python
{1,1,1,1,1,1}
```
```python
};
```
[
](https://img-blog.csdn.net/20151108152346516)建立的图结构为：
![这里写图片描述](https://img-blog.csdn.net/20151108153255700)[ ](https://img-blog.csdn.net/20151108153255700)
于是，从(1,1)到(4,4)的迷宫问题，转化为寻找顶点(1,1)到顶点(4,4)的路径的问题。
[
](https://img-blog.csdn.net/20151108153255700)[参考代码]
[

](https://img-blog.csdn.net/20151108153255700)
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#define MaxSize 100
```
```python
#define M 4
```
```python
#define N 4
```
```python
//以下定义邻接表类型
```
```python
typedef
```
```python
struct
```
```python
ANode
```
```python
//边的结点结构类型
```
```python
{
```
```python
int
```
```python
i,j;
```
```python
//该边的终点位置(i,j)
```
```python
struct
```
```python
ANode *nextarc;
```
```python
//指向下一条边的指针
```
```python
} ArcNode;
```
```python
typedef
```
```python
struct
```
```python
Vnode
```
```python
//邻接表头结点的类型
```
```python
{
    ArcNode *firstarc;
```
```python
//指向第一条边
```
```python
} VNode;
```
```python
typedef
```
```python
struct
```
```python
{
    VNode adjlist[M+
```
```python
2
```
```python
][N+
```
```python
2
```
```python
];
```
```python
//邻接表头节点数组
```
```python
} ALGraph;
```
```python
//图的邻接表类型
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
i;
```
```python
//当前方块的行号
```
```python
int
```
```python
j;
```
```python
//当前方块的列号
```
```python
} Box;
```
```python
typedef
```
```python
struct
```
```python
{
    Box data[MaxSize];
```
```python
int
```
```python
length;
```
```python
//路径长度
```
```python
} PathType;
```
```python
//定义路径类型
```
```python
int
```
```python
visited[M+
```
```python
2
```
```python
][N+
```
```python
2
```
```python
]= {
```
```python
0
```
```python
};
```
```python
int
```
```python
count=
```
```python
0
```
```python
;
```
```python
void
```
```python
CreateList(ALGraph *&G,
```
```python
int
```
```python
mg[][N+
```
```python
2
```
```python
])
```
```python
//建立迷宫数组对应的邻接表G
```
```python
{
```
```python
int
```
```python
i,j,i1,j1,di;
    ArcNode *p;
    G=(ALGraph *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(ALGraph));
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M+
```
```python
2
```
```python
; i++)
```
```python
//给邻接表中所有头节点的指针域置初值
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<N+
```
```python
2
```
```python
; j++)
            G->adjlist[i][j].firstarc=NULL;
```
```python
for
```
```python
(i=
```
```python
1
```
```python
; i<=M; i++)
```
```python
//检查mg中每个元素
```
```python
for
```
```python
(j=
```
```python
1
```
```python
; j<=N; j++)
```
```python
if
```
```python
(mg[i][j]==
```
```python
0
```
```python
)
            {
                di=
```
```python
0
```
```python
;
```
```python
while
```
```python
(di<
```
```python
4
```
```python
)
                {
```
```python
switch
```
```python
(di)
                    {
```
```python
case
```
```python
0
```
```python
:
                        i1=i-
```
```python
1
```
```python
;
                        j1=j;
```
```python
break
```
```python
;
```
```python
case
```
```python
1
```
```python
:
                        i1=i;
                        j1=j+
```
```python
1
```
```python
;
```
```python
break
```
```python
;
```
```python
case
```
```python
2
```
```python
:
                        i1=i+
```
```python
1
```
```python
;
                        j1=j;
```
```python
break
```
```python
;
```
```python
case
```
```python
3
```
```python
:
                        i1=i, j1=j-
```
```python
1
```
```python
;
```
```python
break
```
```python
;
                    }
```
```python
if
```
```python
(mg[i1][j1]==
```
```python
0
```
```python
)
```
```python
//(i1,j1)为可走方块
```
```python
{
                        p=(ArcNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(ArcNode));
```
```python
//创建一个节点*p
```
```python
p->i=i1;
                        p->j=j1;
                        p->nextarc=G->adjlist[i][j].firstarc;
```
```python
//将*p节点链到链表后
```
```python
G->adjlist[i][j].firstarc=p;
                    }
                    di++;
                }
            }
}
```
```python
//输出邻接表G
```
```python
void
```
```python
DispAdj(ALGraph *G)
{
```
```python
int
```
```python
i,j;
    ArcNode *p;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M+
```
```python
2
```
```python
; i++)
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<N+
```
```python
2
```
```python
; j++)
        {
```
```python
printf
```
```python
(
```
```python
"  [%d,%d]: "
```
```python
,i,j);
            p=G->adjlist[i][j].firstarc;
```
```python
while
```
```python
(p!=NULL)
            {
```
```python
printf
```
```python
(
```
```python
"(%d,%d)  "
```
```python
,p->i,p->j);
                p=p->nextarc;
            }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
        }
}
```
```python
void
```
```python
FindPath(ALGraph *G,
```
```python
int
```
```python
xi,
```
```python
int
```
```python
yi,
```
```python
int
```
```python
xe,
```
```python
int
```
```python
ye,PathType path)
{
    ArcNode *p;
    visited[xi][yi]=
```
```python
1
```
```python
;
```
```python
//置已访问标记
```
```python
path.data[path.length].i=xi;
    path.data[path.length].j=yi;
    path.length++;
```
```python
if
```
```python
(xi==xe && yi==ye)
    {
```
```python
printf
```
```python
(
```
```python
"  迷宫路径%d: "
```
```python
,++count);
```
```python
for
```
```python
(
```
```python
int
```
```python
k=
```
```python
0
```
```python
; k<path.length; k++)
```
```python
printf
```
```python
(
```
```python
"(%d,%d) "
```
```python
,path.data[k].i,path.data[k].j);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    p=G->adjlist[xi][yi].firstarc;
```
```python
//p指向顶点v的第一条边顶点
```
```python
while
```
```python
(p!=NULL)
    {
```
```python
if
```
```python
(visited[p->i][p->j]==
```
```python
0
```
```python
)
```
```python
//若(p->i,p->j)方块未访问,递归访问它
```
```python
FindPath(G,p->i,p->j,xe,ye,path);
        p=p->nextarc;
```
```python
//p指向顶点v的下一条边顶点
```
```python
}
    visited[xi][yi]=
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
mg[M+
```
```python
2
```
```python
][N+
```
```python
2
```
```python
]=
```
```python
//迷宫数组
```
```python
{
        {
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
}
    };
    CreateList(G,mg);
```
```python
printf
```
```python
(
```
```python
"迷宫对应的邻接表:\n"
```
```python
);
    DispAdj(G);
```
```python
//输出邻接表
```
```python
PathType path;
    path.length=
```
```python
0
```
```python
;
```
```python
printf
```
```python
(
```
```python
"所有的迷宫路径:\n"
```
```python
);
    FindPath(G,
```
```python
1
```
```python
,
```
```python
1
```
```python
,M,N,path);
```
```python
return
```
```python
0
```
```python
;
}
```
[
](https://img-blog.csdn.net/20151108153255700)测试时，换作下面的迷宫试一试：
![这里写图片描述](https://img-blog.csdn.net/20151108153606661)

[
](https://img-blog.csdn.net/20151108153255700)
