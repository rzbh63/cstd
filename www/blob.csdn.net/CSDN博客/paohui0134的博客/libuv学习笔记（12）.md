
# libuv学习笔记（12） - paohui0134的博客 - CSDN博客


2016年06月16日 12:49:25[paohui0134](https://me.csdn.net/paohui0134)阅读数：2304


# libuv学习笔记（12）
## uv_tcp_t数据结构与相关函数(1)
### 数据结构
```python
typedef
```
```python
struct
```
```python
uv_tcp_s uv_tcp_t;
```
```python
struct
```
```python
uv_tcp_s {
  UV_HANDLE_FIELDS
```
```python
//uv_handle_t的成员
```
```python
UV_STREAM_FIELDS
```
```python
//stream的成员
```
```python
//UV_TCP_PRIVATE_FIELDS展开如下：
```
```python
SOCKET socket;
```
```python
int
```
```python
delayed_error;
```
```python
union
```
```python
{
```
```python
struct
```
```python
{
     uv_tcp_accept_t* accept_reqs;
```
```python
//接受请求列表
```
```python
unsigned
```
```python
int
```
```python
processed_accepts;                                           
     uv_tcp_accept_t* pending_accepts;
```
```python
//等待处理的接受请求
```
```python
LPFN_ACCEPTEX func_acceptex;
```
```python
//accetpex的函数指针
```
```python
} serv;
```
```python
struct
```
```python
{
     uv_buf_t read_buffer;
```
```python
//读取数据的缓存
```
```python
LPFN_CONNECTEX func_connectex;
```
```python
//connectex函数指针
```
```python
} conn;                                
  } tcp;
};
```
相关的请求
```python
typedef
```
```python
struct
```
```python
uv_tcp_accept_s {                                          
    UV_REQ_FIELDS
```
```python
//uv_req_t的成员
```
```python
SOCKET accept_socket;
```
```python
char
```
```python
accept_buffer[
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
sockaddr_storage) *
```
```python
2
```
```python
+
```
```python
32
```
```python
];        
    HANDLE event_handle;                                                 
    HANDLE wait_handle;
```
```python
struct
```
```python
uv_tcp_accept_s* next_pending;                              
  } uv_tcp_accept_t;
```
### 相关函数
#### 初始化。导出函数，在uv.h中声明，在tcp.c中定义
```python
int
```
```python
uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {
```
```python
return
```
```python
uv_tcp_init_ex(loop, handle, AF_UNSPEC);
```
```python
//
```
```python
}
```
#### 初始化扩展函数。导出函数，在uv.h中声明，在tcp.c中定义
```python
int
```
```python
uv_tcp_init_ex(uv_loop_t* loop, uv_tcp_t* handle,
```
```python
unsigned
```
```python
int
```
```python
flags) {
```
```python
int
```
```python
domain;
```
```python
//使用flags的低八位
```
```python
domain = flags &
```
```python
0xFF
```
```python
;
```
```python
//只能是一下三种中的一种，其中AF_UNSPEC并不会做任何操作
```
```python
if
```
```python
(domain != AF_INET && domain != AF_INET6 && domain != AF_UNSPEC)
```
```python
return
```
```python
UV_EINVAL;
```
```python
if
```
```python
(flags & ~
```
```python
0xFF
```
```python
)
```
```python
//高八位有值，返回错误
```
```python
return
```
```python
UV_EINVAL;
```
```python
//初始化stream，handle加入loop的handle列表
```
```python
uv_stream_init(loop, (uv_stream_t*) handle, UV_TCP);
  handle->tcp.serv.accept_reqs = NULL;
  handle->tcp.serv.pending_accepts = NULL;
  handle->socket = INVALID_SOCKET;
  handle->reqs_pending =
```
```python
0
```
```python
;
  handle->tcp.serv.func_acceptex = NULL;
  handle->tcp.conn.func_connectex = NULL;
  handle->tcp.serv.processed_accepts =
```
```python
0
```
```python
;
  handle->delayed_error =
```
```python
0
```
```python
;
```
```python
//在下面的流程中如果发生错误，那么需要移除loop中的本handle
```
```python
if
```
```python
(domain != AF_UNSPEC) {
    SOCKET sock;
    DWORD err;
    sock = socket(domain, SOCK_STREAM,
```
```python
0
```
```python
);
```
```python
//新建socket
```
```python
if
```
```python
(sock == INVALID_SOCKET) {
```
```python
//失败
```
```python
err = WSAGetLastError();
      QUEUE_REMOVE(&handle->handle_queue);
```
```python
return
```
```python
uv_translate_sys_error(err);
    }
```
```python
//将申请的socket与loop的iocp端口联系起来
```
```python
err = uv_tcp_set_socket(handle->loop, handle, sock, domain,
```
```python
0
```
```python
);
```
```python
if
```
```python
(err) {
```
```python
//失败
```
```python
closesocket(sock);
      QUEUE_REMOVE(&handle->handle_queue);
```
```python
return
```
```python
uv_translate_sys_error(err);
    }
  }
```
```python
return
```
```python
0
```
```python
;
}
```
将tcp socket与iocp端口绑定
```python
static int uv_tcp_set_socket(uv_loop_t
```
```python
*
```
```python
loop
```
```python
,
                             uv_tcp_t
```
```python
*
```
```python
handle
```
```python
,
                             SOCKET socket,
                             int family,
                             int imported) {
  DWORD yes
```
```python
=
```
```python
1
```
```python
;
  int non_ifs_lsp;
  int err;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
socket
```
```python
!=
```
```python
INVALID_SOCKET)
```
```python
return
```
```python
UV_EBUSY;
```
```python
//将socket设置为非阻塞模式
```
```python
if
```
```python
(ioctlsocket(socket, FIONBIO,
```
```python
&
```
```python
yes)
```
```python
==
```
```python
SOCKET_ERROR) {
```
```python
return
```
```python
WSAGetLastError();
  }
```
```python
//使socket句柄无法被继承
```
```python
if
```
```python
(
```
```python
!
```
```python
SetHandleInformation((
```
```python
HANDLE
```
```python
) socket, HANDLE_FLAG_INHERIT,
```
```python
0
```
```python
))
```
```python
return
```
```python
GetLastError();
```
```python
//与iocp端口关联起来，并将socket作为key
```
```python
if
```
```python
(CreateIoCompletionPort((
```
```python
HANDLE
```
```python
)socket,
```
```python
loop
```
```python
->
```
```python
iocp,
                             (ULONG_PTR)socket,
```
```python
0
```
```python
)
```
```python
==
```
```python
NULL
```
```python
) {
```
```python
//在uv_tcp_open中为打开一个已有socket中，imported为1
```
```python
if
```
```python
(imported) {
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_EMULATE_IOCP;
    }
```
```python
else
```
```python
{
```
```python
return
```
```python
GetLastError();
    }
  }
```
```python
if
```
```python
(family
```
```python
==
```
```python
AF_INET6) {
```
```python
//uv_tcp_non_ifs_lsp_ipv6 = 1表示IPPROTO_IP协议使用真正地操作系统句柄，没有lsp封装
```
```python
non_ifs_lsp
```
```python
=
```
```python
uv_tcp_non_ifs_lsp_ipv6;
  }
```
```python
else
```
```python
{
```
```python
//同理
```
```python
non_ifs_lsp
```
```python
=
```
```python
uv_tcp_non_ifs_lsp_ipv4;
  }
```
```python
if
```
```python
(pSetFileCompletionNotificationModes
```
```python
&&
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_EMULATE_IOCP)
```
```python
&&
```
```python
!
```
```python
non_ifs_lsp) {
```
```python
if
```
```python
(pSetFileCompletionNotificationModes((
```
```python
HANDLE
```
```python
) socket,
        FILE_SKIP_SET_EVENT_ON_HANDLE
```
```python
|
```
```python
FILE_SKIP_COMPLETION_PORT_ON_SUCCESS))
```
```python
//如果操作立刻完成，不再向iocp发送通知
```
```python
{
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_SYNC_BYPASS_IOCP;
    }
```
```python
else
```
```python
if
```
```python
(GetLastError()
```
```python
!=
```
```python
ERROR_INVALID_FUNCTION) {
```
```python
return
```
```python
GetLastError();
    }
  }
```
```python
//取消使用Nagle算法
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_TCP_NODELAY) {
    err
```
```python
=
```
```python
uv__tcp_nodelay(
```
```python
handle
```
```python
, socket,
```
```python
1
```
```python
);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
err;
  }
```
```python
//使用保持存活
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_TCP_KEEPALIVE) {
    err
```
```python
=
```
```python
uv__tcp_keepalive(
```
```python
handle
```
```python
, socket,
```
```python
1
```
```python
,
```
```python
60
```
```python
);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
err;
  }
```
```python
handle
```
```python
->
```
```python
socket
```
```python
=
```
```python
socket;
```
```python
if
```
```python
(family
```
```python
==
```
```python
AF_INET6) {
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_IPV6;
  }
```
```python
else
```
```python
{
    assert(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_IPV6));
  }
```
```python
return
```
```python
0
```
```python
;
}
```
#### 通过一个socket作为uv_tcp_t。导出函数，在uv.h中声明，在tcp.c中定义
```python
int
```
```python
uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {
  WSAPROTOCOL_INFOW protocol_info;
```
```python
int
```
```python
opt_len;
```
```python
int
```
```python
err;
```
```python
//获取地址的类型
```
```python
opt_len = (
```
```python
int
```
```python
)
```
```python
sizeof
```
```python
protocol_info;
```
```python
//获取协议信息
```
```python
if
```
```python
(getsockopt(sock,
                 SOL_SOCKET,
                 SO_PROTOCOL_INFOW,
                 (
```
```python
char
```
```python
*) &protocol_info,
                 &opt_len) == SOCKET_ERROR) {
```
```python
return
```
```python
uv_translate_sys_error(GetLastError());
  }
```
```python
//将socket与loop的iocp端口联系起来
```
```python
//根据handle的标记设置socket。
```
```python
err = uv_tcp_set_socket(handle->loop,
                          handle,
                          sock,
                          protocol_info.iAddressFamily,
```
```python
1
```
```python
);
```
```python
if
```
```python
(err) {
```
```python
return
```
```python
uv_translate_sys_error(err);
  }
```
```python
return
```
```python
0
```
```python
;
}
```
#### 获取地址。导出函数，在uv.h中声明，在tcp.c中定义
```python
int uv_tcp_getsockname(const uv_tcp_t
```
```python
*
```
```python
handle
```
```python
,
                       struct sockaddr
```
```python
*
```
```python
name,
                       int
```
```python
*
```
```python
namelen) 
{
  int result;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
socket
```
```python
==
```
```python
INVALID_SOCKET) {
```
```python
return
```
```python
UV_EINVAL;
  }
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
delayed_error) {
```
```python
//之前的操作出现错误，比如bind操作
```
```python
return
```
```python
uv_translate_sys_error(
```
```python
handle
```
```python
->
```
```python
delayed_error);
  }
  result
```
```python
=
```
```python
getsockname(
```
```python
handle
```
```python
->
```
```python
socket, name, namelen);
```
```python
//调用API
```
```python
if
```
```python
(result
```
```python
!=
```
```python
0
```
```python
) {
```
```python
return
```
```python
uv_translate_sys_error(WSAGetLastError());
  }
```
```python
return
```
```python
0
```
```python
;
}
```
#### 获取连接对象的地址。导出函数，在uv.h中声明，在tcp.c中定义
```python
int uv_tcp_getpeername(const uv_tcp_t
```
```python
*
```
```python
handle
```
```python
,
                       struct sockaddr
```
```python
*
```
```python
name,
                       int
```
```python
*
```
```python
namelen) {
  int result;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
socket
```
```python
==
```
```python
INVALID_SOCKET) {
```
```python
return
```
```python
UV_EINVAL;
  }
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
delayed_error) {
```
```python
return
```
```python
uv_translate_sys_error(
```
```python
handle
```
```python
->
```
```python
delayed_error);
  }
  result
```
```python
=
```
```python
getpeername(
```
```python
handle
```
```python
->
```
```python
socket, name, namelen);
```
```python
//调用API
```
```python
if
```
```python
(result
```
```python
!=
```
```python
0
```
```python
) {
```
```python
return
```
```python
uv_translate_sys_error(WSAGetLastError());
  }
```
```python
return
```
```python
0
```
```python
;
}
```
#### 建立连接。导出函数，在uv.h中声明，在tcp.c中定义
```python
int
```
```python
uv_tcp_connect(uv_connect_t* req,
                   uv_tcp_t* handle,
```
```python
const
```
```python
struct
```
```python
sockaddr* addr,
                   uv_connect_cb cb) {
```
```python
unsigned
```
```python
int
```
```python
addrlen;
```
```python
if
```
```python
(handle->type != UV_TCP)
```
```python
return
```
```python
UV_EINVAL;
```
```python
if
```
```python
(addr->sa_family == AF_INET)
    addrlen =
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
sockaddr_in);
```
```python
else
```
```python
if
```
```python
(addr->sa_family == AF_INET6)
    addrlen =
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
sockaddr_in6);
```
```python
else
```
```python
return
```
```python
UV_EINVAL;
```
```python
return
```
```python
uv__tcp_connect(req, handle, addr, addrlen, cb);
```
```python
//调用内部函数处理
```
```python
}
```
connect的内部处理
```python
int
```
```python
uv__tcp_connect(uv_connect_t* req,
                    uv_tcp_t* handle,
```
```python
const
```
```python
struct
```
```python
sockaddr* addr,
```
```python
unsigned
```
```python
int
```
```python
addrlen,
                    uv_connect_cb cb) {
```
```python
int
```
```python
err;
  err = uv_tcp_try_connect(req, handle, addr, addrlen, cb);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
uv_translate_sys_error(err);
```
```python
return
```
```python
0
```
```python
;
}
```
```python
static int uv_tcp_try_connect(uv_connect_t
```
```python
*
```
```python
req,
                              uv_tcp_t
```
```python
*
```
```python
handle
```
```python
,
                              const struct sockaddr
```
```python
*
```
```python
addr,
                              unsigned int addrlen,
                              uv_connect_cb cb) {
  uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
  const struct sockaddr
```
```python
*
```
```python
bind_addr;
  BOOL success;
  DWORD
```
```python
bytes
```
```python
;
  int err;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
delayed_error) {
```
```python
return
```
```python
handle
```
```python
->
```
```python
delayed_error;
  }
```
```python
//没有绑定本地地址，使用默认地址绑定
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_BOUND)) {
```
```python
if
```
```python
(addrlen
```
```python
==
```
```python
sizeof(uv_addr_ip4_any_)) {
      bind_addr
```
```python
=
```
```python
(const struct sockaddr
```
```python
*
```
```python
)
```
```python
&
```
```python
uv_addr_ip4_any_;
    }
```
```python
else
```
```python
if
```
```python
(addrlen
```
```python
==
```
```python
sizeof(uv_addr_ip6_any_)) {
      bind_addr
```
```python
=
```
```python
(const struct sockaddr
```
```python
*
```
```python
)
```
```python
&
```
```python
uv_addr_ip6_any_;
    }
```
```python
else
```
```python
{
```
```python
abort
```
```python
();
    }
    err
```
```python
=
```
```python
uv_tcp_try_bind(
```
```python
handle
```
```python
, bind_addr, addrlen,
```
```python
0
```
```python
);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
err;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
delayed_error)
```
```python
return
```
```python
handle
```
```python
->
```
```python
delayed_error;
  }
```
```python
if
```
```python
(
```
```python
!
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
func_connectex) {
```
```python
//根据具体的socket获取connectex函数指针
```
```python
if
```
```python
(
```
```python
!
```
```python
uv_get_connectex_function(
```
```python
handle
```
```python
->
```
```python
socket,
```
```python
&
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
func_connectex))   
    {
```
```python
return
```
```python
WSAEAFNOSUPPORT;
    }
  }
```
```python
//初始化connect请求
```
```python
uv_req_init(
```
```python
loop
```
```python
, (uv_req_t
```
```python
*
```
```python
) req);
  req
```
```python
->
```
```python
type
```
```python
=
```
```python
UV_CONNECT;
  req
```
```python
->
```
```python
handle
```
```python
=
```
```python
(uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
;
  req
```
```python
->
```
```python
cb
```
```python
=
```
```python
cb;
  memset(
```
```python
&
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped,
```
```python
0
```
```python
, sizeof(req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped));
```
```python
//调用connectex函数，异步链接，成功或者失败会通知iocp端口
```
```python
success
```
```python
=
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
func_connectex(
```
```python
handle
```
```python
->
```
```python
socket,
                                           addr,
                                           addrlen,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
&
```
```python
bytes
```
```python
,
```
```python
&
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped);
```
```python
if
```
```python
(UV_SUCCEEDED_WITHOUT_IOCP(success)) {
```
```python
//未能成功，直接将请求添加到loop的请求列表进行处理
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
    REGISTER_HANDLE_REQ(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
, req);
    uv_insert_pending_req(
```
```python
loop
```
```python
, (uv_req_t
```
```python
*
```
```python
)req);
  }
```
```python
else
```
```python
if
```
```python
(UV_SUCCEEDED_WITH_IOCP(success)) {
```
```python
//通过iocp处理，req将会在收到iocp消息时添加到loop的请求列表
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
    REGISTER_HANDLE_REQ(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
, req);
  }
```
```python
else
```
```python
{
```
```python
return
```
```python
WSAGetLastError();
  }
```
```python
return
```
```python
0
```
```python
;
}
```
对于通过iocp的connect请求处理，在uv_run轮询时，会获取连接的消息，并通过overlapped获取对应的req，将其添加到loop的请求列表，在下一个循环迭代loop会调用uv_process_reqs进行处理
```python
case
```
```python
UV_CONNECT
```
```python
:
        DELEGATE_STREAM_REQ(
```
```python
loop
```
```python
, (uv_connect_t*) req, connect, handle);
```
```python
break
```
```python
;
```
最终调用uv_process_tcp_connect_req，处理tcp  connect请求
```python
void
```
```python
uv_process_tcp_connect_req(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_tcp_t
```
```python
*
```
```python
handle
```
```python
,
    uv_connect_t
```
```python
*
```
```python
req) {
  int err;
  assert(
```
```python
handle
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_TCP);
```
```python
//handle的活动计数减一，如果为零则停止handle（loop活动handle减一，handle状态变为非Active）
```
```python
//loop的active_req列表中删除req
```
```python
//因为connect请求到此处处理完就结束了，而对应的uv_tcp_t则应该回归停止状态
```
```python
UNREGISTER_HANDLE_REQ(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
, req);
  err
```
```python
=
```
```python
0
```
```python
;
```
```python
if
```
```python
(REQ_SUCCESS(req)) {
```
```python
//链接成功，更新socket状态
```
```python
if
```
```python
(setsockopt(
```
```python
handle
```
```python
->
```
```python
socket,
                    SOL_SOCKET,
                    SO_UPDATE_CONNECT_CONTEXT,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
)
```
```python
==
```
```python
0
```
```python
) {
      uv_connection_init((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_READABLE
```
```python
|
```
```python
UV_HANDLE_WRITABLE;
```
```python
loop
```
```python
->
```
```python
active_tcp_streams
```
```python
++
```
```python
;
```
```python
//活动的tcp流计数加一
```
```python
}
```
```python
else
```
```python
{
      err
```
```python
=
```
```python
WSAGetLastError();
    }
  }
```
```python
else
```
```python
{
    err
```
```python
=
```
```python
GET_REQ_SOCK_ERROR(req);
  }
  req
```
```python
->
```
```python
cb(req, uv_translate_sys_error(err));
```
```python
//调用回调
```
```python
//DECREASE_PENDING_REQ_COUNT(handle);展开：
```
```python
do
```
```python
{ 
      assert(
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
>
```
```python
0
```
```python
);
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
--
```
```python
;
```
```python
/
```
```python
等待处理的请求数减一
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING
```
```python
&&
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
==
```
```python
0
```
```python
) {
```
```python
//正在关闭状态
```
```python
uv_want_endgame(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
); 
      }                                               
  }
```
```python
while
```
```python
(
```
```python
0
```
```python
)
}
```
#### 读取数据的请求。导出函数，在uv.h中声明，在stream.c中定义
```python
//对于uv_tcp_t类型的stream，调用下面的处理
```
```python
switch
```
```python
(handle->type) {
```
```python
case
```
```python
UV_TCP:
      err = uv_tcp_read_start((uv_tcp_t*)handle, alloc_cb, read_cb);
```
```python
break
```
```python
;
```
uv_tcp_read_start，tcp开始读取
```python
int uv_tcp_read_start(uv_tcp_t
```
```python
*
```
```python
handle
```
```python
, uv_alloc_cb alloc_cb,
    uv_read_cb read_cb) {
  uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_READING;
```
```python
//状态变为reading
```
```python
handle
```
```python
->
```
```python
read_cb
```
```python
=
```
```python
read_cb;
```
```python
handle
```
```python
->
```
```python
alloc_cb
```
```python
=
```
```python
alloc_cb;
```
```python
//activecnt++，如果之前activecnt为0，那么就start  handle
```
```python
INCREASE_ACTIVE_COUNT(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
//如果读取被中断，那么就再次开始
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READ_PENDING)) {
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_EMULATE_IOCP
```
```python
&&
```
```python
!
```
```python
handle
```
```python
->
```
```python
read_req
```
```python
.
```
```python
event_handle) {
```
```python
//模拟iocp的情况下，创建事件
```
```python
handle
```
```python
->
```
```python
read_req
```
```python
.
```
```python
event_handle
```
```python
=
```
```python
CreateEvent(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
if
```
```python
(
```
```python
!
```
```python
handle
```
```python
->
```
```python
read_req
```
```python
.
```
```python
event_handle) {
        uv_fatal_error(GetLastError(),
```
```python
"CreateEvent"
```
```python
);
      }
    }
```
```python
//将读取请求放到队列
```
```python
uv_tcp_queue_read(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
  }
```
```python
return
```
```python
0
```
```python
;
}
```
读取请求放到队列
```python
static
```
```python
void
```
```python
uv_tcp_queue_read(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_tcp_t
```
```python
*
```
```python
handle
```
```python
) {
  uv_read_t
```
```python
*
```
```python
req;
  uv_buf_t buf;
  int result;
  DWORD
```
```python
bytes
```
```python
, flags;
  assert(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING);
  assert(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READ_PENDING));
```
```python
//在等待读取的过程中不应该再次发起读取请
```
```python
//求
```
```python
req
```
```python
=
```
```python
&
```
```python
handle
```
```python
->
```
```python
read_req;
  memset(
```
```python
&
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped,
```
```python
0
```
```python
, sizeof(req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped));
```
```python
//预分配读取缓存，目前uv_active_tcp_streams_threshold值为0
```
```python
if
```
```python
(
```
```python
loop
```
```python
->
```
```python
active_tcp_streams
```
```python
<
```
```python
uv_active_tcp_streams_threshold) {
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_ZERO_READ;
```
```python
handle
```
```python
->
```
```python
alloc_cb((uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
```
```python
65536
```
```python
,
```
```python
&
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer);
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer
```
```python
.
```
```python
len
```
```python
==
```
```python
0
```
```python
) {
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
, UV_ENOBUFS,
```
```python
&
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer);
```
```python
return
```
```python
;
    }
    assert(
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer
```
```python
.
```
```python
base
```
```python
!=
```
```python
NULL
```
```python
);
    buf
```
```python
=
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer;
  }
```
```python
else
```
```python
{
```
```python
//没有预分配
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_ZERO_READ;
    buf
```
```python
.
```
```python
base
```
```python
=
```
```python
(char
```
```python
*
```
```python
)
```
```python
&
```
```python
uv_zero_;
    buf
```
```python
.
```
```python
len
```
```python
=
```
```python
0
```
```python
;
  }
```
```python
//初始化重叠结构体
```
```python
memset(
```
```python
&
```
```python
(req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped),
```
```python
0
```
```python
, sizeof(req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped));
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_EMULATE_IOCP) {
```
```python
//非原生socket等因素导致与iocp端口绑定失败的情况下
```
```python
assert(req
```
```python
->
```
```python
event_handle);
    req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped
```
```python
.
```
```python
hEvent
```
```python
=
```
```python
(
```
```python
HANDLE
```
```python
) ((ULONG_PTR) req
```
```python
->
```
```python
event_handle
```
```python
|
```
```python
1
```
```python
);
  }
  flags
```
```python
=
```
```python
0
```
```python
;
```
```python
//异步接收数据
```
```python
result
```
```python
=
```
```python
WSARecv(
```
```python
handle
```
```python
->
```
```python
socket,
                   (WSABUF
```
```python
*
```
```python
)
```
```python
&
```
```python
buf,
```
```python
1
```
```python
,
```
```python
&
```
```python
bytes
```
```python
,
```
```python
&
```
```python
flags,
```
```python
&
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped,
```
```python
NULL
```
```python
);
```
```python
if
```
```python
(UV_SUCCEEDED_WITHOUT_IOCP(result
```
```python
==
```
```python
0
```
```python
)) {
```
```python
//不通过iocp处理请求，直接添加到loop的请求列表
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_READ_PENDING;
    req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped
```
```python
.
```
```python
InternalHigh
```
```python
=
```
```python
bytes
```
```python
;
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
    uv_insert_pending_req(
```
```python
loop
```
```python
, (uv_req_t
```
```python
*
```
```python
)req);
  }
```
```python
else
```
```python
if
```
```python
(UV_SUCCEEDED_WITH_IOCP(result
```
```python
==
```
```python
0
```
```python
)) {
```
```python
//通过iocp处理请求
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_READ_PENDING;
```
```python
//修改状态
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
```
```python
//活动请求加一
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_EMULATE_IOCP
```
```python
&&
```
```python
//socket与iocp绑定失败
```
```python
req
```
```python
->
```
```python
wait_handle
```
```python
==
```
```python
INVALID_HANDLE_VALUE
```
```python
&&
```
```python
!
```
```python
RegisterWaitForSingleObject(
```
```python
&
```
```python
req
```
```python
->
```
```python
wait_handle,
```
```python
//注册等待事件
```
```python
req
```
```python
->
```
```python
event_handle, post_completion, (
```
```python
void
```
```python
*
```
```python
) req,
          INFINITE, WT_EXECUTEINWAITTHREAD)) {
      SET_REQ_ERROR(req, GetLastError());
      uv_insert_pending_req(
```
```python
loop
```
```python
, (uv_req_t
```
```python
*
```
```python
)req);
```
```python
//读请求添加到loop的请求列表
```
```python
}
  }
```
```python
else
```
```python
{
```
```python
//记录错误信息
```
```python
SET_REQ_ERROR(req, WSAGetLastError());
    uv_insert_pending_req(
```
```python
loop
```
```python
, (uv_req_t
```
```python
*
```
```python
)req);
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
  }
}
```
loop对读请求的处理最终会调用到以下函数：
```python
void
```
```python
uv_process_tcp_read_req(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_tcp_t
```
```python
*
```
```python
handle
```
```python
,
    uv_req_t
```
```python
*
```
```python
req) {
  DWORD
```
```python
bytes
```
```python
, flags, err;
  uv_buf_t buf;
  assert(
```
```python
handle
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_TCP);
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_READ_PENDING;
```
```python
//去掉等待处理标记
```
```python
if
```
```python
(
```
```python
!
```
```python
REQ_SUCCESS(req)) {
```
```python
//读取发生错误
```
```python
if
```
```python
((
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING)
```
```python
||
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_ZERO_READ)) 
    {
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_READING;
      DECREASE_ACTIVE_COUNT(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
//活动计数减一
```
```python
buf
```
```python
=
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_ZERO_READ)
```
```python
?
```
```python
uv_buf_init(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
) :
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer;
      err
```
```python
=
```
```python
GET_REQ_SOCK_ERROR(req);
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAECONNABORTED) {
        err
```
```python
=
```
```python
WSAECONNRESET;
      }
```
```python
//调用读取回调，传入错误信息
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
                      uv_translate_sys_error(err),
```
```python
&
```
```python
buf);
    }
  }
```
```python
else
```
```python
{
```
```python
//成功
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_ZERO_READ)) {
```
```python
if
```
```python
(req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped
```
```python
.
```
```python
InternalHigh
```
```python
>
```
```python
0
```
```python
) {
```
```python
//读取成功
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
                        req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped
```
```python
.
```
```python
InternalHigh,
```
```python
&
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer);
```
```python
//如果当前获取的数据长度与缓存长度相同，继续读取
```
```python
if
```
```python
(req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped
```
```python
.
```
```python
InternalHigh
```
```python
<
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer
```
```python
.
```
```python
len) {
          goto done;
        }
      }
```
```python
else
```
```python
{
```
```python
//链接失败
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING) {
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_READING;
          DECREASE_ACTIVE_COUNT(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
        }
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_READABLE;
        buf
```
```python
.
```
```python
base
```
```python
=
```
```python
0
```
```python
;
        buf
```
```python
.
```
```python
len
```
```python
=
```
```python
0
```
```python
;
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
, UV_EOF,
```
```python
&
```
```python
handle
```
```python
->
```
```python
tcp
```
```python
.
```
```python
conn
```
```python
.
```
```python
read_buffer);
        goto done;
      }
    }
```
```python
//持续读取
```
```python
while
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING) {
```
```python
handle
```
```python
->
```
```python
alloc_cb((uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
```
```python
65536
```
```python
,
```
```python
&
```
```python
buf);
```
```python
//调用分配内存的回调
```
```python
if
```
```python
(buf
```
```python
.
```
```python
len
```
```python
==
```
```python
0
```
```python
) {
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
, UV_ENOBUFS,
```
```python
&
```
```python
buf);
        break;
      }
      assert(buf
```
```python
.
```
```python
base
```
```python
!=
```
```python
NULL
```
```python
);
      flags
```
```python
=
```
```python
0
```
```python
;
```
```python
if
```
```python
(WSARecv(
```
```python
handle
```
```python
->
```
```python
socket,
                  (WSABUF
```
```python
*
```
```python
)
```
```python
&
```
```python
buf,
```
```python
1
```
```python
,
```
```python
&
```
```python
bytes
```
```python
,
```
```python
&
```
```python
flags,
```
```python
NULL
```
```python
,
```
```python
NULL
```
```python
)
```
```python
!=
```
```python
SOCKET_ERROR) {
```
```python
if
```
```python
(
```
```python
bytes
```
```python
>
```
```python
0
```
```python
) {
```
```python
//成功读取，调用读取回调
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
```
```python
bytes
```
```python
,
```
```python
&
```
```python
buf);
```
```python
//判断是否需要继续读取
```
```python
if
```
```python
(
```
```python
bytes
```
```python
<
```
```python
buf
```
```python
.
```
```python
len) {
            break;
          }
        }
```
```python
else
```
```python
{
```
```python
//链接被关闭了
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~(UV_HANDLE_READING
```
```python
|
```
```python
UV_HANDLE_READABLE);
          DECREASE_ACTIVE_COUNT(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
, UV_EOF,
```
```python
&
```
```python
buf);
          break;
        }
      }
```
```python
else
```
```python
{
```
```python
//读取出错
```
```python
err
```
```python
=
```
```python
WSAGetLastError();
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAEWOULDBLOCK) {
```
```python
//读取缓存为空
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
```
```python
0
```
```python
,
```
```python
&
```
```python
buf);
        }
```
```python
else
```
```python
{
```
```python
//出现了严重错误
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_READING;
          DECREASE_ACTIVE_COUNT(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAECONNABORTED) {
            err
```
```python
=
```
```python
WSAECONNRESET;
          }
```
```python
handle
```
```python
->
```
```python
read_cb((uv_stream_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
                          uv_translate_sys_error(err),
```
```python
&
```
```python
buf);
        }
        break;
      }
    }
done:
```
```python
//一个读取请求结束之后，如果没有停止读取，那么再次开启一个请求，持续读取
```
```python
if
```
```python
((
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING)
```
```python
&&
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READ_PENDING)) {
      uv_tcp_queue_read(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
    }
  }
  DECREASE_PENDING_REQ_COUNT(
```
```python
handle
```
```python
);
```
```python
//handle等待处理的请求数量减一
```
```python
}
```
#### 停止读取请求。导出函数，在uv.h中声明，在stream.c中定义
并不会立刻停止，在调用该函数之后，会影响最近的一次读取请求处理，并且不会再次发送读取请求，依次达到停止效果。
```python
int
```
```python
uv_read_stop(uv_stream_t* handle) {
```
```python
int
```
```python
err;
```
```python
if
```
```python
(!(handle->flags & UV_HANDLE_READING))
```
```python
//非读取状态，返回
```
```python
return
```
```python
0
```
```python
;
  err =
```
```python
0
```
```python
;
```
```python
if
```
```python
(handle->type == UV_TTY) {
    err = uv_tty_read_stop((uv_tty_t*) handle);
  }
```
```python
else
```
```python
{
```
```python
if
```
```python
(handle->type == UV_NAMED_PIPE) {
      uv__pipe_stop_read((uv_pipe_t*) handle);
    }
```
```python
else
```
```python
{
      handle->flags &= ~UV_HANDLE_READING;
```
```python
//TCP
```
```python
}
    DECREASE_ACTIVE_COUNT(handle->loop, handle);
```
```python
//handle的活动计数减一
```
```python
}
```
```python
return
```
```python
uv_translate_sys_error(err);
}
```
从uv_tcp_t的connet以及读取可以看出。
1.uv_tcp_t的激活状态主要是依靠请求，比如在connet请求处理完之后，如果没有再发送其他请求（比如read)，那么uv_tcp_t将会处于停止状态，loop不会在活动handle中记录该handle。
2.部分流相关的请求会记录在loop的请求列表中，比如connect以及write，个人推测是用户发出的请求会添加到loop的请求队列，而libuv自己处理中发出的请求则不会（比如uv_read_start,参数中并没有req，是使用的是stream内部的私有uv_read_t;）。
3.一些流相关的请求是会在处理之后自己再重复发起的，比如read，可以推测accept也是如此，不需要用户自己再去重复发送，但是需要用户去停止。
```python
这里写代码片
```
通过uv_close关闭uv_tcp_t,会调用uv_tcp_close
```python
void
```
```python
uv_tcp_close(uv_loop_t* loop, uv_tcp_t* tcp) {
```
```python
int
```
```python
close_socket =
```
```python
1
```
```python
;
```
```python
if
```
```python
(tcp->flags & UV_HANDLE_READ_PENDING) {
```
```python
//等待读请求的处理。也就是调用了异步读取WSARecv，但是还未收到数据
```
```python
if
```
```python
(!(tcp->flags & UV_HANDLE_SHARED_TCP_SOCKET)) 
    {
```
```python
//非共享socket，直接shutdown。在uv_tcp_open的方式初始化uv_tcp_t时，会设置为
```
```python
//UV_HANDLE_SHARED_TCP_SOCKET
```
```python
shutdown(tcp->socket, SD_SEND);
```
```python
//关闭socket的写功能
```
```python
}
```
```python
else
```
```python
if
```
```python
(uv_tcp_try_cancel_io(tcp) ==
```
```python
0
```
```python
)  
    {
```
```python
//通过CancelIo  API取消
```
```python
//如果是共享的，那么尝试取消i/o请求。如果成功，并不立刻关闭socket，等读请求返回的时候关闭
```
```python
close_socket =
```
```python
0
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
//共享socket，取消失败
```
```python
//只能关闭socket了。
```
```python
}
  }
```
```python
else
```
```python
if
```
```python
((tcp->flags & UV_HANDLE_SHARED_TCP_SOCKET) &&
             tcp->tcp.serv.accept_reqs != NULL) {
```
```python
/* Under normal circumstances closesocket() will ensure that all pending */
```
```python
/* accept reqs are canceled. However, when the socket is shared the */
```
```python
/* presence of another reference to the socket in another process will */
```
```python
/* keep the accept reqs going, so we have to ensure that these are */
```
```python
/* canceled. */
```
```python
if
```
```python
(uv_tcp_try_cancel_io(tcp) !=
```
```python
0
```
```python
) {
```
```python
/* When cancellation is not possible, there is another option: we can */
```
```python
/* close the incoming sockets, which will also cancel the accept */
```
```python
/* operations. However this is not cool because we might inadvertently */
```
```python
/* close a socket that just accepted a new connection, which will */
```
```python
/* cause the connection to be aborted. */
```
```python
unsigned
```
```python
int
```
```python
i;
```
```python
for
```
```python
(i =
```
```python
0
```
```python
; i < uv_simultaneous_server_accepts; i++) {
        uv_tcp_accept_t* req = &tcp->tcp.serv.accept_reqs[i];
```
```python
if
```
```python
(req->accept_socket != INVALID_SOCKET &&
            !HasOverlappedIoCompleted(&req->u.io.overlapped)) {
          closesocket(req->accept_socket);
          req->accept_socket = INVALID_SOCKET;
        }
      }
    }
  }
```
```python
if
```
```python
(tcp->flags & UV_HANDLE_READING) {
    tcp->flags &= ~UV_HANDLE_READING;
```
```python
//停止读取
```
```python
DECREASE_ACTIVE_COUNT(loop, tcp);
  }
```
```python
if
```
```python
(tcp->flags & UV_HANDLE_LISTENING) {
    tcp->flags &= ~UV_HANDLE_LISTENING;
    DECREASE_ACTIVE_COUNT(loop, tcp);
  }
```
```python
if
```
```python
(close_socket) {
    closesocket(tcp->socket);
    tcp->socket = INVALID_SOCKET;
    tcp->flags |= UV_HANDLE_TCP_SOCKET_CLOSED;
  }
  tcp->flags &= ~(UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);
  uv__handle_closing(tcp);
```
```python
//状态改为closing
```
```python
//没有等待处理的请求了，关闭handle，否则需要等到处理请求时关闭
```
```python
if
```
```python
(tcp->reqs_pending ==
```
```python
0
```
```python
) {
    uv_want_endgame(tcp->loop, (uv_handle_t*)tcp);
  }
}
```
uv_tcp_t中有两个计数
1.reqs_pending，表示已经添加到loop中的请求，或者已经与iocp绑定的端口调用了i/o函数，可以通过iocp端口获取的请求，在请求处理结束之后减一，如果为0且处于UV_HANDLE_CLOSING状态，那么会将handle添加到关闭列表。
2.activecnt，调用了某一个请求后加一，在对应的处理函数中减一，为0并且正在关闭时stop  handle
请求的调用与处理会引发两个计数的变化。
对于部分请求，比如connect与write，会添加到loop的active_reqs列表，请求处理完成之后，会从列表删除。该列表是判断loop alive的条件之一。
与tcp相关的还有accept与write操作，将在下一篇中分析

