
# 5.5 this 指针 -  芝麻软件工作室的专栏 - CSDN博客


2016年06月13日 08:56:07[seven-soft](https://me.csdn.net/softn)阅读数：202个人分类：[C++																](https://blog.csdn.net/softn/article/category/6266511)



问题：当在对象的外部访问该对象的公有成员时，必须指明是哪一个对象。但是当我们用对象的成员函数来访问本对象的成员时，在成员函数中只要给出成员名就可以实现对该对象成员的访问。再进一步可用同一个类创建很多个对象，但它们共用同一份成员函数的拷贝。既然是同一份拷贝，那么成员函数又怎么知道是取哪一个对象的成员数据呢？
其实，当调用一个成员函数时，系统自动产生一个隐藏的指针，这个指针称为**this指针**，始终指向产生这个调用的对象，并将该指针作为一个参数自动传递给该成员函数。这就是说，成员操作符总是要使用的，只是在对象内是隐式的，而在对象外是显式的。即在对象内省略了this指针。
实际上编译器是这样实现this指针的：
1．改变类成员函数的定义，用附加参数this指针来定义每个成员函数。如：
void Cgoods::RegisterGoods(Cgoods*this,char*nam,
int amount,float price){
strcpy(this->Name,name);this->Amount=amount;
this->price=price;
}
2．每个类成员函数的调用，加上一个附加的实参——被调用对象的地址。如：
Car1.RegisterGoods ( String , number , pr );
改变为：
RegisterGoods ( &Car1 , String , number , pr);
在上例中，this指针不必写成显式的，但是有时必须写成显式的，如在以后要学的某些类型的链表管理中，在需要返回当前调用的对象时（对复数类的赋值号重载中
 ），等等。但必须指出静态成员函数没有this指针。因为普通成员函数虽然在物理上只有一份拷贝，但在逻辑上都认为一个对象有一份拷贝，所以有this指针，而静态成员函数在逻辑上也只有一份拷贝，不属于具体的对象，当然没有this指针。

