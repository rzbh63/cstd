# 白话经典算法

# 白话经典算法系列之一 冒泡排序的三种实现



 冒泡排序是非常容易理解和实现，，以从小到大排序举例：

设数组长度为N。

1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。

2．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。

3．N=N-1，如果N不为0就重复前面二步，否则排序完成。

 

按照定义很容易写出代码：

```cpp
//冒泡排序1
void BubbleSort1(int a[], int n)
{
       int i, j;
       for (i = 0; i < n; i++)
              for (j = 1; j < n - i; j++)
                     if (a[j - 1] > a[j])
                            Swap(a[j - 1], a[j]);
}
```


下面对其进行优化，设置一个标志，如果这一趟发生了交换，则为true，否则为false。明显如果有一趟没有发生交换，说明排序已经完成。

```cpp
//冒泡排序2
void BubbleSort2(int a[], int n)
{
       int j, k;
       bool flag;
 
       k = n;
       flag = true;
       while (flag)
       {
              flag = false;
              for (j = 1; j < k; j++)
                     if (a[j - 1] > a[j])
                     {
                            Swap(a[j - 1], a[j]);
                            flag = true;
                     }
              k--;
       }
}
```





再做进一步的优化。如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。

```cpp
//冒泡排序3
void BubbleSort3(int a[], int n)
{
	int j, k;
	int flag;
	
	flag = n;
	while (flag > 0)
	{
		k = flag;
		flag = 0;
		for (j = 1; j < k; j++)
			if (a[j - 1] > a[j])
			{
				Swap(a[j - 1], a[j]);
				flag = j;
			}
	}
}
```

冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。





# 白话经典算法系列之二 直接插入排序的三种实现

2011年08月06日 19:27:17

 

MoreWindows

 

阅读数：146700

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/6665714

直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。

 

设数组为a[0…n-1]。

\1.      初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1

\2.      将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。

\3.      i++并重复第二步直到i==n-1。排序完成。

 

下面给出严格按照定义书写的代码（由小到大排序）：



```cpp
void Insertsort1(int a[], int n)



{



	int i, j, k;



	for (i = 1; i < n; i++)



	{



		//为a[i]在前面的a[0...i-1]有序区间中找一个合适的位置



		for (j = i - 1; j >= 0; j--)



			if (a[j] < a[i])



				break;



 



		//如找到了一个合适的位置



		if (j != i - 1)



		{



			//将比a[i]大的数据向后移



			int temp = a[i];



			for (k = i - 1; k > j; k--)



				a[k + 1] = a[k];



			//将a[i]放到正确位置上



			a[k + 1] = temp;



		}



	}



}
```

这样的代码太长了，不够清晰。现在进行一下改写，将搜索和数据后移这二个步骤合并。即每次a[i]先和前面一个数据a[i-1]比较，如果a[i] > a[i-1]说明a[0…i]也是有序的，无须调整。否则就令j=i-1,temp=a[i]。然后一边将数据a[j]向后移动一边向前搜索，当有数据a[j]<a[i]时停止并将temp放到a[j + 1]处。

```cpp
void Insertsort2(int a[], int n)



{



	int i, j;



	for (i = 1; i < n; i++)



		if (a[i] < a[i - 1])



		{



			int temp = a[i];



			for (j = i - 1; j >= 0 && a[j] > temp; j--)



				a[j + 1] = a[j];



			a[j + 1] = temp;



		}



}
```


再对将a[j]插入到前面a[0…j-1]的有序区间所用的方法进行改写，用数据交换代替数据后移。如果a[j]前一个数据a[j-1] > a[j]，就交换a[j]和a[j-1]，再j--直到a[j-1] <= a[j]。这样也可以实现将一个新数据新并入到有序区间。

```cpp
void Insertsort3(int a[], int n)



{



	int i, j;



	for (i = 1; i < n; i++)



		for (j = i - 1; j >= 0 && a[j] > a[j + 1]; j--)



			Swap(a[j], a[j + 1]);



}
```







# 白话经典算法系列之三 希尔排序的实现

2011年08月08日 11:41:40

 

MoreWindows

 

阅读数：203603

 

标签： [算法](http://so.csdn.net/so/search/s.do?q=%E7%AE%97%E6%B3%95&t=blog)[shell](http://so.csdn.net/so/search/s.do?q=shell&t=blog)[优化](http://so.csdn.net/so/search/s.do?q=%E4%BC%98%E5%8C%96&t=blog)[c](http://so.csdn.net/so/search/s.do?q=c&t=blog) 更多

个人分类： [白话经典算法系列](https://blog.csdn.net/MoreWindows/article/category/859207)

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/6668714

希尔排序的实质就是分组插入排序，该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。

 

该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

 

以n=10的一个数组49, 38, 65, 97, 26, 13, 27, 49, 55, 4为例

**第一次 gap = 10 / 2 = 5**

49   38   65   97   26   13   27   49   55   4

1A                                        1B

​        2A                                         2B

​                 3A                                         3B

​                         4A                                          4B

​                                  5A                                         5B

*1A,1B，2A,2B等为分组标记，数字相同的表示在同一组，大写字母表示是该组的第几个元素， 每次对同一组的数据进行直接插入排序。即分成了五组(49, 13) (38, 27) (65, 49)  (97, 55)  (26, 4)这样每组排序后就变成了(13, 49)  (27, 38)  (49, 65)  (55, 97)  (4, 26)，下同。*

**第二次 gap = 5 / 2 = 2**

排序后

13   27   49   55   4    49   38   65   97   26

1A             1B             1C              1D            1E

​        2A               2B             2C             2D              2E

**第三次 gap = 2 / 2 = 1**

4   26   13   27   38    49   49   55   97   65

1A   1B     1C    1D    1E      1F     1G    1H     1I     1J

**第四次 gap = 1 / 2 = 0 排序完成得到数组：**

4   13   26   27   38    49   49   55   65   97

 

下面给出严格按照定义来写的希尔排序

```cpp
void shellsort1(int a[], int n)



{



	int i, j, gap;



 



	for (gap = n / 2; gap > 0; gap /= 2) //步长



		for (i = 0; i < gap; i++)        //直接插入排序



		{



			for (j = i + gap; j < n; j += gap) 



				if (a[j] < a[j - gap])



				{



					int temp = a[j];



					int k = j - gap;



					while (k >= 0 && a[k] > temp)



					{



						a[k + gap] = a[k];



						k -= gap;



					}



					a[k + gap] = temp;



				}



		}



}
```

很明显，上面的shellsort1代码虽然对直观的理解希尔排序有帮助，但代码量太大了，不够简洁清晰。因此进行下改进和优化，以第二次排序为例，原来是每次从1A到1E，从2A到2E，可以改成从1B开始，先和1A比较，然后取2B与2A比较，再取1C与前面自己组内的数据比较…….。这种每次从数组第gap个元素开始，每个元素与自己组内的数据进行直接插入排序显然也是正确的。

```cpp
void shellsort2(int a[], int n)



{



	int j, gap;



	



	for (gap = n / 2; gap > 0; gap /= 2)



		for (j = gap; j < n; j++)//从数组第gap个元素开始



			if (a[j] < a[j - gap])//每个元素与自己组内的数据进行直接插入排序



			{



				int temp = a[j];



				int k = j - gap;



				while (k >= 0 && a[k] > temp)



				{



					a[k + gap] = a[k];



					k -= gap;



				}



				a[k + gap] = temp;



			}



}
```


再将直接插入排序部分用 [白话经典算法系列之二 直接插入排序的三种实现](https://blog.csdn.net/morewindows/article/details/6665714)  中直接插入排序的第三种方法来改写下：

```cpp
void shellsort3(int a[], int n)



{



	int i, j, gap;



 



	for (gap = n / 2; gap > 0; gap /= 2)



		for (i = gap; i < n; i++)



			for (j = i - gap; j >= 0 && a[j] > a[j + gap]; j -= gap)



				Swap(a[j], a[j + gap]);



}
```

这样代码就变得非常简洁了。

  

附注：上面希尔排序的步长选择都是从n/2开始，每次再减半，直到最后为1。其实也可以有另外的更高效的步长选择，如果读者有兴趣了解，请参阅维基百科上对希尔排序步长的说明：

http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F

 





# 白话经典算法系列之四 直接选择排序及交换二个数据的正确实现

2011年08月09日 11:15:51

 

MoreWindows

 

阅读数：34733

 

标签： [算法](http://so.csdn.net/so/search/s.do?q=%E7%AE%97%E6%B3%95&t=blog)[面试](http://so.csdn.net/so/search/s.do?q=%E9%9D%A2%E8%AF%95&t=blog)[c](http://so.csdn.net/so/search/s.do?q=c&t=blog) 更多

个人分类： [白话经典算法系列](https://blog.csdn.net/MoreWindows/article/category/859207)

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/6671824

直接选择排序和直接插入排序类似，都将数据分为有序区和无序区，所不同的是直接播放排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。

 

设数组为a[0…n-1]。

\1.      初始时，数组全为无序区为a[0..n-1]。令i=0

\2.      在无序区a[i…n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0…i]就形成了一个有序区。

\3.      i++并重复第二步直到i==n-1。排序完成。

 

直接选择排序无疑是最容易实现的，下面给出代码：

```cpp
void Selectsort(int a[], int n)



{



	int i, j, nMinIndex;



	for (i = 0; i < n; i++)



	{



		nMinIndex = i; //找最小元素的位置



		for (j = i + 1; j < n; j++)



			if (a[j] < a[nMinIndex])



				nMinIndex = j;



 



		Swap(a[i], a[nMinIndex]); //将这个元素放到无序区的开头



	}



}
```

在这里，要特别提醒各位注意下Swap()的实现，建议用：

```cpp
inline void Swap(int &a, int &b)



{



	int c = a;



	a = b;



	b = c;



}
```

笔试面试时考不用中间数据交换二个数，很多人给出了

```cpp
inline void Swap1(int &a, int &b)



{



	a ^= b;



	b ^= a;



	a ^= b;



}
```

在网上搜索下，也可以找到许多这样的写法。不过这样写存在一个隐患，如果a, b指向的是同一个数，那么调用Swap1()函数会使这个数为0。如:

```cpp
int i = 6;



Swap2(i, i);



printf("%d %d\n", i);
```

当然谁都不会在程序中这样的写代码，但回到我们的Selectsort()，如果a[0]就是最小的数，那么在交换时，将会出现将a[0]置0的情况，这种错误相信调试起来也很难发现吧，因此建议大家将交换二数的函数写成：

```cpp
inline void Swap(int &a, int &b)



{



	int c = a;



	a = b;



	b = c;



}
```

或者在Swap1()中加个判断，如果二个数据相等就不用交换了：

```cpp
inline void Swap1(int &a, int &b)



{



	if (a != b)



	{



		a ^= b;



		b ^= a;



		a ^= b;



	}



}
```

 





# 白话经典算法系列之五 归并排序的实现

2011年08月11日 11:01:05

 

MoreWindows

 

阅读数：330806

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/6678165

 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。

```cpp
//将有序数组a[]和b[]合并到c[]中



void MemeryArray(int a[], int n, int b[], int m, int c[])



{



	int i, j, k;



 



	i = j = k = 0;



	while (i < n && j < m)



	{



		if (a[i] < b[j])



			c[k++] = a[i++];



		else



			c[k++] = b[j++]; 



	}



 



	while (i < n)



		c[k++] = a[i++];



 



	while (j < m)



		c[k++] = b[j++];



}
```

可以看出合并有序数列的效率是比较高的，可以达到O(n)。

解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？

可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。

```cpp
//将有二个有序数列a[first...mid]和a[mid...last]合并。



void mergearray(int a[], int first, int mid, int last, int temp[])



{



	int i = first, j = mid + 1;



	int m = mid,   n = last;



	int k = 0;



	



	while (i <= m && j <= n)



	{



		if (a[i] <= a[j])



			temp[k++] = a[i++];



		else



			temp[k++] = a[j++];



	}



	



	while (i <= m)



		temp[k++] = a[i++];



	



	while (j <= n)



		temp[k++] = a[j++];



	



	for (i = 0; i < k; i++)



		a[first + i] = temp[i];



}



void mergesort(int a[], int first, int last, int temp[])



{



	if (first < last)



	{



		int mid = (first + last) / 2;



		mergesort(a, first, mid, temp);    //左边有序



		mergesort(a, mid + 1, last, temp); //右边有序



		mergearray(a, first, mid, last, temp); //再将二个有序数列合并



	}



}



 



bool MergeSort(int a[], int n)



{



	int *p = new int[n];



	if (p == NULL)



		return false;



	mergesort(a, 0, n - 1, p);



	delete[] p;



	return true;



}
```

 

归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。

 

在本人电脑上对冒泡排序，直接插入排序，归并排序及直接使用系统的qsort()进行比较（均在Release版本下）

对20000个随机数据进行测试：

![img](https://img-my.csdn.net/uploads/201206/14/1339667485_3225.jpg)

对50000个随机数据进行测试：

![img](https://img-my.csdn.net/uploads/201206/14/1339667579_6014.jpg)

再对200000个随机数据进行测试：

![img](https://img-my.csdn.net/uploads/201206/14/1339667519_5952.jpg)

 



注：有的书上是在mergearray()合并有序数列时分配临时数组，但是过多的new操作会非常费时。因此作了下小小的变化。只在MergeSort()中new一个临时数组。后面的操作都共用这一个临时数组。

 

 





# 白话经典算法系列之六 快速排序 快速搞定

2011年08月13日 17:19:58

 

MoreWindows

 

阅读数：559045

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/6684558

快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想----分治法也确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个，还有大大小的程序方面的考试如软考，考研中也常常出现快速排序的身影。

总的说来，要直接默写出快速排序还是有一定难度的，因为本人就自己的理解对快速排序作了下白话解释，希望对大家理解有帮助，达到**快速排序，快速搞定**。

 

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。

该方法的基本思想是：

1．先从数列中取出一个数作为基准数。

2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。

3．再对左右区间重复第二步，直到各区间只有一个数。

 

虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：

先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。

 

以一个数组作为示例，取区间第一个数为基准数。

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 72   | 6    | 57   | 88   | 60   | 42   | 83   | 73   | 48   | 85   |

初始时，i = 0;  j = 9;   X = a[i] = 72

由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。

从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++;  这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j--;

 

数组变为：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 48   | 6    | 57   | 88   | 60   | 42   | 83   | 73   | 88   | 85   |

 i = 3;   j = 7;   X=72

再重复上面的步骤，**先从后向前找，再从前向后找**。

从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;

从i开始向后找，当i=5时，由于i==j退出。

此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。

 

数组变为：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 48   | 6    | 57   | 42   | 60   | 72   | 83   | 73   | 88   | 85   |

可以**看出a[5]前面的数字都小于它，a[5]后面的数字都大于它**。因此再对a[0…4]和a[6…9]这二个子区间**重复**上述步骤就可以了。

 

 

对挖坑填数进行总结

1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。

2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。

3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。

4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。

照着这个总结很容易实现挖坑填数的代码：

```cpp
int AdjustArray(int s[], int l, int r) //返回调整后基准数的位置



{



	int i = l, j = r;



	int x = s[l]; //s[l]即s[i]就是第一个坑



	while (i < j)



	{



		// 从右向左找小于x的数来填s[i]



		while(i < j && s[j] >= x) 



			j--;  



		if(i < j) 



		{



			s[i] = s[j]; //将s[j]填到s[i]中，s[j]就形成了一个新的坑



			i++;



		}



 



		// 从左向右找大于或等于x的数来填s[j]



		while(i < j && s[i] < x)



			i++;  



		if(i < j) 



		{



			s[j] = s[i]; //将s[i]填到s[j]中，s[i]就形成了一个新的坑



			j--;



		}



	}



	//退出时，i等于j。将x填到这个坑中。



	s[i] = x;



 



	return i;



}
```

再写分治法的代码：

```cpp
void quick_sort1(int s[], int l, int r)



{



	if (l < r)



    {



		int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[]



		quick_sort1(s, l, i - 1); // 递归调用 



		quick_sort1(s, i + 1, r);



	}



}
```

这样的代码显然不够简洁，对其组合整理下：

```cpp
//快速排序



void quick_sort(int s[], int l, int r)



{



    if (l < r)



    {



		//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1



        int i = l, j = r, x = s[l];



        while (i < j)



        {



            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数



				j--;  



            if(i < j) 



				s[i++] = s[j];



			



            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数



				i++;  



            if(i < j) 



				s[j--] = s[i];



        }



        s[i] = x;



        quick_sort(s, l, i - 1); // 递归调用 



        quick_sort(s, i + 1, r);



    }



}
```

快速排序还有很多改进版本，如随机选择基准数，区间内数据较少时直接用另的方法排序以减小递归深度。有兴趣的筒子可以再深入的研究下。

 

注1，有的书上是以中间的数作为基准数的，要实现这个方便非常方便，直接将中间的数和第一个数进行交换就可以了。

 

 转载请标明出处，原文地址：<http://blog.csdn.net/morewindows/article/details/6684558>





# 白话经典算法系列之七 堆与堆排序

2011年08月22日 20:04:13

 

MoreWindows

 

阅读数：406109

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/6709644

 **堆排序**与**快速排序**，**归并排序**一样都是时间复杂度为O(N*logN)的几种常见排序方法。学习堆排序前，先讲解下什么是数据结构中的二叉堆。

## 二叉堆的定义

二叉堆是完全二叉树或者是近似完全二叉树。

二叉堆满足二个特性：

1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。

2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为**最大堆**。当父结点的键值总是小于或等于任何一个子节点的键值时为**最小堆**。下图展示一个最小堆：

![img](http://hi.csdn.net/attachment/201108/22/0_1314014666d5oe.gif)

由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，一般将二叉堆就简称为堆。

## 堆的存储

一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。

![img](http://hi.csdn.net/attachment/201108/22/0_1314014706gZqn.gif)

## 堆的操作——插入删除

下面先给出《数据结构C++语言描述》中最小堆的建立插入删除的图解，再给出本人的实现代码，最好是先看明白图后再去看代码。

![img](http://hi.csdn.net/attachment/201108/24/0_131415207877s7.gif)

### 堆的插入

每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于**直接插入排序**中将一个数据并入到有序区间中，对照[《白话经典算法系列之二 直接插入排序的三种实现》](http://blog.csdn.net/morewindows/article/details/6665714)不难写出插入一个新数据时堆的调整代码：

```cpp
//  新加入i结点  其父结点为(i - 1) / 2



void MinHeapFixup(int a[], int i)



{



    int j, temp;



	



	temp = a[i];



	j = (i - 1) / 2;      //父结点



	while (j >= 0 && i != 0)



	{



		if (a[j] <= temp)



			break;



		



		a[i] = a[j];     //把较大的子结点往下移动,替换它的子结点



		i = j;



		j = (i - 1) / 2;



	}



	a[i] = temp;



}
```

更简短的表达为：

```cpp
void MinHeapFixup(int a[], int i)



{



	for (int j = (i - 1) / 2; (j >= 0 && i != 0)&& a[i] > a[j]; i = j, j = (i - 1) / 2)



		Swap(a[i], a[j]);



}
```

插入时：

```cpp
//在最小堆中加入新的数据nNum



void MinHeapAddNumber(int a[], int n, int nNum)



{



	a[n] = nNum;



	MinHeapFixup(a, n);



}
```

### 堆的删除

按定义，堆中每次都只能删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。下面给出代码：

```cpp
//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2



void MinHeapFixdown(int a[], int i, int n)



{



    int j, temp;



 



	temp = a[i];



	j = 2 * i + 1;



	while (j < n)



	{



		if (j + 1 < n && a[j + 1] < a[j]) //在左右孩子中找最小的



			j++;



 



		if (a[j] >= temp)



			break;



 



		a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点



		i = j;



		j = 2 * i + 1;



	}



	a[i] = temp;



}



//在最小堆中删除数



void MinHeapDeleteNumber(int a[], int n)



{



	Swap(a[0], a[n - 1]);



	MinHeapFixdown(a, 0, n - 1);



}
```

## 堆化数组

有了堆的插入和删除后，再考虑下如何对一个数据进行堆化操作。要一个一个的从数组中取出数据来建立堆吧，不用！先看一个数组，如下图：

![img](http://hi.csdn.net/attachment/201108/22/0_1314014725K5k6.gif)

很明显，对叶子结点来说，可以认为它已经是一个合法的堆了即20，60， 65， 4， 49都分别是一个合法的堆。只要从A[4]=50开始向下调整就可以了。然后再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分别作一次向下调整操作就可以了。下图展示了这些步骤：

![img](http://hi.csdn.net/attachment/201108/22/0_1314014735kbBA.gif)

写出堆化数组的代码：

```cpp
//建立最小堆



void MakeMinHeap(int a[], int n)



{



	for (int i = n / 2 - 1; i >= 0; i--)



		MinHeapFixdown(a, i, n);



}
```


至此，堆的操作就全部完成了(注1)，再来看下如何用堆这种数据结构来进行排序。

## 堆排序

首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。

由于堆也是用数组模拟的，故堆化数组后，第一次将A[0]与A[n - 1]交换，再对A[0…n-2]重新恢复堆。第二次将A[0]与A[n – 2]交换，再对A[0…n - 3]重新恢复堆，重复这样的操作直到A[0]与A[1]交换。由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。有点类似于**直接选择排序**。



```cpp
void MinheapsortTodescendarray(int a[], int n)



{



	for (int i = n - 1; i >= 1; i--)



	{



		Swap(a[i], a[0]);



		MinHeapFixdown(a, 0, i);



	}



}
```

注意使用最小堆排序后是递减数组，要得到递增数组，可以使用最大堆。



由于每次重新恢复堆的时间复杂度为O(logN)，共N - 1次重新恢复堆操作，再加上前面建立堆时N / 2次向下调整，每次调整时间复杂度也为O(logN)。二次操作时间相加还是O(N * logN)。故堆排序的时间复杂度为O(N * logN)。STL也实现了堆的相关函数，可以参阅《[STL系列之四 heap 堆](https://blog.csdn.net/morewindows/article/details/6967409)》。

 

 

注1 作为一个数据结构，最好用类将其数据和方法封装起来，这样即便于操作，也便于理解。此外，除了堆排序要使用堆，另外还有很多场合可以使用堆来方便和高效的处理数据，以后会一一介绍。

 

 

转载请标明出处，原文地址：<http://blog.csdn.net/morewindows/article/details/6709644>









# 白话经典算法系列之八 MoreWindows白话经典算法之七大排序总结篇

2012年09月10日 10:08:34

 

MoreWindows

 

阅读数：50000

更多

个人分类： [白话经典算法系列](https://blog.csdn.net/MoreWindows/article/category/859207)[Windows编程](https://blog.csdn.net/MoreWindows/article/category/862060)

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/7961256

​       在我的博客对**冒泡排序，直接插入排序，直接选择排序，希尔排序，归并排序，快速排序和堆排序**这七种常用的排序方法进行了详细的讲解，并做成了电子书以供大家下载。下载地址为：<http://download.csdn.net/detail/morewindows/4443208>。

​       有网友提议到这本《[MoreWindows白话经典算法之七大排序](http://download.csdn.net/detail/morewindows/4443208)》电子书讲解细致用来平时学习是非常好的，但是页数有22页，不太合适做面试前的复习资料。因此在这里将这七种常用的排序方法进行下总结，以便大家更好的复习这些经典的排序算法，为面试打下良好的基础。

 

首先回顾下各种排序的主要思路：

一．       **冒泡排序**

冒泡排序主要思路是：

通过交换使相邻的两个数变成小数在前大数在后，这样每次遍历后，最大的数就“沉”到最后面了。重复N次即可以使数组有序。



冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。



冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。

 

二．       **直接插入排序**

直接插入排序主要思路是：

每次将一个待排序的数据，插入到前面已经排好序的序列之中，直到全部数据插入完成。

 

三．       **直接选择排序**

直接选择排序主要思路是：

数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。



上面这三种排序都是非常简单的，下面这四种排序略有难度，希望读者能多多实践以加深理解。

 

四．       **希尔排序**

希尔排序主要思路是：

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对**相隔若干距离**的数据进行**直接插入排序**，因此可以形象的称希尔排序为“**跳着插**”

 

五．       **归并排序**

归并排序主要思路是：

当一个数组左边有序，右边也有序，那合并这两个有序数组就完成了排序。如何让左右两边有序了？用递归！这样**递归下去，合并上来**就是归并排序。

 

六．       **快速排序**

快速选择排序主要思路是：

**“挖坑填数+分治法”**，首先令i =L; j = R; 将a[i]挖出形成第一个坑，称a[i]为基准数。然后j--由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。

 

七．       **堆排序**

堆排序主要思路用张图示来表示更好：

![img](https://img-my.csdn.net/uploads/201209/09/1347195736_3889.PNG)



可见堆排序的难点就在于堆的的插入和删除。

堆的插入就是——每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，因此只要将这个新数据插入到这个有序数列中即可。

堆的删除就是——堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。

因此，堆的插入和删除非常类似**直接插入排序**，只不是在**二叉树**上进行插入过程。所以可以将堆排序形容为“**树上插**”

 

 

再用一张图表示下这七种常用的排序方法的关系。



 ![img](https://img-my.csdn.net/uploads/201209/09/1347195747_3017.PNG)

 



好了，七种常用的排序方法就总结到这了，相信大家上机写下代码再看下这张图必定会印象深刻。在准备面试资料时可以打印最后这张图，这样就能在面试前快速的复习一下了，祝大家面试顺利，拿到自己满意的offer。

 

新版电子书《MoreWindows白话经典算法之七大排序第2版(高清)》已经上传成功，下载地址是：<http://download.csdn.net/detail/morewindows/4560056>

 

转载请标明出处，原文地址：<http://blog.csdn.net/morewindows/article/details/7961256>





# 白话经典算法系列之九 从归并排序到数列的逆序数对（微软笔试题）

2012年10月15日 09:15:49

 

MoreWindows

 

阅读数：35709

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/8029996

首先来看看原题

 

微软2010年笔试题

在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序数对。一个排列中逆序的总数就称为这个排列的逆序数。如{2，4，3，1}中，2和1，4和3，4和1，3和1是逆序数对，因此整个数组的逆序数对个数为4，现在给定一数组，要求统计出该数组的逆序数对个数。

 

计算数列的逆序数对个数最简单的方便就最从前向后依次统计每个数字与它后面的数字是否能组成逆序数对。代码如下：

```cpp
#include <stdio.h>



int main()



{



	printf("     数列的逆序数对 \n");    



	printf(" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n");    



 



	const int MAXN = 8;



	int a[MAXN] = {1, 7, 2, 9, 6, 4, 5, 3};



	



	int nCount = 0;



	int i, j;



	for (i = 0; i < MAXN; i++)



		for (j = i + 1; j < MAXN; j++)



			if (a[i] > a[j])



				nCount++;



 



	printf("逆序数对为: %d\n", nCount);



}
```

运行结果如下：

![img](https://img-my.csdn.net/uploads/201209/28/1348838557_9200.PNG)

这种方法用到了双循环，时间复杂度为O(N^2)，是一个不太优雅的方法。因此我们尝试用其它方法来解决。

 

在《[白话经典算法系列之五归并排序的实现](http://blog.csdn.net/morewindows/article/details/6678165)》中观察归并排序——合并数列(1，3，5)与(2，4)的时候：

1．先取出前面数列中的1。

2．然后取出后面数列中的2，明显！这个2和前面的3，5都可以组成逆序数对即3和2，5和2都是逆序数对。

3．然后取出前面数列中的3。

4．然后取出后面数列中的4，同理，可知这个4和前面数列中的5可以组成一个逆序数对。

这样就完成了逆序数对的统计，归并排序的时间复杂度是O(N * LogN)，因此这种从归并排序到数列的逆序数对的解法的时间复杂度同样是O(N * LogN)，下面给出代码：

```cpp
//从归并排序到数列的逆序数对



#include <stdio.h>



int g_nCount;



void mergearray(int a[], int first, int mid, int last, int temp[])



{



	int i = first, j = mid + 1;



	int m = mid,   n = last;



	int k = 0;



 



	while (i <= m && j <= n) //a[i] 前面的数  a[j] 后面的数



	{



		if (a[i] < a[j])



			temp[k++] = a[i++];



		else



		{



			temp[k++] = a[j++];



			//a[j]和前面每一个数都能组成逆序数对



			g_nCount += m - i + 1;



		}



	}



 



	while (i <= m)



		temp[k++] = a[i++];



 



	while (j <= n)



		temp[k++] = a[j++];



 



	for (i = 0; i < k; i++)



		a[first + i] = temp[i];



}



void mergesort(int a[], int first, int last, int temp[])



{



	if (first < last)



	{



		int mid = (first + last) / 2;



		mergesort(a, first, mid, temp);    //左边有序



		mergesort(a, mid + 1, last, temp); //右边有序



		mergearray(a, first, mid, last, temp); //再将二个有序数列合并



	}



}



 



bool MergeSort(int a[], int n)



{



	int *p = new int[n];



	if (p == NULL)



		return false;



	mergesort(a, 0, n - 1, p);



	return true;



}



 



int main()



{



	printf("     从归并排序到数列的逆序数对 \n");    



	printf(" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n");    



 



	const int MAXN = 8;



	int a[MAXN] = {1, 7, 2, 9, 6, 4, 5, 3};



 



	g_nCount = 0;



	MergeSort(a, MAXN);



	printf("逆序数对为: %d\n", g_nCount);



	return 0;



}
```

运行结果：

![img](https://img-my.csdn.net/uploads/201209/28/1348838573_7621.PNG)

 

 

好了，介绍到这里后，相信大家对如何求数列的逆序数对已经有了很好的认识，文章中所用到的**“知识迁移”**这种方法还是不错的，值得大家掌握。

 

 

转载请标明出处，原文地址：<http://blog.csdn.net/morewindows/article/details/8029996>









# 白话经典算法系列之十 一道有趣的GOOGLE面试题

2012年11月21日 09:03:59

 

MoreWindows

 

阅读数：56275

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/8204460



微博<http://weibo.com/MoreWindows>已开通，欢迎关注。

最近在[微博](http://weibo.com/MoreWindows)上看到一道有趣的GOOGLE面试题，见下图：

![img](https://img-my.csdn.net/uploads/201211/20/1353401436_6587.PNG)



文字版：

一个大小为n的数组，里面的数都属于范围[0, n-1]，有不确定的重复元素，找到至少一个重复元素，要求O(1)空间和O(n)时间。

 

​    这个题目要求用O(n)的时间复杂度，这意味着只能遍历数组一次。同时还要寻找重复元素，很容易想到建立哈希表来完成，遍历数组时将每个元素映射到哈希表中，如果哈希表中已经存在这个元素则说明这就是个重复元素。因此直接使用C++ STL中的hash_set（参见《[STL系列之六 set与hash_set](http://blog.csdn.net/morewindows/article/details/7029587)》）可以方便的在O(n)时间内完成对重复元素的查找。

​    但是题目却在空间复杂度上有限制——要求为O(1)的空间。因此采用哈希表这种解法肯定在空间复杂度上是不符合要求的。但可以沿着哈希法的思路继续思考，题目中数组中所以数字都在范围[0， n-1]，因此哈希表的大小为n即可。因此我们实际要做的就是对n个范围为0到n-1的数进行哈希，而哈希表的大小刚好为n。对排序算法比较熟悉的同学不难发现这与一种经典的排序算法——基数排序非常类似。而基数排序的时间空间复杂度刚好符合题目要求！因此尝试使用基数排序来解这道面试题。

 

​    下面以2，4，1，5，7，6，1，9，0，2这十个数为例，展示下如何用基数排序来查找重复元素。

| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 | 2    | 4    | 1    | 5    | 7    | 6    | 1    | 9    | 0    | 2    |

（1）由于第0个元素a[0] 等于2不为0，故交换a[0]与a[a[0]]即交换a[0]与a[2]得：

| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 | 1    | 4    | 2    | 5    | 7    | 6    | 1    | 9    | 0    | 2    |

（2）由于第0个元素a[0] 等于1不为0，故交换a[0]与a[a[0]]即交换a[0]与a[1]得：

| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 | 4    | 1    | 2    | 5    | 7    | 6    | 1    | 9    | 0    | 2    |

（3）由于第0个元素a[0] 等于4不为0，故交换a[0]与a[a[0]]即交换a[0]与a[4]得：



| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 | 7    | 1    | 2    | 5    | 4    | 6    | 1    | 9    | 0    | 2    |

（4）由于第0个元素a[0] 等于7不为0，故交换a[0]与a[a[0]]即交换a[0]与a[7]得：



| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 | 9    | 1    | 2    | 5    | 4    | 6    | 1    | 7    | 0    | 2    |

（5）由于第0个元素a[0] 等于9不为0，故交换a[0]与a[a[0]]即交换a[0]与a[9]得：



| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 | 2    | 1    | 2    | 5    | 4    | 6    | 1    | 7    | 0    | 9    |

（6）由于第0个元素a[0] 等于2不为0，故交换a[0]与a[a[0]]即交换a[0]与a[2]，但a[2]也为2与a[0]相等，因此我们就找到了一个重复的元素——2。



| 下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 数据 | 2    | 1    | 2    | 5    | 4    | 6    | 1    | 7    | 0    | 9    |

 

 

​    有了上面的分析，代码不难写出：



```cpp
//GOOGLE面试题



//一个大小为n的数组，里面的数都属于范围[0, n-1]，有不确定的重复元素，找到至少一个重复元素，要求O(1)空间和O(n)时间。



//By MoreWindows (http://blog.csdn.net/MoreWindows)



#include <stdio.h>



const int NO_REPEAT_FLAG = -1;



void Swap(int &x, int &y)



{



	int t = x;



	x = y;



	y = t;



}



//类似于基数排序，找出数组中第一个重复元素。



int RadixSort(int a[], int n)



{



	int i;



	for (i = 0; i < n; i++)



	{



		while (i != a[i])



		{



			if (a[i] == a[a[i]])



				return a[i];



			Swap(a[i], a[a[i]]);



		}



	}



	return NO_REPEAT_FLAG;



}



void PrintfArray(int a[], int n)



{



	for (int i = 0; i < n; i++)



		printf("%d ", a[i]);



	putchar('\n');



}



int main()



{



	printf("    白话经典算法系列之十 一道有趣的GOOGLE面试题 \n");      



	printf(" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n"); 



 



	const int MAXN = 10;



	int a[MAXN] = {2, 4, 1, 5, 7,  6, 1, 9, 0, 2};



	//int a[MAXN] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};



 



	printf("数组为: \n");



	PrintfArray(a, MAXN);



 



	int nRepeatNumber = RadixSort(a, MAXN);



	if (nRepeatNumber != NO_REPEAT_FLAG)



		printf("该数组有重复元素，此元素为%d\n", nRepeatNumber);



	else



		printf("该数组没有重复元素\n");



	return 0;



}
```

​    运行结果如下图所示：



![img](https://img-my.csdn.net/uploads/201211/20/1353401509_7923.PNG)

​    整个程序的核心代码只有短短5行左右，虽然有二重循环语句，但每个元素只会被访问一次，完成符合题目对时间复杂度的要求。

 



**用基数排序来解决这道题目虽然思维巧妙，但会改动原数组的数据。有没有一种解法既找出一个重复的数据，又不改动数组中的数据了？请看**[**《【白话经典算法系列之十一】一道有趣的GOOGLE面试题 --【解法2】**](http://blog.csdn.net/morewindows/article/details/8212446)**》。**

 

 

转载请标明出处，原文地址：<http://blog.csdn.net/morewindows/article/details/8204460>

欢迎关注微博：<http://weibo.com/MoreWindows>

另外，白话经典算法系列的电子书已经发布至第二版了，下载地址为：<http://download.csdn.net/detail/morewindows/4560056>

 

 

### [【白话经典算法系列之十二】数组中只出现1次的两个数字(百度面试题) ](http://blog.csdn.net/morewindows/article/details/8214003)将介绍一道百度面试题，欢迎大家浏览。

 

 



# 【白话经典算法系列之十一】一道有趣的GOOGLE面试题 --【解法2】

2012年11月23日 07:57:18

 

MoreWindows

 

阅读数：28233

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/8212446

微博<http://weibo.com/MoreWindows>已开通，欢迎关注。

本系列文章地址：<http://blog.csdn.net/MoreWindows/article/category/859207>

 上一篇《[白话经典算法系列之十一道有趣的GOOGLE面试题](http://blog.csdn.net/morewindows/article/details/8204460)》中对一道有趣的GOOGLE面试题进行了详细的讲解，使用了类似于基数排序的做法在O(N)的时间复杂度和O(1)的空间复杂度完成了题目的要求，文章发表后，网友fengchaokobe在评论中给出了另一种解法，见下图。

![img](https://img-my.csdn.net/uploads/201211/22/1353568130_9766.PNG)

文字版：

```cpp
int Repeat(int *a, int n)



{



	for(int i = 0; i < n; i++)



	{



		if(a[i] > 0) //判断条件



		{



			if(a[ a[i] ] < 0)



			{



				return a[i];//已经被标上负值了，有重复



			}



			else 



			{



				a[ a[i] ]= -a[a[i]]; //记为负



			}



 



		}



		else // 此时|a[i]|代表的值已经出现过一次了



		{



			if(a[-a[i]] < 0)



			{



				return -a[i];//有重复找到



			}



			else 



			{



				a[ -a[i] ] = -a[ -a[i] ];



			}



		}



	}



	return -1;//数组中没有重复的数



}
```

下面对这种以取负为访问标志的方法用个实例来说明下：

​    设int a[] = {1, 2, 1}

​    第一步：由于a[0]等于1大于0，因此先判断下a[a[0]]即a[1]是否小于0，如果小于，说明这是第二次访问下标为1的元素，表明我们已经找到了重复元素。不是则将a[a[0]]取负，a[1]=-a[1]=-2。

​    第二步：由于a[1]等于-2，因此先判断下a[-a[1]]取出a[2]是否小于0，如果小于，说明这是第二次访问下标为2的元素，表明我们已经找到了重复元素。不是则将a[-a[1]]取负，a[2]=-a[2]=-1。

​    第三步：由于a[2]等于-1，因此判断下a[-a[2]]即a[1]是否小于0，由于a[1]在第一步中被取反过了，因此证明这是第二次访问下标为1的元素，直接返回-a[2]即可。

 

这种通过取负来判断元素是否重复访问的方法正如网友jwfeng002所言，当数组第0个元素为0且数据中只有0重复时是无法找出正确解的。只要用：

​       const int MAXN = 5;

​       int a[MAXN] = {0, 1, 2, 3, 0};

这组数据来测试，就会发现该方法无法判断0是个重复出现的元素。运行结果如下图所示：

![img](https://img-my.csdn.net/uploads/201211/22/1353568154_5948.PNG)

 

这个算法虽然有缺陷，但我们可以沿着这个算法的思路——这个算法之所以用到了取负，是因此根据题目条件，数组中数据范围为[0，n-1]，因此可以通过判断元素是否大于0来决定这个元素是未访问过的数据还是已访问过的数据。但也正因为对0的取负是无效操作决定了这个算法存在着缺陷。要改进一下也很简单——不用取负，而用加n。这样通过判断元素是否大于等于n就能决定这个元素是未访问过的数据还是已访问过的数据。完整代码如下：

```cpp
//GOOGLE面试题



//一个大小为n的数组，里面的数都属于范围[0, n-1]，有不确定的重复元素，找到至少一个重复元素，要求O(1)空间和O(n)时间。



//By MoreWindows (http://blog.csdn.net/MoreWindows)



#include <stdio.h>



const int NO_REPEAT_FLAG = -1;



int FindRepeatNumberInArray(int *a, int n)



{



	for(int i = 0; i < n; i++)



	{



		int nRealIndex = a[i] >= n ? a[i] - n : a[i];



		if (a[nRealIndex] >= n) //这个位置上的值大于n说明已经是第二次访问这个位置了



			return nRealIndex;



		else



			a[nRealIndex] += n;



	}



	return NO_REPEAT_FLAG; //数组中没有重复的数



}



void PrintfArray(int a[], int n)



{



	for (int i = 0; i < n; i++)



		printf("%d ", a[i]);



	putchar('\n');



}



int main()



{



	printf("    白话经典算法系列之十一 一道有趣的GOOGLE面试题解法2\n");      



	printf(" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n"); 



 



	const int MAXN = 10;



	//int a[MAXN] = {2, 4, 1, 5, 7,  6, 1, 9, 0, 2};



	int a[MAXN] = {0, 1, 2, 3, 4,  5, 6, 7, 8, 0};



	



	printf("数组为: \n");



	PrintfArray(a, MAXN);



 



	int nRepeatNumber = FindRepeatNumberInArray(a, MAXN);



	if (nRepeatNumber != NO_REPEAT_FLAG)



		printf("该数组有重复元素，此元素为%d\n", nRepeatNumber);



	else



		printf("该数组没有重复元素\n");



	return 0;



}
```

运行结果如图所示：



![img](https://img-my.csdn.net/uploads/201211/22/1353568174_8279.PNG)

如同上一篇《[白话经典算法系列之十一道有趣的GOOGLE面试题](http://blog.csdn.net/morewindows/article/details/8204460)》一样，算法的核心代码依然只有短短5行左右。在时间空间复杂度上也同样满足题目要求。

 

 

相信由这篇文章可以看出，思维的转换性对寻找一个合适算法是非常有用的。

 

另外，代码的书写也要注意一下，对比一下文章中的Repeat()函数与FindRepeatNumberInArray()就能发现对代码进行一下简洁是非常有必要的。如果真在GOOGLE的面试中，虽然都完成了面试题，但面试官对这二份代码的感觉会是如何了？这也正是很多童鞋在面试后感觉困惑，为什么答的还不错怎么就面挂了。

 

白话经典算法系列文章地址：

<http://blog.csdn.net/MoreWindows/article/category/859207>

转载请标明出处，原文地址：<http://blog.csdn.net/morewindows/article/details/8212446>

欢迎关注微博：<http://weibo.com/MoreWindows>





# 【白话经典算法系列之十二】数组中只出现1次的两个数字(百度面试题)

2012年11月27日 09:17:57

 

MoreWindows

 

阅读数：41236

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/8214003

微博<http://weibo.com/MoreWindows>已开通，欢迎关注。

本系列文章地址：<http://blog.csdn.net/MoreWindows/article/category/859207>

首先来看题目要求：

在一个数组中除两个数字只出现1次外，其它数字都出现了2次， 要求尽快找出这两个数字。

​    考虑下这个题目的简化版——数组中除一个数字只出现1次外，其它数字都成对出现，要求尽快找出这个数字。这个题目在之前的《[位操作基础篇之位操作全面总结](http://blog.csdn.net/morewindows/article/details/7354571)》中的“位操作趣味应用”中就已经给出解答了。根据异或运算的特点，直接异或一次就可以找出这个数字。

​    现在数组中有两个数字只出现1次，直接异或一次只能得到这两个数字的异或结果，但光从这个结果肯定无法得到这个两个数字。因此我们来分析下简化版中“异或”解法的关键点，这个关键点也相当明显——**数组只能有一个数字出现1次**。

​    设题目中这两个只出现1次的数字分别为A和B，如果能将A，B分开到二个数组中，那显然符合“异或”解法的关键点了。因此这个题目的关键点就是将A，B分开到二个数组中。**由于A，B肯定是不相等的，因此在二进制上必定有一位是不同的。根据这一位是0还是1可以将A，B分开到A组和B组。**而这个数组中其它数字要么就属于A组，要么就属于B组。再对A组和B组分别执行“异或”解法就可以得到A，B了。而要判断A，B在哪一位上不相同，只要根据A异或B的结果就可以知道了，这个结果在二进制上为1的位都说明A，B在这一位上是不相同的。

​    比如int a[] = {1, 1, 3, 5, 2, 2}

​    整个数组异或的结果为3^5即 0x0011 ^ 0x0101 = 0x0110

​    对0x0110，第1位（由低向高，从0开始）就是1。因此整个数组根据第1位是0还是1分成两组。

​    a[0] =1  0x0001  第一组

​    a[1] =1  0x0001  第一组

​    a[2] =3  0x0011  第二组

​    a[3] =5  0x0101  第一组

​    a[4] =2  0x0010  第二组

​    a[5] =2  0x0010  第二组

​    第一组有{1, 1, 5}，第二组有{3, 2, 3}，明显对这二组分别执行“异或”解法就可以得到5和3了。

​    分析至些，相信代码不难写出，下面给出完整的源代码：

```cpp
// 百度面试题



//数组中除两个数字外，其它数字都出现了次。要求尽可能快的找出这两个数字



//By MoreWindows (http://blog.csdn.net/MoreWindows)



#include <stdio.h>



void FindTwoNotRepeatNumberInArray(int *a, int n, int *pN1, int *pN2)



{



	int i, j, temp;



    



	//计算这两个数的异或结果



	temp = 0;



	for (i = 0; i < n; i++)



		temp ^= a[i];



	



	// 找第一个为1的位



	for (j = 0; j < sizeof(int) * 8; j++)



		if (((temp >> j) & 1) == 1)



			break;



 



	// 第j位为1,说明这两个数字在第j位上是不相同的



	// 由此分组即可



	*pN1 = 0, *pN2 = 0;



	for (i = 0; i < n; i++)



		if (((a[i] >> j) & 1) == 0)



			*pN1 ^= a[i];



		else



			*pN2 ^= a[i];



}



void PrintfArray(int a[], int n)



{



	for (int i = 0; i < n; i++)



		printf("%d ", a[i]);



	putchar('\n');



}



int main()



{



	printf("    白话经典算法系列之十二数组中不重复的个数字(百度面试题) \n");      



	printf(" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n"); 



 



	const int MAXN = 10;



	//int a[MAXN] = {1, 2, 7, 5, 100,  100, 6, 1, 2, 5};



	int a[MAXN] = {1, 2, 3, 4, 1,  2, 3, 4, 0, 5};



 



	printf("数组为: \n");



	PrintfArray(a, MAXN);



 



	int nNotRepeatNumber1, nNotRepeatNumber2;



	FindTwoNotRepeatNumberInArray(a, MAXN, &nNotRepeatNumber1, &nNotRepeatNumber2);



	printf("两个不重复的数字分别为: %d %d\n", nNotRepeatNumber1, nNotRepeatNumber2);



	return 0;



}
```

运行结果如下所示：

![img](https://img-my.csdn.net/uploads/201211/22/1353588176_1246.PNG)

 

百度面试在算法这一环节上一般会出多道算法题，下次再整理几篇，欢迎大家继续参阅。

 

白话经典算法系列文章地址：

<http://blog.csdn.net/MoreWindows/article/category/859207>

转载请标明出处，原文地址：<http://blog.csdn.net/morewindows/article/details/8214003>

欢迎关注微博：<http://weibo.com/MoreWindows>





# 【白话经典算法系列之十三】随机生成和为S的N个正整数——投影法

2013年01月04日 13:46:21

 

MoreWindows

 

阅读数：18271

更多

所属专栏： [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html) [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/8439393

【白话经典算法系列之十三】随机生成和为S的N个正整数——投影法 

​    随机生成和为S的N个正整数有很多种解法。下面讲解一种比较高效且比较有趣味性的解法——投影法。

​    以生成和为20的4个数为例，可以先生成随机生成0到20之间的三个数字再排序，假设得到了4，7，18。然后在X-Y数轴上画出这三个数，如下图：

![img](https://img-my.csdn.net/uploads/201212/26/1356508045_8531.PNG)

然后将这些数值投影到Y轴上，可得下图：

![img](https://img-my.csdn.net/uploads/201212/26/1356508060_2198.PNG)

由图很容易看出AB，BC，CD，DE这四段的长度和肯定为20。因此AB，BC，CD，DE这四段的长度即和为20的4个数，这4个数分别为4，3，11，2。

 

这种方法只要随机生成N - 1个小于S的不同数字，排序后计算两两差值就可以得到和为S的N个正整数，因此效率还是比较高的。下面给出完整代码（随机生成N - 1个不同数可以参考《[STL系列十一随机三趣题——随机重排，文件中随机取一行，生成N个随机数](http://blog.csdn.net/morewindows/article/details/7659532)》）：

```cpp
#include <cstdio>



#include <ctime>



#include <set>



#include <algorithm>



using namespace std;



//在[s, e)区间上随机取n个数并存放到a[]中



void GetRandomNum(int *a, int n, int s, int e)



{



	std::set<int> set_a;



	srand(time(NULL));



	for (int i = e - n; i < e; i++)



	{



		int num = (rand() % i) + s;



		if (set_a.find(num) == set_a.end())



			set_a.insert(num);



		else



			set_a.insert(i);



	}



	i = 0;



	std::set<int>::iterator pos;



	for (pos = set_a.begin(); pos != set_a.end(); pos++)



		a[i++] = *pos;



}



int main()



{



	const int NSUM = 20;



	const int NCOUNT = 4;



	



	printf("           生成和为%d的%d个数 \n", NSUM, NCOUNT);



	printf("--- by MoreWindows( http://blog.csdn.net/MoreWindows )  ---\n\n");	



	



	int    a[NCOUNT];



	



	GetRandNumberInRange(a, NCOUNT - 1, 0, NSUM);



	sort(a, a + NCOUNT - 1);



	a[NCOUNT - 1] = NSUM;



 



	printf("  已经生成和为%d的%d个数: \n", NSUM, NCOUNT);



	printf("%d ", a[0]);



	for (int i = 1; i < NCOUNT; i++)



		printf("%d ", a[i] - a[i - 1]);



	putchar('\n');



	return 0;



}
```

运算结果如下图所示：

![img](https://img-my.csdn.net/uploads/201212/26/1356508158_1462.PNG)

 

这种“投影法”能有效解决随机生成和为S的N个正整数，其算法本质是**通过“投影”得到各数据之间的长度差，而且这些长度差之和即投影线段的总长度显然会等于最大数据的值减去最小数据的值**。

 

下面分析下算法的时间复杂度：

算法分为生成随机的N-1个数+排序+遍历共费时O(N * logN) +O(N * logN) + O(N)，整体时间复杂度为O(N * logN)。

算法的最主要费时操作在排序上，如果数据量不是太大，使用基数排序（见《[【白话经典算法系列之十】一道有趣的GOOGLE面试题解法](http://blog.csdn.net/morewindows/article/details/8204460)》）可以将排序操作的时间复杂度降低到O(N)。

其次在生成随机的N-1个数时，虽然只要调用rand()随机函数N-1次，但由于使用了set来做数据存储的容器，因此每次插入数据前的查找要费时O(logN)，插入新数据时也要费时O(logN)，可以改用hast_set来进一步提高效率（见《[STL系列之六 set与hash_set](http://blog.csdn.net/morewindows/article/details/7029587)》）。

 

欢迎大家讨论新颖的解法^_^，多多交流，开阔思路。

 

 

《白话经典算法系列》专栏地址：<http://blog.csdn.net/morewindows/article/category/859207>

转载请标明出处，原文地址：

欢迎关注微博：<http://weibo.com/MoreWindows>





# 【白话经典算法系列之十四】腾讯2012年实习生笔试加分题

2013年04月01日 09:25:57

 

MoreWindows

 

阅读数：46160

更多

所属专栏： [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html) [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/8742666

地址：<http://blog.csdn.net/morewindows/article/details/8742666>转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>      

 

​    之前参加2012年腾讯实习生笔试时，在考场中遇到一道加分题，当时灵光一闪，直接挥笔就解决这道题目。今天看到学校论坛上有师弟师妹们在询问这题的解法，就写篇博客来分享我的解法吧，也欢迎大家讨论其它解法。

​    首先来看题目描述：

三 、加分题

28）给定一数组a[N]，我们希望构造数组b [N]，其中b[j]=a[0]*a[1]…a[N-1] / a[j]，在构造过程中，不允许使用除法：

要求O（1）空间复杂度和O（n）的时间复杂度；

除遍历计数器与a[N] b[N]外，不可使用新的变量（包括栈临时变量、堆空间和全局静态变量等）；

实现程序（主流编程语言任选）实现并简单描述。

​    这道题目最为独特的要求就是除去遍历计算器外不能申请其它新的变量。怎么解决了？首先不考虑这个条件，代码如下：

```cpp
// 腾讯2012年实习生笔试加分题



//http://blog.csdn.net/morewindows/article/details/8742666



//By MoreWindows( http://blog.csdn.net/MoreWindows )



#include <stdio.h>



void PrintfArray(int a[], int n)  



{  



	for (int i = 0; i < n; i++)  



		   printf("%5d ", a[i]);  



	putchar('\n');  



} 



int main()



{



	printf("    腾讯2012年实习生笔试加分题  \n");



	printf(" - http://blog.csdn.net/morewindows/article/details/8742666 -\n");



	printf(" -- By MoreWindows( http://blog.csdn.net/MoreWindows ) --\n\n"); 



	



	const int MAXN = 5;



	int a[MAXN] = {1, 3, 5, 7, 9};



	int b[MAXN];



	



	printf("数组a为:\n");



	PrintfArray(a, MAXN);



 



	b[0] = 1;



	int i;



	for (i = 1; i < MAXN; i++)



		b[i] = b[i - 1] * a[i - 1];



	int temp = 1;



	for (i = MAXN - 2; i >= 0; i--)



	{



		temp *= a[i + 1];



		b[i] *= temp;



	}



 



	printf("数组b为:\n");



	PrintfArray(b, MAXN);



	return 0;



}
```



解释下代码，设有数组大小为5。

对于第一个for循环

第一步：b[0] = 1;

第二步：b[1] = b[0] * a[0] = a[0]

第三步：b[2] = b[1] * a[1] = a[0] * a[1];

第四步：b[3] = b[2] * a[2] = a[0] * a[1] * a[2];

第五步：b[4] = b[3] * a[3] = a[0] * a[1] * a[2] * a[3];

然后对于第二个for循环

第一步

temp *= a[4] = a[4];  

b[3] = b[3] * temp = a[0] * a[1] * a[2] * a[4];

第二步

temp *= a[3] = a[4] * a[3];

b[2] = b[2] * temp = a[0] * a[1] * a[4] * a[3];

第三步

temp *= a[2] = a[4] * a[3] * a[2];  

b[1] = b[1] * temp = a[0] * a[4] * a[3] * a[2];

第四步

temp *= a[1] = a[4] * a[3] * a[2] * a[1];  

b[0] = b[0] * temp = a[4] * a[3] * a[2] * a[1];

由此可以看出从b[4]到b[0]均已经得到正确计算。

运行结果如下所示（图片无法打开？请访问<http://blog.csdn.net/morewindows/article/details/8742666>）：

![img](https://img-my.csdn.net/uploads/201303/31/1364714744_3084.png)

然后考虑到题目要求不能申请额外的临时变量，因此int temp肯定是不能有的，那用什么来代替这个temp了？很简单，用b[0]来代替即可。于是上面的第二个for循环语句变为：

```cpp
	for (i = MAXN - 1; i >= 1; i--)



	{



		b[i] *= b[0];



		b[0] *= a[i];



	}
```

试验下，运行结果如下所示（图片无法打开？请访问<http://blog.csdn.net/morewindows/article/details/8742666>）：

![img](https://img-my.csdn.net/uploads/201303/31/1364714845_4899.png)

呵呵，**b[0]一代替，轻轻松松加分到手^_^**。有其它方法欢迎交流（<http://weibo.com/MoreWindows>  Or[morewindows@126.com](mailto:morewindows@126.com)），谢谢。

 

地址：<http://blog.csdn.net/morewindows/article/details/8742666>转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>      





# 【白话经典算法系列之十五】“一步千里”之数组找数

2013年09月02日 12:57:19

 

MoreWindows

 

阅读数：28854

更多

所属专栏： [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html) [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/10645269

本文地址：<http://blog.csdn.net/morewindows/article/details/10645269>转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>    

首先看看题目要求（题目来源：<http://weibo.com/lirenchen>，特此鸣谢）：

有这样一个数组A，大小为n，相邻元素差的绝对值都是1。如：A={4,5,6,5,6,7,8,9,10,9}。现在，给定A和目标整数t，请找到t在A中的位置。除了依次遍历，还有更好的方法么？

这道题目的解法非常有趣。

数组第一个数为array[0], 要找的数为y，设t = abs(y - array[0])。由于每个相邻的数字之差的绝对值为1。故第t个位置之前的数肯定都比y小。因此直接定位到array[t]，重新计算t，t = abs(y – array[t])，再重复上述步骤即可。这种算法主要利用了当前位置的数与查找数的差来实现跨越式搜索。算法效率要比遍历数组的算法要高一些，并且易于实现。完整的代码如下：

```cpp
// 【白话经典算法系列之十五】“一步千里”之数组找数



//  by MoreWindows( http://blog.csdn.net/MoreWindows ) 



//  欢迎关注http://weibo.com/morewindows



#include <stdio.h>



#include <math.h>



void PrintfArray(int a[], int n)  



{  



  for (int i = 0; i < n; i++)  



      printf("%d ", a[i]);  



  putchar('\n');  



} 



int FindNumberInArray(int arr[], int n , int find_number)



{



  int next_arrive_index = abs(find_number - arr[0]);



  while (next_arrive_index < n)



  {



    if (arr[next_arrive_index] == find_number)



      return next_arrive_index;



    next_arrive_index += abs(find_number - arr[next_arrive_index]);



  }



  return -1;



}



int main()



{



  printf("    【白话经典算法系列之十五】“一步千里”之数组找数\n");



  printf(" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n");



  printf(" -- http://blog.csdn.net/morewindows/article/details/10645269 -- \n\n");



 



  const int MAXN = 10;



  int arr[MAXN] = {4,5,6,5,6,7,8,9,10,9};



  PrintfArray(arr, MAXN);



  for (int i = 0; i < MAXN; i++)



    printf("查找%d   \t下标为%d\n", arr[i], FindNumberInArray(arr, MAXN, arr[i]));



 



  printf("查找%d   \t下标为%d\n", -1, FindNumberInArray(arr, MAXN, -1));



  printf("查找%d   \t下标为%d\n", 0, FindNumberInArray(arr, MAXN, 0));



  printf("查找%d   \t下标为%d\n", 100, FindNumberInArray(arr, MAXN, 100));



  return 0;



}
```

运行结果如下图所示：

![img](https://img-blog.csdn.net/20130831110459187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9yZVdpbmRvd3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 

本文地址：<http://blog.csdn.net/morewindows/article/details/10645269>转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>   





# 【白话经典算法系列之十六】“基数排序”之数组中缺失的数字

2013年10月15日 10:17:41

 

MoreWindows

 

阅读数：16289

 

标签： [白话经典算法](http://so.csdn.net/so/search/s.do?q=%E7%99%BD%E8%AF%9D%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95&t=blog)[数组](http://so.csdn.net/so/search/s.do?q=%E6%95%B0%E7%BB%84&t=blog)[基数排序](http://so.csdn.net/so/search/s.do?q=%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F&t=blog)[缺失的数字](http://so.csdn.net/so/search/s.do?q=%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97&t=blog)[面试题](http://so.csdn.net/so/search/s.do?q=%E9%9D%A2%E8%AF%95%E9%A2%98&t=blog)更多

个人分类： [白话经典算法系列](https://blog.csdn.net/MoreWindows/article/category/859207)

所属专栏： [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html) [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/12683723

本文地址：<http://blog.csdn.net/morewindows/article/details/12683723> 转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>    

首先看看题目要求：

给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的整数。比如[1,2,0]返回3，[3,4,-1,1]返回2，[1, 5, 3, 4, 2]返回6，[100, 3, 2, 1, 6,8, 5]返回4。要求使用O(1)空间和O(n)时间。

 

这道题目初看没有太好的思路，但是借鉴下《[白话经典算法系列之十  一道有趣的GOOGLE面试题](http://blog.csdn.net/morewindows/article/details/8204460)》这篇文章，我们不发现使用“基数排序”正好可以用来解决这道题目。

以{1, 3, 6, -100, 2}为例来简介这种解法：

从第一个数字开始，由于a[0]=1，所以不用处理了。

第二个数字为3，因此放到第3个位置（下标为2），交换a[1]和a[2]，得到数组为{1, 6, 3, -100, 2}。由于6无法放入数组，所以直接跳过。

第三个数字是3，不用处理。

第四个数字是-100，也无法放入数组，直接跳过。

第五个数字是2，因此放到第2个位置（下标为1），交换a[4]和a[1]，得到数组为{1, 2, 3, -100, 6}，由于6无法放入数组，所以直接跳过。
此时“基数排序”就完成了，然后再从遍历数组，如果对于某个位置上没该数，就说明数组缺失了该数字。如{1, 2, 3, -100, 6}缺失的就为4。

这样，通过第i个位置上就放i的“基数排序”就顺利的搞定此题了。

 

代码也非常好写，不过在交换两数时要注意判断下两个数字是否相等，不然对于像{1, 1, 1}这样的数据会出现死循环。

完整的代码如下：



```cpp
// 【白话经典算法系列之十六】“基数排序”之数组中缺失的数字



//  by MoreWindows( http://blog.csdn.net/MoreWindows ) 



//  欢迎关注http://weibo.com/morewindows



#include <stdio.h>



void Swap(int &a, int &b)



{



  int c = a;



  a = b;



  b = c;



}



int FindFirstNumberNotExistenceInArray(int a[], int n)



{



  int i;



  // 类似基数排序，当a[i]>0且a[i]<N时保证a[i] == i + 1



  for (i = 0; i < n; i++)



    while (a[i] > 0 && a[i] <= n && a[i] != i + 1 && a[i] != a[a[i] - 1])



        Swap(a[i], a[a[i] - 1]);



  // 查看缺少哪个数



  for (i = 0; i < n; i++)



    if (a[i] != i + 1)



      break;



  return i + 1;



}



void PrintfArray(int a[], int n)  



{  



  for (int i = 0; i < n; i++)  



    printf("%d ", a[i]);  



  putchar('\n');  



} 



int main()



{



  printf("    【白话经典算法系列之十六】“基数排序”之数组中缺失的数字\n");



  printf(" -- by MoreWindows( http://blog.csdn.net/MoreWindows ) --\n");



  printf(" -- http://blog.csdn.net/morewindows/article/details/12683723 -- \n\n");



 



  const int MAXN = 5;



  //int a[MAXN] = {1, 2, 3, 4, 7}; 



  //int a[MAXN] = {1, 3, 5, 4, 2};



  int a[MAXN] = {2, -100, 4, 1, 70};



  //int a[MAXN] = {2, 2, 2, 2, 1};



  PrintfArray(a, MAXN);



  printf("该数组缺失的数字为%d\n", FindFirstNumberNotExistenceInArray(a, MAXN));



  return 0;



}
```

运行结果如下图所示：

 ![img](https://img-blog.csdn.net/20131013194529234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9yZVdpbmRvd3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 

本文地址：<http://blog.csdn.net/morewindows/article/details/12683723> 转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>    


 

 

 

 【白话经典算法系列之十七】 数组中只出现一次的数

2013年10月21日 11:49:03

 

MoreWindows

 

阅读数：37672

更多

所属专栏： [白话经典算法](https://blog.csdn.net/column/details/algorithm-easyword.html) [Windows C/C++/C# 编程](https://blog.csdn.net/column/details/morewindows-program.html)



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/MoreWindows/article/details/12684497

本文地址：<http://blog.csdn.net/morewindows/article/details/12684497>转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>    

首先看看题目要求：

数组A中，除了某一个数字x之外，其他数字都出现了三次，而x出现了一次。请给出最快的方法找到x。

 

这个题目非常有意思，在本人博客中有《[位操作基础篇之位操作全面总结](http://blog.csdn.net/morewindows/article/details/7354571)》这篇文章介绍了使用位操作的异或来解决——数组中其他数字出现二次，而x出现一次，找出x。有《[【白话经典算法系列之十二】数组中只出现1次的两个数字(百度面试题)](http://blog.csdn.net/morewindows/article/details/8214003)》这边文章介绍了分组异或的方法来解决——数组中其他数字出现二次，而x和y出现一次，找出x和y。而这个题目则是其他数字出现3次，x出现一次。

 

应该如何思考了？

 

前两篇文章是利用两个相同的数异或结果为0来计算的，但这个题目中其他数字是出现了3次，因此肯定不可以再使用异或了。

我们换一个角度来看，如果数组中没有x，那么数组中所有的数字都出现了3次，在二进制上，每位上1的个数肯定也能被3整除。如{1, 5, 1, 5, 1, 5}从二进制上看有：

1：0001

5：0101

1：0001

5：0101

1：0001

5：0101

二进制第0位上有6个1，第2位上有3个1.第1位和第3位上都是0个1，每一位上的统计结果都可以被3整除。而再对该数组添加任何一个数，如果这个数在二进制的某位上为1都将导致该位上1的个数不能被3整除。因此通过统计二进制上每位1的个数就可以推断出x在该位置上是0还是1了，这样就能计算出x了。

推广一下，所有其他数字出现N（N>=2）次，而一个数字出现1次都可以用这种解法来推导出这个出现1次的数字。

示范代码如下：

```cpp
// 【白话经典算法系列之十七】数组中只出现一次的数
//  by MoreWindows( http://blog.csdn.net/MoreWindows ) 
//  欢迎关注http://weibo.com/morewindows
#include <stdio.h>
#include <string.h>
int FindNumber(int a[], int n)
{
  int bits[32];
  int i, j;
  // 累加数组中所有数字的二进制位
  memset(bits, 0, 32 * sizeof(int));
  for (i = 0; i < n; i++)
    for (j = 0; j < 32; j++)
      bits[j] += ((a[i] >> j) & 1);
  // 如果某位上的结果不能被整除，则肯定目标数字在这一位上为
  int result = 0;
  for (j = 0; j < 32; j++)
    if (bits[j] % 3 != 0)
      result += (1 << j);
  return result;
}
int main()
{
  const int MAXN = 10;
  int a[MAXN] = {2, 3, 1, 2, 3, 4, 1, 2, 3, 1};
  printf("%d\n", FindNumber(a, MAXN));
  return 0;
}
```

运行结果如下图所示：

![img](https://img-blog.csdn.net/20131021114800343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTW9yZVdpbmRvd3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 

 

本文地址：<http://blog.csdn.net/morewindows/article/details/12684497>转载请标明出处，谢谢。

欢迎关注微博：<http://weibo.com/MoreWindows>    


 



