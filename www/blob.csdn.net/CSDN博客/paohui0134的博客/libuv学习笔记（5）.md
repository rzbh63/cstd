
# libuv学习笔记（5） - paohui0134的博客 - CSDN博客


2016年06月12日 10:10:26[paohui0134](https://me.csdn.net/paohui0134)阅读数：2554


# libuv学习笔记（5）
## uv_timer_t 定时器的数据结构与相关API
所有的定时器存在一颗红黑树中，红黑树在tree.h中定义，通过宏的方式实现类似模板的功能。红黑树的具体实现可以参考sgi_stl的红黑树，差别不大，树节点的内存分配需要用户管理。
### 数据结构
在uv.h中定义
```python
typedef
```
```python
struct
```
```python
uv_timer_s uv_timer_t;
```
```python
struct
```
```python
uv_timer_s 
{
  UV_HANDLE_FIELDS
```
```python
//uv_handle_t的数据，此处不再展开，请参考之前的文章
```
```python
//UV_TIMER_PRIVATE_FIELDS展开如下：
```
```python
RB_ENTRY(uv_timer_s) tree_entry;
```
```python
//红黑树节点
```
```python
uint64_t due;                                                              
  uint64_t repeat;
```
```python
//重复执行的间隔，为零将只执行一次回调
```
```python
uint64_t start_id;                                                          
  uv_timer_cb timer_cb;
```
```python
//回调函数
```
```python
};
```
### 相关函数
#### 1.初始化函数，导出函数，在uv.h中声明，timer.c中定义
```python
int uv_timer_init(uv_loop_t*
```
```python
loop
```
```python
, uv_timer_t* handle) 
{
```
```python
//
```
```python
uv__handle_init(
```
```python
loop
```
```python
, (uv_handle_t*) handle, UV_TIMER);宏展开如下：
```
```python
do
```
```python
{
```
```python
(handle)
```
```python
->
```
```python
loop
```
```python
= (
```
```python
loop
```
```python
);
```
```python
(handle)
```
```python
->
```
```python
type = (UV_TIMER);
```
```python
(handle)
```
```python
->
```
```python
flags = UV__HANDLE_REF;
```
```python
/* 设置为引用状态 */
```
```python
//
```
```python
将定时器handle添加到
```
```python
loop
```
```python
handle队列的末尾
    QUEUE_INSERT_TAIL
```
```python
(&(
```
```python
loop
```
```python
)->handle_queue, &(handle)->handle_queue)
```
```python
;               
    //
```
```python
uv__handle_platform_init
```
```python
(h)
```
```python
; 宏展开如下：
```
```python
((handle)->u.fd = -
```
```python
1
```
```python
)
```
```python
}
```
```python
while
```
```python
(
```
```python
0
```
```python
)
```
```python
;
```
```python
handle
```
```python
->
```
```python
timer_cb = NULL;
  handle->repeat =
```
```python
0
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
#### 2.开启定时器，导出函数，在uv.h中声明，timer.c中定义
```python
int uv_timer_start(uv_timer_t
```
```python
*
```
```python
handle
```
```python
,
```
```python
//定时器句柄
```
```python
uv_timer_cb cb,
```
```python
//定时器回调函数
```
```python
uint64_t timeout,
```
```python
//第一次回调间隔，毫秒
```
```python
uint64_t repeat)
```
```python
//重复回调间隔，毫秒
```
```python
{
  uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
  uv_timer_t
```
```python
*
```
```python
old;
```
```python
if
```
```python
(timer_cb
```
```python
==
```
```python
NULL
```
```python
)
```
```python
//必须设置回调函数
```
```python
return
```
```python
UV_EINVAL;
```
```python
//如果已经是激活状态，先停止。此时起到更新作用
```
```python
//if (uv__is_active(handle))展开如下：
```
```python
if
```
```python
((((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_ACTIVE)
```
```python
!=
```
```python
0
```
```python
))
    uv_timer_stop(
```
```python
handle
```
```python
);
```
```python
handle
```
```python
->
```
```python
timer_cb
```
```python
=
```
```python
timer_cb;
```
```python
//获取第一次执行相对loop的当前时间的时间。(loop->time + timeout)
```
```python
handle
```
```python
->
```
```python
due
```
```python
=
```
```python
get_clamped_due_time(
```
```python
loop
```
```python
->
```
```python
time, timeout);
```
```python
handle
```
```python
->
```
```python
repeat
```
```python
=
```
```python
repeat;
```
```python
//uv__handle_start(handle);展开如下：
```
```python
//激活定时器
```
```python
do
```
```python
{                                                                        
    assert(((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING)
```
```python
==
```
```python
0
```
```python
);
```
```python
if
```
```python
(((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_ACTIVE)
```
```python
!=
```
```python
0
```
```python
) break;                         
    (
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV__HANDLE_ACTIVE;
```
```python
if
```
```python
(((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_REF)
```
```python
!=
```
```python
0
```
```python
)
```
```python
//uv__active_handle_add(handle); 展开如下：
```
```python
do
```
```python
{                                                                       
            (h)
```
```python
->
```
```python
loop
```
```python
->
```
```python
active_handles
```
```python
++
```
```python
;
```
```python
//loop中活动的句柄数量加一
```
```python
}
```
```python
while
```
```python
(
```
```python
0
```
```python
)  
  }
```
```python
while
```
```python
(
```
```python
0
```
```python
);
```
```python
// start_id 是uv__timer_cmp()函数中的第二比较对象
```
```python
handle
```
```python
->
```
```python
start_id
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
->
```
```python
timer_counter
```
```python
++
```
```python
;
```
```python
//定时器数量加一，timer_counter只会递增
```
```python
//将定时器插入红黑树（树中不应该存在相同的定时器——时间相同，strat_id也相同）
```
```python
old
```
```python
=
```
```python
RB_INSERT(uv_timer_tree_s,
```
```python
&
```
```python
loop
```
```python
->
```
```python
timers,
```
```python
handle
```
```python
);
  assert(old
```
```python
==
```
```python
NULL
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
#### 3.停止定时器，导出函数，在uv.h中声明，timer.c中定义
```python
int uv_timer_stop(uv_timer_t* handle) 
{
```
```python
//
```
```python
非线程安全
  uv_loop_t*
```
```python
loop
```
```python
= handle->
```
```python
loop
```
```python
;
```
```python
//
```
```python
非激活状态，直接返回
```
```python
if
```
```python
(!uv__is_active(handle))
```
```python
return
```
```python
0
```
```python
;
```
```python
//
```
```python
在红黑树中移除
  RB_REMOVE(uv_timer_tree_s, &
```
```python
loop
```
```python
->timers, handle);
```
```python
//
```
```python
uv__handle_stop(handle);展开：
```
```python
do
```
```python
{                                                                        
    assert
```
```python
(((h)->flags & UV__HANDLE_CLOSING) ==
```
```python
0
```
```python
)
```
```python
;
    //非活动状态直接返回
```
```python
if
```
```python
(((h)->flags & UV__HANDLE_ACTIVE) ==
```
```python
0
```
```python
)
```
```python
break
```
```python
;
```
```python
(h)
```
```python
->
```
```python
flags &= ~UV__HANDLE_ACTIVE;
```
```python
//
```
```python
去掉激活状态标志
```
```python
//
```
```python
如果定时器处于引用状态，
```
```python
loop
```
```python
活动的handle数减一
```
```python
if
```
```python
(((h)->flags & UV__HANDLE_REF) !=
```
```python
0
```
```python
)
```
```python
uv__active_handle_rm
```
```python
(h)
```
```python
; 
  }
```
```python
while
```
```python
(
```
```python
0
```
```python
)
```
```python
；
```
```python
return
```
```python
0;
}
```
#### 4.再次运行，导出函数，在uv.h中声明，timer.c中定义
```python
int uv_timer_again(uv_timer_t
```
```python
*
```
```python
handle
```
```python
) 
{
```
```python
/* 如果回调函数timer_cb 是null，意味着定时器还未开始 */
```
```python
if
```
```python
(
```
```python
!
```
```python
handle
```
```python
->
```
```python
timer_cb) 
  {
```
```python
return
```
```python
UV_EINVAL;
  }
```
```python
//如果重复运行间隔不为0，那么以间隔值重新开始定时器
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
repeat) {
    uv_timer_stop(
```
```python
handle
```
```python
);
    uv_timer_start(
```
```python
handle
```
```python
,
```
```python
handle
```
```python
->
```
```python
timer_cb,
```
```python
handle
```
```python
->
```
```python
repeat,
```
```python
handle
```
```python
->
```
```python
repeat);
  }
```
```python
return
```
```python
0
```
```python
;
}
```
#### 5.设置重复间隔值，导出函数，在uv.h中声明，timer.c中定义
```python
void
```
```python
uv_timer_set_repeat(uv_timer_t
```
```python
*
```
```python
handle
```
```python
, uint64_t repeat) 
{
  assert(
```
```python
handle
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_TIMER);
```
```python
handle
```
```python
->
```
```python
repeat
```
```python
=
```
```python
repeat;
}
```
##### 6.定时器handle关闭时的处理(uv_close)
```python
void
```
```python
uv_close(uv_handle_t
```
```python
*
```
```python
handle
```
```python
, uv_close_cb cb) 
{
  uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING) {
    assert(
```
```python
0
```
```python
);
```
```python
return
```
```python
;
  }
```
```python
handle
```
```python
->
```
```python
close_cb
```
```python
=
```
```python
cb;
```
```python
/* Handle-specific close actions */
```
```python
switch (
```
```python
handle
```
```python
->
```
```python
type
```
```python
) 
  {
```
```python
...
```
```python
case
```
```python
UV_TIMER:
      uv_timer_stop((uv_timer_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
```
```python
//先停止定时器
```
```python
//uv__handle_closing(handle);展开：
```
```python
do
```
```python
{                                                                  
            assert(
```
```python
!
```
```python
((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING));
```
```python
//不能处于正在关闭状态
```
```python
if
```
```python
(
```
```python
!
```
```python
(((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_ACTIVE)
```
```python
&&
```
```python
((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_REF)))
```
```python
//非激活或者非引用状态下，先将loop的活动handle数量加一
```
```python
//对于定时器，比如初始化但未开始的情况下，或者调用了uv_timer_stop之后。只有
```
```python
//UV__HANDLE_REF，没有UV__HANDLE_ACTIVE
```
```python
uv__active_handle_add((uv_handle_t
```
```python
*
```
```python
) (
```
```python
handle
```
```python
));                                                      
            (
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV__HANDLE_CLOSING;
```
```python
//正在关闭状态
```
```python
(
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV__HANDLE_ACTIVE;
```
```python
//非激活状态
```
```python
}
```
```python
while
```
```python
(
```
```python
0
```
```python
)
```
```python
//内部函数
```
```python
uv_want_endgame(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
return
```
```python
;
```
```python
...
```
```python
}
}
```
内部函数：
```python
INLINE
```
```python
static
```
```python
void
```
```python
uv_want_endgame(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_handle_t
```
```python
*
```
```python
handle
```
```python
) 
{
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_ENDGAME_QUEUED)) 
  {
```
```python
//将本handle插入到loop需要关闭的handle列表的表头
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_ENDGAME_QUEUED;
```
```python
handle
```
```python
->
```
```python
endgame_next
```
```python
=
```
```python
loop
```
```python
->
```
```python
endgame_handles;
```
```python
loop
```
```python
->
```
```python
endgame_handles
```
```python
=
```
```python
handle
```
```python
;
  }
}
```
最终，在uv_run中会调用内部函数处理所有需要关闭的句柄
```python
INLINE
```
```python
static
```
```python
void
```
```python
uv_process_endgames(uv_loop_t
```
```python
*
```
```python
loop
```
```python
) {
  uv_handle_t
```
```python
*
```
```python
handle
```
```python
;
```
```python
while
```
```python
(
```
```python
loop
```
```python
->
```
```python
endgame_handles) {
```
```python
handle
```
```python
=
```
```python
loop
```
```python
->
```
```python
endgame_handles;
```
```python
loop
```
```python
->
```
```python
endgame_handles
```
```python
=
```
```python
handle
```
```python
->
```
```python
endgame_next;
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_ENDGAME_QUEUED;
    switch (
```
```python
handle
```
```python
->
```
```python
type
```
```python
) 
    {
```
```python
...
```
```python
case
```
```python
UV_TIMER:
```
```python
//处理定时器handle的关闭
```
```python
uv_timer_endgame(
```
```python
loop
```
```python
, (uv_timer_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
        break;
```
```python
...
```
```python
}
  }
}
```
```python
void
```
```python
uv_timer_endgame(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_timer_t
```
```python
*
```
```python
handle
```
```python
)  
{
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING) 
  {
    assert(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_CLOSED));
```
```python
//uv__handle_close(handle);展开：
```
```python
do
```
```python
{
```
```python
//在handle队列中移除需要关闭的handle
```
```python
QUEUE_REMOVE(
```
```python
&
```
```python
(
```
```python
handle
```
```python
)
```
```python
->
```
```python
handle_queue);
```
```python
//活动handle计数递减
```
```python
uv__active_handle_rm((uv_handle_t
```
```python
*
```
```python
) (
```
```python
handle
```
```python
));
```
```python
//状态更新为已关闭
```
```python
(
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_CLOSED;
```
```python
//调用回掉函数
```
```python
if
```
```python
((
```
```python
handle
```
```python
)
```
```python
->
```
```python
close_cb)                                             
          (
```
```python
handle
```
```python
)
```
```python
->
```
```python
close_cb((uv_handle_t
```
```python
*
```
```python
) (
```
```python
handle
```
```python
));                     
    }
```
```python
while
```
```python
(
```
```python
0
```
```python
)
  }
}
```
整个定时器的关闭流程大致如下：
1.调用uv_close函数，针对uv_timer_t类型的handle，会先停止定时器
2.接着将loop中的活动handle计数加一，因为定时器handle如果调用过uv_timer_start，活动handle计数将会加一，而在调用了uv_timer_stop之后，会减一。此时无论是否调用过uv_timer_start，活动handle计数都没有再记录本handle，而接下来的操作仍然需要在loop中进行回调，所以需要此处在加一，之后的流程会减去。
3调用内部uv_want_endgame函数，讲本handle插入loop需要关闭的handle队列的头部。
4.uv_run中会在每个迭代中调用uv_process_endgames处理需要关闭的句柄。
5.在uv_process_endgames中，对于uv_timer_t会调用uv_timer_endgame
6.在uv_timer_endgame中，移除loop  handle列表中的本handle，活动handle计数减一（对应第二步），跟新状态为UV__HANDLE_CLOSED，最后调用uv_close中传入的回调函数。
#### 7.对于定时器的回调
在uv_run中会通过uv_process_timers处理所有的定时器
```python
void
```
```python
uv_process_timers(uv_loop_t
```
```python
*
```
```python
loop
```
```python
) 
{
  uv_timer_t
```
```python
*
```
```python
timer;
```
```python
/* 调用定时器回调 */
```
```python
for (timer
```
```python
=
```
```python
RB_MIN(uv_timer_tree_s,
```
```python
&
```
```python
loop
```
```python
->
```
```python
timers);
       timer
```
```python
!=
```
```python
NULL
```
```python
&&
```
```python
timer
```
```python
->
```
```python
due
```
```python
<=
```
```python
loop
```
```python
->
```
```python
time;
```
```python
//因为是红黑树，找到第一个触发时间比当前时间
```
```python
//大的定时器之后就不用继续查找了
```
```python
timer
```
```python
=
```
```python
RB_MIN(uv_timer_tree_s,
```
```python
&
```
```python
loop
```
```python
->
```
```python
timers)) {
    uv_timer_stop(timer);
    uv_timer_again(timer);
    timer
```
```python
->
```
```python
timer_cb((uv_timer_t
```
```python
*
```
```python
) timer);
  }
}
```
#### 8.uv_timer_tree_s红黑树使用的比较函数
```python
static int uv_timer_compare(uv_timer_t
```
```python
*
```
```python
a, uv_timer_t
```
```python
*
```
```python
b) 
{
```
```python
//线比较触发时间
```
```python
if
```
```python
(a
```
```python
->
```
```python
due
```
```python
<
```
```python
b
```
```python
->
```
```python
due)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
if
```
```python
(a
```
```python
->
```
```python
due
```
```python
>
```
```python
b
```
```python
->
```
```python
due)
```
```python
return
```
```python
1
```
```python
;
```
```python
//如果触发时间相同，比较start_id，start_id是在uv_timer_start函数中设置的当前loop的
```
```python
//timer_counter（只会递增，所以同一loop中不会出现相同的值），
```
```python
if
```
```python
(a
```
```python
->
```
```python
start_id
```
```python
<
```
```python
b
```
```python
->
```
```python
start_id)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
if
```
```python
(a
```
```python
->
```
```python
start_id
```
```python
>
```
```python
b
```
```python
->
```
```python
start_id)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
libuv的定时器使用一颗全局的红黑树保存，以触发时间以及start_id作为key值比较，每次循环都会在更新了当前事件之后处理本loop所有的定时器，从出发时间最早的树节点（RB_MIN）开始。对于每一个定时器，处理流程如下：
1.先关闭，从红黑树删除
2.再以重复调用的间隔值重新开始，如果没有就意味着回调函数只调用一次，如果有重复间隔值，就以新的触发时间插入红黑树。
3.调用回调函数

