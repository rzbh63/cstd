# 排序算法常用评价指标计算方式（AUC,MAP,NDCG,MRR）

### 一 、MAP(Mean Average Precision)：

单个主题的平均准确率是每篇相关文档检索出后的准确率的平均值。主集合的平均准确率(MAP)是每个主题的平均准确率的平均值。MAP 是反映系统在全部相关文档上性能的单值指标。系统检索出来的相关文档越靠前(rank 越高)，MAP就可能越高。如果系统没有返回相关文档，则准确率默认为0。

只有1和0，1代表相关，0代表不相关。

例如：假设有两个主题，主题1有4个相关网页，主题2有5个相关网页。某系统对于主题1检索出4个相关网页，其rank分别为1, 2, 4, 7；对于主题2检索出3个相关网页，其rank分别为1,3,5。对于主题1，平均准确率为(1/1+2/2+3/4+4/7)/4=0.83。对于主题2，平均准确率为(1/1+2/3+3/5+0+0)/5=0.45。则MAP= (0.83+0.45)/2=0.64。

### 二、MRR(Mean Reciprocal Rank)：

是把标准答案在被评价系统给出结果中的排序取倒数作为它的准确度，再对所有的问题取平均。相对简单，举个例子：有3个query如下图所示：

(黑体为返回结果中最匹配的一项)

 

可计算这个系统的MRR值为：(1/3 + 1/2 + 1)/3 = 11/18=0.61。

### 三、NDCG(Normalized Discounted Cumulative Gain)：

NDCG相比MAP和MRR复杂，但是它也是评价信息检索质量的最好评价之一。我首先举一个例子来说明一种NDCG是怎么计算的，因为关于NDCG的计算其实是存在差异的。

我首先介绍下CG和DCG，在此基础上，NDCG的定义也更容易理解。

#### 3.1 DG和DCG

CG（cumulative gain，累计增益）可以用于评价基于打分的个性推荐系统，当然可以应用于任何排序的场景，这里只是以推荐为例。假设我们推荐k个物品，这个推荐列表的CG_k计算公式如下：

$CG_k=\sum_{i=1}^k \text{rel}_i$

$\text{rel}_i$表示第k个物品的相关性或者评分。假设我们共推荐k个电影，\text{rel}_i可以是用户对第i部电影的评分。

比如豆瓣给用户推荐了五部电影，$M_1, M_2,M_3,M_4,M_5$

该用户对这五部电影的评分分别是

5, 3, 2, 1, 2

那么这个推荐列表的CG等于

$CG_5=5+3+2+1+2=13$.

不难看出，CG并不考虑在搜索结果的排序信息，CG得分高只能说明这个结果页面总体的质量比较高并不能说明这个算法做的排序好或差。在上面例子中，如果调换第二个结果和第三个结果的位置CG=5+2+3+1+2=13，并没有改变总体的得分。

因此，在此基础之后我们引入对物品顺序的考虑，就有了DCG(discounted CG)，折扣累积增益。公式如下：

$DCG_k=\sum_{i=1}^k \frac{2^{\text{rel}_i}-1}{\log_2(i+1)}$.

比如豆瓣给用户推荐了五部电影，$M_1, M_2,M_3,M_4,M_5$

该用户对这五部电影的评分分别是

5, 3, 2, 1, 2

那么这个推荐列表的DCG等于

$DCG_5=\frac{2^5-1}{\log_2 2}+\frac{2^3-1}{\log_2 3}+\frac{2^2-1}{\log_2 4}+\frac{2^1-1}{\log_2 5}+\frac{2^2-1}{\log_2 6}=31+4.4+1.5+0.4+1.2=38.5$

#### 3.2 NDCG

但是DCG在评估策略效果的过程中，因为不同搜索模型给出的结果有多有少（P的大小不同），仍然会造成无法对比两个模型的效果。为了避免这种情况，我们进一步优化这个指标，成为NDCG（normalize DCG），顾名思义，就是将一个策略的效果标准归一化，以方便不同策略的效果对比。公式如下：

$NDCG_k=\frac{DCG_k}{IDCG_k}$

其中IDCG是指ideal DCG，也就是完美结果下的DCG。

继续上面的例子，如果相关电影一共有7部

$M_1, M_2,M_3,M_4,M_5,M_6,M_7$

该用户对这七部电影的评分分别是

5, 3, 2, 1, 2 , 4, 0

把这7部电影按评分排序

5, 4, 3, 2, 2, 1, 0

这个情况下的完美DCG是（我们仍然计算5个，因为我们只推荐了5个）

$IDCG_5=\frac{2^5-1}{\log_2 2}+\frac{2^4-1}{\log_2 3}+\frac{2^3-1}{\log_2 4}+\frac{2^2-1}{\log_2 5}+\frac{2^2-1}{\log_2 6}=31+9.5+3.5+1.3+1.2=46.5$

所以

$NDCG_5 = \frac{DCG_5}{IDCG_5}=\frac{38.5}{46.5}=0.827$

NDCG是0到1的数，越接近1说明推荐越准确。

#### 3.3 NDCG计算差异的解释

我们用NDCG@n代表对n个item排序的NDCG值。

NDCG可以拆解为四个部分，分别是N（Normalization）标准化、D（Discounted）折减、C（Cumulative）累积、G（Gain）增益。四个部分通过下式表示NDCG。
$$
NDCG@n(x) = \frac{1}{N}\sum^n_{i=1}\frac G D
$$
其中x表示一个查询，n表示用返回的前n个答案计算本次查询的NDCG，i表示第几个答案。

  - G可以理解为一个返回的答案对于本次查询质量的加分。G的大小与i无关，只取决于这个答案的质量。
  - D可以理解为对于一个加分的适当减分。因为越靠前的答案应该加分越多，越靠后的答案加分越少，加分G是与答案的位置前后无关的，所以需要通过D来控制加分大小。所以D是一个随答案位置i增大而增大的量。
  - C是对1到n​​​​​​​个位置的G/D进行累加，得到这次查询的质量得分。
  - N是对得分进行归一化处理，可以理解为N是理想情况下的得分，即能够取得的最高得分。

计算NDCG存在的差异

NDCG相对于MAR和MRR指标公式会更复杂，所以计算方式存在差异的可能性更大。除了C是进行累加没有什么争议以外，N、D、G三项计算都可能存在差别。

  1. G的差别比较大，有的是直接取相关度得分rel作为G的值，有的是取2^rel-1作为G的值，当然还存在有其他的表达方式。相同的是相关度得分都是rel = {0,1,2......}。上例用的即是取2^rel-1作为G的值。
  2. 对于D相同的都是以log(i)的形式取值，显然i=1时D=0，不可作为分母。因此发现有两种不同的方式。第一种，当i=1时，D取1，其余的取log(i)。第二种D=log(1+i)。上例用的即是第二种D=log(1+i)。
  3. 对于N也发现了两种计算方式。相同的是都使用了相同的DCG方式计算，不同的在于取哪些值计算。 
    
  - 第一种，取当前返回结果的前n的最优排序计算DCG作为N的值。例如，一组NDCG@5的相关度为X={1,0,2,2,1}，将其变化成X={2,2,1,1,0}计算DCG的值作为N。也就是说集合X的取值一定出现在答案中。但是假设返回的前n个的相关度得分都是0，N也变成了0，那么答案将出错。
  - 第二种，是将整个搜索空间中的最优n个答案形成集合X，从高到低排列后计算DCG作为N的值。集合X的值不要求出现在系统返回的答案中。上例用的即是第二种。

#### 3.4 NDCG进一步理解

对于搜索引擎，本质是用户搜一个query，引擎返回一个结果列表，那么如何衡量这个结果列表的好坏？我能够想到的是：

1. 我们希望把最相关的结果放到排名最靠前的位置，因为大部分用户都是从上往下阅读的，那么最相关的在前面可以最大程度减少用户的阅读时间； 
2. 我们希望整个列表的结果尽可能的和query相关。

第一个条件的满足是首要的，而第二个条件的加入是保证整体结果质量，而这两个条件都体现在了NDCG里面，首先，计算NDCG，需要计算Gain，这个gain即是每条结果的质量的定义，NDCG把所有结果相加最终相加保证，整体质量越高的列表NDCG值越大。同时，Discounted的设计使得越靠前的结果权重越大，这保证了第一条，更相关的排在靠前的结果会有更大的NDCG值。从这两点看，以NDCG为优化目标，保证了搜索引擎在返回结果总体质量好的情况下，把更高质量结果排在更前面。

### 四、参考文献：

【1】http://www.woshipm.com/pmd/232014.html
【2】https://blog.csdn.net/lightty/article/details/47079017
【3】https://blog.csdn.net/more_ugly_less_bug/article/details/79076439
【4】http://sofasofa.io/forum_main_post.php?postid=1002561


