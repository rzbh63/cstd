
# libuv学习笔记（11） - paohui0134的博客 - CSDN博客


2016年06月14日 20:23:50[paohui0134](https://me.csdn.net/paohui0134)阅读数：1875


# libuv学习笔记（11）
## uv_stream_t数据结构以及相关函数
uv_stream_t提供一个抽象的双工通信通道。uv_stream_t是抽象类型，libuv提供3种流测实现：uv_tcp_t,uv_pipe_t以及uv_tty_t
### 数据结构：
```python
typedef
```
```python
struct
```
```python
uv_stream_s uv_stream_t;
```
```python
struct
```
```python
uv_stream_s {
  UV_HANDLE_FIELDS
```
```python
//uv_handle_t成员，此处不再展开
```
```python
//UV_STREAM_FIELDS宏展开如下：
```
```python
#define UV_STREAM_FIELDS
```
```python
/* number of bytes queued for writing */
```
```python
size_t write_queue_size;
```
```python
//需要写入的数据量
```
```python
uv_alloc_cb alloc_cb;
```
```python
//内存分配回调函数
```
```python
uv_read_cb read_cb;
```
```python
//读取数据回调函数
```
```python
/* private */
```
```python
//UV_STREAM_PRIVATE_FIELDS宏展开如下：
```
```python
unsigned
```
```python
int
```
```python
reqs_pending;
```
```python
int
```
```python
activecnt;
```
```python
//基于此流的活动请求计数
```
```python
uv_read_t read_req;
```
```python
//读操作请求
```
```python
union
```
```python
{
```
```python
struct
```
```python
{
```
```python
unsigned
```
```python
int
```
```python
write_reqs_pending;                                           
     uv_shutdown_t* shutdown_req;
    } conn;
```
```python
struct
```
```python
{ 
      uv_connection_cb connection_cb; 
    } serv;                             
  } stream;
};
```
uv_stream_t首先包含uv_handle_t的全部数据，因此uv_stream_t的指针可以转换为uv_handle_t的指针,剩下的数据通过宏UV_STREAM_PRIVATE_FIELDS定义
### 相关请求类型：
uv_connect_t，连接请求
```python
struct
```
```python
uv_connect_s {
  UV_REQ_FIELDS
```
```python
//uv_req_t的数据，此处不再展开
```
```python
uv_connect_cb cb;
```
```python
//连接回调
```
```python
uv_stream_t* handle;
```
```python
//
```
```python
//UV_CONNECT_PRIVATE_FIELDS宏为空
```
```python
};
```
uv_shutdown_t，关闭请求
```python
struct
```
```python
uv_shutdown_s {
  UV_REQ_FIELDS
```
```python
//uv_req_t的数据，此处不再展开
```
```python
uv_stream_t* handle;
  uv_shutdown_cb cb;
```
```python
//关闭回调
```
```python
//UV_SHUTDOWN_PRIVATE_FIELDS宏为空
```
```python
};
```
uv_write_t，写操作请求
```python
struct uv_write_s {
  UV_REQ_FIELDS
```
```python
//uv_req_t的数据，此处不再展开
```
```python
uv_write_cb cb;
```
```python
//写回调
```
```python
uv_stream_t
```
```python
*
```
```python
send_handle;
```
```python
//发送对象
```
```python
uv_stream_t
```
```python
*
```
```python
handle
```
```python
;
```
```python
//
```
```python
//UV_WRITE_PRIVATE_FIELDS宏展开：
```
```python
int ipc_header;                                                             
  uv_buf_t write_buffer;
```
```python
//写内容
```
```python
HANDLE
```
```python
event_handle;
```
```python
HANDLE
```
```python
wait_handle;
};
```
以上三种请求都可以说是uv_req_t的子类，内部都有uv_stream_t对象的指针
### 相关函数
#### 关闭流的写端。导出函数，在uv.h中声明，steam.c中定义
```python
int uv_shutdown(uv_shutdown_t
```
```python
*
```
```python
req, uv_stream_t
```
```python
*
```
```python
handle
```
```python
, uv_shutdown_cb cb) 
{
  uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
```
```python
//stream不可写，返回错误
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_WRITABLE)) {
```
```python
return
```
```python
UV_EPIPE;
  }
```
```python
//初始化请求
```
```python
uv_req_init(
```
```python
loop
```
```python
, (uv_req_t
```
```python
*
```
```python
) req);
  req
```
```python
->
```
```python
type
```
```python
=
```
```python
UV_SHUTDOWN;
```
```python
//类型
```
```python
req
```
```python
->
```
```python
handle
```
```python
=
```
```python
handle
```
```python
;
```
```python
//与流联系起来
```
```python
req
```
```python
->
```
```python
cb
```
```python
=
```
```python
cb;
```
```python
/
```
```python
回调函数
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_WRITABLE;
```
```python
//去掉可写的标记
```
```python
handle
```
```python
->
```
```python
stream
```
```python
.
```
```python
conn
```
```python
.
```
```python
shutdown_req
```
```python
=
```
```python
req;
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
```
```python
//REGISTER_HANDLE_REQ(loop, handle, req);宏展开
```
```python
do
```
```python
{
```
```python
//INCREASE_ACTIVE_COUNT((loop), (handle));展开
```
```python
do
```
```python
{
```
```python
if
```
```python
((
```
```python
handle
```
```python
)
```
```python
->
```
```python
activecnt
```
```python
++
```
```python
==
```
```python
0
```
```python
) {                                
        uv__handle_start((
```
```python
handle
```
```python
));
```
```python
//第一个请求，开始handle
```
```python
}                                                                  
      assert((
```
```python
handle
```
```python
)
```
```python
->
```
```python
activecnt
```
```python
>
```
```python
0
```
```python
);                                  
    }
```
```python
while
```
```python
(
```
```python
0
```
```python
)
```
```python
//uv__req_register((loop), (req));  展开：
```
```python
do
```
```python
{
```
```python
//将请求添加到loop请求列表的尾端
```
```python
QUEUE_INSERT_TAIL(
```
```python
&
```
```python
(
```
```python
loop
```
```python
)
```
```python
->
```
```python
active_reqs,
```
```python
&
```
```python
(req)
```
```python
->
```
```python
active_queue);          
    }
```
```python
while
```
```python
(
```
```python
0
```
```python
)                             
  }
```
```python
while
```
```python
(
```
```python
0
```
```python
)；
```
```python
//将流添加到loop的关闭列表
```
```python
uv_want_endgame(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
uv_run中调用uv_process_endgames对关闭流的处理：
```python
case
```
```python
UV_TCP
```
```python
:
        uv_tcp_endgame(
```
```python
loop
```
```python
, (uv_tcp_t*) handle);
```
```python
break
```
```python
;
```
```python
case
```
```python
UV_NAMED_PIPE
```
```python
:
        uv_pipe_endgame(
```
```python
loop
```
```python
, (uv_pipe_t*) handle);
```
```python
break
```
```python
;
```
```python
case
```
```python
UV_TTY
```
```python
:
        uv_tty_endgame(
```
```python
loop
```
```python
, (uv_tty_t*) handle);
```
```python
break
```
```python
;
```
之后的学习会对于具体对象的分析
uv_run调用uv_process_reqs对于shutdown请求的处理：
```python
case
```
```python
UV_SHUTDOWN
```
```python
:
```
```python
//
```
```python
TCP的关闭请求不在此处处理，因为在tcp的关闭处理uv_tcp_endgame中会UNREGISTER_HANDLE_REQ
    assert
```
```python
(((uv_shutdown_t*) req)->handle->type == UV_NAMED_PIPE)
```
```python
;
```
```python
uv_process_pipe_shutdown_req
```
```python
(
```
```python
loop
```
```python
,
        (uv_pipe_t*) ((uv_shutdown_t*) req)->handle,
        (uv_shutdown_t*) req)
```
```python
;
```
```python
break
```
```python
;
```
三种请求，对于不同的流对象，会调用不同的实现，具体细节将在之后对应的流对象中分析

