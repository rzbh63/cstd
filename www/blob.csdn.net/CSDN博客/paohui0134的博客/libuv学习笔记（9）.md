
# libuv学习笔记（9） - paohui0134的博客 - CSDN博客


2016年06月14日 11:41:45[paohui0134](https://me.csdn.net/paohui0134)阅读数：1084


# libuv学习笔记（9）
## uv_signal_t数据结构与相关函数
### uv_signal_t数据结构
```python
typedef
```
```python
struct
```
```python
uv_signal_s uv_signal_t;
```
```python
struct
```
```python
uv_signal_s {
  UV_HANDLE_FIELDS
```
```python
//uv_handle_t的成员，此处不再展开
```
```python
uv_signal_cb signal_cb;
```
```python
//回调函数
```
```python
int
```
```python
signum;
```
```python
//信号
```
```python
//UV_SIGNAL_PRIVATE_FIELDS宏展开：
```
```python
RB_ENTRY(uv_signal_s) tree_entry;
```
```python
//红黑树节点
```
```python
struct
```
```python
uv_req_s signal_req;
```
```python
//请求
```
```python
unsigned
```
```python
long
```
```python
pending_signum;
};
```
### 相关函数
#### 1.初始化，导出函数，在uv.h中声明，signal.c中定义
```python
int uv_signal_init(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_signal_t
```
```python
*
```
```python
handle
```
```python
) 
{
  uv_req_t
```
```python
*
```
```python
req;
```
```python
//初始化handle，添加到loop的handle列表，改变状态为引用状态
```
```python
uv__handle_init(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
, UV_SIGNAL);
```
```python
handle
```
```python
->
```
```python
pending_signum
```
```python
=
```
```python
0
```
```python
;
```
```python
handle
```
```python
->
```
```python
signum
```
```python
=
```
```python
0
```
```python
;
```
```python
handle
```
```python
->
```
```python
signal_cb
```
```python
=
```
```python
NULL
```
```python
;
  req
```
```python
=
```
```python
&
```
```python
handle
```
```python
->
```
```python
signal_req;
  uv_req_init(
```
```python
loop
```
```python
, req);
```
```python
//初始化请求
```
```python
req
```
```python
->
```
```python
type
```
```python
=
```
```python
UV_SIGNAL_REQ;
```
```python
//设置请求类型
```
```python
req
```
```python
->
```
```python
data
```
```python
=
```
```python
handle
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
#### 2.开始。导出函数，在uv.h中声明，signal.c中定义
```python
int uv_signal_start(uv_signal_t
```
```python
*
```
```python
handle
```
```python
, uv_signal_cb signal_cb, int signum) {
  int err;
```
```python
//将信号值设为0，直接返回错误
```
```python
//如果signum是无效值，那么uv__signal_register会检测出来
```
```python
if
```
```python
(signum
```
```python
==
```
```python
0
```
```python
) {
```
```python
return
```
```python
UV_EINVAL;
  }
```
```python
//如果已经监控了这个信号，不会进入注销与注册流程。
```
```python
if
```
```python
(signum
```
```python
==
```
```python
handle
```
```python
->
```
```python
signum) {
```
```python
handle
```
```python
->
```
```python
signal_cb
```
```python
=
```
```python
signal_cb;
```
```python
return
```
```python
0
```
```python
;
  }
```
```python
//如果已经开始监控了，先停止
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
signum
```
```python
!=
```
```python
0
```
```python
) {
    int r
```
```python
=
```
```python
uv_signal_stop(
```
```python
handle
```
```python
);
```
```python
/* uv_signal_stop is infallible. */
```
```python
assert(r
```
```python
==
```
```python
0
```
```python
);
  }
```
```python
//进入临界区
```
```python
EnterCriticalSection(
```
```python
&
```
```python
uv__signal_lock);
```
```python
//此临界区是全局的
```
```python
err
```
```python
=
```
```python
uv__signal_register(signum);
```
```python
//注册信号
```
```python
if
```
```python
(err) {
```
```python
/* Uh-oh, didn't work. */
```
```python
LeaveCriticalSection(
```
```python
&
```
```python
uv__signal_lock);
```
```python
return
```
```python
uv_translate_sys_error(err);
  }
```
```python
handle
```
```python
->
```
```python
signum
```
```python
=
```
```python
signum;
```
```python
//将信号插入红黑树，key的比较函数为uv__signal_compare
```
```python
RB_INSERT(uv_signal_tree_s,
```
```python
&
```
```python
uv__signal_tree,
```
```python
handle
```
```python
);
  LeaveCriticalSection(
```
```python
&
```
```python
uv__signal_lock);
```
```python
handle
```
```python
->
```
```python
signal_cb
```
```python
=
```
```python
signal_cb;
  uv__handle_start(
```
```python
handle
```
```python
);
```
```python
//状态变为UV__HANDLE_ACTIVE,loop活动handle计数加一
```
```python
return
```
```python
0
```
```python
;
}
```
uv__signal_register
```python
static
```
```python
int
```
```python
uv__signal_register(
```
```python
int
```
```python
signum) 
{
```
```python
switch
```
```python
(signum) {
```
```python
//控制台相关的信号，通过安装控制台钩子来实现
```
```python
case
```
```python
SIGINT:
```
```python
case
```
```python
SIGBREAK:
```
```python
case
```
```python
SIGHUP:
```
```python
return
```
```python
uv__signal_register_control_handler();
```
```python
case
```
```python
SIGWINCH:
```
```python
/* SIGWINCH is generated in tty.c. No need to register anything. */
```
```python
return
```
```python
0
```
```python
;
```
```python
case
```
```python
SIGILL:
```
```python
case
```
```python
SIGABRT_COMPAT:
```
```python
case
```
```python
SIGFPE:
```
```python
case
```
```python
SIGSEGV:
```
```python
case
```
```python
SIGTERM:
```
```python
case
```
```python
SIGABRT:
```
```python
/* Signal is never raised. */
```
```python
return
```
```python
0
```
```python
;
```
```python
default
```
```python
:
```
```python
/* Invalid signal. */
```
```python
return
```
```python
ERROR_INVALID_PARAMETER;
  }
}
```
uv__signal_register_control_handler()，安装控制台事件钩子处理控制台事件
```python
static
```
```python
int
```
```python
uv__signal_register_control_handler() {
```
```python
//调用本函数时，uv__signal_lock必须锁定
```
```python
//如果已经添加了钩子，那么只用递增引用计数
```
```python
if
```
```python
(uv__signal_control_handler_refs >
```
```python
0
```
```python
) {
    uv__signal_control_handler_refs++;
```
```python
return
```
```python
0
```
```python
;
  }
```
```python
//安装控制台事件钩子处理控制台程序事件
```
```python
//回调函数会通过uv__signal_dispatch分发处理信号
```
```python
if
```
```python
(!SetConsoleCtrlHandler(uv__signal_control_handler,
```
```python
TRUE
```
```python
))
```
```python
return
```
```python
GetLastError();
  uv__signal_control_handler_refs++;
```
```python
return
```
```python
0
```
```python
;
}
```
uv__signal_dispatch分发处理信号
```python
int uv__signal_dispatch(int signum) 
{
  uv_signal_t lookup;
  uv_signal_t
```
```python
*
```
```python
handle
```
```python
;
  int dispatched
```
```python
=
```
```python
0
```
```python
;
  EnterCriticalSection(
```
```python
&
```
```python
uv__signal_lock);
  lookup
```
```python
.
```
```python
signum
```
```python
=
```
```python
signum;
  lookup
```
```python
.
```
```python
loop
```
```python
=
```
```python
NULL
```
```python
;
```
```python
//遍历信号红黑树处理
```
```python
//先找到第一个，然后依次比较下一个，直到信号值不相等
```
```python
for (
```
```python
handle
```
```python
=
```
```python
RB_NFIND(uv_signal_tree_s,
```
```python
&
```
```python
uv__signal_tree,
```
```python
&
```
```python
lookup);
```
```python
handle
```
```python
!=
```
```python
NULL
```
```python
&&
```
```python
handle
```
```python
->
```
```python
signum
```
```python
==
```
```python
signum;
```
```python
handle
```
```python
=
```
```python
RB_NEXT(uv_signal_tree_s,
```
```python
&
```
```python
uv__signal_tree,
```
```python
handle
```
```python
)) {
    unsigned long previous
```
```python
=
```
```python
InterlockedExchange(
            (volatile LONG
```
```python
*
```
```python
)
```
```python
&
```
```python
handle
```
```python
->
```
```python
pending_signum, signum);
```
```python
//没有正在处理的信号，向iocp端口发送事件通知，以便uv_run捕获处理,也就是说，有可能收到了多次信号，
```
```python
//但是可能只处理了一次
```
```python
if
```
```python
(
```
```python
!
```
```python
previous) {
      POST_COMPLETION_FOR_REQ(
```
```python
handle
```
```python
->
```
```python
loop
```
```python
,
```
```python
&
```
```python
handle
```
```python
->
```
```python
signal_req);
    }
    dispatched
```
```python
=
```
```python
1
```
```python
;
  }
  LeaveCriticalSection(
```
```python
&
```
```python
uv__signal_lock);
```
```python
return
```
```python
dispatched;
}
```
在uv_run的io轮询中会获取uv__signal_dispatch发送的通知，并通过lpOverlapped获取对应的uv_req_t请求，接着在下一个迭代中通过uv_process_reqs处理这个请求
对于uv_signal_req类型的请求，最终会调用uv_process_signal_req
```python
void
```
```python
uv_process_signal_req(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_signal_t
```
```python
*
```
```python
handle
```
```python
,
    uv_req_t
```
```python
*
```
```python
req) 
{
  long dispatched_signum;
  assert(
```
```python
handle
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_SIGNAL);
  assert(req
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_SIGNAL_REQ);
```
```python
//将uv_signal_t的等待处理的信号设为0
```
```python
dispatched_signum
```
```python
=
```
```python
InterlockedExchange(
          (volatile LONG
```
```python
*
```
```python
)
```
```python
&
```
```python
handle
```
```python
->
```
```python
pending_signum,
```
```python
0
```
```python
);
  assert(dispatched_signum
```
```python
!=
```
```python
0
```
```python
);
```
```python
//信号相同，调用回调函数
```
```python
if
```
```python
(dispatched_signum
```
```python
==
```
```python
handle
```
```python
->
```
```python
signum)
```
```python
handle
```
```python
->
```
```python
signal_cb(
```
```python
handle
```
```python
, dispatched_signum);
```
```python
//如果正在关闭，就添加到loop的关闭列表，比如在收到了信号但是还未处理的情况下调用了uv_close
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING) {
```
```python
/* When it is closing, it must be stopped at this point. */
```
```python
assert(
```
```python
handle
```
```python
->
```
```python
signum
```
```python
==
```
```python
0
```
```python
);
    uv_want_endgame(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
  }
}
```
#### 3.停止监控。导出函数，在uv.h中声明，signal.c中定义
```python
int uv_signal_stop(uv_signal_t
```
```python
*
```
```python
handle
```
```python
) 
{
  uv_signal_t
```
```python
*
```
```python
removed_handle;
```
```python
//如果没有开始监控，直接返回
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
signum
```
```python
==
```
```python
0
```
```python
)
```
```python
return
```
```python
0
```
```python
;
```
```python
//进入临界区
```
```python
EnterCriticalSection(
```
```python
&
```
```python
uv__signal_lock);
```
```python
//注销监控，递减引用计数，如果为0，卸载控制台程序钩子
```
```python
uv__signal_unregister(
```
```python
handle
```
```python
->
```
```python
signum);
```
```python
//从红黑树去掉
```
```python
removed_handle
```
```python
=
```
```python
RB_REMOVE(uv_signal_tree_s,
```
```python
&
```
```python
uv__signal_tree,
```
```python
handle
```
```python
);
  assert(removed_handle
```
```python
==
```
```python
handle
```
```python
);
  LeaveCriticalSection(
```
```python
&
```
```python
uv__signal_lock);
```
```python
handle
```
```python
->
```
```python
signum
```
```python
=
```
```python
0
```
```python
;
```
```python
//
```
```python
uv__handle_stop(
```
```python
handle
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
通过uv_close关闭
最终会调用
```python
void
```
```python
uv_signal_close(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_signal_t
```
```python
*
```
```python
handle
```
```python
) 
{
  uv_signal_stop(
```
```python
handle
```
```python
);
```
```python
//先停止
```
```python
uv__handle_closing(
```
```python
handle
```
```python
);
```
```python
//handle状态变为UV_HANDLE_CLOSING
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
pending_signum
```
```python
==
```
```python
0
```
```python
) {
```
```python
//如果没有等待处理的信号了，那么直接添加到loop的关闭handle队列，否则就需要在处理信号时添加到关闭队列
```
```python
//了，参考uv_process_signal_req
```
```python
uv_want_endgame(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
  }
}
```

