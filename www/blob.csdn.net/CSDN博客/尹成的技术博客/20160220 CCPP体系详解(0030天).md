
# 20160220.CCPP体系详解(0030天) - 尹成的技术博客 - CSDN博客

置顶2016年03月15日 00:40:36[尹成](https://me.csdn.net/yincheng01)阅读数：4124


程序片段(01):对称.c
内容概要:**对称**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.对称原理:
```
```python
//  1.双索引or双指针-->双边对称夹逼-->进行字符比对
```
```python
//  2.判断存在情况,默认所有情况
```
```python
int
```
```python
isSemmetry(
```
```python
char
```
```python
* pStr)
{
```
```python
char
```
```python
* p1 = pStr;
```
```python
char
```
```python
* p2 = pStr +
```
```python
strlen
```
```python
(pStr) -
```
```python
1
```
```python
;
```
```python
while
```
```python
(p1 < p2)
    {
```
```python
if
```
```python
(*p1 != *p2)
        {
```
```python
return
```
```python
0
```
```python
;
        }
        --p2;
        ++p1;
    }
```
```python
return
```
```python
1
```
```python
;
}
```
```python
//01.所有位于栈内存的静态数组:
```
```python
//  1.只要存在静态前置初始化,就一定存在静态后续默认初始化
```
```python
//  2.字符串数组可以通过字符串拷贝实质初始化
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//char str[1024] = "";//""是一种初始化方式
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
```
```python
scanf
```
```python
(
```
```python
"%s"
```
```python
, str);
```
```python
printf
```
```python
(
```
```python
"isSemmetry = %d \n"
```
```python
, isSemmetry(str));
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):指针.c
内容概要:**指针**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.指针内容大总结:
```
```python
//  1.按照所指向内存实质的不同:
```
```python
//      数据区:数据指针
```
```python
//      代码区:函数指针
```
```python
//  2.按照常变量的不同特点:
```
```python
//      常量指针
```
```python
//      变量指针
```
```python
//  3.两种不同类型的常变量指针特点:
```
```python
//      数据指针:
```
```python
//          常量指针:
```
```python
//              添加星号("*")右侧的const关键字
```
```python
//              所有数组名称
```
```python
//          变量指针:
```
```python
//              常规形式
```
```python
//      函数指针:
```
```python
//          常量指针:
```
```python
//              函数名称
```
```python
//          变量指针:
```
```python
//              常规形式
```
```python
//02.间接修改数据和调用函数的不同:
```
```python
//  间接修改数据:
```
```python
//      数据指针
```
```python
//      需要指向变量的指针!
```
```python
//  间接调用函数:
```
```python
//      函数指针
```
```python
//      必须得是函数指针变量
```
```python
//注:严格区分跨函数间接调用还是本函数间接调用:
```
```python
//      本函数间接调用:只需函数指针变量
```
```python
//      跨函数间接调用:必须指向函数指针的指针(二级函数指针)
```
```python
//03.跨函数修改函数指针变量不成功的原因:
```
```python
//  1.严格区分跨函数(跨进程)和非跨函数
```
```python
//  2.跨进程要注意外部对内部访问权限的满足情况
```
```python
//  3.安全软件劫持跨进程调用
```
```python
//  4.Debug和Release模式的不同特点
```
```python
//  5.跨进程访问并开启新的进程
```
```python
//      进程1告诉进程2开启进程3
```
```python
//04.严格区分是打开线程还是打开进程的特点
```
```python
//  所导致的差异
```
```python
void
```
```python
run()
{
```
```python
//system("pause");
```
```python
MessageBoxA(
```
```python
0
```
```python
,
```
```python
"haihua"
```
```python
,
```
```python
"fangfang"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
void
```
```python
test()
{
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"fangfang"
```
```python
,
```
```python
"haihua"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
//数据区
```
```python
//run,&run,*run所获取的数值都是一样的,都是同一块儿还是实体的入口点
```
```python
printf
```
```python
(
```
```python
"&num = %p, run = %p, &run = %p, *run = %p \n"
```
```python
, &num, run, &run, *run);
```
```python
//同一个函数实现间接调用-->只需函数指针变量
```
```python
void
```
```python
(*pFun)() = run;
```
```python
printf
```
```python
(
```
```python
"&pFun = %p, test = %p \n"
```
```python
, &pFun, test);
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
//printf("%d \n", num);
```
```python
pFun();
        Sleep(
```
```python
3000
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(03):dll.c
内容概要:**外部间接修改调用**
```python
#include
```
```python
<stdio
```
```python
.h
```
```python
>
```
```python
//01.注入函数的执行特点:
```
```python
//  在执行注入操作的那一刻
```
```python
//      注入的指定函数被直接加载进注入进程所占用的进程当中
```
```python
//      并且此时所注入的指定函数位于运行时堆栈(栈顶)当中
```
```python
//  也就注入之后,立即得到执行
```
```python
//      执行的结果显示于所注入的进程当中
```
```python
//02.严格区分地址与指针之间的区别:
```
```python
//      空指针(空指针变量):存储的是地址
```
```python
//      指针(常量指针和变量指针:存储的是指针
```
```python
//  注:地址不具备解析意义,指针具备解析意义!
```
```python
//03.跨进程调用和跨进程修改调用:
```
```python
// 跨进程调用:
```
```python
//      一级函数指针变量(需要函数常量指针)
```
```python
//  跨进程修改调用:
```
```python
//      二级函数指针变量(需要函数变量指针)
```
```python
//04.经过测试,要想实现函数的间接调用:
```
```python
//  必须使用函数变量指针,不能使用函数常量指针
```
```python
_
```
```python
declspec(dllexport)
```
```python
void
```
```python
go()
```
```python
{
```
```python
printf(
```
```python
"注入成功! \n"
```
```python
)
```
```python
;
```
```python
//数据区-->数据指针-->跨函数间接修改数据
```
```python
//int * pNum = (int *)0x004FFC0C;
```
```python
//*pNum = 1000;
```
```python
//代码区-->函数指针-->跨函数间接调用函数-->获取调用行为
```
```python
//void(*const pFun)() = (void(*)())0x0032136B;//函数常量指针不能够实现间接调用
```
```python
//void(*pFun)() = (void(*)())0x009E136B;//函数指针变量
```
```python
pFun()
```
```python
;
```
```python
//代码区-->二级函数指针-->跨函数修改调用-->修改调用行为
```
```python
//void(**ppFun)() = (void(**)())0x0018F914;
```
```python
//*ppFun = (void(*)())0x0134136B;
```
```python
}
```
程序片段(04):01.结构体.c+02.结构体定义变量.c+03.结构体变量初始化.c
内容概要:**结构体定义**
```python
///01.结构体.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.结构体:
```
```python
//  用法:
```
```python
//      可以用于组合不同类型的多个变量
```
```python
//  举例:
```
```python
//      待拆分的字符串整体:
```
```python
//      tyhyxs_fw@163.com,袁可,长治路303号大生科技楼411室,3517027946，15110340952，14.90
```
```python
struct
```
```python
DangDang01
{
```
```python
//定义方式一:标准形式
```
```python
char
```
```python
email[
```
```python
20
```
```python
];
```
```python
char
```
```python
name[
```
```python
20
```
```python
];
```
```python
char
```
```python
addr[
```
```python
100
```
```python
];
```
```python
long
```
```python
long
```
```python
QQ;
```
```python
long
```
```python
long
```
```python
mobile;
```
```python
double
```
```python
price;
};
```
```python
//02.结构体嵌套定义特点:
```
```python
//  1.结构体之间可以进行嵌套定义(不同)
```
```python
//      并且支持结构体多层嵌套定义
```
```python
//  2.结构体本体不能进行嵌套定义(相同)
```
```python
//注:严格区分是否能够准确分配内存大小!
```
```python
//  这是结构体是否能够成功定义的判断条件
```
```python
struct
```
```python
DangDang02
{
```
```python
int
```
```python
num;
```
```python
struct
```
```python
DangDang01 dd01;
```
```python
//不同
```
```python
//struct DangDang02 dd02;//本体
```
```python
};
```
```python
struct
```
```python
DangDang03
{
```
```python
int
```
```python
num;
```
```python
struct
```
```python
DangDang02 dd02;
};
```
```python
//03.结构体类型定义的两种方式:
```
```python
//  方式一:标准形式:
```
```python
// 方式二:匿名形式
```
```python
//      用作锁定结构体变量的定义数量,可以用作权限控制
```
```python
//  方式三:简写形式
```
```python
struct
```
```python
{
```
```python
//定义方式二:匿名方式
```
```python
char
```
```python
email[
```
```python
20
```
```python
];
```
```python
char
```
```python
name[
```
```python
20
```
```python
];
```
```python
char
```
```python
addr[
```
```python
100
```
```python
];
```
```python
long
```
```python
long
```
```python
QQ;
```
```python
long
```
```python
long
```
```python
mobile;
```
```python
double
```
```python
price;
} boss;
```
```python
//匿名结构体:用于锁定结构体变量的定义数量[经常用作权限控制]
```
```python
//04.结构体成员的作用范围:
```
```python
//  仅仅作用于当前结构体变量范围之内,外部不可直接进行访问
```
```python
//05.结构体成员变量的初始化方式:
```
```python
//  1.在定义结构体变量的同时完成初始化:
```
```python
//      (1).可以采用指定成员指定初始化,其余成员默认初始化的方式
```
```python
//          如果是字符串同样可以采用指定初始化方式,而无需使用strcpy();完成初始化操作
```
```python
//      (2).如果是整体初始化:
```
```python
//          就可以按照非指定初始化方式进行初始化,结构体成员按照顺序进行初始化,此状态
```
```python
//          下的结构体成员(字符串)也同样可以直接完成初始化操作(无需借助strcpy();函数)
```
```python
//  2.其余赋值情况:
```
```python
//      既不能使用指定初始化方式,而且还不能使用非strcpy();函数完成字符串初始化操作!
```
```python
//注:凡是基于非初始化状态下的结构体变量赋值都必须采用strcpy();函数完成结构体成员
```
```python
//      字符串的赋值操作
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//price;//结构体成员的作用范围:仅仅作用于当前结构体变量定义范围之内
```
```python
strcpy
```
```python
(boss.email,
```
```python
"tyhyxs_fw@163.com"
```
```python
);
```
```python
strcpy
```
```python
(boss.name,
```
```python
"袁可"
```
```python
);
```
```python
strcpy
```
```python
(boss.addr,
```
```python
"长治路303号大生科技楼411室"
```
```python
);
    boss.QQ =
```
```python
3417027946
```
```python
;
    boss.mobile =
```
```python
15110240952
```
```python
;
    boss.price =
```
```python
14.90
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%s, %s, %s, %lld, %lld, %lf \n"
```
```python
, boss.email, boss.name, boss.addr, boss.QQ, boss.mobile, boss.price);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.结构体定义变量.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.结构体类型特点:
```
```python
//  1.定义的结构体类型只是会作用于本文件当中,跨文件无效!
```
```python
//      定义的结构体类型作用域:定义位置开始+本文件结束
```
```python
//      因此,结构体类型常常被定义与头文件当中(以备其他文件所使用)
```
```python
struct
```
```python
DangDang01
{
```
```python
char
```
```python
email[
```
```python
20
```
```python
];
```
```python
char
```
```python
name[
```
```python
20
```
```python
];
```
```python
char
```
```python
addr[
```
```python
100
```
```python
];
```
```python
long
```
```python
long
```
```python
QQ;
```
```python
long
```
```python
long
```
```python
mobile;
```
```python
double
```
```python
price;
} dd03, *pDD04, dd05[
```
```python
10
```
```python
];
```
```python
//02.结构体类型的简化形式:
```
```python
//  宏定义简化:
```
```python
//      #define DangDang struct DangDang01
```
```python
//  关键字简化:
```
```python
//      typedef struct DangDang01 DnagDang;
```
```python
//注:严格区分这两种方式所定义变量的区别
```
```python
//  尤其是在同时定义多个变量的时候;
```
```python
//  尤其是在定义指针变量的时候!
```
```python
//03.结构体定义特点:
```
```python
//  1.既可以定义于函数外部,也可以定义于函数内部
```
```python
//  2.如果出现同名的结构体类型定义,按照从前往后
```
```python
//      的就近原则进行准确区分!
```
```python
#define DANGDANG struct DangDang01
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
DangDang01 dd06;
```
```python
struct
```
```python
DangDang01 * dd07, dd08;
```
```python
//结构体指针变量+结构体普通变量
```
```python
DANGDANG
```
```python
* dd09, dd10;
```
```python
//同上!
```
```python
struct
```
```python
DangDang01 dd11[
```
```python
3
```
```python
];
```
```python
struct
```
```python
DangDang01 dd12[
```
```python
3
```
```python
][
```
```python
4
```
```python
];
```
```python
struct
```
```python
DangDang01
    {
```
```python
int
```
```python
num;
```
```python
double
```
```python
price;
    } dd13;
    dd13.num =
```
```python
10
```
```python
;
    dd13.price =
```
```python
99.0
```
```python
;
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///03.结构体变量初始化.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.C99新语法之结构体变量初始化:
```
```python
//  C99新语法当中的结构体整体可以看做为
```
```python
//  一个数组进行静态初始化,不过没有索引
```
```python
struct
```
```python
MyStruct01
{
```
```python
//初始化方式一:全体成员初始化
```
```python
int
```
```python
num;
```
```python
char
```
```python
str[
```
```python
10
```
```python
];
} ms01 = {
```
```python
10
```
```python
,
```
```python
"123"
```
```python
}, ms04 = {.num =
```
```python
10
```
```python
,
```
```python
"123"
```
```python
};
```
```python
struct
```
```python
MyStruct01 ms02 = {
```
```python
10
```
```python
,
```
```python
"123"
```
```python
};
```
```python
//初始化方式二:指定成员初始化
```
```python
struct
```
```python
MyStruct01 ms03 = { .num =
```
```python
10
```
```python
,.str =
```
```python
"123"
```
```python
};
```
```python
//02.结构体初始化方式:
```
```python
//  1.全体成员初始化:
```
```python
//      按照成员的顺序进行完整初始化
```
```python
//  2.指定成员初始化:
```
```python
//      通过点儿号('.')代表结构体变量本体,执行指定初始化操作
```
```python
//      一旦存在指定初始化的操作,就存在默认初始化操作
```
```python
//注:只有在初始化的赋值情况之下才存在指定初始化的操作
```
```python
//          其他情况之下的赋值操作不具备指定初始化的特点
```
```python
//      指定初始化的赋值操作同样适用于匿名结构体
```
```python
struct
```
```python
{
```
```python
int
```
```python
num;
```
```python
char
```
```python
str[
```
```python
10
```
```python
];
} ms05 = { .num =
```
```python
10
```
```python
,.str =
```
```python
"123"
```
```python
};
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"%d, %s \n"
```
```python
, ms01.num, ms01.str);
```
```python
printf
```
```python
(
```
```python
"%d, %s \n"
```
```python
, ms02.num, ms02.str);
```
```python
printf
```
```python
(
```
```python
"%d, %s \n"
```
```python
, ms03.num, ms03.str);
```
```python
printf
```
```python
(
```
```python
"%d, %s \n"
```
```python
, ms04.num, ms04.str);
```
```python
printf
```
```python
(
```
```python
"%d, %s \n"
```
```python
, ms05.num, ms05.str);
```
```python
struct
```
```python
MyStruct01 ms06;
```
```python
//ms05.str = "123";//结构体变量当中的字符串成员只有在初始化的条件下进行字符串赋值无需strcpy();函数
```
```python
//其它情况之下的赋值操作都必须依赖于strcpy();函数完成对字符串成员的赋值操作
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):01.引用结构体.c+02.结构体深浅拷贝.c
内容概要:**结构体引用**
```python
///01.引用结构体.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.结构体类型定义特点:
```
```python
//  定义结构体类型的时候,不允许对结构体成员实施初始化操作!
```
```python
//  (结构体类型成员默认初始化操作!)
```
```python
//注:此条法则只是针对于C语言有效,针对于C++语言是无效的!
```
```python
struct
```
```python
MyStruct01
{
```
```python
int
```
```python
num;
```
```python
char
```
```python
str[
```
```python
10
```
```python
];
```
```python
//double db = 99.0;
```
```python
};
```
```python
struct
```
```python
MyStruct02
{
```
```python
struct
```
```python
MyStruct01 ms01;
```
```python
int
```
```python
num;
```
```python
char
```
```python
str[
```
```python
10
```
```python
];
};
```
```python
//02.关于结构体当中的struct关键字:
```
```python
//  在C语言当中,如果没有定义结构体类型别名的情况之下:
```
```python
//      凡是使用结构体类型的时候都必须添加上struct关键字
```
```python
//03.结构体成员在进行初始化的时候:
```
```python
//  全体成员初始化:无需结构体成员名
```
```python
//  指定成员初始化:必须结构体成员名
```
```python
//04.同一类型的结构体变量之间支持赋值操作
```
```python
//05.结构体嵌套形式的多层访问需要使用点儿号('.')
```
```python
//06.结构体访问成员的两种方式:
```
```python
//  结构体变量:点儿号('.')
```
```python
//  结构体指针:箭头号('->')
```
```python
//注:指针执行某个结构体,那么就能采用指针方式直接
```
```python
//      访问结构体当中的该级成员
```
```python
//07.结构体不支持整体打印操作:
```
```python
//  需要逐级访问内部成员实现打印结构体内容
```
```python
//08.针对于结构体变量整体的无意义运算符:
```
```python
//  1.算数运算符(+,-,*,/,%)
```
```python
//  1.自变运算符(++,--)
```
```python
//  2.关系运算符(>,<,>=,<=,==,!=)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct02 ms01 = { {
```
```python
10
```
```python
,
```
```python
"calc"
```
```python
},
```
```python
101
```
```python
,
```
```python
"notepad"
```
```python
};
```
```python
struct
```
```python
MyStruct02 ms02 = ms01;
    ms01.ms01.num =
```
```python
90
```
```python
;
    ms01.num =
```
```python
30
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d, %s, %d, %s \n"
```
```python
, ms01.ms01.num, ms01.ms01.str, ms01.num, ms01.str);
```
```python
printf
```
```python
(
```
```python
"%d, %s, %d, %s \n"
```
```python
, ms02.ms01.num, ms02.ms01.str, ms02.num, ms02.str);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.结构体深浅拷贝.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.浅拷贝和深拷贝:
```
```python
//  1.其实浅拷贝和深拷贝的实质都是一样的:
```
```python
//      都同样执行的是拷贝数据操作!
```
```python
//  2.针对不同的拷贝对象,意义层次不同:
```
```python
//      普通变量:拷贝的仅仅是数据本身而已
```
```python
//      指针变量:拷贝的是指向实际数据的指针
```
```python
//注:当结构体成员是属于数组类型的情况:
```
```python
//  由于Ｃ语言当中的数组名称属于是常量指针,
```
```python
//  因此,在进行结构体变量拷贝操作的时候,针对于
```
```python
//  数组类型的成员执行的都是副本拷贝(深拷贝),而不是原本拷贝(浅拷贝)
```
```python
//特:在结构体变量之间进行拷贝操作的时候,凡是涉及到数组类型的成员
```
```python
//  拷贝操作,都是深拷贝,不会涉及到浅拷贝的情况!-->数组名:常量指针导致!
```
```python
//02.结构体成员的深浅拷贝分类:
```
```python
//  1.所有指针变量都涉及到深浅考别问题
```
```python
//  2.由于数组名称是常量指针,因此只涉及到深拷贝问题,不会涉及到浅拷贝问题
```
```python
//  3.其他类型的所有变量都只会涉及到浅拷贝问题!
```
```python
//03.strcpy();函数的原理依赖于memset();函数进行实现!
```
```python
struct
```
```python
MyStruct01
{
```
```python
int
```
```python
num;
```
```python
char
```
```python
* p;
```
```python
int
```
```python
* px;
```
```python
char
```
```python
arr[
```
```python
10
```
```python
];
};
```
```python
//04.所有变量的赋值操作,默认情况之下都是浅拷贝操作:
```
```python
//  因此,如果涉及到结构体变量的拷贝操作的时候,需要
```
```python
//  根据成员需要,手动执行深拷贝操作!
```
```python
//05.结构体成员深浅考别注意事项:
```
```python
//  凡是涉及到指针变量的拷贝问题,都必须注意深浅拷贝问题!
```
```python
//注:只需要注意指针变量的拷贝默认拷贝情况分析:
```
```python
//  其实就是为了切断两个不同结构体变量之间的关联!
```
```python
//  防止两个结构体变量共享一片儿内存!
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct01 ms01 = {.arr =
```
```python
"HaHaHa"
```
```python
};
    ms01.num =
```
```python
30
```
```python
;
    ms01.p =
```
```python
malloc
```
```python
(
```
```python
20
```
```python
);
```
```python
strcpy
```
```python
(ms01.p,
```
```python
"Hello World!"
```
```python
);
```
```python
struct
```
```python
MyStruct01 ms02 = ms01;
```
```python
//赋值操作:默认都是浅拷贝!
```
```python
ms02.p =
```
```python
malloc
```
```python
(
```
```python
20
```
```python
);
```
```python
//以待深拷贝
```
```python
ms02.p =
```
```python
strcpy
```
```python
(ms02.p, ms01.p);
```
```python
//替换浅拷贝
```
```python
free
```
```python
(ms01.p);
```
```python
//浅拷贝情况之下会出现问题,深拷贝不会出现问题
```
```python
printf
```
```python
(
```
```python
"ms01.p = %s, ms02.p = %s \n"
```
```python
, ms01.p, ms02.p);
```
```python
printf
```
```python
(
```
```python
"ms01.str = %s, ms02.str = %s \n"
```
```python
, ms01.arr, ms02.arr);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):结构体赋值.c
内容概要:**结构体赋值**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
struct
```
```python
MyStruct01
{
```
```python
int
```
```python
arr[
```
```python
5
```
```python
];
```
```python
char
```
```python
str[
```
```python
10
```
```python
];
```
```python
char
```
```python
* p;
};
```
```python
//01.结构体变量赋值:
```
```python
//  1.首先拷贝深浅拷贝问题:
```
```python
//      1.一旦涉及到指针(无论是常指针还是变指针),都会涉及到深浅拷贝问题
```
```python
//      2.数组比较特殊,由于数组名不可直接通过赋值号进行修改,因此只有浅拷贝
```
```python
//          区分:静态数组和动态数组(只有静态数组才会涉及到深浅拷贝问题!)
```
```python
//  2.赋值号所做的只是浅拷贝动作而已
```
```python
//  3.深浅拷贝的执行过程:
```
```python
//      先执行浅拷贝操作,再执行深拷贝操作
```
```python
//注:深浅拷贝的底层实现依赖于memcpy();函数
```
```python
//      默认的浅拷贝操作只是简单的使用了memcpy();函数完成
```
```python
//02.关于结构体初始化的注意事项:
```
```python
//  1.大括号("{}")叫做静态初始化方式,只能用于具备初始化的赋值意义时期!
```
```python
//  2.C99新语法之指定成员初始化方式只能用于静态初始化情况之下
```
```python
//注:只有在初始化的情况之下对字符指针赋值无需strcpy();函数,其它情况之下
```
```python
//  对于字符指针的赋值都必须依赖于strcpy();函数
```
```python
//03.初始化情况也存在浅初始化和深初始化:
```
```python
//  只要结构体的成员当中有指针就必定涉及到深浅问题!(拷贝+初始)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct01 ms01 = { {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
},
```
```python
"calc"
```
```python
, NULL };
```
```python
//浅初始化
```
```python
ms01.p = (
```
```python
char
```
```python
*)
```
```python
malloc
```
```python
(
```
```python
30
```
```python
);
```
```python
//深初始化
```
```python
strcpy
```
```python
(ms01.p,
```
```python
"HaiHuaLove"
```
```python
);
```
```python
struct
```
```python
MyStruct01 ms02 = ms01;
```
```python
//赋值号默认只是执行浅拷贝操作(针对于指针而言)
```
```python
ms01.arr[
```
```python
3
```
```python
] =
```
```python
'X'
```
```python
;
    ms01.str[
```
```python
2
```
```python
] =
```
```python
'X'
```
```python
;
    *(ms01.p) =
```
```python
'X'
```
```python
;
```
```python
free
```
```python
(ms01.p);
```
```python
//释放共享内存块儿
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d, %d \n"
```
```python
, *(ms01.arr + i), *(ms02.arr + i));
    }
```
```python
printf
```
```python
(
```
```python
"%s, %s \n"
```
```python
, ms01.str, ms01.str);
```
```python
printf
```
```python
(
```
```python
"%s, %s \n"
```
```python
, ms01.p, ms02.p);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(07):进化论.c
内容概要:**结构体嵌套**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
struct
```
```python
Life
{
```
```python
//生物
```
```python
int
```
```python
canMove;
};
```
```python
struct
```
```python
Animal
{
```
```python
//动物
```
```python
struct
```
```python
Life life;
```
```python
int
```
```python
canRun;
};
```
```python
struct
```
```python
Tiger
{
```
```python
//老虎
```
```python
struct
```
```python
Animal animal;
```
```python
int
```
```python
tooth;
```
```python
int
```
```python
ismao;
};
```
```python
//01.在C语言当中的结构体类型嵌套可以实现继承
```
```python
//  1.在基于Windows的C语言编程过程当中,经常基于结构体实现单继承以及多继承
```
```python
//  2.还可以实现多重继承(都是通过C语言当中的结构体完成实现!)
```
```python
struct
```
```python
Human
{
```
```python
//人类
```
```python
struct
```
```python
Animal animal;
```
```python
char
```
```python
think[
```
```python
30
```
```python
];
};
```
```python
//02.在C语言当中的所有数据结构体都依赖于结构体实现:
```
```python
//  例如:二叉树这种数据结构体的实现!
```
```python
struct
```
```python
BinTree
{
```
```python
int
```
```python
num;
```
```python
//节点序号
```
```python
struct
```
```python
BinTree * pLeftList;
```
```python
//指向左子树
```
```python
struct
```
```python
BinTree * pRightList;
```
```python
//指向右子树
```
```python
};
```
```python
struct
```
```python
File
{
```
```python
//文件描述
```
```python
int
```
```python
time;
```
```python
int
```
```python
size;
```
```python
int
```
```python
isBin;
```
```python
int
```
```python
isExe;
};
```
```python
//03.在C语言当中模拟磁盘文件系统:
```
```python
//  磁盘系统可以通过结构体描述!
```
```python
struct
```
```python
Dictory
{
```
```python
//目录描述
```
```python
struct
```
```python
File * pFile;
```
```python
//动态数组管理多个文件
```
```python
int
```
```python
fileNum;
```
```python
struct
```
```python
Dictory * pDictory;
```
```python
//动态数组管理多个目录
```
```python
int
```
```python
dictoryNum;
};
```
```python
//04.在C语言当中模拟动态数组
```
```python
struct
```
```python
Array
{
```
```python
//数组描述
```
```python
int
```
```python
* pArr;
```
```python
int
```
```python
length;
};
```
```python
//05.总的来说,C语言的结构体作用:
```
```python
//  1.可以描述C++语言的继承体系:
```
```python
//      单继承+多继承+多重继承
```
```python
//  2.用于组合多个不同类型的变量
```
```python
//      数据封装体
```
```python
//  3.所有标准数据结构的实现
```
```python
//  4.所有扩充数据结构的实现
```
```python
//注:所有复杂事物的描述
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(08):1.c+run1.c+run2.c
内容概要:**头文件的作用以及结构体定义**
```python
///
```
```python
1.c
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
//定义并初始化一个变量
```
```python
int
```
```python
add(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
//函数的定义
```
```python
}
```
```python
///
```
```python
run1.c
```
```python
#include "1.h"
```
```python
///run2.c
```
```python
#include <stdio.h>
```
```python
#include "1.h"
```
```python
//01.严格区分声明与定义之间的区别:
```
```python
//  1.存在情况分析:
```
```python
//      声明:只是说这个东西儿存在,但是并不一定存在(虚的)
```
```python
//      定义:这个东西儿确实存在
```
```python
//  2.存放位置不同:
```
```python
//      声明:存放于头文件当中
```
```python
//      定义:存放于源文件当中
```
```python
//  3.包含性不同:
```
```python
//      声明:由于声明可以进行重复声明,因此,可以重复包含
```
```python
//          没有内存实体
```
```python
//      定义:由于定义不能进行重复定义,因此,不能重复定义
```
```python
//          存在内存实体
```
```python
//      注:只有全局变量和函数存在声明和定义的区别,局部变量不存在区别
```
```python
//  4.预编译和编译的不同:
```
```python
//      预编译处理的是头文件
```
```python
//      编译处理的是源文件(是在预编译之后的源文件)
```
```python
//注:所有针对于类型的申明:
```
```python
//      都只是作用于声明类型的文件本身:从声明位置起始,到本文件结束
```
```python
//     所有全局内容的默认作用范围
```
```python
//          当前定义文件起始,到跨文件范围之内
```
```python
void
```
```python
main01()
{
```
```python
struct
```
```python
MyStruct my01;
    #include
```
```python
"2.h"
```
```python
//包含的只是内容而已
```
```python
}
```
程序片段(09):LanMDa.cpp
内容概要:**LanMda**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//
```
```python
01
```
```python
.关于函数嵌套定义问题:
```
```python
//
```
```python
C语言:既不允许函数的直接嵌套定义,也不允许函数的间接嵌套定义
//  C++:只是不允许函数的直接嵌套定义,但是允许函数的间接嵌套定义
//      而这个间接嵌套定义的方式就是Lambda表达式
```
```python
int
```
```python
add(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a + b;
}
//
```
```python
02
```
```python
.C++语法之Lambda表达式
//  [](函数形参){函数实体}(函数实参);
```
```python
//
```
```python
03
```
```python
.C++语法之
```
```python
for
```
```python
循环:
```
```python
//
```
```python
for
```
```python
(auto tmp : arr){
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, tmp);};
```
```python
//
```
```python
04
```
```python
.C++语法之增强
```
```python
for
```
```python
循环:
```
```python
//
```
```python
for
```
```python
each
```
```python
(
```
```python
int
```
```python
tmp in arr){
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, tmp)};
```
```python
//
```
```python
05
```
```python
.C++语法之初始和赋值的区分:
```
```python
//
```
```python
初始格式:
```
```python
int
```
```python
num(
```
```python
10
```
```python
);
```
```python
//
```
```python
赋值格式:num =
```
```python
20
```
```python
;
```
```python
int
```
```python
main01(void)
{
    []() {
```
```python
system
```
```python
(
```
```python
"notepad"
```
```python
); }();
```
```python
//
```
```python
最简单的Lambda表达式
    [](
```
```python
int
```
```python
a,
```
```python
int
```
```python
b) {
```
```python
printf
```
```python
(
```
```python
"a =
```
```python
%d
```
```python
, b =
```
```python
%d
```
```python
\n"
```
```python
, a, b); MessageBoxA(
```
```python
0
```
```python
,
```
```python
"World"
```
```python
,
```
```python
"Hello"
```
```python
,
```
```python
0
```
```python
); }(
```
```python
10
```
```python
,
```
```python
20
```
```python
);
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
for
```
```python
(auto tmp : arr)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%3d
```
```python
"
```
```python
, tmp);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
for
```
```python
each
```
```python
(
```
```python
int
```
```python
tmp in arr)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%3d
```
```python
"
```
```python
, tmp);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
for
```
```python
each
```
```python
(auto tmp in arr)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%3d
```
```python
"
```
```python
, tmp);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
int
```
```python
num(
```
```python
10
```
```python
);
```
```python
printf
```
```python
(
```
```python
"num =
```
```python
%d
```
```python
\n"
```
```python
, num);
    num =
```
```python
20
```
```python
;
```
```python
printf
```
```python
(
```
```python
"num =
```
```python
%d
```
```python
\n"
```
```python
, num);
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
```
程序片段(10):01.时间优先压缩与解压缩.c+02.空间优先压缩与解压缩.c
内容概要:**压缩与解压缩**
```python
///01.时间优先压缩与解压缩.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.数据压缩与解压缩涉及知识:
```
```python
//  1.考虑时间和空间问题?
```
```python
//      时间优先-->节省时间-->浪费空间
```
```python
//      空间优先-->节省空间-->浪费时间
```
```python
//  2.按照压缩单元问题区分?
```
```python
//      单字符压缩
```
```python
//      字符串压缩
```
```python
//注:这里仅仅是对字符类型的数据实施压缩操作!
```
```python
//02.如何选取具体的压缩算法?
```
```python
//  1.电脑性能+占用空间:
```
```python
//      时间优先or空间优先
```
```python
//  2.数据操作方式:
```
```python
//      双索引or双指针
```
```python
//  3.压缩数据类型:
```
```python
//      字符压缩or字符串压缩
```
```python
//03.时间优先和空间优先的体现点:
```
```python
//  看是否开辟了额外的内存空间:
```
```python
//      如果已开辟:时间优先
```
```python
//      如果未开辟:空间优先
```
```python
char
```
```python
* timePriorityZip(
```
```python
char
```
```python
* pStr)
{
```
```python
int
```
```python
pStrLen =
```
```python
strlen
```
```python
(pStr);
```
```python
char
```
```python
* pZipStr = (
```
```python
char
```
```python
*)
```
```python
calloc
```
```python
(pStrLen +
```
```python
1
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
));
```
```python
char
```
```python
* pCopy = pZipStr;
```
```python
while
```
```python
(
```
```python
'\0'
```
```python
!= *pStr)
    {
```
```python
char
```
```python
* pTmpStr = pStr;
```
```python
char
```
```python
tmpChr = *pStr;
```
```python
int
```
```python
tmpStrLen =
```
```python
0
```
```python
;
```
```python
while
```
```python
(*(pTmpStr) == *(pTmpStr +
```
```python
1
```
```python
))
        {
            ++tmpStrLen;
            ++pTmpStr;
        }
```
```python
if
```
```python
(!tmpStrLen)
        {
            *pCopy = *pStr;
            ++pCopy;
            ++pStr;
        }
```
```python
else
```
```python
{
            *pCopy = tmpStrLen +
```
```python
1
```
```python
+
```
```python
'0'
```
```python
;
            *(pCopy +
```
```python
1
```
```python
) = *pStr;
            pCopy +=
```
```python
2
```
```python
;
            pStr += tmpStrLen +
```
```python
1
```
```python
;
        }
    }
```
```python
return
```
```python
(
```
```python
char
```
```python
*)_recalloc(pZipStr,
```
```python
strlen
```
```python
(pZipStr) +
```
```python
1
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
));
}
```
```python
char
```
```python
* timePriorityUnZip(
```
```python
char
```
```python
* pStr)
{
```
```python
char
```
```python
* pUnZipStr = (
```
```python
char
```
```python
*)
```
```python
calloc
```
```python
(
```
```python
1024
```
```python
*
```
```python
10
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
));
```
```python
char
```
```python
* pCopy = pUnZipStr;
```
```python
while
```
```python
(*pStr)
    {
```
```python
char
```
```python
tmpChr = *pStr;
```
```python
if
```
```python
(
```
```python
'0'
```
```python
<= tmpChr &&
```
```python
'9'
```
```python
>= tmpChr)
        {
```
```python
int
```
```python
tmpStrLen = tmpChr -
```
```python
'0'
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < tmpStrLen; ++i)
            {
                *pCopy++ = *(pStr +
```
```python
1
```
```python
);
            }
            pStr +=
```
```python
2
```
```python
;
        }
```
```python
else
```
```python
{
            *pCopy++ = *pStr++;
        }
    }
```
```python
return
```
```python
(
```
```python
char
```
```python
*)_recalloc(pUnZipStr,
```
```python
strlen
```
```python
(pUnZipStr) +
```
```python
1
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
));
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//字符原串:aaaaabbbhaihualovefangfangooooooooo
```
```python
//字符压缩:5a3bhaihualovefangfang9o
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] =
```
```python
"aaaaabbbhaihualovefangfangooooooooo"
```
```python
;
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, timePriorityZip(str));
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, timePriorityUnZip(timePriorityZip(str)));
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.空间优先压缩与解压缩.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
void
```
```python
spacePriorityZip(
```
```python
char
```
```python
* pSrcStr)
{
```
```python
char
```
```python
* p1 = pSrcStr;
```
```python
char
```
```python
* p2 = pSrcStr;
```
```python
while
```
```python
(*p1 = *p2)
    {
```
```python
//if ('a' != *p1)
```
```python
//{//删除所有字符
```
```python
//  ++p1;
```
```python
//}
```
```python
int
```
```python
sameChrLen =
```
```python
1
```
```python
;
```
```python
char
```
```python
* pTmp = p2 +
```
```python
1
```
```python
;
```
```python
while
```
```python
(*p2 == *pTmp)
        {
            ++sameChrLen;
            ++pTmp;
        }
```
```python
if
```
```python
(
```
```python
1
```
```python
== sameChrLen)
        {
            ++p1;
            ++p2;
        }
```
```python
else
```
```python
{
            *(pTmp -
```
```python
2
```
```python
) = sameChrLen +
```
```python
'0'
```
```python
;
            p2 += sameChrLen -
```
```python
2
```
```python
;
        }
    }
}
```
```python
void
```
```python
spacePriorityUnZip(
```
```python
char
```
```python
* pZipStr)
{
```
```python
char
```
```python
* p1 = pZipStr;
```
```python
char
```
```python
* p2 = pZipStr;
```
```python
while
```
```python
(*p1 = *p2)
    {
```
```python
int
```
```python
tmpStrLen =
```
```python
0
```
```python
;
```
```python
if
```
```python
(
```
```python
'0'
```
```python
<= *p2 &&
```
```python
'9'
```
```python
>= *p2)
        {
            tmpStrLen = *p2 -
```
```python
'0'
```
```python
;
        }
```
```python
char
```
```python
tmpChr = *(p2 +
```
```python
1
```
```python
);
```
```python
if
```
```python
(!tmpStrLen)
        {
            ++p1;
            ++p2;
        }
```
```python
else
```
```python
{
```
```python
for
```
```python
(
```
```python
char
```
```python
* p = p2 +
```
```python
strlen
```
```python
(p2); p >= p2; --p)
            {
                *(p + tmpStrLen -
```
```python
2
```
```python
) = *p;
            }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < tmpStrLen; ++i)
            {
                *(p2 + i) = tmpChr;
            }
        }
    }
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] =
```
```python
"aaaaabbbhaihualovefangfangooooooooo"
```
```python
;
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    spacePriorityZip(str);
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    spacePriorityUnZip(str);
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(11):strspn.c
内容概要:**strspn**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.strspn(str1, str2);(返回字符串中第一个不在指定字符串中出现的字符下标)
```
```python
//  原理:不断遍历字符串str2,如果那个字符不存在与str1当中的字符相匹配,就
```
```python
//      返回该字符在str2当中的位置
```
```python
int
```
```python
myStrSpn(
```
```python
char
```
```python
* pStr1,
```
```python
char
```
```python
* pStr2)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
strlen
```
```python
(pStr1); ++i)
    {
```
```python
int
```
```python
flag =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
strlen
```
```python
(pStr2); ++j)
        {
```
```python
if
```
```python
(*(pStr1 + i) == *(pStr2 + j))
            {
                flag =
```
```python
1
```
```python
;
            }
        }
```
```python
if
```
```python
(!flag)
        {
```
```python
return
```
```python
i;
        }
    }
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
str1[
```
```python
100
```
```python
] =
```
```python
"o12345"
```
```python
;
```
```python
char
```
```python
str2[
```
```python
100
```
```python
] =
```
```python
"lh3jklo"
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
strspn
```
```python
(str1, str2));
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, myStrSpn(str1, str2));
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(12):字符串.c
内容概要:**360面试字符串出现一次的第一个字符**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.字符串当中出现次数为一次的第一个字符:
```
```python
//  要点:出现一次+首个字符
```
```python
//  思路:从头到(尾-1)遍历每个字符,让其和后面的每一个
```
```python
//      字符进行比较,然后统计字符个数,统计完成之后,如果
```
```python
//      此时相同字符个数还是为0,那么就是该字符!
```
```python
//02.严格区分空字符和空指针:
```
```python
// 空字符:'\0'
```
```python
//  空指针:空类型的指针变量
```
```python
//  指针为空:NULL用于标识指针变量并为存储有意义的地址
```
```python
//03.双for循环实现查找首个出现一次的字符:
```
```python
//  时间复杂度为O(N*N)
```
```python
char
```
```python
getFirstOnceByForFor(
```
```python
char
```
```python
* pStr)
{
```
```python
if
```
```python
(NULL == pStr)
```
```python
return
```
```python
'\0'
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
strlen
```
```python
(pStr); ++i)
    {
```
```python
int
```
```python
sameChrNum =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
j = i +
```
```python
1
```
```python
; j <
```
```python
strlen
```
```python
(pStr); ++j)
        {
```
```python
if
```
```python
(*(pStr + i) == *(pStr + j))
            {
                ++sameChrNum;
            }
        }
```
```python
if
```
```python
(!sameChrNum)
        {
```
```python
return
```
```python
*(pStr + i);
        }
    }
```
```python
return
```
```python
'\0'
```
```python
;
}
```
```python
//04.哈希表的建立特点:
```
```python
//  1.等同于ASCII码表的一一映射对应关系
```
```python
//  2.通过查表法可以直接查询到所需查询的信息
```
```python
//  3.通过建立有序的哈希表,可以提高查询效率
```
```python
//05.哈希表的最大特点:
```
```python
//  1.原生数据有序
```
```python
//  2.查找数据可以采用二分查找法
```
```python
//  3.可以通过(余数+模数)快速确定一个数据所在的位置
```
```python
//      先判断个位,再判断十位,再判断百位..(按个进行匹配)
```
```python
//06.哈希表(HashTable)的时间复杂度
```
```python
//  O(N+256)-->字符-->索引-->统计
```
```python
//07.根据不同的字符映射哈希表当中的数值:
```
```python
//  char-->单字节-->8(bit位)-->2^8-->256种可能
```
```python
//  因此哈希表的时间复杂度为(((N+256))
```
```python
//08.哈希表的由来:
```
```python
//  a[00]-->'\0'
```
```python
//  a[49]-->'1'
```
```python
//  a[65]-->'A'
```
```python
//  索引从0~256分别对应于一个字符,
```
```python
//  而该索引所对应的数值,就表示该整数出现的次数
```
```python
//  从而该整数的出现次数就等同于该字符出现的次数!
```
```python
//  字符-->索引-->统计
```
```python
//09.整型+字符+转义字符:
```
```python
//  同一个整型数值可能同时对应于一个字符和一个转义字符
```
```python
//注:转义字符'\0'所对应的ASCII码值就是0
```
```python
//10.哈希表的建立特点和查询特点:
```
```python
//  按照字符的顺序进行哈希表的建立;
```
```python
//  按照字符的顺序进行哈希表的查询:
```
```python
//注:顺序的一次,以便于快速定位查询
```
```python
char
```
```python
getFirstOnceByHashTable(
```
```python
char
```
```python
* pStr)
{
```
```python
if
```
```python
(NULL == pStr)
```
```python
return
```
```python
'\0'
```
```python
;
```
```python
int
```
```python
hashTable[
```
```python
256
```
```python
] = {
```
```python
0
```
```python
};
```
```python
char
```
```python
* pCopy = pStr;
```
```python
while
```
```python
(*pCopy)
    {
```
```python
//字符-->整型|索引-->统计(统计索引就等同于统计字符)
```
```python
hashTable[*pCopy++]++;
    }
    pCopy = pStr;
```
```python
while
```
```python
(*pCopy)
    {
```
```python
if
```
```python
(
```
```python
1
```
```python
== hashTable[*pCopy])
        {
```
```python
return
```
```python
*pCopy;
        }
        ++pCopy;
    }
```
```python
return
```
```python
'\0'
```
```python
;
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
str[
```
```python
100
```
```python
] =
```
```python
"abcdfabcdvg"
```
```python
;
```
```python
//putchar(getFirstOnce(str));
```
```python
putchar
```
```python
(getFirstOnceByHashTable(str));
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(13):01.字符串加密.c+02.密码加密.c
内容概要:**加密**
```python
///01.字符串加密.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
void
```
```python
encode(
```
```python
char
```
```python
* pStr)
{
```
```python
int
```
```python
pStrLen =
```
```python
strlen
```
```python
(pStr);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < pStrLen; ++i)
    {
        *(pStr + i) +=
```
```python
3
```
```python
;
    }
}
```
```python
//01.加解密方式一:
```
```python
//  加密:让每个数据进行统一算数运算
```
```python
//  解密:让每个数据进行统一算数逆算
```
```python
void
```
```python
decode(
```
```python
char
```
```python
* pStr)
{
```
```python
int
```
```python
pStrLen =
```
```python
strlen
```
```python
(pStr);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < pStrLen; ++i)
    {
        *(pStr + i) -=
```
```python
3
```
```python
;
    }
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] =
```
```python
"HaiHua say: WangFang i love you 1314 forever"
```
```python
;
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    encode(str);
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    decode(str);
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.加解密方式二:
```
```python
//  采用异或运算符
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a =
```
```python
100
```
```python
, b =
```
```python
10
```
```python
;
    a = a ^ b;
```
```python
//加密
```
```python
b = a ^ b;
```
```python
//解密-->加密
```
```python
a = a ^ b;
```
```python
//        -->解密
```
```python
printf
```
```python
(
```
```python
"a = %d, b = %d \n"
```
```python
, a, b);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
encryptOrDecrypt(
```
```python
char
```
```python
* pStr)
{
```
```python
int
```
```python
pStrLen =
```
```python
strlen
```
```python
(pStr);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < pStrLen; ++i)
    {
        *(pStr + i) ^=
```
```python
48
```
```python
;
    }
}
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] =
```
```python
"HaiHua say: WangFang i love you 1314 forever"
```
```python
;
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    encryptOrDecrypt(str);
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    encryptOrDecrypt(str);
```
```python
printf
```
```python
(
```
```python
"(%s) \n"
```
```python
, str);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.密码加密.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
void
```
```python
encodeOrDecode(
```
```python
char
```
```python
* pStr,
```
```python
char
```
```python
* pPass,
```
```python
int
```
```python
pStrLen)
{
```
```python
int
```
```python
pPassLen = strlen(pPass);
```
```python
int
```
```python
modulus = pStrLen / pPassLen;
```
```python
int
```
```python
remainder = pStrLen % pPassLen;
```
```python
if
```
```python
(!remainder)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < modulus; ++i)
        {
```
```python
//分块儿
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j < pPassLen; ++j)
            {
                *(pStr + i * pPassLen + j) ^= *(pPass + j);
            }
        }
    }
```
```python
else
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < modulus; ++i)
        {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j < pPassLen; ++j)
            {
                *(pStr + i * pPassLen + j) ^= *(pPass + j);
            }
        }
```
```python
for
```
```python
(
```
```python
int
```
```python
k =
```
```python
0
```
```python
; k < remainder; ++k)
        {
            *(pStr + modulus * pPassLen + k) ^= *(pPass + k);
        }
    }
}
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
str
```
```python
[
```
```python
1024
```
```python
] =
```
```python
"HaiHua say: WangFang i love you 1314 forever"
```
```python
;
```
```python
char
```
```python
pass[
```
```python
20
```
```python
] =
```
```python
"lovefang1314"
```
```python
;
```
```python
int
```
```python
strLen = strlen(
```
```python
str
```
```python
);
    printf(
```
```python
"(%s) \n"
```
```python
,
```
```python
str
```
```python
);
    encodeOrDecode(
```
```python
str
```
```python
, pass, strLen);
    printf(
```
```python
"(%s) \n"
```
```python
,
```
```python
str
```
```python
);
    encodeOrDecode(
```
```python
str
```
```python
, pass, strLen);
    printf(
```
```python
"(%s) \n"
```
```python
,
```
```python
str
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```

