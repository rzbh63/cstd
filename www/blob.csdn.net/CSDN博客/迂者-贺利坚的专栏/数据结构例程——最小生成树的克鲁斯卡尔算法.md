
# 数据结构例程——最小生成树的克鲁斯卡尔算法 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月07日 10:34:22[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：4672


本文是[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]中第12课时[[最小生成树的克鲁斯卡尔算法](http://edu.csdn.net/course/detail/1595/24602)]的例程。
（程序中graph.h是图存储结构的“算法库”中的头文件，详情请[单击链接…](http://blog.csdn.net/sxhelijian/article/details/49591419)）
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
#define MaxSize 100
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
u;
```
```python
//边的起始顶点
```
```python
int
```
```python
v;
```
```python
//边的终止顶点
```
```python
int
```
```python
w;
```
```python
//边的权值
```
```python
} Edge;
```
```python
void
```
```python
InsertSort(Edge E[],
```
```python
int
```
```python
n)
```
```python
//对E[0..n-1]按递增有序进行直接插入排序
```
```python
{
```
```python
int
```
```python
i,j;
    Edge temp;
```
```python
for
```
```python
(i=
```
```python
1
```
```python
; i<n; i++)
    {
        temp=E[i];
        j=i-
```
```python
1
```
```python
;
```
```python
//从右向左在有序区E[0..i-1]中找E[i]的插入位置
```
```python
while
```
```python
(j>=
```
```python
0
```
```python
&& temp.w<E[j].w)
        {
            E[j+
```
```python
1
```
```python
]=E[j];
```
```python
//将关键字大于E[i].w的记录后移
```
```python
j--;
        }
        E[j+
```
```python
1
```
```python
]=temp;
```
```python
//在j+1处插入E[i]
```
```python
}
}
```
```python
void
```
```python
Kruskal(MGraph g)
{
```
```python
int
```
```python
i,j,u1,v1,sn1,sn2,k;
```
```python
int
```
```python
vset[MAXV];
    Edge E[MaxSize];
```
```python
//存放所有边
```
```python
k=
```
```python
0
```
```python
;
```
```python
//E数组的下标从0开始计
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//由g产生的边集E
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
```
```python
if
```
```python
(g.edges[i][j]!=
```
```python
0
```
```python
&& g.edges[i][j]!=INF)
            {
                E[k].u=i;
                E[k].v=j;
                E[k].w=g.edges[i][j];
                k++;
            }
    InsertSort(E,g.e);
```
```python
//采用直接插入排序对E数组按权值递增排序
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//初始化辅助数组
```
```python
vset[i]=i;
    k=
```
```python
1
```
```python
;
```
```python
//k表示当前构造生成树的第几条边,初值为1
```
```python
j=
```
```python
0
```
```python
;
```
```python
//E中边的下标,初值为0
```
```python
while
```
```python
(k<g.n)
```
```python
//生成的边数小于n时循环
```
```python
{
        u1=E[j].u;
        v1=E[j].v;
```
```python
//取一条边的头尾顶点
```
```python
sn1=vset[u1];
        sn2=vset[v1];
```
```python
//分别得到两个顶点所属的集合编号
```
```python
if
```
```python
(sn1!=sn2)
```
```python
//两顶点属于不同的集合
```
```python
{
```
```python
printf
```
```python
(
```
```python
"  (%d,%d):%d\n"
```
```python
,u1,v1,E[j].w);
            k++;
```
```python
//生成边数增1
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//两个集合统一编号
```
```python
if
```
```python
(vset[i]==sn2)
```
```python
//集合编号为sn2的改为sn1
```
```python
vset[i]=sn1;
        }
        j++;
```
```python
//扫描下一条边
```
```python
}
}
```
```python
int
```
```python
main()
{
    MGraph g;
```
```python
int
```
```python
A[
```
```python
6
```
```python
][
```
```python
6
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
6
```
```python
,
```
```python
1
```
```python
,
```
```python
5
```
```python
,INF,INF},
        {
```
```python
6
```
```python
,
```
```python
0
```
```python
,
```
```python
5
```
```python
,INF,
```
```python
3
```
```python
,INF},
        {
```
```python
1
```
```python
,
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
4
```
```python
},
        {
```
```python
5
```
```python
,INF,
```
```python
5
```
```python
,
```
```python
0
```
```python
,INF,
```
```python
2
```
```python
},
        {INF,
```
```python
3
```
```python
,
```
```python
6
```
```python
,INF,
```
```python
0
```
```python
,
```
```python
6
```
```python
},
        {INF,INF,
```
```python
4
```
```python
,
```
```python
2
```
```python
,
```
```python
6
```
```python
,
```
```python
0
```
```python
}
    };
    ArrayToMat(A[
```
```python
0
```
```python
],
```
```python
6
```
```python
, g);
```
```python
printf
```
```python
(
```
```python
"最小生成树构成:\n"
```
```python
);
    Kruskal(g);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试用图结构
![这里写图片描述](https://img-blog.csdn.net/20151107103349402)

