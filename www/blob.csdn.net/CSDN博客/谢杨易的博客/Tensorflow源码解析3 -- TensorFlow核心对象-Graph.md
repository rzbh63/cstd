
# Tensorflow源码解析3 -- TensorFlow核心对象 - Graph - 谢杨易的博客 - CSDN博客

2018年11月16日 15:23:33[谢杨易](https://me.csdn.net/u013510838)阅读数：1121


Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)
# 1 Graph概述
计算图Graph是TensorFlow的核心对象，TensorFlow的运行流程基本都是围绕它进行的。包括图的构建、传递、剪枝、按worker分裂、按设备二次分裂、执行、注销等。因此理解计算图Graph对掌握TensorFlow运行尤为关键。

# 2 默认Graph
### 默认图替换
之前讲解Session的时候就说过，一个Session只能run一个Graph，但一个Graph可以运行在多个Session中。常见情况是，session会运行全局唯一的隐式的默认的Graph，operation也是注册到这个Graph中。
也可以显示创建Graph，并调用as_default()使他替换默认Graph。在该上下文管理器中创建的op都会注册到这个graph中。退出上下文管理器后，则恢复原来的默认graph。一般情况下，我们不用显式创建Graph，使用系统创建的那个默认Graph即可。
```python
print
```
```python
tf
```
```python
.
```
```python
get_default_graph
```
```python
(
```
```python
)
```
```python
with
```
```python
tf
```
```python
.
```
```python
Graph
```
```python
(
```
```python
)
```
```python
.
```
```python
as_default
```
```python
(
```
```python
)
```
```python
as
```
```python
g
```
```python
:
```
```python
print
```
```python
tf
```
```python
.
```
```python
get_default_graph
```
```python
(
```
```python
)
```
```python
is
```
```python
g
```
```python
print
```
```python
tf
```
```python
.
```
```python
get_default_graph
```
```python
(
```
```python
)
```
```python
print
```
```python
tf
```
```python
.
```
```python
get_default_graph
```
```python
(
```
```python
)
```
输出如下
`<tensorflow.python.framework.ops.Graph object at 0x106329fd0>
True
<tensorflow.python.framework.ops.Graph object at 0x18205cc0d0>
<tensorflow.python.framework.ops.Graph object at 0x10d025fd0>`由此可见，在上下文管理器中，当前线程的默认图被替换了，而退出上下文管理后，则恢复为了原来的默认图。
### 默认图管理
默认graph和默认session一样，也是线程作用域的。当前线程中，永远都有且仅有一个graph为默认图。TensorFlow同样通过栈来管理线程的默认graph。
```python
@tf_export
```
```python
(
```
```python
"Graph"
```
```python
)
```
```python
class
```
```python
Graph
```
```python
(
```
```python
object
```
```python
)
```
```python
:
```
```python
# 替换线程默认图
```
```python
def
```
```python
as_default
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
return
```
```python
_default_graph_stack
```
```python
.
```
```python
get_controller
```
```python
(
```
```python
self
```
```python
)
```
```python
# 栈式管理，push pop
```
```python
@tf_contextlib
```
```python
.
```
```python
contextmanager
```
```python
def
```
```python
get_controller
```
```python
(
```
```python
self
```
```python
,
```
```python
default
```
```python
)
```
```python
:
```
```python
try
```
```python
:
```
```python
context
```
```python
.
```
```python
context_stack
```
```python
.
```
```python
push
```
```python
(
```
```python
default
```
```python
.
```
```python
building_function
```
```python
,
```
```python
default
```
```python
.
```
```python
as_default
```
```python
)
```
```python
finally
```
```python
:
```
```python
context
```
```python
.
```
```python
context_stack
```
```python
.
```
```python
pop
```
```python
(
```
```python
)
```
替换默认图采用了堆栈的管理方式，通过push pop操作进行管理。获取默认图的操作如下，通过默认graph栈_default_graph_stack来获取。
```python
@tf_export
```
```python
(
```
```python
"get_default_graph"
```
```python
)
```
```python
def
```
```python
get_default_graph
```
```python
(
```
```python
)
```
```python
:
```
```python
return
```
```python
_default_graph_stack
```
```python
.
```
```python
get_default
```
```python
(
```
```python
)
```
下面来看_default_graph_stack的创建
```python
_default_graph_stack
```
```python
=
```
```python
_DefaultGraphStack
```
```python
(
```
```python
)
```
```python
class
```
```python
_DefaultGraphStack
```
```python
(
```
```python
_DefaultStack
```
```python
)
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
# 调用父类来创建
```
```python
super
```
```python
(
```
```python
_DefaultGraphStack
```
```python
,
```
```python
self
```
```python
)
```
```python
.
```
```python
__init__
```
```python
(
```
```python
)
```
```python
self
```
```python
.
```
```python
_global_default_graph
```
```python
=
```
```python
None
```
```python
class
```
```python
_DefaultStack
```
```python
(
```
```python
threading
```
```python
.
```
```python
local
```
```python
)
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
super
```
```python
(
```
```python
_DefaultStack
```
```python
,
```
```python
self
```
```python
)
```
```python
.
```
```python
__init__
```
```python
(
```
```python
)
```
```python
self
```
```python
.
```
```python
_enforce_nesting
```
```python
=
```
```python
True
```
```python
# 和默认session栈一样，本质上也是一个list
```
```python
self
```
```python
.
```
```python
stack
```
```python
=
```
```python
[
```
```python
]
```
_default_graph_stack的创建如上所示，最终和默认session栈一样，本质上也是一个list。

# 3 前端Graph数据结构
### Graph数据结构
理解一个对象，先从它的数据结构开始。我们先来看Python前端中，Graph的数据结构。Graph主要的成员变量是Operation和Tensor。Operation是Graph的节点，它代表了运算算子。Tensor是Graph的边，它代表了运算数据。
```python
@tf_export
```
```python
(
```
```python
"Graph"
```
```python
)
```
```python
class
```
```python
Graph
```
```python
(
```
```python
object
```
```python
)
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
# 加线程锁，使得注册op时，不会有其他线程注册op到graph中，从而保证共享graph是线程安全的
```
```python
self
```
```python
.
```
```python
_lock
```
```python
=
```
```python
threading
```
```python
.
```
```python
Lock
```
```python
(
```
```python
)
```
```python
# op相关数据。
```
```python
# 为graph的每个op分配一个id，通过id可以快速索引到相关op。故创建了_nodes_by_id字典
```
```python
self
```
```python
.
```
```python
_nodes_by_id
```
```python
=
```
```python
dict
```
```python
(
```
```python
)
```
```python
# GUARDED_BY(self._lock)
```
```python
self
```
```python
.
```
```python
_next_id_counter
```
```python
=
```
```python
0
```
```python
# GUARDED_BY(self._lock)
```
```python
# 同时也可以通过name来快速索引op，故创建了_nodes_by_name字典
```
```python
self
```
```python
.
```
```python
_nodes_by_name
```
```python
=
```
```python
dict
```
```python
(
```
```python
)
```
```python
# GUARDED_BY(self._lock)
```
```python
self
```
```python
.
```
```python
_version
```
```python
=
```
```python
0
```
```python
# GUARDED_BY(self._lock)
```
```python
# tensor相关数据。
```
```python
# 处理tensor的placeholder
```
```python
self
```
```python
.
```
```python
_handle_feeders
```
```python
=
```
```python
{
```
```python
}
```
```python
# 处理tensor的read操作
```
```python
self
```
```python
.
```
```python
_handle_readers
```
```python
=
```
```python
{
```
```python
}
```
```python
# 处理tensor的move操作
```
```python
self
```
```python
.
```
```python
_handle_movers
```
```python
=
```
```python
{
```
```python
}
```
```python
# 处理tensor的delete操作
```
```python
self
```
```python
.
```
```python
_handle_deleters
```
```python
=
```
```python
{
```
```python
}
```
下面看graph如何添加op的，以及保证线程安全的。
```python
def
```
```python
_add_op
```
```python
(
```
```python
self
```
```python
,
```
```python
op
```
```python
)
```
```python
:
```
```python
# graph被设置为final后，就是只读的了，不能添加op了。
```
```python
self
```
```python
.
```
```python
_check_not_finalized
```
```python
(
```
```python
)
```
```python
# 保证共享graph的线程安全
```
```python
with
```
```python
self
```
```python
.
```
```python
_lock
```
```python
:
```
```python
# 将op以id和name分别构建字典，添加到_nodes_by_id和_nodes_by_name字典中，方便后续快速索引
```
```python
self
```
```python
.
```
```python
_nodes_by_id
```
```python
[
```
```python
op
```
```python
.
```
```python
_id
```
```python
]
```
```python
=
```
```python
op
      self
```
```python
.
```
```python
_nodes_by_name
```
```python
[
```
```python
op
```
```python
.
```
```python
name
```
```python
]
```
```python
=
```
```python
op
      self
```
```python
.
```
```python
_version
```
```python
=
```
```python
max
```
```python
(
```
```python
self
```
```python
.
```
```python
_version
```
```python
,
```
```python
op
```
```python
.
```
```python
_id
```
```python
)
```
### GraphKeys 图分组
每个Operation节点都有一个特定的标签，从而实现节点的分类。相同标签的节点归为一类，放到同一个Collection中。标签是一个唯一的GraphKey，GraphKey被定义在类GraphKeys中，如下
```python
@tf_export
```
```python
(
```
```python
"GraphKeys"
```
```python
)
```
```python
class
```
```python
GraphKeys
```
```python
(
```
```python
object
```
```python
)
```
```python
:
```
```python
GLOBAL_VARIABLES
```
```python
=
```
```python
"variables"
```
```python
QUEUE_RUNNERS
```
```python
=
```
```python
"queue_runners"
```
```python
SAVERS
```
```python
=
```
```python
"savers"
```
```python
WEIGHTS
```
```python
=
```
```python
"weights"
```
```python
BIASES
```
```python
=
```
```python
"biases"
```
```python
ACTIVATIONS
```
```python
=
```
```python
"activations"
```
```python
UPDATE_OPS
```
```python
=
```
```python
"update_ops"
```
```python
LOSSES
```
```python
=
```
```python
"losses"
```
```python
TRAIN_OP
```
```python
=
```
```python
"train_op"
```
```python
# 省略其他
```
### name_scope 节点命名空间
使用name_scope对graph中的节点进行层次化管理，上下层之间通过斜杠分隔。
```python
# graph节点命名空间
```
```python
g
```
```python
=
```
```python
tf
```
```python
.
```
```python
get_default_graph
```
```python
(
```
```python
)
```
```python
with
```
```python
g
```
```python
.
```
```python
name_scope
```
```python
(
```
```python
"scope1"
```
```python
)
```
```python
:
```
```python
c
```
```python
=
```
```python
tf
```
```python
.
```
```python
constant
```
```python
(
```
```python
"hello, world"
```
```python
,
```
```python
name
```
```python
=
```
```python
"c"
```
```python
)
```
```python
print
```
```python
c
```
```python
.
```
```python
op
```
```python
.
```
```python
name
```
```python
with
```
```python
g
```
```python
.
```
```python
name_scope
```
```python
(
```
```python
"scope2"
```
```python
)
```
```python
:
```
```python
c
```
```python
=
```
```python
tf
```
```python
.
```
```python
constant
```
```python
(
```
```python
"hello, world"
```
```python
,
```
```python
name
```
```python
=
```
```python
"c"
```
```python
)
```
```python
print
```
```python
c
```
```python
.
```
```python
op
```
```python
.
```
```python
name
```
输出如下
```python
scope1
```
```python
/
```
```python
c
scope1
```
```python
/
```
```python
scope2
```
```python
/
```
```python
c
```
```python
# 内层的scope会继承外层的，类似于栈，形成层次化管理
```

# 4 后端Graph数据结构
### Graph
先来看graph.h文件中的Graph类的定义，只看关键代码
```python
class Graph
```
```python
{
```
```python
private
```
```python
:
```
```python
// 所有已知的op计算函数的注册表
```
```python
FunctionLibraryDefinition ops_
```
```python
;
```
```python
// GraphDef版本号
```
```python
const
```
```python
std
```
```python
:
```
```python
:
```
```python
unique_ptr
```
```python
<
```
```python
VersionDef
```
```python
>
```
```python
versions_
```
```python
;
```
```python
// 节点node列表，通过id来访问
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Node
```
```python
*
```
```python
>
```
```python
nodes_
```
```python
;
```
```python
// node个数
```
```python
int64 num_nodes_
```
```python
=
```
```python
0
```
```python
;
```
```python
// 边edge列表，通过id来访问
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Edge
```
```python
*
```
```python
>
```
```python
edges_
```
```python
;
```
```python
// graph中非空edge的数目
```
```python
int
```
```python
num_edges_
```
```python
=
```
```python
0
```
```python
;
```
```python
// 已分配了内存，但还没使用的node和edge
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Node
```
```python
*
```
```python
>
```
```python
free_nodes_
```
```python
;
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Edge
```
```python
*
```
```python
>
```
```python
free_edges_
```
```python
;
```
```python
}
```
后端中的Graph主要成员也是节点node和边edge。节点node为计算算子Operation，边为算子所需要的数据，或者代表节点间的依赖关系。这一点和Python中的定义相似。边Edge的持有它的源节点和目标节点的指针，从而将两个节点连接起来。下面看Edge类的定义。
### Edge
```python
class Edge
```
```python
{
```
```python
private
```
```python
:
```
```python
Edge
```
```python
(
```
```python
)
```
```python
{
```
```python
}
```
```python
friend class EdgeSetTest
```
```python
;
```
```python
friend class Graph
```
```python
;
```
```python
// 源节点, 边的数据就来源于源节点的计算。源节点是边的生产者
```
```python
Node
```
```python
*
```
```python
src_
```
```python
;
```
```python
// 目标节点，边的数据提供给目标节点进行计算。目标节点是边的消费者
```
```python
Node
```
```python
*
```
```python
dst_
```
```python
;
```
```python
// 边id，也就是边的标识符
```
```python
int
```
```python
id_
```
```python
;
```
```python
// 表示当前边为源节点的第src_output_条边。源节点可能会有多条输出边
```
```python
int
```
```python
src_output_
```
```python
;
```
```python
// 表示当前边为目标节点的第dst_input_条边。目标节点可能会有多条输入边。
```
```python
int
```
```python
dst_input_
```
```python
;
```
```python
}
```
```python
;
```
Edge既可以承载tensor数据，提供给节点Operation进行运算，也可以用来表示节点之间有依赖关系。对于表示节点依赖的边，其`src_output_, dst_input_`均为-1，此时边不承载任何数据。
下面来看Node类的定义。
### Node
```python
class Node
```
```python
{
```
```python
public
```
```python
:
```
```python
// NodeDef,节点算子Operation的信息，比如op分配到哪个设备上了，op的名字等，运行时有可能变化。
```
```python
const
```
```python
NodeDef
```
```python
&
```
```python
def
```
```python
(
```
```python
)
```
```python
const
```
```python
;
```
```python
// OpDef, 节点算子Operation的元数据，不会变的。比如Operation的入参列表，出参列表等
```
```python
const
```
```python
OpDef
```
```python
&
```
```python
op_def
```
```python
(
```
```python
)
```
```python
const
```
```python
;
```
```python
private
```
```python
:
```
```python
// 输入边，传递数据给节点。可能有多条
```
```python
EdgeSet in_edges_
```
```python
;
```
```python
// 输出边，节点计算后得到的数据。可能有多条
```
```python
EdgeSet out_edges_
```
```python
;
```
```python
}
```
节点Node中包含的主要数据有输入边和输出边的集合，从而能够由Node找到跟他关联的所有边。Node中还包含NodeDef和OpDef两个成员。NodeDef表示节点算子的信息，运行时可能会变，创建Node时会new一个NodeDef对象。OpDef表示节点算子的元信息，运行时不会变，创建Node时不需要new OpDef，只需要从OpDef仓库中取出即可。因为元信息是确定的，比如Operation的入参个数等。
由Node和Edge，即可以组成图Graph，通过任何节点和任何边，都可以遍历完整图。Graph执行计算时，按照拓扑结构，依次执行每个Node的op计算，最终即可得到输出结果。入度为0的节点，也就是依赖数据已经准备好的节点，可以并发执行，从而提高运行效率。
系统中存在默认的Graph，初始化Graph时，会添加一个Source节点和Sink节点。Source表示Graph的起始节点，Sink为终止节点。Source的id为0，Sink的id为1，其他节点id均大于1.

# 5 Graph运行时生命周期
Graph是TensorFlow的核心对象，TensorFlow的运行均是围绕Graph进行的。运行时Graph大致经过了以下阶段
图构建：client端用户将创建的节点注册到Graph中，一般不需要显示创建Graph，使用系统创建的默认的即可。
图发送：client通过session.run()执行运行时，将构建好的整图序列化为GraphDef后，传递给master
图剪枝：master先反序列化拿到Graph，然后根据session.run()传递的fetches和feeds列表，反向遍历全图full graph，实施剪枝，得到最小依赖子图。
图分裂：master将最小子图分裂为多个Graph Partition，并注册到多个worker上。一个worker对应一个Graph Partition。
图二次分裂：worker根据当前可用硬件资源，如CPU GPU，将Graph Partition按照op算子设备约束规范（例如tf.device(’/cpu:0’)，二次分裂到不同设备上。每个计算设备对应一个Graph Partition。
图运行：对于每一个计算设备，worker依照op在kernel中的实现，完成op的运算。设备间数据通信可以使用send/recv节点，而worker间通信，则使用GRPC或RDMA协议。
这些阶段根据TensorFlow运行时的不同，会进行不同的处理。运行时有两种，本地运行时和分布式运行时。故Graph生命周期到后面分析本地运行时和分布式运行时的时候，再详细讲解。
Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)

