
# 粒子群算法通识 - saltriver的专栏 - CSDN博客


2017年03月19日 09:59:04[saltriver](https://me.csdn.net/saltriver)阅读数：1565


粒子群算法（Particle swarm optimization，PSO）是模拟群体智能所建立起来的一种优化算法，主要用于解决最优化问题（optimization problems）。1995年由 Eberhart和Kennedy 提出，是基于对鸟群觅食行为的研究和模拟而来的。
假设一群鸟在觅食，在觅食范围内，只在一个地方有食物，所有鸟儿都看不到食物（即不知道食物的具体位置。当然不知道了，知道了就不用觅食了），但是能闻到食物的味道（即能知道食物距离自己是远是近。鸟的嗅觉是很灵敏的）。
![这里写图片描述](https://img-blog.csdn.net/20170319094933354?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2FsdHJpdmVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
假设鸟与鸟之间能共享信息（即互相知道每个鸟离食物多远。这个是人工假定，实际上鸟们肯定不会也不愿意），那么最好的策略就是结合自己离食物最近的位置和鸟群中其他鸟距离食物最近的位置这2个因素综合考虑找到最好的搜索位置。
粒子群算法与《[遗传算法](http://blog.csdn.net/saltriver/article/details/57584086)》等进化算法有很多相似之处。也需要初始化种群，计算适应度值，通过进化进行迭代等。但是与遗传算法不同，它没有交叉，变异等进化操作。与遗传算法比较，PSO的优势在于很容易编码，需要调整的参数也很少。
#### 一、基本概念
与遗传算法类似，PSO也有几个核心概念。
粒子（particle）：一只鸟。类似于遗传算法中的个体。
种群（population）：一群鸟。类似于遗传算法中的种群。
位置（position）：一个粒子（鸟）当前所在的位置。
经验（best）：一个粒子（鸟）自身曾经离食物最近的位置。
速度（velocity ）：一个粒子（鸟）飞行的速度。
适应度（fitness）：一个粒子（鸟）距离食物的远近。与遗传算法中的适应度类似。
#### 二、粒子群算法的过程
![这里写图片描述](https://img-blog.csdn.net/20170319095212317?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2FsdHJpdmVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
可以看出，粒子群算法的过程比遗传算法还要简单。
1）根据问题需要，随机生成粒子，粒子的数量可自行控制。
2）将粒子组成一个种群。这前2个过程一般合并在一起。
3）计算粒子适应度值。
4）更新种群中每个粒子的位置和速度。
5）满足退出条件就退出，不满足就转向步骤3）。
#### 三、核心—“速度更新”
从上面PSO的算法流程中可以看出，核心步骤是更新种群中每个粒子的位置和速度，而速度的更新又是核心中的核心。
下面直接给出速度更新公式：

$$
new\_v = w \bullet v + c1 \bullet rand() \bullet (pbest - position) + c2 \bullet rand() \bullet (gbest - position)
$$
v为粒子当前的速度，w为惯性因子（有速度就有运动惯性）。rand()为随机数生成函数，能够生成0-1之间的随机数。position为粒子当前的位置，pbest为本粒子历史上最好的位置，gbest为种群中所有粒子中当前最好的位置。c1和c2表示学习因子，分别向本粒子历史最好位置和种群中当前最好位置进行学习。
参数好像也有很多，需要设置的是3个，w，c1和c2，但实际上一般都设置c1=c2=1，w一般设在0.5左右。所以也没什么好设置的。
从物理原理上来解释这个速度更新公式，该公式由加号分割为3个部分：
**第一部分是惯性保持部分**，粒子沿着当前的速度和方向惯性飞行，不会偏移，直来直去。（牛顿运动学第一定理）。
**第二部分是自我认知部分**，粒子受到自身历史最好位置的吸引力，有回到自身历史最好位置的意愿。（牛顿运动学第二定理）。
**第三部分是社会认知部分**，粒子处在一个社会中（种群中），社会上有更好的粒子（成功人士），粒子受到成功人士的吸引力，有去社会中成功人士位置的意愿。（牛顿运动学第二定理）。
速度更新公式的意义就是粒子在自身惯性和2种外力作用下，速度和方向发生的改变。
注意这3部分都有重要含义。没有惯性部分，粒子们将很快向当前的自身最优位置和全局最优粒子位置靠拢，变成了一个局部算法了。有了惯性，不同粒子将有在空间中自由飞行的趋势，能够在整个搜索区域内寻找食物（最优解）。而没有自我认知部分，粒子们将向当前的全局最优粒子位置靠拢，容易陷入局部最优。没有社会认知部分，粒子们各自向自身最优位置靠拢，各自陷入自身最优，整个搜索过程都不收敛了。
最后，有了速度更新公式，位置更新就简单了：

$$
new\_position = position + new\_v \bullet t
$$
t一般默认取1。[这里写链接内容](http://blog.csdn.net/saltriver/article/details/57584086)

