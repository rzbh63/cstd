
# libuv学习笔记（3） - paohui0134的博客 - CSDN博客


2016年06月11日 17:10:53[paohui0134](https://me.csdn.net/paohui0134)阅读数：2169


# libuv学习笔记（3）
## uv_handle_t结构体以及相关函数
### 结构体定义
```python
typedef
```
```python
struct
```
```python
uv_handle_s uv_handle_t;
```
```python
struct
```
```python
uv_handle_s {
    UV_HANDLE_FIELDS
};
```
libuv将许多通用的数据结构定义为宏，这样类型之间的关系就很清晰，并且能够实现类似继承的关系。
UV_HANDLE_FIELDS宏定义如下(其他所有类型的handle都包含本宏，所以能够转换为uv_handle_t):
```python
#
```
```python
define
```
```python
UV_HANDLE_FIELDS
```
```python
/* 公有数据，指向用户自定义数据，libuv不使用该成员*/
```
```python
\
```
```python
void
```
```python
* data;                                                              \
```
```python
/* 只读数据 */
```
```python
\
   uv_loop_t* loop;
```
```python
//指向依赖的循环
```
```python
uv_handle_type type;
```
```python
//句柄类型                                      \
```
```python
/* 内部使用数据*/
```
```python
\
   uv_close_cb close_cb;
```
```python
//句柄关闭时的回调函数                             \
```
```python
void
```
```python
* handle_queue[
```
```python
2
```
```python
];
```
```python
//句柄队列指针，分别指向上一个和下一个             \
```
```python
union {                                                                  \
```
```python
int
```
```python
fd;                                                                \
```
```python
void
```
```python
* reserved[
```
```python
4
```
```python
];                                                     \
   } u;                                                                     \
   UV_HANDLE_PRIVATE_FIELDS
```
```python
//内部使用数据宏定义                          \
```
UV_HANDLE_PRIVATE_FIELDS宏定义如下：
```python
#
```
```python
define
```
```python
UV_HANDLE_PRIVATE_FIELDS                                         \
```
```python
uv_handle_t* endgame_next;
```
```python
//指向下一个需要关闭的handle                   \
```
```python
unsigned
```
```python
int
```
```python
flags;
```
```python
//状态标记，比如引用、关闭、正在关闭、激活等状态
```
### 相关函数
#### 判断handle是否是激活(active)状态 导出函数，在uv.h中定义，handle.c中实现
```python
int
```
```python
uv_is_active(
```
```python
const
```
```python
uv_handle_t*  handle)
{
```
```python
//handle是激活状态且非正在关闭状态
```
```python
return
```
```python
(handle->flags & UV_HANDLE_ACTIVE) &&
         !(handle->flags & UV_HANDLE_CLOSING);
}
```
#### 判断handle是否是关闭状态 导出函数，在uv.h中定义，handle.c中实现
```python
int
```
```python
uv_is_closing(
```
```python
const
```
```python
uv_handle_t* handle)
{
```
```python
//flags可以是UV__HANDLE_CLOSING或UV_HANDLE_CLOSED
```
```python
//双重否定将返回值强制转换为bool，然后转换为int
```
```python
return
```
```python
!!(handle->flags & (UV__HANDLE_CLOSING | UV_HANDLE_CLOSED));
}
```
#### 关闭handle，导出函数，在uv.h中声明，在handle.c中定义
```python
void
```
```python
uv_close(uv_handle_t
```
```python
*
```
```python
handle
```
```python
,  uv_close_cb  cb)
{
    uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
```
```python
//如果循环正在关闭，返回
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING)
    {
        assert(
```
```python
0
```
```python
);
```
```python
return
```
```python
;
    }
```
```python
Handle
```
```python
->
```
```python
close_cb
```
```python
=
```
```python
cb;
```
```python
//根据不同的handle类型(handle->type),调用对应的关闭处理,在之后具体的类型中具体分析
```
```python
...
```
```python
...
```
```python
}
```
#### 引用handle，导出函数，在uv.h中声明，在uv-common.c中定义
```python
void
```
```python
uv_ref(uv_handle_t
```
```python
*
```
```python
handle
```
```python
)
{
```
```python
//以下是uv__habdle_ref(handle)宏展开
```
```python
do
```
```python
{
```
```python
//如果已经是引用状态，返回
```
```python
if
```
```python
(((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_REF)
```
```python
!=
```
```python
0
```
```python
) break;
```
```python
//设为引用状态
```
```python
(
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV__HANDLE_REF;
```
```python
//正在关闭，直接返回
```
```python
if
```
```python
((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING)
```
```python
!=
```
```python
0
```
```python
) break;
```
```python
//激活状态下，将循环的active_handles加一
```
```python
if
```
```python
(((
```
```python
handle
```
```python
)
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_ACTIVE)
```
```python
!=
```
```python
0
```
```python
)
```
```python
//以下是uv__active_handle_add宏的展开
```
```python
do
```
```python
{
            (
```
```python
handle
```
```python
)
```
```python
->
```
```python
loop
```
```python
->
```
```python
active_handles
```
```python
++
```
```python
;
        }
```
```python
while
```
```python
(
```
```python
0
```
```python
)
    }
```
```python
while
```
```python
(
```
```python
0
```
```python
);
}
```
#### 取消handle引用,导出函数，在uv.h中声明，uv-common.c中定义
```python
void
```
```python
uv_unref(uv_handle_t* handle)
{
```
```python
//
```
```python
以下是uv__handle_unref(handle)宏的展开
```
```python
do
```
```python
{
```
```python
if
```
```python
(((handle)->flags & UV__HANDLE_REF) ==
```
```python
0
```
```python
)
```
```python
break
```
```python
;
        //去掉
```
```python
UV__HANDLE_REF
```
```python
标记
```
```python
(handle)
```
```python
->
```
```python
flags &= ~UV__HANDLE_REF;
```
```python
if
```
```python
(((handle)->flags & UV__HANDLE_CLOSONG) !=
```
```python
0
```
```python
)
```
```python
break
```
```python
;
```
```python
if
```
```python
(((handle)->flags & UV__HANDLE_ACTIVE) !=
```
```python
0
```
```python
)
```
```python
//以下是
```
```python
uv__active_handle_rm
```
```python
(h)
```
```python
宏的展开
```
```python
do
```
```python
{
```
```python
(handle)
```
```python
->
```
```python
loop
```
```python
->active_handles--;
        }
```
```python
while
```
```python
(
```
```python
0
```
```python
);
    }
```
```python
while
```
```python
(
```
```python
0
```
```python
)
}
```
#### 设置系统socket发送数据大小缓存,导出函数，在uv.h中声明，在uv-common.c中定义。只支持uv_tcp_t和uv_udp_t
```python
uv_send_buffer_size(uv_handle_t* handle,
```
```python
int
```
```python
*
```
```python
value
```
```python
)
{
```
```python
return
```
```python
uv__socket_sockopt(handle, SO_SNDBUF,
```
```python
value
```
```python
);
}
```
内部函数
```python
int
```
```python
uv__socket_sockopt(uv_handle_t* handle,
```
```python
int
```
```python
optname,
```
```python
int
```
```python
*
```
```python
value
```
```python
)
{
```
```python
int
```
```python
r;
```
```python
int
```
```python
len;
    SOCKET socket;
```
```python
if
```
```python
(handle ==
```
```python
null
```
```python
||
```
```python
value
```
```python
==
```
```python
null
```
```python
)
```
```python
return
```
```python
UV_EINVAL;
```
```python
//windows平台下只支持tcp或udphandle
```
```python
if
```
```python
(handle->type == UV_TCP)
        socket = ((uv_tcp_t*)handle)->socket;
```
```python
else
```
```python
if
```
```python
(handle->type == UV_UDP)
        socket = ((uv_udp_t*)handle)->socket;
```
```python
else
```
```python
return
```
```python
UV_ENOTSUP;
    len =
```
```python
sizeof
```
```python
(*
```
```python
value
```
```python
);
```
```python
//value指向的int为0，返回目前设置
```
```python
if
```
```python
(*
```
```python
value
```
```python
==
```
```python
0
```
```python
)
        r = getsocket(socket, SOL_SOCKET, optname, (
```
```python
char
```
```python
*)
```
```python
value
```
```python
, &len);
```
```python
//否则设置目前设置
```
```python
else
```
```python
r = setsocket(socket, SOL_SOCKET, optname, (
```
```python
const
```
```python
char
```
```python
*)
```
```python
value
```
```python
, len);
```
```python
if
```
```python
(r == SOCKET_ERROR)
```
```python
return
```
```python
uv_translate_sys_error(WSAGetLastError());
```
```python
return
```
```python
0
```
```python
;
}
```
以上函数为handle的一些通用的处理函数（最后一个设置发送缓存大小的函数除外），并没有涉及到具体的handle类型（比如uv_tcp_t）以及相关类型的事件处理，这些将在之后的学习中具体分析。

