
# 20160227.CCPP体系详解(0037天) - 尹成的技术博客 - CSDN博客

置顶2016年03月27日 16:44:12[尹成](https://me.csdn.net/yincheng01)阅读数：4396个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)


程序片段(01):01.一对一模式.c+02.中介者模式.c+03.广播模式.c
内容概要:**事件**
```python
///01.一对一模式.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.关于多线程:
```
```python
//  (临界区+互斥量):线程冲突
```
```python
//  (事件):线程通信
```
```python
//  (时间):同步线程
```
```python
HANDLE eventArrA[
```
```python
2
```
```python
] = {
```
```python
0
```
```python
};
HANDLE threadArrA[
```
```python
2
```
```python
] = {
```
```python
0
```
```python
};
DWORD WINAPI haiHua(
```
```python
void
```
```python
* p)
{
    printf(
```
```python
"海华第01次说:i love you fangFang, please help me debug! \n"
```
```python
);
```
```python
//信息通信内容
```
```python
Sleep(
```
```python
1000
```
```python
);
```
```python
//信息传递时间
```
```python
SetEvent(eventArrA[
```
```python
0
```
```python
]);
```
```python
//提示信息传到
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrA[
```
```python
1
```
```python
], INFINITE);
```
```python
//等待信息传到
```
```python
printf(
```
```python
"海华第%02d次说:i love you fangFang, please help me debug! \n"
```
```python
, i);
        Sleep(
```
```python
1000
```
```python
);
```
```python
//ResetEvent(eventArrA[1]);//重置信息提示(手动)
```
```python
SetEvent(eventArrA[
```
```python
0
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI fangFang(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrA[
```
```python
0
```
```python
], INFINITE);
        printf(
```
```python
"王芳第%02d次说:sorry! but i love you! \n"
```
```python
, i);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArrA[
```
```python
1
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//02.关于CreateEvent(arg1, arg2, arg3, arg4);
```
```python
//  arg1:安全属性集---->通常用NULL
```
```python
//  arg2:手动重置事件-->手动:TRUE|自动:FALSE
```
```python
//      注:使用一次事件通知,用TRUE,使用多次事件通知,用FALSE
```
```python
//      注:使用一次线程通信,通常用的是信号量机制,而不是事件机制
```
```python
//  arg3:事件激活状态-->通常用FALSE
```
```python
//  arg4:事件唯一名称-->自定义(便于检索指定事件)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    eventArrA[
```
```python
0
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    eventArrA[
```
```python
1
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    threadArrA[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, haiHua,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArrA[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, fangFang,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    WaitForMultipleObjects(
```
```python
2
```
```python
, threadArrA,
```
```python
TRUE
```
```python
, INFINITE);
```
```python
//维持多线程异步并发执行的状态
```
```python
system(
```
```python
""
```
```python
);
}
```
```python
//01.事件深入:
```
```python
//  1.事件用于线程通信
```
```python
//  2.事件的额外细节:三个案例
```
```python
//      双方通话---->三方通话---->一对多模式
```
```python
//      (相亲)            (媒婆)中介者     (广播)广播模式
```
```python
//02.了解一些问题:
```
```python
//  (临界区+互斥+原子变量):线程冲突
```
```python
//  事件:线程通信
```
```python
//  时间:同步线程
```
```python
//03.什么是死锁?
```
```python
//  编写事件的时候最容易遇到死锁的事情!
```
```python
//04.现在我们需要几个信号量,而且这个信号量我们用什么来进行描述?
```
```python
//  时间通知+信号量
```
```python
//05.顺序不严密:
```
```python
//  1.等待信号之后,信号需要复原才行,否则会出现不正常的情况(信号错乱!)
```
```python
//  2.信号不同步和乱序的解决方案-收到信号之后进行复位
```
```python
//      (1).信号复位情况--必须复位,某些情况之下自动复位,建议主动复位
```
```python
//      (2).围绕信号:的False&TRUE的分别
```
```python
//          第二个参数:密切相关-自动&手动[复位情况]
```
```python
///02.中介者模式.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
HANDLE threadArrB[
```
```python
3
```
```python
] = {
```
```python
0
```
```python
};
HANDLE eventArrB[
```
```python
4
```
```python
] = {
```
```python
0
```
```python
};
```
```python
char
```
```python
strB[
```
```python
256
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//线程通信内容
```
```python
//01.三方通话:中介者设计模式
```
```python
//  海华向中介者:发出事件通知0
```
```python
//      中介者等海华:等待事件通知0
```
```python
//  中介者向芳芳:发出事件通知1
```
```python
//      芳芳等中介者:等待事件通知1
```
```python
//  芳芳向中介者:发出事件通知2
```
```python
//      中介者等芳芳:等待事件通知2
```
```python
//  中介者向海华:发出事件通知3
```
```python
//      海华等中介者:等待事件通知3
```
```python
//  海华向中介者:发出事件通知0
```
```python
DWORD WINAPI haiHuaB(
```
```python
void
```
```python
* p)
{
    sprintf(strB,
```
```python
"海华第01次说:i love you fangFang, please help me debug! \n"
```
```python
);
```
```python
//发出通信内容
```
```python
Sleep(
```
```python
1000
```
```python
);
```
```python
//模拟通信时间
```
```python
SetEvent(eventArrB[
```
```python
0
```
```python
]);
```
```python
//提示通信到达
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrB[
```
```python
3
```
```python
], INFINITE);
        memset(strB,
```
```python
'\0'
```
```python
,
```
```python
256
```
```python
);
        sprintf(strB,
```
```python
"海华第%02d次说:i love you fangFang, please help me debug! \n"
```
```python
, i);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArrB[
```
```python
0
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI ruiFuB(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
int
```
```python
status =
```
```python
0
```
```python
;
```
```python
//切换通信对象
```
```python
while
```
```python
(++i)
    {
```
```python
if
```
```python
(!status)
        {
            WaitForSingleObject(eventArrB[
```
```python
0
```
```python
], INFINITE);
            printf(
```
```python
"媒婆传递海华通信内容(传递次数:%02d): \n"
```
```python
, i);
            printf(
```
```python
"\t%s \n"
```
```python
, strB);
            Sleep(
```
```python
1000
```
```python
);
            SetEvent(eventArrB[
```
```python
1
```
```python
]);
            status =
```
```python
1
```
```python
;
        }
```
```python
else
```
```python
{
            WaitForSingleObject(eventArrB[
```
```python
2
```
```python
], INFINITE);
            printf(
```
```python
"媒婆传递芳芳通信内容(传递次数:%02d): \n"
```
```python
, i);
            printf(
```
```python
"\t%s \n"
```
```python
, strB);
            Sleep(
```
```python
1000
```
```python
);
            SetEvent(eventArrB[
```
```python
3
```
```python
]);
            status =
```
```python
0
```
```python
;
        }
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI fangFangB(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrB[
```
```python
1
```
```python
], INFINITE);
        memset(strB,
```
```python
'\0'
```
```python
,
```
```python
256
```
```python
);
        sprintf(strB,
```
```python
"王芳第%02d次说:sorry! but i love you! \n"
```
```python
, i);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArrB[
```
```python
2
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    eventArrB[
```
```python
0
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
, L
```
```python
"haiHua"
```
```python
);
    eventArrB[
```
```python
1
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
, L
```
```python
"ruiFuToFang"
```
```python
);
    eventArrB[
```
```python
2
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
, L
```
```python
"fangFang"
```
```python
);
    eventArrB[
```
```python
3
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
, L
```
```python
"ruiFuToHua"
```
```python
);
    threadArrB[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, haiHuaB,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArrB[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, ruiFuB,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArrB[
```
```python
2
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, fangFangB,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    WaitForMultipleObjects(
```
```python
3
```
```python
, threadArrB,
```
```python
TRUE
```
```python
, INFINITE);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.中介者模式&广播模式&图论模式[多对多]
```
```python
//  中介者:三方
```
```python
//  广播:一对多
```
```python
//  图论:多对多
```
```python
//注:多线程这块儿必须要会树和图
```
```python
//02.一对多的情况下:
```
```python
//  既可以采用数组进行管理也可以采用链表进行管理
```
```python
//03.涉及到树的情况之下:
```
```python
//  QQ群聊天儿多线程,练就数据结构
```
```python
//04.一对多&多对多:
```
```python
//  群聊原理:中介者-->每个人进行转发
```
```python
//  中介者进行转发原理-->数组管理-->数组广播-->群聊模式
```
```python
//05.流程梳理:
```
```python
//  1.我发送一条消息,中介者收到之后,他进行群发动作
```
```python
//  2.中介者的衍生模式-->形成闭环-->选好起始点
```
```python
//06.编程思想:精髓
```
```python
//  原则上一个消息全局变量读取特点
```
```python
// 相当于是一个公告栏,权限读取
```
```python
//07.操作:
```
```python
//      定义全局变量,便于读取全局变量的数据
```
```python
///03.广播模式.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
HANDLE threadArrC[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
};
HANDLE eventArrC[
```
```python
1
```
```python
] = {
```
```python
0
```
```python
};
```
```python
char
```
```python
strC[
```
```python
256
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//线程通信内容
```
```python
char
```
```python
chrArr[
```
```python
10
```
```python
] = {
```
```python
'A'
```
```python
,
```
```python
'B'
```
```python
,
```
```python
'C'
```
```python
,
```
```python
'D'
```
```python
,
```
```python
'E'
```
```python
,
```
```python
'F'
```
```python
,
```
```python
'G'
```
```python
,
```
```python
'H'
```
```python
,
```
```python
'J'
```
```python
,
```
```python
'K'
```
```python
};
```
```python
//代表十个人
```
```python
//01.一个线程发出事件通知消息,多条线程监听该事件通知消息
```
```python
//  一对多的模式
```
```python
DWORD WINAPI haiHuaC(
```
```python
void
```
```python
* p)
{
```
```python
char
```
```python
* pChr = (
```
```python
char
```
```python
*)p;
    printf(
```
```python
"i am %c haiHua's gir friend! \n"
```
```python
, *pChr);
```
```python
if
```
```python
(
```
```python
'A'
```
```python
== *pChr)
    {
        MessageBox(
```
```python
0
```
```python
, TEXT(
```
```python
"1"
```
```python
), TEXT(
```
```python
"1"
```
```python
),
```
```python
0
```
```python
);
```
```python
//暂停通知线程
```
```python
sprintf(strC,
```
```python
"海华女友%c speak:xiaohuahua lovely! \n"
```
```python
, *pChr);
```
```python
//消息通知内容
```
```python
SetEvent(eventArrC[
```
```python
0
```
```python
]);
```
```python
//发出事件通知
```
```python
MessageBox(
```
```python
0
```
```python
, TEXT(
```
```python
"1"
```
```python
), TEXT(
```
```python
"1"
```
```python
),
```
```python
0
```
```python
);
```
```python
//暂停通知线程
```
```python
sprintf(strC,
```
```python
"海华女友%c speak:xiaohuahua lovely! \n"
```
```python
, *pChr);
```
```python
//消息通知内容
```
```python
SetEvent(eventArrC[
```
```python
0
```
```python
]);
```
```python
//发出事件通知
```
```python
}
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrC[
```
```python
0
```
```python
], INFINITE);
```
```python
//等待事件通知
```
```python
printf(
```
```python
"haiHua's girl friend %c read %s! \n"
```
```python
, pChr, strC);
        Sleep(
```
```python
1000
```
```python
);
        ResetEvent(eventArrC[
```
```python
0
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
    eventArrC[
```
```python
0
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        threadArrC[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, haiHuaC, &chrArr[i],
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    }
    WaitForMultipleObjects(
```
```python
10
```
```python
, threadArrC,
```
```python
TRUE
```
```python
, INFINITE);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.中介者设计模式之广播模式:QQ群聊原理
```
```python
//  群聊-->数组-->链表-->环状-->局域网:环状结构[网络可靠性]
```
```python
//02.QQ的开发:不仅有发送和收取消息-->所以线程非常多
```
```python
//  信号对称-->需要进行手动进行事件的设置
```
```python
//      一对一:自动
```
```python
//      中介者:自动
```
```python
//      一对多:手动
```
```python
//      多对多:手动
```
程序片段(02):01.Semaphore.c+02.SemaphoreNew.c
内容概要:**信号量**
```python
///01.Semaphore.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.信号量:
```
```python
//  1.类似于空位的特点:
```
```python
//  2.空置多少个位置就可以容纳多少个并行线程执行
```
```python
//注:当空余的位置为0的时候,也就不能在另起线程执行任务了
```
```python
#define id L"haiHua"
```
```python
//信号ID
```
```python
#define MAX 3
```
```python
//空位数
```
```python
//02.多线程信号量(semaphore)通信:
```
```python
//  1.特点:打开一个信号量(等同于检索一个指定ID名称的信号量)
```
```python
//  2.格式:HANDLE mySema = OpenSemaphore(arg1, arg2, arg3);
```
```python
//      arg1:信号量检索范围(SEMAPHORE_ALL_ACCESS)
```
```python
//      arg2:继承特性
```
```python
//      arg3:信号量检索名称(自定义名称,在固定范围内唯一标识信号量)
```
```python
//  3.刚打开信号量的时候:
```
```python
//      信号量的空位为0,也就是无法开启新的异步线程执行任务
```
```python
//      信号量的空位为N,也就是说此刻可以开启N条异步线程执行任务代码
```
```python
//注:空位为N,表示除开当前线程之外可以另起的异步线程个数
```
```python
DWORD WINAPI myWorker(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
* pInt = (
```
```python
int
```
```python
*)p;
```
```python
printf
```
```python
(
```
```python
"worker:%d si running! \n"
```
```python
, *pInt);
    HANDLE mySema = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, id);
```
```python
//指定范围检索指定名称的信号量
```
```python
if
```
```python
(mySema)
```
```python
//判断信号量是否存在
```
```python
{
```
```python
printf
```
```python
(
```
```python
"worker:%d is waiting! \n"
```
```python
, *pInt);
```
```python
//表示当前线程处于判定信号量状态
```
```python
Sleep(
```
```python
1000
```
```python
);
```
```python
if
```
```python
(WaitForSingleObject(mySema, INFINITE) == WAIT_OBJECT_0)
```
```python
//等待空位为0
```
```python
{
```
```python
//如果信号空位为0,也就是无法开启异步线程的情况
```
```python
printf
```
```python
(
```
```python
"worker:%d is getting! \n"
```
```python
, *pInt);
```
```python
//此时只有当前线程获得CPU执行权,其它线程无法获取CPU可执行权
```
```python
Sleep(
```
```python
3000
```
```python
);
```
```python
printf
```
```python
(
```
```python
"worker:%d is leaving! \n"
```
```python
, *pInt);
            ReleaseSemaphore(mySema,
```
```python
1
```
```python
, NULL);
```
```python
//释放信号:只是打开一个空位,也就是可以开启另外一条异步线程进行执行了
```
```python
CloseHandle(mySema);
```
```python
//释放资源信号量资源
```
```python
}
    }
```
```python
return
```
```python
1
```
```python
;
}
```
```python
//03.创建信号量:
```
```python
//  1.特点:初始化信号量对象
```
```python
//  2.格式:HANDLE mySema = CreateSemaphore(arg1, arg2, arg3, arg4);
```
```python
//      arg1:安全属性集
```
```python
//      arg2:初始空位数
```
```python
//      arg3:最大空位数
```
```python
//      arg4:信号量名称
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    HANDLE mySema = CreateSemaphore(NULL,
```
```python
0
```
```python
, MAX, id);
    HANDLE threadArr[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
//由于当前信号量为0,因此多条执行同一段儿代码的时候,需要判定能否通过
```
```python
threadArr[i] = CreateThread(NULL,
```
```python
0
```
```python
, myWorker, threadArr + i,
```
```python
0
```
```python
, NULL);
    }
    Sleep(
```
```python
5000
```
```python
);
```
```python
printf
```
```python
(
```
```python
"激活状态! \n"
```
```python
);
    ReleaseSemaphore(mySema, MAX, NULL);
```
```python
//释放信号量
```
```python
WaitForMultipleObjects(
```
```python
10
```
```python
, threadArr, TRUE, INFINITE);
    CloseHandle(mySema);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.信号量:Semaphore
```
```python
//  1.量值:0-1-2-3
```
```python
//  2.使用一次进行一次减数,到了一定的数据之后,做一些指定操作
```
```python
//      当数据减到至0的时候,信号为0,在使用信号量的地方,处于停滞状态
```
```python
//  3.信号量还可以做一些其他的限定操作
```
```python
//  4.线程通信:用途
```
```python
//  5.具备等待机制
```
```python
//02.信号计数原理:
```
```python
//  1.两个按键入口,多个行李
```
```python
//  2.信号衰减原理:空位原理
```
```python
//      信号为0的时候,没有空位为0,通过判断信号的空位情况,决定是否让线程干活儿
```
```python
//      等待唤醒机制0与非0的区别(非0,线程可执行,0线程不可执行)
```
```python
//03.关卡原理:
```
```python
//  1.同时最多支持10000个人购票
```
```python
//  2.如果超过10000个人,就需要排队
```
```python
//  3.当10000个人购票完毕的时候,重新开启线程执行任务
```
```python
//04.原理:if 0 等下去
```
```python
//  1.同一个信号量
```
```python
//  2.10个线程
```
```python
//  3.状态判定:
```
```python
//      0-->10个等待
```
```python
//      5-->5个等待,5个执行
```
```python
//          执行一次,减去一次-->信号量衰减
```
```python
//  4.所有的线程都能够读取到该信号量
```
```python
//      多个线程占用资源:等待执行状态
```
```python
//      用完与没有用完(线程不可执行状态与线程可执行状态)
```
```python
//05.信号量完全解析:
```
```python
//  步骤一:
```
```python
//      HANDLE hSEM=CreateSemaphore(NULL,0,MAX,id);
```
```python
//      创建一个信号量,信号量的最大值为MAX,如果等于0的情况之下,它就在这儿死等下去
```
```python
//  步骤二:
```
```python
//      ReleaseSemaphore(mySema,MAX,NULL);//释放信号量,补充空位数量
```
```python
//      一旦将信号量设定为5就会开始进行执行
```
```python
//06.什么样儿的情况之下我们使用信号量?
```
```python
//      实现两个线程的死锁状态,设定为1这个信号量,进或者不进
```
```python
///02.SemaphoreNew.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
//01.信号量的应用:
```
```python
//  1.排队执行机制
```
```python
//      让多个线程处于执行状态,让多个线程处于休眠状态
```
```python
//  2.实现线程互斥
```
```python
//      让一个线程处于执行状态,让其它所有线程处于等待状态
```
```python
DWORD WINAPI add(
```
```python
void
```
```python
* p)
{
    HANDLE mySema = OpenSemaphore(SEMAPHORE_ALL_ACCESS,
```
```python
FALSE
```
```python
, L
```
```python
"xiaobin"
```
```python
);
```
```python
//打开信号量:
```
```python
if
```
```python
(mySema)
    {
```
```python
if
```
```python
(WAIT_OBJECT_0 == WaitForSingleObject(mySema, INFINITE))
        {
```
```python
//判断信号强弱(判断信号量的数目,也就是判断空位数目)
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10000
```
```python
; ++i)
            {
                ++num;
            }
            ReleaseSemaphore(mySema,
```
```python
1
```
```python
,
```
```python
NULL
```
```python
);
            CloseHandle(mySema);
        }
    }
```
```python
else
```
```python
{
        printf(
```
```python
"打开信号量失败! \n"
```
```python
);
    }
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//01.实现线程互斥的关键代码:
```
```python
//  最多只能有一个空位(最多只能同时有一条线程处于执行状态)
```
```python
HANDLE mySema = CreateSemaphore(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
, L
```
```python
"xiaobin"
```
```python
);
    HANDLE threadArr[
```
```python
64
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
64
```
```python
; ++i)
    {
        threadArr[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, add,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    }
    printf(
```
```python
"激活线程"
```
```python
);
    ReleaseSemaphore(mySema,
```
```python
1
```
```python
,
```
```python
NULL
```
```python
);
    WaitForMultipleObjects(
```
```python
64
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    printf(
```
```python
"num = %d \n"
```
```python
, num);
    CloseHandle(mySema);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.信号量可以实现多个线程的卡顿现象
```
```python
//02.信号量的空位原理-->0和1的原理:互斥特点
```
```python
//  入职与离职原理的特点-->空位原理
```
```python
//03.如何使用信号量实现一个全局变量的自增?
```
```python
//  互斥类型的方式实现-->使用信号量实现线程之间的互斥现象
```
```python
//04.随机数的求取方法:
```
```python
//  1.原始函数
```
```python
//  2.多线程的数据丢失
```
```python
//05.多线程处理状态下的CPU是不会稳定的情况
```
```python
//06.信号量:0代表没有空位-->线程等待状况
```
```python
//  控制访问次数
```
```python
//07.互斥量与信号量的区别:
```
```python
//  互斥量:只能让一个线程处于运行状态
```
```python
//  信号量:可以让多个线程处于运行状态,其他线程休眠
```
```python
//  临界区:只能让一个线程处于运行状态
```
```python
//  时间同步:
```
```python
//  事件:也可以实现让多个线程处于运行状态,其他线程休眠状态
```
```python
//  原子操作:操作速度最快,因为它不需要等待操作线程,几乎直接运行状态
```
```python
//注:原子量的速度快在于无需让多条线程处于等待执行状态,其他线程互斥的方式
```
```python
//      存在着线程等待执行的状态
```
程序片段(03):01.互斥.c+02.互斥读写.c
内容概要:**互斥锁**
```python
///01.互斥.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
int
```
```python
static
```
```python
num =
```
```python
6400000
```
```python
;
```
```python
//01.全局写入锁
```
```python
//  当一个线程在进行指定变量的写入操作的时候;
```
```python
//  其它线程若是需要写入这个指定变量数据,那么
```
```python
//  其他线程只能处于等待执行写入数据的状态
```
```python
SRWLOCK gw_lock = {
```
```python
0
```
```python
};
```
```python
static
```
```python
DWORD WINAPI write(
```
```python
void
```
```python
* p)
{
```
```python
//多线程写入状态下,同一时刻只能由一条线程执行写入状态!
```
```python
AcquireSRWLockExclusive(&gw_lock);
```
```python
//获得独立写入锁(进入锁定状态)
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100000
```
```python
; ++i)
    {
        --num;
    }
    ReleaseSRWLockExclusive(&gw_lock);
```
```python
//释放独立写入锁(释放锁定状态)
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    InitializeSRWLock(&gw_lock);
    HANDLE threadArr[
```
```python
64
```
```python
];
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
64
```
```python
; ++i)
    {
        threadArr[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, write,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    }
```
```python
//num += 10000;//没有生效,说明互斥锁的原则是全局生效,是对所有线程生效!
```
```python
WaitForMultipleObjects(
```
```python
64
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    printf(
```
```python
"num = %d \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.互斥锁的概念:互斥
```
```python
//  如同交往一个女友之后就被锁定了
```
```python
//02.互斥锁问题:
```
```python
//  线程互斥:同一时刻,只能由同一个线程执行数据操作
```
```python
//03.线程的互斥实现方式:
```
```python
//  临界区-->互斥量-->原子操作-->事件-->信号量-->互斥锁
```
```python
//04.互斥锁的创建流程:
```
```python
//  全局变量:定义互斥量
```
```python
//      SRWLOCK g_lock;
```
```python
//  Main函数:初始化互斥量
```
```python
//      InitializeSRWLock(&g_lock);
```
```python
//  数据锁定:写入和读取的锁定
```
```python
//  线程函数:
```
```python
//      AcquireSRWLockExclusive(&g_lock);//锁定写入
```
```python
//      ReleaseSRWLockExclusive(&g_lock);//锁定释放
```
```python
//05.互斥锁的使用场景:
```
```python
//  1.改变一个变量的时候需要锁定(防止同时读取,同时写入)
```
```python
//  2.读取一个变量的时候也需要锁定(防止同时写入,同时读取)
```
```python
///02.互斥读写.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
int
```
```python
num =
```
```python
6400000
```
```python
;
```
```python
//待读写的数据
```
```python
SRWLOCK g_lock = {
```
```python
0
```
```python
};
```
```python
//写入锁
```
```python
DWORD WINAPI write(
```
```python
void
```
```python
* p)
{
```
```python
printf
```
```python
(
```
```python
"开始写入! \n"
```
```python
);
    AcquireSRWLockExclusive(&g_lock);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100000
```
```python
; ++i)
    {
        --num;
```
```python
//Sleep(10);
```
```python
}
    ReleaseSRWLockExclusive(&g_lock);
```
```python
printf
```
```python
(
```
```python
"结束写入! \n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI read(
```
```python
void
```
```python
* p)
{
```
```python
printf
```
```python
(
```
```python
"读取状态! \n"
```
```python
);
    AcquireSRWLockShared(&g_lock);
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
        ++i;
        Sleep(
```
```python
1000
```
```python
);
```
```python
printf
```
```python
(
```
```python
"第%d秒, num = %d \n"
```
```python
, i, num);
```
```python
//由于写入状态锁定了,因此这里的读取状态,无法读取到数据
```
```python
if
```
```python
(
```
```python
20
```
```python
== i)
```
```python
break
```
```python
;
    }
    ReleaseSRWLockShared(&g_lock);
```
```python
printf
```
```python
(
```
```python
"读取结束! \n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    InitializeSRWLock(&g_lock);
    CreateThread(NULL,
```
```python
0
```
```python
, read, NULL,
```
```python
0
```
```python
, NULL);
    HANDLE threadArr[
```
```python
64
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
64
```
```python
; ++i)
    {
        threadArr[i] = CreateThread(NULL,
```
```python
0
```
```python
, write, NULL,
```
```python
0
```
```python
, NULL);
    }
    WaitForMultipleObjects(
```
```python
64
```
```python
, threadArr, TRUE, INFINITE);
```
```python
printf
```
```python
(
```
```python
"num = %d \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.互斥锁的读写状态控制
```
```python
//  写入的状态下不可读取,读取的状态下不可写入
```
```python
//02.锁定状态,读取完成之后才进行锁定
```
```python
//03.一个资源只能锁定一次,不能锁定多次
```
```python
//04.锁定-->防止冲突问题-->读取和写入的状态
```
```python
//  防止同时写入和读取数据
```
程序片段(04):Mutex.c
内容概要:**01.跨进程Mutex(发互斥)**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
char
```
```python
name[
```
```python
100
```
```python
] =
```
```python
"haihualovefang"
```
```python
;
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
//01.创建互斥量"Mutex":
```
```python
//  位于内核层|Ring0层
```
```python
HANDLE myMutex = CreateMutexA(NULL, TRUE, name);
```
```python
printf
```
```python
(
```
```python
"在内核层|Ring0层创建互斥量(Mutex)成功! \n"
```
```python
);
```
```python
char
```
```python
chr = getch();
```
```python
//实时获取单个字符
```
```python
//02.释放互斥量:
```
```python
//  相当于发出通知
```
```python
ReleaseMutex(myMutex);
```
```python
//03.关闭互斥量:
```
```python
CloseHandle(myMutex);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.关于跨进程的驱动访问:内核对象
```
```python
//  无论是Windows还是Linux都是存在互斥量说法
```
```python
//02.如果是跨进程的话:
```
```python
//  创建跨进程的Mutext需要有名称(便于全局访问)
```
```python
//03.编写网络程序的时候:
```
```python
//  既需要编写客户端也需要编写网络端
```
```python
//  -->编写两个程序的时代
```
```python
//04.演示的时候需要:
```
```python
//  进行编译好的程序之间的演示
```
```python
//05.跨进程通信:
```
```python
//  1.Event&Mutex&semaphore都可以实现跨进程的线程通信
```
```python
//  2.Mutex是最安全的跨进程线程访问(因为能够处理发送通知方的断开情况)
```
```python
//      发出通信信息的进程退出情况能够处理!
```
程序片段(05):Mutex.c
内容概要:**02.跨进程Mutex(收互斥)**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
char
```
```python
name[
```
```python
100
```
```python
] =
```
```python
"haihualovefang"
```
```python
;
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
//01.打开互斥量:
```
```python
//  作用:获取互斥量
```
```python
//  格式:HANDLE mutex = OpenMutexA(arg1, arg2, arg3);
```
```python
//      mutex:互斥量+arg1:检索范围+arg2:继承句柄+互斥量名称
```
```python
HANDLE myMutex = OpenMutexA(MUTEX_ALL_ACCESS, TRUE, name);
```
```python
//获取互斥量
```
```python
//if (NULL == myMutex)//判定互斥量
```
```python
//{
```
```python
//  printf("获取互斥量失败! \n");
```
```python
//  system("pause");
```
```python
//  return;
```
```python
//}
```
```python
printf
```
```python
(
```
```python
"等待状态! \n"
```
```python
);
```
```python
//02.控制互斥量的等待时间:
```
```python
//  先获得互斥量-->设定等待状态时间(等待指定的时间范围!)
```
```python
DWORD res = WaitForSingleObject(myMutex,
```
```python
10000
```
```python
);
```
```python
//设置等待状态
```
```python
switch
```
```python
(res)
    {
```
```python
case
```
```python
WAIT_OBJECT_0:
```
```python
printf
```
```python
(
```
```python
"收到跨进程信号! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
WAIT_TIMEOUT:
```
```python
printf
```
```python
(
```
```python
"等待跨进程信号超时! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
WAIT_ABANDONED:
```
```python
printf
```
```python
(
```
```python
"另外一个进程发生终止!结束跨进程信号等待状态! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
break
```
```python
;
    }
    CloseHandle(myMutex);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.刚才的程序特点:
```
```python
//  都是出于同一个进程内的线程操作(同一进程)
```
```python
//02.C++关于"事件"和"信号量"的封装:
```
```python
//  封装通用的一个机制,Cocos2dx的时候都是一样的情况
```
```python
//  包含OC也一样,只不过它们将接口内容进行了简化
```
```python
//03.多线程的强化:
```
```python
//  1.event&mutex&semaphore:(驱动层|Ring0层)
```
```python
//      本质:是处于驱动里面的一个综合信号量
```
```python
//  2.操作系统起到什么作用?
```
```python
//      (1).操作系统类似于一个巨大的进程,里面运行的每个程序类似于线程
```
```python
//          (类比:大进程&进程)<--->(进程&线程)
```
```python
//      (2).电脑重启,打开多个.exe都需要重启
```
```python
//      (3).操作系统和应用程序之间的关系就如同进程和线程之间的关系
```
```python
//      (4).高级机制:内核对象(Ring0层对象)
```
```python
//04.操作系统的高级机制:内核对象-->项目使用-->跨进程使用
```
```python
//  1.操作系统的分层机制:
```
```python
//      (1).ring0:就是最底层,这里可以用于编写驱动(出错:蓝屏)
```
```python
//      (2).ring3:就是应用层,(出错:进程出错)
```
```python
//  2.线程互斥区分机制:
```
```python
//      (1).event&mutex:
```
```python
//          这里创建的指针处于应用层,但是指针所指向的内存处于ring0层
```
```python
//              ring0层当中的对象可以看到所有进程的内存(最高访问权限)
```
```python
//      (2).进程之间不可以进行相互读写,必须通过注射方式
```
```python
//      (3).event&mutex都是出于ring0层的内核对象
```
```python
//          本质:对象的底层特点
```
```python
//          所以:它们不仅可以用于一个进程内的线程互斥,还可以用于多个进程之间的线程互斥
```
```python
//05.mutex的互斥问题解析:
```
```python
//  1.跨进程的mutex互斥问题
```
```python
//  2.C++的线程库都是对C语言多线程的封装
```
```python
//          大概原理-->C++的类使用
```
```python
//06.关于跨进程通信的问题:
```
```python
//  最好使用互斥量(mutex)实现跨进程通信
```
```python
//  原因:其他方式(event&semaphore)不能处理进程断开的情况!
```
程序片段(06):发事件.c
内容概要:**01.跨进程Event(发事件)**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
char
```
```python
name[
```
```python
100
```
```python
] =
```
```python
"haihualovefang"
```
```python
;
```
```python
//01.Event实现跨进程通信:
```
```python
//  1.这儿的Event不是线程级别的含义,而是进程级别的含义:
```
```python
//      该Event实质上是位于(内核|Ring0层),因此可以实现跨进程通信
```
```python
//  2.参数说明:第二个参数表示是否重置手动重置事件状态
```
```python
//      TRUE:手动重置+FALSE:自动重置
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
    HANDLE myEvent = CreateEventA(NULL, FALSE, FALSE, name);
```
```python
//创建事件
```
```python
printf
```
```python
(
```
```python
"跨进程Event创建成功! \n"
```
```python
);
```
```python
char
```
```python
chr = getch();
    SetEvent(myEvent);
```
```python
//设置事件
```
```python
printf
```
```python
(
```
```python
"发送跨进程Event事件! \n"
```
```python
);
    CloseHandle(myEvent);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.严格区分跨线程和跨进程
```
```python
//02.使用Event实现跨进程线程访问
```
```python
//03.Event和Mutex有一定的区别:
```
```python
//  Event跨进程不能使用匿名的,否则的话找不到
```
```python
//注:跨进程一定要采用唯一名称标识信号
```
```python
//04.TCP/UDP的时候就是如此复杂的情况
```
```python
//05.一般进程与进程之间都需要设定一个超时等待时间
```
```python
//06.Event天生的缺陷:
```
```python
//  只有Mutex可以感知到另外一个进程的丢失
```
```python
//  Event不具备感知进程丢失的功能
```
```python
//注:进程通信情况之下的进程丢失情况分析!
```
程序片段(07):收事件.c
内容概要:**02.跨进程Event(收事件)**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
char
```
```python
name[
```
```python
100
```
```python
] =
```
```python
"haihualovefang"
```
```python
;
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
//01.打开事件:
```
```python
//  获取跨进程所创建的事件
```
```python
HANDLE myEvent = OpenEventA(EVENT_ALL_ACCESS, TRUE, name);
```
```python
//获取事件
```
```python
if
```
```python
(NULL == myEvent)
    {
```
```python
printf
```
```python
(
```
```python
"跨进程Event获取失败! \n"
```
```python
);
        system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
;
    }
```
```python
printf
```
```python
(
```
```python
"跨进程Event等待状态! \n"
```
```python
);
    DWORD res = WaitForSingleObject(myEvent,
```
```python
10000
```
```python
);
```
```python
switch
```
```python
(res)
    {
```
```python
case
```
```python
WAIT_OBJECT_0:
```
```python
printf
```
```python
(
```
```python
"跨进程Event收到状态! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
WAIT_TIMEOUT:
```
```python
printf
```
```python
(
```
```python
"跨进程Event超时状态! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
WAIT_ABANDONED:
```
```python
printf
```
```python
(
```
```python
"另外一个进程已经中止! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
break
```
```python
;
    }
    CloseHandle(myEvent);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(08):发信号.c
内容概要:**01.跨进程Semaphore(发信号)**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
char
```
```python
name[
```
```python
100
```
```python
] =
```
```python
"haihualovefang"
```
```python
;
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{   
    HANDLE mySema = CreateSemaphoreA(NULL,
```
```python
0
```
```python
,
```
```python
1
```
```python
, name);
```
```python
printf
```
```python
(
```
```python
"跨进程Semaphore信号量创建成功! \n"
```
```python
);
```
```python
char
```
```python
chr = getch();
    ReleaseSemaphore(mySema,
```
```python
1
```
```python
, NULL);
```
```python
printf
```
```python
(
```
```python
"跨进程Semaphore发出信号! \n"
```
```python
);
    CloseHandle(mySema);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.当一条线程做完一件事情之后,需要通知其他线程的时候:
```
```python
//  这个时候就需要进行线程之间的通信
```
```python
//注:区分线程通信与进程通信
```
```python
//02.大数据你就得将图论和树结构玩儿的相当好才行
```
```python
//  图和树就是用于管理这么多的线程的
```
```python
//03.线程与线程之间的关系是很复杂的:
```
```python
//  需要掌握逻辑&排序&容错&模糊
```
```python
//04.跨进程的线程通信:
```
```python
//  Event&Mutex&Semaphore
```
```python
//05.使用跨进程通信的时候:
```
```python
//  1.最佳解决方案就是Mutex
```
```python
//  2.缺点比较:
```
```python
//      Event&Semaphore:发信信号的进程关闭之后无法感知到!
```
```python
//      Mutex:发送信号的进程关闭之后能够被感知到!
```
程序片段(09):收信号.c
内容概要:**02.跨进程Semaphore(收信号)**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
char
```
```python
name[
```
```python
100
```
```python
] =
```
```python
"haihualovefang"
```
```python
;
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
    HANDLE mySema = OpenSemaphoreA(SEMAPHORE_ALL_ACCESS, TRUE, name);
```
```python
if
```
```python
(NULL == mySema)
    {
```
```python
printf
```
```python
(
```
```python
"跨进程Semaphore创建失败! \n"
```
```python
);
        system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
;
    }
```
```python
printf
```
```python
(
```
```python
"跨进程Semaphore等待状态! \n"
```
```python
);
    DWORD res = WaitForSingleObject(mySema,
```
```python
10000
```
```python
);
```
```python
switch
```
```python
(res)
    {
```
```python
case
```
```python
WAIT_OBJECT_0:
```
```python
printf
```
```python
(
```
```python
"跨进程Semaphore通信收到! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
WAIT_TIMEOUT:
```
```python
printf
```
```python
(
```
```python
"跨进程Semaphore通信超时! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
WAIT_ABANDONED:
```
```python
printf
```
```python
(
```
```python
"另外一个进程已经中止! \n"
```
```python
);
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
break
```
```python
;
    }
    CloseHandle(mySema);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(10):TimePrc.c
内容概要:**时间同步**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.时间同步:标准回调函数格式
```
```python
//  1.小写"void"和大写"VOID"实质一样-->在这儿只是回调函数的规范
```
```python
//  2.参数:普通指针+时间1[低点]+时间2[高点]-->相当于时差
```
```python
//  3.创建一个回调函数格式的函数指针常量
```
```python
//  4.回调函数:CALLBACK的标识定义(标准定义)
```
```python
VOID CALLBACK timeRun(
```
```python
void
```
```python
* pArg, DWORD timeLow, DWORD timeHigh)
{
    DWORD dwindex = *(DWORD *)pArg;
```
```python
printf
```
```python
(
```
```python
"第%d次! \n"
```
```python
, dwindex);
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"1"
```
```python
,
```
```python
"2"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
//02.Win操作系统之下使用系统自带的定时器资源:
```
```python
//  1.创建定时器:有几个函数-->起到等待作用的定时器
```
```python
//  2.参数:arg1,arg2,arg3-->arg3是定时器的名称
```
```python
//  3.匿名定时器只能有一个,携带名称的定时器可以有多个!
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
    HANDLE time1 = CreateWaitableTimerA(NULL, TRUE,
```
```python
"haihua"
```
```python
);
```
```python
if
```
```python
(NULL == time1)
    {
```
```python
printf
```
```python
(
```
```python
"定时器创建失败! \n"
```
```python
);
    }
```
```python
//设置定时器特点
```
```python
LARGE_INTEGER myTime;
    myTime.QuadPart = -
```
```python
50000000
```
```python
;
```
```python
//单位:0.1微妙--万分之一毫秒
```
```python
//SetWaitTimer:定义解释
```
```python
//  _In_ HANDLE hTimer;定时器
```
```python
//  _In_ const LARGE_INTEGER * 1pDueTime;//时间
```
```python
//  _In_ LONG 1Period;//循环次数
```
```python
//  _In_opt_ PTIMERAPCROUTINE pfnCompletionRoutine;//函数指针
```
```python
//  _In_opt_ LPVOID 1pArgToCompletionRoutline;//参数
```
```python
//  _In_ BOOL fResume;//始终恢复状态
```
```python
//设置等待的定时器(等待定时器)
```
```python
DWORD dwparam =
```
```python
1
```
```python
;
```
```python
//1000说明1000毫秒-->1分钟干一次,回调间隔
```
```python
if
```
```python
(SetWaitableTimer(time1, &myTime,
```
```python
1000
```
```python
, timeRun, &dwparam, FALSE))
    {
```
```python
//五秒钟之后触发该事件:1|0
```
```python
printf
```
```python
(
```
```python
"等待5秒之后开始干活儿! \n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
15
```
```python
; ++i, ++dwparam)
        {
```
```python
//执行次数-->循环多少次,就回调多少次
```
```python
SleepEx(INFINITE, TRUE);
        }
    }
```
```python
//循环完毕之后所需执行的操作:
```
```python
//  取消定时器和关闭句柄资源
```
```python
CancelWaitableTimer(time1);
    CloseHandle(time1);
```
```python
if
```
```python
(WAIT_OBJECT_0 == WaitForSingleObject(time1, INFINITE))
    {
```
```python
//等待消息成功
```
```python
printf
```
```python
(
```
```python
"wait ok! \n"
```
```python
);
    }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"wait no! \n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.多线程与队列:
```
```python
//  实现文件加密
```
```python
//02.关于"时间定时器"的一些操作:
```
```python
//  简单定时器-->允许回调函数
```
```python
//03.时间同步问题:
```
```python
//  1.主要用于解决多个线程的时间问题[多线程]
```
```python
//  2.围绕时间定时器,每隔一段事件干一定的活儿
```
```python
//  3.满足一定的时间条件,然后解决一定的问题
```
```python
//04.回调函数与时间的概念:
```
```python
//  1.触发函数的动作-->回调动作
```
```python
//  2.执行完一段代码之后,执行某一个函数
```
```python
//05.回调函数原理:
```
```python
//  1.数据1,2-->根据符号进行运算
```
```python
//  2.整体函数[参数1+参数2+函数指针]
```
```python
//  3.定时器触发一个函数的执行
```
```python
//  4.多个线程在同一时间要干某些事件
```
```python
//06.同一个事件通知多个事件的执行
```
```python
//07.回调函数:Callback
```
```python
//  1.函数指针,可以进行调用-->实现任何代码都可以进行自定义
```
```python
//  2.整合功能:自定义功能以及它定义功能
```
```python
//08.函数指针:新的功能-->函数指针-->功能随时更换
```
```python
//  1.百度搜索原理
```
```python
//  2.百度后台的搜索算法的改变
```
```python
//  3.用户调用的时候会根据函数指针的区别[付钱状态,区域]
```
```python
//09.创建多个定时器需要根据名称进行区分
```
```python
//10.定时器的使用步骤:
```
```python
//  1.创建定时器:
```
```python
//      HANDLE time1=CreateWaitableTimerA(NULL,TRUE,"haihua");
```
```python
//  2.五秒钟之后启动定时器:
```
```python
//      LARGE_INTEGER mytime;
```
```python
//      mytime.QuadPart=-50000000;
```
```python
//  3.定时器回调函数:
```
```python
//      if(SetWaitableTimer(time1,&mytime,3000,timerun,&dwparam,FALSE)){}
```
```python
//      回调周期:3000毫秒之后循环一次-->循环多少次
```
```python
//11.时间同步:主要用于游戏的开发
```
```python
//  内核对象:游戏开发-->为了时间而单独编写一条线程不划算
```
```python
//  CreateWaitableTimerA();-->内核对象
```
```python
//  SetWaitableTimer();-->内核对象
```
```python
//  内核对象-->多个时钟都有一个名称-->我就可以让多个线程同时读取一个时钟,进行操作,避免耗费资源
```
程序片段(11):`volatile.c`
内容概要:**Volatile**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <limits.h>
```
```python
void
```
```python
main01()
{
```
```python
for
```
```python
(
```
```python
volatile
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < INT_MAX; i++)
    {
```
```python
//(1)区分Debug模式和Release[+]模式
```
```python
//(2)优化:强制读取内存
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
main02()
{
```
```python
volatile
```
```python
int
```
```python
i =
```
```python
10
```
```python
;
```
```python
int
```
```python
a = i;
```
```python
printf
```
```python
(
```
```python
"\ni=%d"
```
```python
, a);
```
```python
//{偷偷改变i的值}
```
```python
_asm
    {
```
```python
//(1)_asm是汇编语言
```
```python
//(2)修改数据-->栈底的内存是ebp,这里让其-4,也就是i这个栈底数据的改变
```
```python
//(3)16进制的20h=32
```
```python
//(4)这里的i已经不再寄存器里面,所以volatile强制读取内存当中经过修改之后的数据
```
```python
//(5)ebp-4相当于栈底的指针:直接修改数据
```
```python
mov dword ptr[ebp -
```
```python
4
```
```python
],
```
```python
20
```
```python
h;
    }
```
```python
int
```
```python
b = i;
```
```python
printf
```
```python
(
```
```python
"\ni=%d"
```
```python
, b);
    getchar();
}
```
```python
//01.Volatile强化:
```
```python
//  主要解决强制读取内存的动作
```
```python
//02.Volatile原理:寄存器-内存
```
```python
//  1.寄存器读取i的值,然后赋值给a,b
```
```python
//  2.当检测到i没有被修改的时候,读取寄存器中的i值
```
```python
//  3.写入到a,b当中-->于是就缺少了读取内存的一次
```
```python
//  4.只是读取了一次内存当中的i值
```
```python
//03.数据被意外改变的情况之下经常使用Volatile
```
```python
//  数据意外改变-->编译器优化-->不读取内存[失误]
```
程序片段(12):Queue.h+Queue.c+数组顺序队列.c
内容概要:**01.数组顺序队列**
```python
///
```
```python
Queue.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
#
```
```python
define
```
```python
DT int
```
```python
#
```
```python
define
```
```python
EN 100
```
```python
typedef
```
```python
struct
```
```python
queue
{
```
```python
int
```
```python
head;
```
```python
int
```
```python
tail;
    DT arr[EN];
} Queue;
```
```python
void
```
```python
initQueue(Queue * pQueue);
```
```python
int
```
```python
queueIsFull(Queue * pQueue);
```
```python
void
```
```python
enQueue(Queue * pQueue, DT data);
```
```python
int
```
```python
queueIsEmpty(Queue * pQueue);
```
```python
void
```
```python
showQueue(Queue * pQueue);
DT queuGetHead(Queue * pQueue);
```
```python
void
```
```python
deQueue(Queue * pQueue);
```
```python
///Queue.c
```
```python
#include "Queue.h"
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
void
```
```python
initQueue(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
memset
```
```python
((*pQueue).arr,
```
```python
0
```
```python
, EN *
```
```python
sizeof
```
```python
(DT));
    (*pQueue).tail = (*pQueue).head =
```
```python
0
```
```python
;
}
```
```python
int
```
```python
queueIsFull(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(EN == (*pQueue).tail)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
enQueue(Queue * pQueue, DT data)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(queueIsFull(pQueue))
```
```python
return
```
```python
;
    (*pQueue).arr[(*pQueue).tail] = data;
    ++(*pQueue).tail;
}
```
```python
int
```
```python
queueIsEmpty(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pQueue).head == (*pQueue).tail)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
showQueue(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(queueIsEmpty(pQueue))
```
```python
return
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < (*pQueue).tail; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, (*pQueue).arr[i]);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
DT queueGetHead(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(queueIsEmpty(pQueue))
```
```python
return
```
```python
;
```
```python
return
```
```python
(*pQueue).arr[
```
```python
0
```
```python
];
}
```
```python
//01.几种特殊数据结构的实现方式:
```
```python
//  1.栈结构:
```
```python
//      数组栈:tail-=1(无所谓正向和反向)
```
```python
//      链表栈:
```
```python
//          正向:尾部增加,尾部减少
```
```python
//          反向:头部增加,头部减少
```
```python
//  2.队列结构:
```
```python
//      数组队列:正反向的效率一致
```
```python
//      链表队列:
```
```python
//          正向:尾部增加,头部减少
```
```python
//          反向:头部增加,尾部减少
```
```python
//注:数组队列,存在明显缺点,需要进行内存移动!
```
```python
//      队列的损耗,移动费时费力!
```
```python
//注:解决数组移动移动费时费力的方案:
```
```python
//      改造成环数组形队列+改造成链表队列
```
```python
void
```
```python
deQueue(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(queueIsEmpty(pQueue))
```
```python
return
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < (*pQueue).tail -
```
```python
1
```
```python
; ++i)
    {
        (*pQueue).arr[i] = (*pQueue).arr[i +
```
```python
1
```
```python
];
    }
    --(*pQueue).tail;
}
```
```python
///数组顺序队列.c
```
```python
#include "Queue.h"
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    Queue
```
```python
queue
```
```python
;
    initQueue(&
```
```python
queue
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        enQueue(&
```
```python
queue
```
```python
, i);
    }
    showQueue(&
```
```python
queue
```
```python
);
```
```python
while
```
```python
(!queueIsEmpty(&
```
```python
queue
```
```python
))
    {
```
```python
printf
```
```python
(
```
```python
"出队的数据是%3d \n"
```
```python
, queueGetHead(&
```
```python
queue
```
```python
));
        deQueue(&
```
```python
queue
```
```python
);
        showQueue(&
```
```python
queue
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.顺序队列:逻辑编程
```
```python
//  工厂模式+(生产者-消费者)模式+请求响应模式
```
```python
//02.生产者与消费者:
```
```python
//  1.生产线程(生产者)
```
```python
//  2.消费线程(消费者)
```
```python
//  3.库存情况:库存越少越好,但是不能断掉供应链
```
```python
//      队列关系:生产者生产,消费者消费
```
```python
//      顺序关系:先进先出特点(存在顺序)
```
```python
//      原理:队列&多线程--请求|响应模式
```
```python
//03.三种队列的实现:
```
```python
//  1.数组顺序队列(尾部插入,头部取出)
```
```python
//  2.数组环形顺序队列(尾部插入,头部取出)
```
```python
//  2.链表反向队列(头部插入,尾部取出)
```
```python
//      队列实现:基础之上实现
```
```python
//          (生产者&消费者)模式
```
```python
//          (发送消息&接收消息)的模式
```
```python
//          (请求&响应)模式
```
```python
//04.数组顺序队列-->数组环形顺序队列
```
```python
//  单链表-->双链表:单独的结构-->追求快一点儿,从简
```
```python
//05.环形队列原理:
```
```python
//  1.吃东西-->拉东西
```
```python
//  2.吃:前面+,拉:往前走
```
```python
//  3.吃的太多,重合情况(特殊情况)
```
```python
//06.环形队列解释:
```
```python
//  1.头尾重合,没有数据,添加一个数据之后,头不变,尾向后移一个结构体单位
```
```python
//  2.顺序队列的缺点:删除的时候移动很累(数组环形队列可以解决这个问题)
```
```python
//07.顺序队列解释:
```
```python
//  1.头部必须固定
```
```python
//  2.移动费时费力
```
```python
//08.队列移动问题的改造:
```
```python
//  1.链表结构
```
```python
//  2.环形队列
```
程序片段(13):CircleQueue.h+CircleQueue.c+数组正向环形队列.c
内容概要:**02.数组环形顺序队列**
```python
///
```
```python
CircleQueue.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
#
```
```python
define
```
```python
DT int
```
```python
#
```
```python
define
```
```python
EN 0
```
```python
typedef
```
```python
struct
```
```python
circleQueue
{
```
```python
int
```
```python
head;
```
```python
int
```
```python
tail;
    DT arr[EN];
} CircleQueue;
```
```python
void
```
```python
initCircleQueue(CircleQueue * pCircleQueue);
```
```python
int
```
```python
circleQueueIsFull(CircleQueue * pCircleQueue);
```
```python
void
```
```python
enCircleQueue(CircleQueue * pCircleQueue, DT data);
```
```python
int
```
```python
circleQueueIsEmpty(CircleQueue * pCircleQueue);
```
```python
void
```
```python
showCircleQueue(CircleQueue * pCircleQueue);
DT circleQueueGetHead(CircleQueue * pCircleQueue);
```
```python
void
```
```python
deCircleQueue(CircleQueue * pCircleQueue);
```
```python
///CircleQueue.c
```
```python
#include "CircleQueue.h"
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
void
```
```python
initCircleQueue(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
memset
```
```python
((*pCircleQueue).arr,
```
```python
0
```
```python
, EN *
```
```python
sizeof
```
```python
(DT));
    (*pCircleQueue).tail = (*pCircleQueue).head =
```
```python
0
```
```python
;
}
```
```python
//01.如何判断环形队列是否装满元素?
```
```python
//  1.这儿有三种特殊情况需要考虑:
```
```python
//      头部+中部+尾部
```
```python
//  2.最终可归结为两种环形队列满元素的情况:
```
```python
//      头部+中部(尾部和头部合并)
```
```python
//  3.归纳总结:
```
```python
//      头尾+循环情况
```
```python
int
```
```python
circleQueueIsFull(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pCircleQueue).head == ((*pCircleQueue).tail +
```
```python
1
```
```python
) % EN)
    {
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
enCircleQueue(CircleQueue * pCircleQueue, DT data)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsFull(pCircleQueue))
```
```python
return
```
```python
;
    (*pCircleQueue).arr[(*pCircleQueue).tail] = data;
    (*pCircleQueue).tail = ((*pCircleQueue).tail +
```
```python
1
```
```python
) % EN;
}
```
```python
int
```
```python
circleQueueIsEmpty(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pCircleQueue).head == (*pCircleQueue).tail)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
///
```
```python
数组正向环形队列.c
```
```python
//01.数组顺序环形队列的思想:
```
```python
//  1.就是把数组当成闭合顺序环形队列(数组-->抽象-->环形队列)
```
```python
//  2.思想演示:
```
```python
//      (1).原型:1         2       3       4       5       6       7       8       9       10
```
```python
//                         rear                                        front
```
```python
//      (2).抽离:8         9       10  1       2
```
```python
//          原理:普通数组抽象为顺序环形队列
```
```python
//              1).front-->rear:两个指针轮询移动
```
```python
//              2).防止front和rear:都走到头的情况
```
```python
//              3).节约移动情况(环形队列的优点)
```
```python
//02.环形队列实现:
```
```python
//  数组法+链表法
```
```python
//  顺序法+逆序法
```
```python
//03.环形队列的应用场景:
```
```python
//  操作系统对线程的管理这块儿
```
```python
//04.环形队列的两种情况:
```
```python
//  头尾情况+中部情况
```
```python
//05.环形队列:情况分析
```
```python
//  头尾+中部最终利用一个表达式进行表示
```
```python
//06.环形链表:
```
```python
//  1.rear说明了元素的个数
```
```python
//      front=0&rear=5的情况
```
```python
//  2.rear重合情况二
```
```python
//  3.一般情况之下,要是想实现环形队列,数组或者链表都
```
```python
//      需要空出一个位置,防止front&rear重合
```
```python
//07.环形链表规则指定:
```
```python
//  1.为空:避免重合和满了的情况一致
```
```python
//  2.rear+1%5的特点-->代表存储继续前进
```
```python
//  3.满的情况综合:
```
```python
//      (rear+1)%5==front说明重合装满
```
程序片段(15):CircleQueue.h+CircleQueue.h+数组正向环形队列.c
内容概要:**01.数组正向环形队列**
```python
///
```
```python
CircleQueue.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
#
```
```python
define
```
```python
DT int
```
```python
#
```
```python
define
```
```python
EN 10
```
```python
//01.数组正向环形队列:
```
```python
//  优点:出队一个元素,无需进行队列数组元素的整体移动
```
```python
//  特点:如果模拟数组的长度为N
```
```python
//      普通队列:需要使用到N个元素
```
```python
//      环形队列:需要使用到N-1个元素
```
```python
//注:留出一个空位是为了区分队列重合情况和队列满载情况
```
```python
//  普通重合情况:就是空队列
```
```python
//  特殊重合情况:就是满队列
```
```python
typedef
```
```python
struct
```
```python
circleQueue
{
    DT arr[EN];
```
```python
int
```
```python
head;
```
```python
int
```
```python
tail;
}CircleQueue;
```
```python
void
```
```python
initCircleQueue(CircleQueue * pCircleQueue);
```
```python
int
```
```python
circleQueueIsFull(CircleQueue * pCircleQueue);
```
```python
void
```
```python
enCircleQueue(CircleQueue * pCircleQueue, DT data);
```
```python
int
```
```python
circleQueueIsEmpty(CircleQueue * pCircleQueue);
```
```python
void
```
```python
showCircleQueue(CircleQueue * pCircleQueue);
DT circleQueueGetHead(CircleQueue * pCircleQueue);
```
```python
void
```
```python
deCircleQueue(CircleQueue * pCircleQueue);
```
```python
///CircleQueue.c
```
```python
#include "CircleQueue.h"
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
#include <stdio.h>
```
```python
void
```
```python
initCircleQueue(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
memset
```
```python
((*pCircleQueue).arr,
```
```python
0
```
```python
, EN *
```
```python
sizeof
```
```python
(DT));
    (*pCircleQueue).tail = (*pCircleQueue).head =
```
```python
0
```
```python
;
}
```
```python
int
```
```python
circleQueueIsFull(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pCircleQueue).head == ((*pCircleQueue).tail +
```
```python
1
```
```python
) % EN)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//01.空位主要的作用:
```
```python
//  1.为了缓冲末尾位置可以进行循环填充数据!
```
```python
//  2.为了可以准确区分环形队列的两种情况:
```
```python
//      空队列+满队列
```
```python
//注:还可以确定最后一个入队的元素到底应当放置于何处!
```
```python
void
```
```python
enCircleQueue(CircleQueue * pCircleQueue, DT data)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsFull(pCircleQueue))
```
```python
return
```
```python
;
    (*pCircleQueue).arr[(*pCircleQueue).tail] = data;
    (*pCircleQueue).tail = ((*pCircleQueue).tail +
```
```python
1
```
```python
) % EN;
}
```
```python
int
```
```python
circleQueueIsEmpty(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pCircleQueue).head == (*pCircleQueue).tail)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
showCircleQueue(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsEmpty(pCircleQueue))
```
```python
return
```
```python
;
```
```python
//环形队列:元素不确定+起点不确定(无法确定循环次数)
```
```python
int
```
```python
i = (*pCircleQueue).head;
```
```python
int
```
```python
count =
```
```python
0
```
```python
;
```
```python
do
```
```python
{
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, (*pCircleQueue).arr[(i++) % EN]);
```
```python
if
```
```python
(
```
```python
9
```
```python
== ++count)
```
```python
break
```
```python
;
    }
```
```python
while
```
```python
((((*pCircleQueue).tail +
```
```python
1
```
```python
) % EN != i % EN) && (i %EN < (*pCircleQueue).tail));
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
DT circleQueueGetHead(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsEmpty(pCircleQueue))
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
return
```
```python
(*pCircleQueue).arr[(*pCircleQueue).head];
}
```
```python
void
```
```python
deCircleQueue(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsEmpty(pCircleQueue))
```
```python
return
```
```python
;
    (*pCircleQueue).head = ((*pCircleQueue).head +
```
```python
1
```
```python
) % EN;
}
```
```python
///数组正向环形队列.c
```
```python
#include "CircleQueue.h"
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    CircleQueue circleQueue;
    initCircleQueue(&circleQueue);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
9
```
```python
; ++i)
    {
        enCircleQueue(&circleQueue, i +
```
```python
1
```
```python
);
        showCircleQueue(&circleQueue);
    }
```
```python
while
```
```python
(!circleQueueIsEmpty(&circleQueue))
    {
        printf(
```
```python
"数组正向环形队列出队:%3d \n"
```
```python
, circleQueueGetHead(&circleQueue));
        deCircleQueue(&circleQueue);
        showCircleQueue(&circleQueue);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(16):Queue.h+Queue.c+数组正向环形队列.c
内容概要:**02.数组正向环形队列(标准版)**
```python
///
```
```python
Queue.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
#
```
```python
define
```
```python
DT int
```
```python
#
```
```python
define
```
```python
EN 10
```
```python
//01.采用数组模拟队列的两种特点:
```
```python
//  1.假设待用于模拟的数组共有N个元素
```
```python
//  2.两种目标队列模型:
```
```python
//      普通队列:数组正向队列,使用N个元素
```
```python
//      环形队列:数组正向环形队列,使用N-1个元素
```
```python
//注:环形队列,删除一个元素便无需移动
```
```python
typedef
```
```python
struct
```
```python
queue
{
    DT arr[EN];
```
```python
int
```
```python
head;
```
```python
int
```
```python
tail;
}Queue;
```
```python
void
```
```python
initQueue(Queue * pQueue);
```
```python
int
```
```python
queueIsFull(Queue * pQueue);
```
```python
void
```
```python
enQueue(Queue * pQueue, DT data);
```
```python
int
```
```python
queueIsEmpty(Queue * pQueue);
```
```python
void
```
```python
showQueue(Queue * pQueue);
DT queueGetHead(Queue * pQueue);
```
```python
void
```
```python
deQueue(Queue * pQueue);
```
```python
///Queue.c
```
```python
#include "Queue.h"
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
#include <stdio.h>
```
```python
void
```
```python
initQueue(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
memset
```
```python
((*pQueue).arr,
```
```python
0
```
```python
, EN *
```
```python
sizeof
```
```python
(DT));
    (*pQueue).tail = (*pQueue).head =
```
```python
0
```
```python
;
}
```
```python
//01.区分:数组正向环形队列的两种情况
```
```python
//  1.空队列:起始位置=终止位置
```
```python
//  2.满队列:起始位置=(终止位置+1)%EN;
```
```python
//注:关于环形队列的面试填空问题
```
```python
//  1.预留一个空数组元素用作这两种情况的区分
```
```python
//      空队列和满队列的准确区分
```
```python
//  2.使得环形队列的循环利用情况得到维持
```
```python
//      能够循环利用到环形队列当中的每个元素位置
```
```python
//  3.极端情况分析:
```
```python
//      (1).头尾:head<tail
```
```python
//      (2).中间:head>tail
```
```python
//      (3).相同:head=tail
```
```python
int
```
```python
queueIsFull(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pQueue).head == ((*pQueue).tail +
```
```python
1
```
```python
) % EN)
    {
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//02.数组正向环形队列的入队比数组正向队列麻烦多了:
```
```python
//  1.特点就是:始终在模拟正向环形队列的数组当中空余一个元素位置
```
```python
//      用作区分空队列和满队列以及维持环形队列的循环状况
```
```python
//  2.走环形的特点!充分利用取余运算符的特点
```
```python
//注:取余运算符能够杜绝两种特殊情况:
```
```python
//      起点刚好冲数组首位置开始的情况
```
```python
//      起点不是位于数组首位置的情况
```
```python
//  特:在这两种情况之下都能够维持空余一个元素位置的特点
```
```python
//最后一个位置无论何种情况都不会被使用到!
```
```python
void
```
```python
enQueue(Queue * pQueue, DT data)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(queueIsFull(pQueue))
```
```python
return
```
```python
;
    (*pQueue).arr[(*pQueue).tail] = data;
    (*pQueue).tail = ((*pQueue).tail +
```
```python
1
```
```python
) % EN;
```
```python
//就是为了一定要空余最后一个位置
```
```python
}
```
```python
//03.空队列的两种情况:
```
```python
//  重合点为:(起点位置or终点位置)
```
```python
// 重合点为:模拟数组的任何位置!
```
```python
//注:实质上就是两点重合!
```
```python
int
```
```python
queueIsEmpty(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pQueue).head == (*pQueue).tail)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
showQueue(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
for
```
```python
(
```
```python
int
```
```python
i = (*pQueue).head; i % EN < (*pQueue).tail ; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, (*pQueue).arr[i]);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
DT queueGetHead(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(queueIsEmpty(pQueue))
```
```python
return
```
```python
;
```
```python
return
```
```python
(*pQueue).arr[(*pQueue).head];
}
```
```python
void
```
```python
deQueue(Queue * pQueue)
{
```
```python
if
```
```python
(NULL == pQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(queueIsEmpty(pQueue))
```
```python
return
```
```python
;
    (*pQueue).head = ((*pQueue).head +
```
```python
1
```
```python
) % EN;
}
```
```python
///数组正向环形队列.c
```
```python
#include "Queue.h"
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//for (int i = 0;;++i)
```
```python
//{
```
```python
//  printf("%2d", i %10);
```
```python
//}
```
```python
Queue
```
```python
queue
```
```python
;
    initQueue(&
```
```python
queue
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < EN -
```
```python
1
```
```python
; ++i)
    {
        enQueue(&
```
```python
queue
```
```python
, i +
```
```python
1
```
```python
);
        showQueue(&
```
```python
queue
```
```python
);
    }
```
```python
while
```
```python
(!queueIsEmpty(&
```
```python
queue
```
```python
))
    {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, queueGetHead(&
```
```python
queue
```
```python
));
        deQueue(&
```
```python
queue
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.环形队列:
```
```python
//  1.最后一个坑用于表示模拟结束:标识结束
```
```python
//      标识结束+区分空队列和满队列+可循环利用
```
```python
//  2.环形队列原理深究:
```
```python
//      环形队列的优先级问题-->顺序队列同样有
```
```python
//注:优先队列
```
```python
//02.环形队列的应用:
```
```python
//  1.高效应用
```
```python
//  2.操作系统在一段时间之内只能运行一个线程
```
```python
//03.操作系统的特点:
```
```python
//  1.我一段时间限定内只能运行一段儿程序,所以操作系统
```
```python
//      为每一条线程分配相应的时间片,然后获取时间片之后
```
```python
//      就开始执行-->操作系统1秒钟有1000次夺回控制权
```
```python
//  2.Windows属于抢占式操作系统
```
```python
//      操作系统时时刻刻夺回控制权,在重新进行分配
```
```python
//  3.冻结状态与解冻状态的体现
```
```python
//04.处理队列的时候需要将数据更替为HANDLE类型
```
```python
//05.使用数组构建环形队列比使用链表构建环形队列简单多了
```
```python
//06.数组正向环形队列相比数组正向队列的好处:
```
```python
//      删除一个元素之后不需要进行移动,消耗效率
```
程序片段(17):CircleQueue.h+CircleQueue.c+数组正向环形队列.c
内容概要:**01.数组正向环形队列**
```python
///
```
```python
CircleQueue.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
#
```
```python
define
```
```python
DT int
```
```python
#
```
```python
define
```
```python
EN 10
```
```python
//01.数组模拟队列:
```
```python
//  普通队列:使用N个数组元素
```
```python
//  环形队列:使用N-1个数组元素
```
```python
typedef
```
```python
struct
```
```python
circleQueue
{
    DT arr[EN];
```
```python
int
```
```python
head;
```
```python
int
```
```python
tail;
}CircleQueue;
```
```python
void
```
```python
initCircleQueue(CircleQueue * pCircleQueue);
```
```python
int
```
```python
circleQueueIsFull(CircleQueue * pCircleQueue);
```
```python
void
```
```python
enCircleQueue(CircleQueue * pCircleQueue, DT data);
```
```python
int
```
```python
circleQueueIsEmpty(CircleQueue * pCircleQueue);
```
```python
void
```
```python
showCircleQueue(CircleQueue * pCircleQueue);
DT circleQueueGetHead(CircleQueue * pCircleQueue);
```
```python
void
```
```python
deCircleQueue(CircleQueue * pCircleQueue);
```
```python
///CircleQueue.c
```
```python
#include "CircleQueue.h"
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
#include <stdio.h>
```
```python
void
```
```python
initCircleQueue(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
memset
```
```python
((*pCircleQueue).arr,
```
```python
0
```
```python
, EN *
```
```python
sizeof
```
```python
(DT));
    (*pCircleQueue).tail = (*pCircleQueue).head =
```
```python
0
```
```python
;
}
```
```python
int
```
```python
circleQueueIsFull(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pCircleQueue).head == ((*pCircleQueue).tail +
```
```python
1
```
```python
) % EN)
```
```python
//满队列
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
enCircleQueue(CircleQueue * pCircleQueue, DT data)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsFull(pCircleQueue))
```
```python
return
```
```python
;
    (*pCircleQueue).arr[(*pCircleQueue).tail] = data;
```
```python
//当前填充位置
```
```python
(*pCircleQueue).tail = ((*pCircleQueue).tail +
```
```python
1
```
```python
) % EN;
```
```python
//下个填充位置+保证连续存储
```
```python
}
```
```python
int
```
```python
circleQueueIsEmpty(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
((*pCircleQueue).head == (*pCircleQueue).tail)
```
```python
//空队列
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
showCircleQueue(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsEmpty(pCircleQueue))
```
```python
return
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i = (*pCircleQueue).head; i%EN < (*pCircleQueue).tail; ++i)
```
```python
//i<=>i%EN:这里是环形队列没有出现特殊情况的特点!
```
```python
{
```
```python
//数组正向环形队列:1.不确定数组环形队列元素个数+2.不确定环形队列的起始元素和终止元素位置(因此打印无法控制)
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, (*pCircleQueue).arr[i]);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
DT circleQueueGetHead(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsEmpty(pCircleQueue))
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
return
```
```python
(*pCircleQueue).arr[(*pCircleQueue).head];
}
```
```python
void
```
```python
deCircleQueue(CircleQueue * pCircleQueue)
{
```
```python
if
```
```python
(NULL == pCircleQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(circleQueueIsEmpty(pCircleQueue))
```
```python
return
```
```python
;
    (*pCircleQueue).head = ((*pCircleQueue).head +
```
```python
1
```
```python
) % EN;
}
```
```python
///数组正向环形队列.c
```
```python
#include "CircleQueue.h"
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    CircleQueue circleQueue = {
```
```python
0
```
```python
};
    initCircleQueue(&circleQueue);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
9
```
```python
; ++i)
    {
        enCircleQueue(&circleQueue, i +
```
```python
1
```
```python
);
        showCircleQueue(&circleQueue);
    }
```
```python
while
```
```python
(!circleQueueIsEmpty(&circleQueue))
    {
        printf(
```
```python
"%3d \n"
```
```python
, circleQueueGetHead(&circleQueue));
        deCircleQueue(&circleQueue);
        showCircleQueue(&circleQueue);
    }
    system(
```
```python
"pause"
```
```python
);
}
CircleQueue circleQueue = {
```
```python
0
```
```python
};
DWORD WINAPI producer(
```
```python
void
```
```python
* p)
{
    printf(
```
```python
"生产者第01次执行生产任务! \n"
```
```python
);
```
```python
int
```
```python
data =
```
```python
0
```
```python
;
```
```python
while
```
```python
(!circleQueueIsFull(&circleQueue))
    {
```
```python
//生产者:一次性补充满库存黁量
```
```python
enCircleQueue(&circleQueue, ++data);
        printf(
```
```python
"生产者生产了%3d! \n"
```
```python
, data);
    }
    Sleep(
```
```python
1000
```
```python
);
    HANDLE event1 = OpenEvent(EVENT_ALL_ACCESS,
```
```python
TRUE
```
```python
, L
```
```python
"producer"
```
```python
);
    SetEvent(event1);
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
while
```
```python
(++i)
    {
        HANDLE event2 = OpenEvent(EVENT_ALL_ACCESS,
```
```python
TRUE
```
```python
, L
```
```python
"consumer"
```
```python
);
        WaitForSingleObject(event2, INFINITE);
        printf(
```
```python
"生产者第%02d次执行生产任务! \n"
```
```python
, i);
```
```python
while
```
```python
(!circleQueueIsFull(&circleQueue))
        {
            enCircleQueue(&circleQueue, ++data);
            printf(
```
```python
"生产者生产了%3d! \n"
```
```python
, data);
        }
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(event1);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI consumer(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        HANDLE event1 = OpenEvent(EVENT_ALL_ACCESS,
```
```python
TRUE
```
```python
, L
```
```python
"producer"
```
```python
);
        WaitForSingleObject(event1, INFINITE);
        printf(
```
```python
"消费者第%02d次执行消费任务! \n"
```
```python
, i);
```
```python
int
```
```python
num =
```
```python
9
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j < num; ++j)
        {
```
```python
if
```
```python
(!circleQueueIsEmpty(&circleQueue))
            {
                printf(
```
```python
"消费者消费了%3d! \n"
```
```python
, circleQueueGetHead(&circleQueue));
                deCircleQueue(&circleQueue);
            }
        }
        Sleep(
```
```python
1000
```
```python
);
        HANDLE event2 = OpenEvent(EVENT_ALL_ACCESS,
```
```python
TRUE
```
```python
, L
```
```python
"consumer"
```
```python
);
        SetEvent(event2);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    HANDLE event1 = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
, L
```
```python
"producer"
```
```python
);
    HANDLE event2 = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
, L
```
```python
"consumer"
```
```python
);
    HANDLE threadArr[
```
```python
2
```
```python
] = {
```
```python
0
```
```python
};
    threadArr[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, producer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArr[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, consumer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//WaitForSingleObject(producer, INFINITE);//可以直接等待单个线程任务执行结束以后!
```
```python
WaitForMultipleObjects(
```
```python
2
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    CloseHandle(event1);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.消费者不管买走多少,都需要将存储结构塞满
```
```python
//  紧缺产品:针对于畅销产品的库存解决方案
```
```python
//      随时保持库存充足
```
```python
//  停滞产品:针对于停滞产品的库存解决方案
```
```python
//      在满足市场供需的情况之下,库存越少越好
```
```python
//02.Scanf不是一个线程安全的函数
```
```python
//  1.所以需要手动进行安全检查
```
```python
//  2.它也是系统出现漏洞的原因之一
```
```python
//03.防止进栈压栈冲突:延迟
```
```python
//  互锁:不要让生产者边生产而消费者边消费
```
```python
//  解决:生产者完成之后消费者进行消费
```
```python
//注:以上情况不符合现实情况,现实情况之下需要解决多线程异步并发访问冲突问题
```
```python
//04.生产者&消费者:
```
```python
//  1.环形队列的仓库,保证这个库存-->生产的是紧缺产品(随时满足库存量)
```
```python
//  2.库存一定需要填满(针对于畅销紧缺产品)
```
```python
//05.工厂设计模式:
```
```python
//  1.同时生产多个产品-->产品&线程开辟-->平衡调度线程
```
```python
//      工厂:多线程
```
```python
//  2.前台卖货:平衡调度
```
```python
//      库存控制,畅销与非畅销
```
```python
//  3.消费者消费:千变万化
```
```python
//注:区分(生产者与消费者)和(工厂)两种设计模式的区别:
```
```python
//  生产者与消费者:单产品
```
```python
//  工厂:多产品
```
```python
//06.链式队列(无线)&栈(有限)
```
```python
//  服务器几十万几百万的多线程操作
```
```python
//07.内存数据库:
```
```python
//  1.所有数据都载入内存-->发出请求
```
```python
//  2.文件载入内存
```
```python
//  3.消费者提出(需求),生产者进行(生产)
```
```python
//  4.线程不断的进行加载
```
```python
//  5.防止多线程并发访问
```
```python
//  6.迁移到CGI: 手机查询
```
```python
//  7.多线程与队列问题-->稳定与不稳定
```
程序片段(18):Queue.h+Queue.c+Main.c
内容概要:**02.链表反向队列**
```python
///
```
```python
Queue.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
#
```
```python
define
```
```python
DT int
```
```python
typedef
```
```python
struct
```
```python
node
{
    DT data;
```
```python
struct
```
```python
node * pNext;
}Node;
```
```python
void
```
```python
initQueue(Node ** ppQueue);
```
```python
void
```
```python
enQueue(Node ** ppQueue, DT data);
```
```python
void
```
```python
showQueue(Node * pQueue);
DT queueGetHead(Node * pQueue);
```
```python
void
```
```python
deQueue(Node ** ppQueue);
```
```python
///Queue.c
```
```python
#include
```
```python
"Queue.h"
```
```python
#include
```
```python
<
```
```python
stdlib
```
```python
.
```
```python
h
```
```python
>
```
```python
#include
```
```python
<
```
```python
stdio
```
```python
.
```
```python
h
```
```python
>
```
```python
void
```
```python
initQueue(Node
```
```python
**
```
```python
ppQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
ppQueue)
```
```python
abort
```
```python
();
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
NULL
```
```python
;
}
```
```python
void
```
```python
enQueue(Node
```
```python
**
```
```python
ppQueue, DT
```
```python
data
```
```python
)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
ppQueue)
```
```python
//无队列
```
```python
abort
```
```python
();
    Node
```
```python
*
```
```python
pNew
```
```python
=
```
```python
(Node
```
```python
*
```
```python
)malloc(sizeof(Node));
    pNew
```
```python
->
```
```python
data
```
```python
=
```
```python
data
```
```python
;
    pNew
```
```python
->
```
```python
pNext
```
```python
=
```
```python
NULL
```
```python
;
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
*
```
```python
ppQueue)
```
```python
//空队列
```
```python
{
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
pNew;
```
```python
return
```
```python
;
    }
    pNew
```
```python
->
```
```python
pNext
```
```python
=
```
```python
*
```
```python
ppQueue;
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
pNew;
}
```
```python
void
```
```python
showQueue(Node
```
```python
*
```
```python
pQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pQueue)
```
```python
return
```
```python
;
    for (Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
pQueue;
```
```python
NULL
```
```python
!=
```
```python
pTmp; pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext)
    {
        printf(
```
```python
"%3d"
```
```python
, pTmp
```
```python
->
```
```python
data
```
```python
);
    }
    printf(
```
```python
"\n"
```
```python
);
}
DT queueGetHead(Node
```
```python
*
```
```python
pQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pQueue)
```
```python
abort
```
```python
();
    Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
pQueue;
```
```python
while
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
pTmp
```
```python
->
```
```python
pNext)
    {
        pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext;
    }
```
```python
return
```
```python
pTmp
```
```python
->
```
```python
data
```
```python
;
}
```
```python
void
```
```python
deQueue(Node
```
```python
**
```
```python
ppQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
ppQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
*
```
```python
ppQueue)
```
```python
return
```
```python
;
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
(
```
```python
*
```
```python
ppQueue)
```
```python
->
```
```python
pNext)
    {
        free(
```
```python
*
```
```python
ppQueue);
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
NULL
```
```python
;
```
```python
return
```
```python
;
    }
    Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
*
```
```python
ppQueue;
```
```python
while
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
pTmp
```
```python
->
```
```python
pNext
```
```python
->
```
```python
pNext)
    {
        pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext;
    }
    free(pTmp
```
```python
->
```
```python
pNext);
    pTmp
```
```python
->
```
```python
pNext
```
```python
=
```
```python
NULL
```
```python
;
}
```
```python
///Main.c
```
```python
#include "Queue.h"
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.链表反向队列:
```
```python
//  全局变量:用作跨线程通信变量
```
```python
Node * pQueue =
```
```python
NULL
```
```python
;
```
```python
//02.生产者消费者模式之生产者:
```
```python
//  1.时时刻刻盯着链表反向队列结构
```
```python
//  2.区分:畅销产品与非畅销产品
```
```python
//注:避免过度消耗资源的情况发生
```
```python
DWORD WINAPI producer(
```
```python
void
```
```python
* p)
{
```
```python
//非畅销产品
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
```
```python
if
```
```python
(
```
```python
NULL
```
```python
== pQueue)
        {
            enQueue(&pQueue, i);
            printf(
```
```python
"生产者生产了产品%3d! \n"
```
```python
, i);
        }
        Sleep(
```
```python
1000
```
```python
);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI consumer(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        MessageBoxA(
```
```python
0
```
```python
,
```
```python
"wait"
```
```python
,
```
```python
"consumer"
```
```python
,
```
```python
0
```
```python
);
        printf(
```
```python
"消费者消费了%3d! \n"
```
```python
, queueGetHead(pQueue));
        deQueue(&pQueue);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    HANDLE threadArr[
```
```python
2
```
```python
] = {
```
```python
0
```
```python
};
    threadArr[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, producer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArr[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, consumer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    WaitForMultipleObjects(
```
```python
2
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.生产者与消费者(设计模式):
```
```python
//  1.链表反向队列:作为流水线
```
```python
//      数组(正向&反向)队列&数组(正向&反向)环形队列&链表(正向&反向)队列
```
```python
//  2.线程结构:生产者&消费者
```
```python
//  3.流程原理:
```
```python
//      (1).当流水线为空的时候,生产者生产
```
```python
//      (2).生产者:非畅销&畅销(视具体情况而定)
```
```python
//      (3).消费者:手动控制,可以获取任意个数
```
```python
//          设计模式:看不明白的主要原因是因为多线程
```
```python
//          单线程没有意义,多线程才有意义
```
```python
//02.生产者&消费者:
```
```python
//  1.生产"紧缺"产品&生产"非紧缺"产品
```
```python
//  2.生产者&消费者所做事情:
```
```python
//      (1),生产者时时刻刻检测数据结构是否已经填充满了
```
```python
//          没有满需要插入数据-->链式队列:锁定数目就行了(防止无限仓库产生)
```
```python
//          理论上都不推荐使用链式队列:因为过渡消耗资源
```
```python
//          -->链式栈不存在满的情况:可以进行无限拓展
```
```python
//      (2).用于软件开发的两种情况:
```
```python
//          1).生产&消费分开做
```
```python
//          2).工厂模式更加复杂(不同类型的生产者与消费者模式)
```
```python
//03.理解生产者与消费者
```
```python
//  1.生产者需要保证至少有一个
```
```python
//  2.消费者的消费情况是随机消费的
```
```python
//  3.消费者需要配合生产着
```
```python
//      一个入队,一个出队[消费者的消费是个不确定的数据]
```
```python
//  4.线程通信中间使用最多的是什么?
```
```python
//          事件&互斥量&信号量
```
程序片段(19):Queue.h+Queue.c+01.Event通信(生产者消费者).cpp+02.Semaphore通信(生产者消费者).c
内容概要:**03.生产者与消费者模式**
```python
///
```
```python
Queue.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
#
```
```python
define
```
```python
DT int
```
```python
typedef
```
```python
struct
```
```python
node
{
    DT data;
```
```python
struct
```
```python
node * pNext;
}Node;
```
```python
void
```
```python
initQueue(Node ** ppQueue);
```
```python
void
```
```python
enQueue(Node ** ppQueue, DT data);
```
```python
void
```
```python
showQueue(Node * pQueue);
DT queueGetHead(Node * pQueue);
```
```python
void
```
```python
deQueue(Node ** ppQueue);
```
```python
///Queue.c
```
```python
#include
```
```python
"Queue.h"
```
```python
#include
```
```python
<
```
```python
stdlib
```
```python
.
```
```python
h
```
```python
>
```
```python
#include
```
```python
<
```
```python
stdio
```
```python
.
```
```python
h
```
```python
>
```
```python
void
```
```python
initQueue(Node
```
```python
**
```
```python
ppQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
ppQueue)
```
```python
abort
```
```python
();
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
NULL
```
```python
;
}
```
```python
void
```
```python
enQueue(Node
```
```python
**
```
```python
ppQueue, DT
```
```python
data
```
```python
)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
ppQueue)
```
```python
//无队列
```
```python
abort
```
```python
();
    Node
```
```python
*
```
```python
pNew
```
```python
=
```
```python
(Node
```
```python
*
```
```python
)malloc(sizeof(Node));
    pNew
```
```python
->
```
```python
data
```
```python
=
```
```python
data
```
```python
;
    pNew
```
```python
->
```
```python
pNext
```
```python
=
```
```python
NULL
```
```python
;
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
*
```
```python
ppQueue)
```
```python
//空队列
```
```python
{
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
pNew;
```
```python
return
```
```python
;
    }
    pNew
```
```python
->
```
```python
pNext
```
```python
=
```
```python
*
```
```python
ppQueue;
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
pNew;
}
```
```python
void
```
```python
showQueue(Node
```
```python
*
```
```python
pQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pQueue)
```
```python
return
```
```python
;
    for (Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
pQueue;
```
```python
NULL
```
```python
!=
```
```python
pTmp; pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext)
    {
        printf(
```
```python
"%3d"
```
```python
, pTmp
```
```python
->
```
```python
data
```
```python
);
    }
    printf(
```
```python
"\n"
```
```python
);
}
DT queueGetHead(Node
```
```python
*
```
```python
pQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pQueue)
```
```python
abort
```
```python
();
    Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
pQueue;
```
```python
while
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
pTmp
```
```python
->
```
```python
pNext)
    {
        pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext;
    }
```
```python
return
```
```python
pTmp
```
```python
->
```
```python
data
```
```python
;
}
```
```python
void
```
```python
deQueue(Node
```
```python
**
```
```python
ppQueue)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
ppQueue)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
*
```
```python
ppQueue)
```
```python
return
```
```python
;
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
(
```
```python
*
```
```python
ppQueue)
```
```python
->
```
```python
pNext)
    {
        free(
```
```python
*
```
```python
ppQueue);
```
```python
*
```
```python
ppQueue
```
```python
=
```
```python
NULL
```
```python
;
```
```python
return
```
```python
;
    }
    Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
*
```
```python
ppQueue;
```
```python
while
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
pTmp
```
```python
->
```
```python
pNext
```
```python
->
```
```python
pNext)
    {
        pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext;
    }
    free(pTmp
```
```python
->
```
```python
pNext);
    pTmp
```
```python
->
```
```python
pNext
```
```python
=
```
```python
NULL
```
```python
;
}
```
```python
///01.Event通信(生产者消费者).cpp
```
```python
#include "Queue.h"
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
Node * pQueue =
```
```python
NULL
```
```python
;
DWORD WINAPI producer(
```
```python
void
```
```python
* p)
{
    enQueue(&pQueue,
```
```python
1
```
```python
);
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
while
```
```python
(++i)
    {
        HANDLE event1 = OpenEvent(EVENT_ALL_ACCESS,
```
```python
TRUE
```
```python
, L
```
```python
"consumer"
```
```python
);
        WaitForSingleObject(event1, INFINITE);
        printf(
```
```python
"生产者生产了%3d! \n"
```
```python
, i);
        enQueue(&pQueue, i);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI consumer(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        MessageBoxA(
```
```python
0
```
```python
,
```
```python
"wait"
```
```python
,
```
```python
"wait"
```
```python
,
```
```python
0
```
```python
);
        printf(
```
```python
"消费者消费了%3d! \n"
```
```python
, queueGetHead(pQueue));
        deQueue(&pQueue);
        HANDLE event1 = OpenEvent(EVENT_ALL_ACCESS,
```
```python
TRUE
```
```python
, L
```
```python
"consumer"
```
```python
);
        SetEvent(event1);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    HANDLE event1 = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
FALSE
```
```python
, L
```
```python
"consumer"
```
```python
);
    HANDLE threadArr[
```
```python
2
```
```python
] = {
```
```python
0
```
```python
};
    threadArr[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, producer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArr[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, consumer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    WaitForMultipleObjects(
```
```python
2
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    CloseHandle(event1);
    system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
1
```
```python
;
}
```
```python
//01.消费完成之后设置事件的触发
```
```python
//02.每秒钟进行检测,浪费资源
```
```python
//03.事件的关键步骤:
```
```python
//  CloseHandle(event);
```
```python
//04.在一个线程里面不需要死循环:
```
```python
//  因为它在这儿i不断的进行自增,增加的次数不确定
```
```python
//05.事件通信&信号量通信
```
```python
///02.Semaphore通信(生产者消费者).c
```
```python
#include "Queue.h"
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
Node * pQueue =
```
```python
NULL
```
```python
;
DWORD WINAPI producer(
```
```python
void
```
```python
* p)
{
    HANDLE sema = OpenSemaphoreA(SEMAPHORE_ALL_ACCESS,
```
```python
TRUE
```
```python
,
```
```python
"consumer"
```
```python
);
    enQueue(&pQueue,
```
```python
1
```
```python
);
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(sema, INFINITE);
        printf(
```
```python
"生产者生产了%3d! \n"
```
```python
, i);
        enQueue(&pQueue, i);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI consumer(
```
```python
void
```
```python
* p)
{
    HANDLE sema = OpenSemaphoreA(SEMAPHORE_ALL_ACCESS,
```
```python
TRUE
```
```python
,
```
```python
"consumer"
```
```python
);
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        MessageBoxA(
```
```python
0
```
```python
,
```
```python
"wait"
```
```python
,
```
```python
"consumer"
```
```python
,
```
```python
0
```
```python
);
        printf(
```
```python
"消费者消费了%3d! \n"
```
```python
, queueGetHead(pQueue));
        deQueue(&pQueue);
        ReleaseSemaphore(sema,
```
```python
1
```
```python
,
```
```python
NULL
```
```python
);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    HANDLE sema = CreateSemaphoreA(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
"consumer"
```
```python
);
    HANDLE threadArr[
```
```python
2
```
```python
] = {
```
```python
0
```
```python
};
    threadArr[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, producer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArr[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, consumer,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    WaitForMultipleObjects(
```
```python
2
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    CloseHandle(sema);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.信号量解决生产者与消费者问题:
```
```python
//  C++称之为工厂设计模式
```
```python
//02.事件-->互斥量解决线程通信问题:
```
```python
//  事件-->信号量问题分析
```
```python
//03.设计模式结合多线程比较好理解
```
```python
//  两个变量之间的双方通信规则
```

