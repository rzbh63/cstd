
# libuv学习笔记（20） - paohui0134的博客 - CSDN博客


2016年06月29日 23:13:17[paohui0134](https://me.csdn.net/paohui0134)阅读数：1657


# libuv学习笔记（20）
## 线程池工作调度
### 相关数据结构
```python
typedef
```
```python
struct
```
```python
uv_work_s uv_work_t;
```
```python
struct
```
```python
uv_work_s {
  UV_REQ_FIELDS
```
```python
//uv_req_t的成员
```
```python
uv_loop_t* loop;
  uv_work_cb work_cb;
  uv_after_work_cb after_work_cb;
```
```python
//UV_WORK_PRIVATE_FIELDS展开：
```
```python
struct
```
```python
uv__work work_req;
};
```
```python
//涉及到需要线程池处理的请求都会带有这个结构体
```
```python
struct
```
```python
uv__work {
```
```python
void
```
```python
(*work)(
```
```python
struct
```
```python
uv__work *w);
```
```python
//具体的任务函数
```
```python
void
```
```python
(*done)(
```
```python
struct
```
```python
uv__work *w,
```
```python
int
```
```python
status);
```
```python
//任务完成之后由loop调用的函数
```
```python
struct
```
```python
uv_loop_s* loop;
```
```python
void
```
```python
* wq[
```
```python
2
```
```python
];
```
```python
//任务队列
```
```python
};
```
### 相关函数
#### 将任务添加到线程池
```python
int
```
```python
uv_queue_work(uv_loop_t* loop,
                  uv_work_t* req,
                  uv_work_cb work_cb,
                  uv_after_work_cb after_work_cb) {
```
```python
if
```
```python
(work_cb == NULL)
```
```python
return
```
```python
UV_EINVAL;
  uv__req_init(loop, req, UV_WORK);
```
```python
//初始化req
```
```python
req->loop = loop;
  req->work_cb = work_cb;
  req->after_work_cb = after_work_cb;
```
```python
//内部处理
```
```python
uv__work_submit(loop, &req->work_req, uv__queue_work, uv__queue_done);
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
uv__work_submit(uv_loop_t
```
```python
*
```
```python
loop
```
```python
,
                     struct uv__work
```
```python
*
```
```python
w,
```
```python
void
```
```python
(
```
```python
*
```
```python
work)(struct uv__work
```
```python
*
```
```python
w),
```
```python
void
```
```python
(
```
```python
*
```
```python
done)(struct uv__work
```
```python
*
```
```python
w, int status)) {
  uv_once(
```
```python
&
```
```python
once, init_once);
```
```python
//初始化线程池，只会执行一次
```
```python
w
```
```python
->
```
```python
loop
```
```python
=
```
```python
loop
```
```python
;
  w
```
```python
->
```
```python
work
```
```python
=
```
```python
work;
  w
```
```python
->
```
```python
done
```
```python
=
```
```python
done;
  post(
```
```python
&
```
```python
w
```
```python
->
```
```python
wq);
```
```python
//将任务添加到线程池任务队列
```
```python
}
```
初始化线程池
```python
static
```
```python
void
```
```python
init_once(
```
```python
void
```
```python
) {
```
```python
unsigned
```
```python
int
```
```python
i;
```
```python
const
```
```python
char
```
```python
* val;
  nthreads = ARRAY_SIZE(default_threads);
```
```python
//默认4个线程
```
```python
val = getenv(
```
```python
"UV_THREADPOOL_SIZE"
```
```python
);
```
```python
//可以通过这个环境变量改变
```
```python
if
```
```python
(val != NULL)
    nthreads = atoi(val);
```
```python
if
```
```python
(nthreads ==
```
```python
0
```
```python
)
    nthreads =
```
```python
1
```
```python
;
```
```python
//至少一个
```
```python
if
```
```python
(nthreads > MAX_THREADPOOL_SIZE)
    nthreads = MAX_THREADPOOL_SIZE;
```
```python
//最多128个
```
```python
threads = default_threads;
```
```python
if
```
```python
(nthreads > ARRAY_SIZE(default_threads)) {
    threads = uv__malloc(nthreads *
```
```python
sizeof
```
```python
(threads[
```
```python
0
```
```python
]));
```
```python
if
```
```python
(threads == NULL) {
      nthreads = ARRAY_SIZE(default_threads);
      threads = default_threads;
    }
  }
```
```python
if
```
```python
(uv_cond_init(&cond))
```
```python
abort
```
```python
();
```
```python
if
```
```python
(uv_mutex_init(&mutex))
```
```python
//初始化互斥量，内部由临界区实现
```
```python
abort
```
```python
();
  QUEUE_INIT(&wq);
```
```python
//初始化全局任务队列
```
```python
for
```
```python
(i =
```
```python
0
```
```python
; i < nthreads; i++)
```
```python
if
```
```python
(uv_thread_create(threads + i, worker, NULL))
```
```python
abort
```
```python
();
  initialized =
```
```python
1
```
```python
;
}
```
将任务添加到队列
```python
static
```
```python
void
```
```python
post(QUEUE* q) {
  uv_mutex_lock(&mutex);
```
```python
//锁定
```
```python
QUEUE_INSERT_TAIL(&wq, q);
```
```python
//添加到队列末尾
```
```python
if
```
```python
(idle_threads >
```
```python
0
```
```python
)
```
```python
//有线程空闲
```
```python
uv_cond_signal(&cond);
```
```python
//唤醒空闲线程中的一个线程
```
```python
uv_mutex_unlock(&mutex);
}
```
每个线程调用的函数
```python
static
```
```python
UINT __stdcall uv__thread_start(
```
```python
void
```
```python
* arg) {
```
```python
struct
```
```python
thread_ctx *ctx_p;
```
```python
struct
```
```python
thread_ctx ctx;
  ctx_p = arg;
  ctx = *ctx_p;
  uv__free(ctx_p);
  uv_once(&uv__current_thread_init_guard, uv__init_current_thread_key);
  uv_key_set(&uv__current_thread_key, (
```
```python
void
```
```python
*) ctx.self);
```
```python
//设置线程局部变量，也就是线程句柄
```
```python
ctx.entry(ctx.arg);
```
```python
//调用worker
```
```python
return
```
```python
0
```
```python
;
}
```
线程池内每个线程调用的函数
```python
static
```
```python
void
```
```python
worker(
```
```python
void
```
```python
*
```
```python
arg) {
  struct uv__work
```
```python
*
```
```python
w;
```
```python
QUEUE
```
```python
*
```
```python
q;
  (
```
```python
void
```
```python
) arg;
  for (;;) {
    uv_mutex_lock(
```
```python
&
```
```python
mutex);
```
```python
while
```
```python
(QUEUE_EMPTY(
```
```python
&
```
```python
wq)) {
```
```python
//没有任务
```
```python
idle_threads
```
```python
+=
```
```python
1
```
```python
;
```
```python
//计数加一
```
```python
uv_cond_wait(
```
```python
&
```
```python
cond,
```
```python
&
```
```python
mutex);
```
```python
//释放临界区并一直等待
```
```python
idle_threads
```
```python
-=
```
```python
1
```
```python
;
```
```python
//被激活
```
```python
}
    q
```
```python
=
```
```python
QUEUE_HEAD(
```
```python
&
```
```python
wq);
```
```python
//取第一个
```
```python
if
```
```python
(q
```
```python
==
```
```python
&
```
```python
exit_message)
```
```python
//是退出消息
```
```python
uv_cond_signal(
```
```python
&
```
```python
cond);
```
```python
//唤醒线程，如此一来就能唤醒所有等待的线程
```
```python
else
```
```python
{
      QUEUE_REMOVE(q);
      QUEUE_INIT(q);
```
```python
/* Signal uv_cancel() that the work req is
                             executing. */
```
```python
}
    uv_mutex_unlock(
```
```python
&
```
```python
mutex);
```
```python
if
```
```python
(q
```
```python
==
```
```python
&
```
```python
exit_message)
```
```python
//堆出消息，直接结束线程
```
```python
break;
    w
```
```python
=
```
```python
QUEUE_DATA(q, struct uv__work, wq);
```
```python
//获取对应的uv__work
```
```python
w
```
```python
->
```
```python
work(w);
```
```python
//调用任务函数，内部会调用用户的任务回调函数
```
```python
//向loop发送wake消息，有loop调用done函数
```
```python
uv_mutex_lock(
```
```python
&
```
```python
w
```
```python
->
```
```python
loop
```
```python
->
```
```python
wq_mutex);
    w
```
```python
->
```
```python
work
```
```python
=
```
```python
NULL
```
```python
;
```
```python
/* Signal uv_cancel() that the work req is done
                        executing. */
```
```python
QUEUE_INSERT_TAIL(
```
```python
&
```
```python
w
```
```python
->
```
```python
loop
```
```python
->
```
```python
wq,
```
```python
&
```
```python
w
```
```python
->
```
```python
wq);
    uv_async_send(
```
```python
&
```
```python
w
```
```python
->
```
```python
loop
```
```python
->
```
```python
wq_async);
    uv_mutex_unlock(
```
```python
&
```
```python
w
```
```python
->
```
```python
loop
```
```python
->
```
```python
wq_mutex);
  }
}
```
#### 取消一个线程池任务
```python
int uv_cancel(uv_req_t* req) {
  struct uv__work* wreq;
  uv_loop_t*
```
```python
loop
```
```python
;
```
```python
switch
```
```python
(req->type) {
```
```python
case
```
```python
UV_FS
```
```python
:
```
```python
loop
```
```python
=
```
```python
((uv_fs_t*) req)
```
```python
->
```
```python
loop
```
```python
;
    wreq = &
```
```python
((uv_fs_t*) req)
```
```python
->
```
```python
work_req;
```
```python
break
```
```python
;
```
```python
case
```
```python
UV_GETADDRINFO
```
```python
:
```
```python
loop
```
```python
=
```
```python
((uv_getaddrinfo_t*) req)
```
```python
->
```
```python
loop
```
```python
;
    wreq = &
```
```python
((uv_getaddrinfo_t*) req)
```
```python
->
```
```python
work_req;
```
```python
break
```
```python
;
```
```python
case
```
```python
UV_GETNAMEINFO
```
```python
:
```
```python
loop
```
```python
=
```
```python
((uv_getnameinfo_t*) req)
```
```python
->
```
```python
loop
```
```python
;
    wreq = &
```
```python
((uv_getnameinfo_t*) req)
```
```python
->
```
```python
work_req;
```
```python
break
```
```python
;
```
```python
case
```
```python
UV_WORK
```
```python
:
```
```python
loop
```
```python
=
```
```python
((uv_work_t*) req)
```
```python
->
```
```python
loop
```
```python
;
    wreq = &
```
```python
((uv_work_t*) req)
```
```python
->
```
```python
work_req;
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
return
```
```python
UV_EINVAL;
  }
```
```python
return
```
```python
uv__work_cancel(
```
```python
loop
```
```python
, req, wreq);
}
```
```python
static
```
```python
int
```
```python
uv__work_cancel(uv_loop_t* loop, uv_req_t* req,
```
```python
struct
```
```python
uv__work* w) {
```
```python
int
```
```python
cancelled;
  uv_mutex_lock(&mutex);
```
```python
//进入临界区
```
```python
uv_mutex_lock(&w->loop->wq_mutex);
  cancelled = !QUEUE_EMPTY(&w->wq) && w->work != NULL;
```
```python
if
```
```python
(cancelled)
```
```python
//还没被处理，直接从列表中去掉即可
```
```python
QUEUE_REMOVE(&w->wq);
  uv_mutex_unlock(&w->loop->wq_mutex);
  uv_mutex_unlock(&mutex);
```
```python
if
```
```python
(!cancelled)
```
```python
//正在被处理
```
```python
return
```
```python
UV_EBUSY;
```
```python
//去掉之后，直接将任务插入loop的任务列表，并发送异步请求唤醒loop，以便loop调用线程池任务的完成回调函数，走完整个流程
```
```python
w->work = uv__cancelled;
  uv_mutex_lock(&loop->wq_mutex);
  QUEUE_INSERT_TAIL(&loop->wq, &w->wq);
  uv_async_send(&loop->wq_async);
  uv_mutex_unlock(&loop->wq_mutex);
```
```python
return
```
```python
0
```
```python
;
}
```
注意，uv_cancel取消一个线程池任务之后，并不是立刻停止了任务，还是会继续走流程，最终还是会由loop所在线程调用任务的完成回调函数，只是完成回调函数中会指明当前任务被取消了，非正常完成。

