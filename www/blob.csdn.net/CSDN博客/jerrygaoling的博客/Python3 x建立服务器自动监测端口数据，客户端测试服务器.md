
# Python3.x建立服务器自动监测端口数据，客户端测试服务器 - jerrygaoling的博客 - CSDN博客


2018年03月11日 22:57:59[jerrygaoling](https://me.csdn.net/jerrygaoling)阅读数：453


## 建立Python的服务端
### 类似于java的tcp协议，Python中的服务端建立方式类似
### 首先需要导入socket类
```python
import
```
```python
socket
```
```python
from
```
```python
time
```
```python
import
```
```python
ctime
```
```python
#导入时间类
```
### 建立套接字，绑定IP地址和端口，设置最大连接数
创建了一个socket对象。type参数代表套接字类型，可为SOCK_STREAM(流套接字)和SOCK_DGRAM(数据报套接字)。AF_INET表示创建的是ipv4的类型。
```python
""
```
```python
"
```
```python
@version
```
```python
: v1.0
```
```python
@author
```
```python
: jerrygaoling
```
```python
@site
```
```python
:
```
```python
${SITE}
```
```python
@file
```
```python
:
```
```python
$test_python_sever
```
```python
.py
```
```python
@time
```
```python
: 2018.03.10 
"
```
```python
""
```
```python
if
```
```python
__name_
```
```python
_
```
```python
==
```
```python
"__main__"
```
```python
:
    sock =
```
```python
socket
```
```python
.
```
```python
socket
```
```python
(
```
```python
socket
```
```python
.AF_INET,
```
```python
socket
```
```python
.SOCK_STREAM)
```
```python
#创建套接字
```
```python
sock.
```
```python
bind
```
```python
((
```
```python
'localhost'
```
```python
,
```
```python
8081
```
```python
))
```
```python
#配置soket，绑定IP地址和端口号
```
```python
sock.
```
```python
listen
```
```python
(
```
```python
1
```
```python
)
```
```python
#设置最大允许连接数，各连接和server的通信遵循FIFO原则
```
```python
print
```
```python
(
```
```python
"Server is listenting port 8081, with max connection 1"
```
```python
)
```
```python
#给定输出提示性语句。
```
### 循环监听端口
不断接收请求：收到连接请求后，这些请求需要排队，如果队列满，就拒绝请求。
**accept()**方法返回一个含有两个元素的 元组(connection,address)。第一个元素connection是新的socket对象，服务器必须通过它与客户通信；第二个元素 address是客户的Internet地址。
```python
while
```
```python
True
```
```python
:
```
```python
#循环轮询socket状态，等待访问
```
```python
connection,address = sock.accept()
```
### 注意！！：
### 当为多线程时，需要进行多线程编写，本文只是单线程连接。
```python
try
```
```python
:    
            connection.settimeout(
```
```python
50
```
```python
)
```
```python
#设置定时时间
```
```python
#获得一个连接，然后开始循环处理这个连接发送的信息
```
```python
while
```
```python
True
```
```python
:
```
```python
try
```
```python
:
                    buf = connection.recv(
```
```python
1024
```
```python
).decode()
```
```python
if
```
```python
not
```
```python
buf:
```
```python
break
```
```python
print
```
```python
(buf)
```
```python
if
```
```python
buf ==
```
```python
'1'
```
```python
:
```
```python
print
```
```python
(
```
```python
"send welcome"
```
```python
)  
                        connection.send((
```
```python
'[%s] %s'
```
```python
% (ctime(),
```
```python
"welcome，glyz的学习记录"
```
```python
)).encode())
```
```python
elif
```
```python
buf==
```
```python
'2'
```
```python
:    
                        connection.send((
```
```python
'[%s] %s'
```
```python
% (ctime(),
```
```python
"我的学习记录!"
```
```python
)).encode())
```
```python
print
```
```python
(
```
```python
"send refuse"
```
```python
)
```
```python
else
```
```python
:
```
```python
print
```
```python
(
```
```python
"close"
```
```python
)
```
```python
break
```
```python
#退出连接监听循环
```
```python
except
```
```python
socket.error:
```
```python
print
```
```python
(
```
```python
"get connect error,lost_client"
```
```python
)
```
```python
#当连接失败时，捕捉异常并退出，继续监听。
```
```python
break
```
```python
except
```
```python
socket.timeout:
```
```python
#如果建立连接后，该连接在设定的时间内无数据发来，则time out
```
```python
print
```
```python
(
```
```python
"time out"
```
```python
)
```
```python
print
```
```python
(
```
```python
"closing one connection"
```
```python
)
```
```python
#当一个连接监听循环退出后，连接可以关掉
```
```python
connection.close()
```
### 注意：
### 在Python3.x以上，使用send()方法进行交互传送数据的时候，不能够直接send（”类似于这样的数据”），需要使用上述代码中的格式，使用encode（）方法进行转换。否则会报出
### a bytes-like object is required, not ‘str’
### 的错误。
### 需要使用encode（）方法将bytes类型转换为str类型。使用recv（）方法接收数据时，也同样需要使用decode（）来转换。
#### 注：代码以按照严格的Python格式进行排版。可直接使用
## 附上测试用客户端代码
```python
import
```
```python
socket
```
```python
import
```
```python
time
```
```python
if
```
```python
__name_
```
```python
_
```
```python
==
```
```python
"__main__"
```
```python
:    
    sock =
```
```python
socket
```
```python
.
```
```python
socket
```
```python
(
```
```python
socket
```
```python
.AF_INET,
```
```python
socket
```
```python
.SOCK_STREAM)    
    sock.
```
```python
connect
```
```python
((
```
```python
'localhost'
```
```python
,
```
```python
8081
```
```python
))
```
```python
#设置连接IP地址与端口
```
```python
flag =
```
```python
'1'
```
```python
sock.
```
```python
send
```
```python
(flag.encode())
```
```python
''
```
```python
'#以下代码为循环访问服务器给出数据请求
    print (type(flag))
    while True:   
        time.sleep(3)    
        print ('
```
```python
send
```
```python
to server with value:
```
```python
'+ flag)   
        sock.send(flag.encode())    
        print (sock.recv(1024).decode())   
        flag = (flag=='
```
```python
1
```
```python
') and '
```
```python
2
```
```python
' or '
```
```python
1
```
```python
' #change to another type of value each time
        '
```
```python
''
```
```python
sock.
```
```python
close
```
```python
()
```
### 运行结果：
**启动服务器**
![这里写图片描述](https://img-blog.csdn.net/20180312145724311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVycnlnYW9saW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)[ ](https://img-blog.csdn.net/20180312145724311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVycnlnYW9saW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**打开客户端，循环发送、接收数据：**
![这里写图片描述](https://img-blog.csdn.net/20180312155317626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVycnlnYW9saW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

[
](https://img-blog.csdn.net/20180312145724311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamVycnlnYW9saW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
