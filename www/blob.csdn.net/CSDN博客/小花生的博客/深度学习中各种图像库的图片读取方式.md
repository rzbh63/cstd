
# 深度学习中各种图像库的图片读取方式 - 小花生的博客 - CSDN博客


2018年07月24日 23:18:05[Peanut_范](https://me.csdn.net/u013841196)阅读数：1971


深度学习中各种图像库的图片读取方式总结
在数据预处理过程中，经常需要写python代码搭建深度学习模型，不同的深度学习框架会有不同的读取数据方式（eg：Caffe的python接口默认BGR格式，Tensorflow默认RGB格式），经常需要借助python图像库来读取图像并进行一系列的图像处理工作。
**这篇文章总结了Python图像库处理数据的基本方式：**
**1.Opencv**
**2.PIL（pillow）**
**3.matplotlib.image**
**4.scipy.misc**
**5.skimage**
**6.Tensorflow**
---

## opencv: cv2.imread
opencv是最常用的图像处理库
**基本图像操作：**
```python
import
```
```python
cv2
```
```python
import
```
```python
numpy
```
```python
as
```
```python
np
```
```python
#读入图片：默认彩色图，cv2.IMREAD_GRAYSCALE灰度图，cv2.IMREAD_UNCHANGED包含alpha通道
```
```python
img = cv2.imread(
```
```python
'aa.jpg'
```
```python
)
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
```
```python
# 转换为灰度图
```
```python
img1 = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)
```
```python
# 转换为RGB
```
```python
cv2.imshow(
```
```python
'src'
```
```python
,img)
cv2.imshow(
```
```python
'gray'
```
```python
,gray)
cv2.imshow(
```
```python
'RGB'
```
```python
,img1)
print(img.shape)
```
```python
# (h,w,c)
```
```python
print(img.size)
```
```python
# 像素总数目
```
```python
print(img.dtype)
```
```python
# 像素类型
```
```python
cv2.imwrite(
```
```python
'test.jpg'
```
```python
,img1)
```
```python
# 保存图像
```
```python
cv2.waitKey()
```
**值得注意的是：**
**1**.opencv读进来的图片已经是一个numpy矩阵了，彩色图片维度是（高度，宽度，通道数）。数据类型是uint8。
**2**.opencv读进来的图片的通道排列是BGR，而不是主流的RGB
**Caffe使用opencv处理图像的基本操作：**
```python
import
```
```python
os
```
```python
import
```
```python
numpy
```
```python
as
```
```python
np
```
```python
import
```
```python
cv2
```
```python
import
```
```python
sys
caffe_root =
```
```python
'./fancp/caffe/'
```
```python
#指定caffe路径
```
```python
sys.path.insert(
```
```python
0
```
```python
, caffe_root +
```
```python
'python'
```
```python
)
```
```python
import
```
```python
caffe
```
```python
def
```
```python
predict
```
```python
(path, deploy, weight)
```
```python
:
```
```python
net = caffe.Net( deploy, weight, caffe.TEST)    
    batch_size, channels, height, width = net.blobs[
```
```python
'data'
```
```python
].data.shape
    X = np.zeros([
```
```python
1
```
```python
,channels,height,width], dtype = np.float32)
```
```python
# caffe的输入格式[N,C,H,W]
```
```python
img = cv2.imread(path).astype(np.float32)
```
```python
# 读取图片，并进行类型转换
```
```python
Img = cv2.resize(img,(
```
```python
102
```
```python
,
```
```python
102
```
```python
))[
```
```python
11
```
```python
:
```
```python
90
```
```python
,
```
```python
11
```
```python
:
```
```python
90
```
```python
,::-
```
```python
1
```
```python
]
```
```python
# Resize以及ROI操作
```
```python
img -=
```
```python
127.5
```
```python
img /=
```
```python
128.0
```
```python
# 归一化操作
```
```python
img = np.transpose(img,(
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
))
```
```python
# 通道转换，有H,W,C转变成 C,H,W
```
```python
#在深度学习搭建CNN时，往往要做相应的图像数据处理，比如图像要扩展维度，比如 扩展成（batch_size,channels,height,width）。
```
```python
img=np.expand_dims(img,axis=
```
```python
0
```
```python
)
    X[
```
```python
0
```
```python
,:,:,:] = img
    net.blobs[
```
```python
'data'
```
```python
].data[...] = X
    output = net.forward()
    output = output[
```
```python
'logits'
```
```python
][
```
```python
0
```
```python
]
    print(output)
```
```python
# 输出结果
```
```python
return
```
```python
0
```
```python
if
```
```python
__name__ ==
```
```python
'__main__'
```
```python
:
```
```python
#caffe.set_device(0)
```
```python
#caffe.set_mode_gpu()
```
```python
caffe.set_mode_cpu()
    model_def =
```
```python
'**.prototxt'
```
```python
model_weights =
```
```python
'**.caffemodel'
```
```python
image =
```
```python
'test.jpg'
```
```python
result = predict(image, model_def, model_weights)
```
---

## PIL：PIL.Image.open
PIL即Python Imaging Library，也即为我们所称的Pillow，是一个很流行的图像库，它比opencv更为轻巧，正因如此，它深受大众的喜爱。
**图像的基本操作：**
```python
from
```
```python
PIL
```
```python
import
```
```python
Image
```
```python
import
```
```python
numpy
```
```python
as
```
```python
np
img = Image.open(
```
```python
'aa.jpg'
```
```python
)
print(img.format) 
print(img.size)
```
```python
#注意，省略了通道。 (w，h)
```
```python
print(img.mode)
```
```python
#L为灰度图，RGB为真彩色,RGBA为加了透明通道
```
```python
img.show()
```
```python
# 显示图片
```
```python
gray = img.convert(
```
```python
'L'
```
```python
)
```
```python
# 转化为灰度图
```
```python
gray.show()
```
```python
#pillow读进来的图片不是矩阵，我们将图片转矩阵
```
```python
arr = np.array(img)
print(arr.shape)
print(arr.dtype)
```
```python
#矩阵再转为图像
```
```python
new_im = Image.fromarray(arr)
new_im.save(
```
```python
'test.png'
```
```python
)
```
**注：**
**1**.PIL读进来的图像是一个对象，而不是我们所熟知的numpy 矩阵。
**2**.PIL的通道顺序是RGB
**图像操作：**
```python
#分离合并通道
```
```python
r, g, b = img.
```
```python
split
```
```python
()
img = Image.
```
```python
merge
```
```python
(
```
```python
"RGB"
```
```python
, (b, g, r))
img = img.copy()
```
```python
#复制图像
```
```python
#ROI获取
```
```python
img3 = Image.
```
```python
open
```
```python
(
```
```python
'1.jpg'
```
```python
)
roi = img3.crop((
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
300
```
```python
,
```
```python
300
```
```python
))
```
```python
#(左上x，左上y，右下x，右下y)坐标
```
```python
roi.show()
```
---

## matplotlib：matplotlib.image.imread
matplotlib多用于科学绘图
**图像的基本操作：**
```python
import
```
```python
matplotlib.pyplot
```
```python
as
```
```python
plt
```
```python
import
```
```python
numpy
```
```python
as
```
```python
np
image = plt.imread(
```
```python
'aa.jpg'
```
```python
)
plt.imshow(image)
plt.axis(
```
```python
'off'
```
```python
)
```
```python
#也可以关闭显示x，y轴上的数字
```
```python
plt.show()
```
```python
#plt.imread读入的就是一个矩阵，跟opencv一样，但彩图读进的是RGB，与opencv有区别
```
```python
print(image.shape)
```
```python
# (h,w,c)
```
```python
print(image.size)
print(image.dtype)
```
**综合例子：**
```python
import
```
```python
matplotlib.pyplot
```
```python
as
```
```python
plt
```
```python
import
```
```python
numpy
```
```python
as
```
```python
np
im_lol1 =  plt.imread(
```
```python
'aa.jpg'
```
```python
)
im_lol2 =  plt.imread(
```
```python
'aa.jpg'
```
```python
)
figure = plt.figure(figsize=(
```
```python
10
```
```python
,
```
```python
5
```
```python
))
```
```python
# 调整显示图片的大小
```
```python
'''
figsize参数：指定绘图对象的宽度和高度，单位为英寸；dpi参数指定绘图对象的分辨率，
即每英寸多少个像素，缺省值为80。因此本例中所创建的图表窗口的宽度为8*80 = 640像素
'''
```
```python
plt.axis(
```
```python
"off"
```
```python
)
```
```python
#不显示刻度
```
```python
ax = figure.add_subplot(
```
```python
121
```
```python
)
```
```python
# 图片以1行2列的形式显示
```
```python
plt.axis(
```
```python
'off'
```
```python
)
ax.imshow(im_lol1)
```
```python
#第一张图
```
```python
ax.set_title(
```
```python
'image 1'
```
```python
)
```
```python
#给图片加titile
```
```python
ax = figure.add_subplot(
```
```python
122
```
```python
) 
plt.axis(
```
```python
'off'
```
```python
)
ax.imshow(im_lol2) 
ax.set_title(
```
```python
'image 2'
```
```python
)
```
```python
#给图片加titile
```
```python
plt.savefig(
```
```python
'twp.jpg'
```
```python
)
plt.show()
```
---

## scipy.misc：scipy.misc.imread
**图像的基本操作：**
```python
from
```
```python
scipy
```
```python
import
```
```python
misc
```
```python
import
```
```python
matplotlib.pyplot
```
```python
as
```
```python
plt
im = misc.imread(
```
```python
'aa.jpg'
```
```python
)
print(im.dtype)
print(im.size)
print(im.shape)
misc.imsave(
```
```python
'misc1.png'
```
```python
,im)
plt.imshow(im)
plt.show()
```
**注**：imread和imsave在后来的版本将会被弃用，现在使用imageio.imread和imageio.imwrite。
**深度学习中使用misc：**
```python
from scipy import misc
import numpy as np
import matplotlib.pyplot as plt
```
```python
image
```
```python
= misc.imread(
```
```python
'./fancp/aa.jpg'
```
```python
)
```
```python
image
```
```python
= misc.imresize(
```
```python
image
```
```python
, (
```
```python
112
```
```python
,
```
```python
96
```
```python
))
```
```python
image
```
```python
=
```
```python
image
```
```python
.astype(np.float32)
```
```python
image
```
```python
-=
```
```python
127.5
```
```python
image
```
```python
/=
```
```python
128.0
```
```python
image
```
```python
=
```
```python
image
```
```python
[
```
```python
10
```
```python
:
```
```python
89
```
```python
,
```
```python
10
```
```python
:
```
```python
89
```
```python
,:]
```
```python
image
```
```python
=
```
```python
image
```
```python
.transpose(
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
)
```
```python
print
```
```python
(
```
```python
image
```
```python
.shape)
```
---

## skimage：skimage.io.imread
**图像的基本操作：**
```python
from
```
```python
skimage
```
```python
import
```
```python
io
```
```python
from
```
```python
skimage
```
```python
import
```
```python
color
im = io.imread(
```
```python
'aa.jpg'
```
```python
)
print(im.shape)
```
```python
# numpy矩阵，(h,w,c)
```
```python
print(im.dtype)
print(im.size)
im3 = color.rgb2grey(im)
```
```python
# 灰度化处理
```
```python
io.imshow(im3)
io.imsave(
```
```python
'sk.png'
```
```python
,im)
```
**注**：图像也是以numpy array形式读入
---

## Tensorflow：tf.image.decode
**1.TensorFlow函数：tf.image.decode_bmp**
**tf.image.decode_bmp函数：**
```python
tf
```
```python
.image
```
```python
.decode
```
```python
_bmp(
    contents,
    channels=
```
```python
0
```
```python
,
    name=None
)
```
将BMP编码图像的第一帧解码为uint8张量。
attr channels表示解码图像的期望数量的颜色通道。
接受的值是：
0：使用BMP编码图像中的通道数量。
3：输出RGB图像。
4：输出RGBA图像。
**参数：**
contents：string类型的Tensor，0维，BMP编码的图像。
channels：可选的int，默认为0。
name：操作的名称（可选）。
**返回值：**
函数返回uint8类型的Tensor。
**2.TensorFlow函数：tf.image.decode_jpeg**
**tf.image.decode_jpeg函数：**
```python
tf.image.decode_jpeg(
    contents,
    channels=
```
```python
0
```
```python
,
    ratio=
```
```python
1
```
```python
,
    fancy_upscaling=
```
```python
True
```
```python
,
    try_recover_truncated=
```
```python
False
```
```python
,
    acceptable_fraction=
```
```python
1
```
```python
,
    dct_method=
```
```python
''
```
```python
,
    name=
```
```python
None
```
```python
)
```
将JPEG编码图像解码为uint8张量。
attr channels表示解码图像的期望数量的颜色通道。
接受的值是：
0：使用JPEG编码图像中的通道数量。
1：输出灰度图像。
3：输出RGB图像。
如果需要，JPEG编码的图像将被转换以匹配请求的颜色通道数量。
attr ratio允许在解码过程中将图像缩小整数倍。允许的值为：1、2、4和8。这比稍后缩小图像要快得多。
**参数：**
contents：string类型的Tensor，0维，JPEG编码的图像。
channels：可选的int，默认为0，解码图像的颜色通道数量。
ratio：可选的int，默认为1，缩小比例。
fancy_upscaling：可选的bool，默认为True，如果为true，则使用更慢但更好的色度平面升级（仅限yuv420 / 422）。
try_recover_truncated：可选的bool，默认为False，如果为true，则尝试从截断的输入中恢复图像。
acceptable_fraction：可选的float，默认为1，在截断输入之前所需的最小行数被接受。
dct_method：可选的string，默认为”“，用于指定用于解压缩的算法提示的字符串；默认为“”，映射到系统特定的默认值。当前有效值为[“INTEGER_FAST”，“INTEGER_ACCURATE”]。
name：操作的名称（可选）。
**返回值：**
该tf.image.decode_jpeg函数将返回uint8类型的Tensor。
**3.TensorFlow函数：tf.image.decode_png**
**tf.image.decode_png函数：**
```python
tf
```
```python
.image
```
```python
.decode
```
```python
_png(
    contents,
    channels=
```
```python
0
```
```python
,
    dtype=tf
```
```python
.uint
```
```python
8,
    name=None
)
```
将PNG编码的图像解码为uint8或uint16张量。
attr channels表示解码图像的期望数量的颜色通道。
接受的值是：
0：使用PNG编码图像中的通道数量。
1：输出灰度图像。
3：输出RGB图像。
4：输出RGBA图像。
如果需要，将PNG编码的图像转换为与请求的颜色通道数匹配。
此操作还支持解码JPEG和非动画GIF，因为界面相同，但使用tf.image.decode_image将更清晰。
**参数：**
contents：string类型的Tensor，0维，PNG编码的图像。
channels：可选的int，默认为0，解码图像的颜色通道数量。
dtype：可选的tf.DType，其来自：tf.uint8，tf.uint16，默认为tf.uint8。
name：操作的名称（可选）。
**返回值：**
该函数返回dtype类型的Tensor。
**4.TensorFlow函数：tf.image.decode_image**
**tf.image.decode_image函数**
```python
tf.image.decode_image(
    contents,
    channels=
```
```python
None
```
```python
,
    name=
```
```python
None
```
```python
)
```
decode_bmp，decode_gif，decode_jpeg和decode_png的方便函数。
检测图像是否为BMP，GIF，JPEG或PNG，并执行相应的操作将输入字节string转换为类型uint8的Tensor。
注意: decode_gif返回一个4维数组[num_frames、高度、宽度、3]，而不是decode_bmp、decode_jpeg和decode_png，后者返回3维数组[height, width, num_channels]。如果您使用BMP、JPEG或PNG文件混合GIF文件，请确保在构造图表时考虑到这一点。
**参数：**
contents：0-D string，编码的图像字节。
channels：可选的int，默认为0，解码图像的颜色通道数量。
name：操作的名称（可选）
**返回值：**
对于BMP、JPEG和PNG图像，形状为[height, width, num_channels]或者对于GIF图像，形状为[num_frames, height, width, 3]的类型为uint8的Tensor。
**可能引发的异常：**
ValueError：通道数量不正确。
**5.TensorFlow将raw格式转换为张量**
**tf.decode_raw函数**
```python
decode_raw （
```
```python
bytes
```
```python
， 
    out_type ， 
    little_endian
```
```python
=
```
```python
None
```
```python
， 
    name
```
```python
=
```
```python
None
```
```python
）
```
将字符串的字节重新解释为数字的向量。
**ARGS：**
bytes：字符串类型的张量。所有元素的长度必须相同。
out_type：一个选自：tf.half，tf.float32，tf.float64，tf.int32，tf.uint8，tf.int16，tf.int8 以及 tf.int64 的 tf.DType 。
little_endian：可选的 bool 值，默认为 True。输入字节是否为小字节顺序。忽略存储在单个字节 (如 uint8) 中的 out_type 值。
name：操作的名称（可选）。
**返回：**
out_type 类型的张量。一个比输入字节多一个维度的张量。添加的维度的大小将等于字节的元素的长度除以要表示 out_type 的字节数。
---
**总结：**
除了opencv读入的彩色图片以BGR顺序存储外，其他所有图像库读入彩色图片都以RGB存储。
除了PIL读入的图片是img类之外，其他库读进来的图片都是以numpy 矩阵。
**参考**：
[https://www.cnblogs.com/skyfsm/p/8276501.html](https://www.cnblogs.com/skyfsm/p/8276501.html)
[https://www.w3cschool.cn/tensorflow_python/](https://www.w3cschool.cn/tensorflow_python/)
---

###### 注：博众家之所长，集群英之荟萃。

