
# Pytorch的mean和std调查 - 机器学习的小学生 - CSDN博客


2018年07月10日 10:50:34[机器学习的小学生](https://me.csdn.net/xuluhui123)阅读数：1417



```python
# coding: utf-8
```
```python
from
```
```python
__future__
```
```python
import
```
```python
print_function
```
```python
import
```
```python
copy
```
```python
import
```
```python
click
```
```python
import
```
```python
cv2
```
```python
import
```
```python
numpy
```
```python
as
```
```python
np
```
```python
import
```
```python
torch
```
```python
from
```
```python
torch.autograd
```
```python
import
```
```python
Variable
```
```python
from
```
```python
torchvision
```
```python
import
```
```python
models, transforms
```
```python
import
```
```python
matplotlib.pyplot
```
```python
as
```
```python
plt
```
```python
import
```
```python
load_caffemodel
```
```python
import
```
```python
scipy.io
```
```python
as
```
```python
sio
```
```python
# if model has LSTM
```
```python
# torch.backends.cudnn.enabled = False
```
```python
imgpath =
```
```python
'D:/ck/files_detected_face224/'
```
```python
imgname =
```
```python
'S055_002_00000025.png'
```
```python
# anger
```
```python
image_path = imgpath + imgname
mean_file = [
```
```python
0.485
```
```python
,
```
```python
0.456
```
```python
,
```
```python
0.406
```
```python
]
std_file  = [
```
```python
0.229
```
```python
,
```
```python
0.224
```
```python
,
```
```python
0.225
```
```python
]
raw_image = cv2.imread(image_path)[..., ::-
```
```python
1
```
```python
]
print(raw_image.shape)
raw_image = cv2.resize(raw_image, (
```
```python
224
```
```python
, ) *
```
```python
2
```
```python
)
image = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(
        mean=mean_file,
        std =std_file,
```
```python
#mean = mean_file,
```
```python
#std = std_file,
```
```python
)
])(raw_image).unsqueeze(
```
```python
0
```
```python
)
print(image.shape)
convert_image1 = image.numpy()
convert_image1 = np.squeeze(convert_image1)
```
```python
# 3* 224 *224, C * H * W
```
```python
convert_image1 = convert_image1 * np.reshape(std_file,(
```
```python
3
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
)) + np.reshape(mean_file,(
```
```python
3
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
))
convert_image1 = np.transpose(convert_image1, (
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
))
```
```python
# H * W * C
```
```python
print(convert_image1.shape)
convert_image1 = convert_image1 *
```
```python
255
```
```python
diff = raw_image - convert_image1
err  = np.max(diff)
print(err)
plt.imshow(np.uint8(convert_image1))
plt.show()
```
结论：
```python
input_image
```
```python
=
```
```python
(raw_image / 255 - mean) ./ std
```
下面调查均值文件和方差文件是如何生成的：
```python
mean_file =
```
```python
[
```
```python
0.485
```
```python
,
```
```python
0.456
```
```python
,
```
```python
0.406
```
```python
]
```
```python
std_file  =
```
```python
[
```
```python
0.229
```
```python
,
```
```python
0.224
```
```python
,
```
```python
0.225
```
```python
]
```
```python
# coding: utf-8
```
```python
import
```
```python
matplotlib.pyplot
```
```python
as
```
```python
plt
```
```python
import
```
```python
argparse
```
```python
import
```
```python
os
```
```python
import
```
```python
numpy
```
```python
as
```
```python
np
```
```python
import
```
```python
torchvision
```
```python
import
```
```python
torchvision.transforms
```
```python
as
```
```python
transforms
dataset_names = (
```
```python
'cifar10'
```
```python
,
```
```python
'cifar100'
```
```python
,
```
```python
'mnist'
```
```python
)
parser = argparse.ArgumentParser(description=
```
```python
'PyTorchLab'
```
```python
)
parser.add_argument(
```
```python
'-d'
```
```python
,
```
```python
'--dataset'
```
```python
, metavar=
```
```python
'DATA'
```
```python
, default=
```
```python
'cifar10'
```
```python
, choices=dataset_names,
                    help=
```
```python
'dataset to be used: '
```
```python
+
```
```python
' | '
```
```python
.join(dataset_names) +
```
```python
' (default: cifar10)'
```
```python
)
args = parser.parse_args()
data_dir = os.path.join(
```
```python
'.'
```
```python
, args.dataset)
print(args.dataset)
args.dataset =
```
```python
'cifar10'
```
```python
if
```
```python
args.dataset ==
```
```python
"cifar10"
```
```python
:
    train_transform = transforms.Compose([transforms.ToTensor()])
    train_set = torchvision.datasets.CIFAR10(root=data_dir, train=
```
```python
True
```
```python
, download=
```
```python
True
```
```python
, transform=train_transform)
```
```python
#print(vars(train_set))
```
```python
print(train_set.train_data.shape)
    print(train_set.train_data.mean(axis=(
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
))/
```
```python
255
```
```python
)
    print(train_set.train_data.std(axis=(
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
))/
```
```python
255
```
```python
)
```
```python
# imshow image
```
```python
train_data = train_set.train_data
    ind =
```
```python
100
```
```python
img0 = train_data[ind,...]
```
```python
## test channel number, in total , the correct channel is : RGB,not like BGR in caffe
```
```python
# error produce
```
```python
#b,g,r=cv2.split(img0)
```
```python
#img0=cv2.merge([r,g,b])
```
```python
print(img0.shape)
    print(type(img0))
    plt.imshow(img0)
    plt.show()
```
```python
# in ship in sea
```
```python
#img0 = cv2.resize(img0,(224,224))
```
```python
#cv2.imshow('img0',img0)
```
```python
#cv2.waitKey()
```
```python
elif
```
```python
args.dataset ==
```
```python
"cifar100"
```
```python
:
    train_transform = transforms.Compose([transforms.ToTensor()])
    train_set = torchvision.datasets.CIFAR100(root=data_dir, train=
```
```python
True
```
```python
, download=
```
```python
True
```
```python
, transform=train_transform)
```
```python
#print(vars(train_set))
```
```python
print(train_set.train_data.shape)
    print(np.mean(train_set.train_data, axis=(
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
))/
```
```python
255
```
```python
)
    print(np.std(train_set.train_data, axis=(
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
))/
```
```python
255
```
```python
)
```
```python
elif
```
```python
args.dataset ==
```
```python
"mnist"
```
```python
:
    train_transform = transforms.Compose([transforms.ToTensor()])
    train_set = torchvision.datasets.MNIST(root=data_dir, train=
```
```python
True
```
```python
, download=
```
```python
True
```
```python
, transform=train_transform)
```
```python
#print(vars(train_set))
```
```python
print(list(train_set.train_data.size()))
    print(train_set.train_data.float().mean()/
```
```python
255
```
```python
)
    print(train_set.train_data.float().std()/
```
```python
255
```
```python
)
```
结果：
```python
cifar1
```
```python
0
```
```python
Files
```
```python
already downloaded
```
```python
and
```
```python
verified
(
```
```python
50000
```
```python
,
```
```python
32
```
```python
,
```
```python
32
```
```python
,
```
```python
3
```
```python
)
[
```
```python
0
```
```python
.
```
```python
49139968
```
```python
0
```
```python
.
```
```python
48215841
```
```python
0
```
```python
.
```
```python
44653091
```
```python
]
[
```
```python
0
```
```python
.
```
```python
24703223
```
```python
0
```
```python
.
```
```python
24348513
```
```python
0
```
```python
.
```
```python
26158784
```
```python
]
(
```
```python
32
```
```python
,
```
```python
32
```
```python
,
```
```python
3
```
```python
)
<
```
```python
class
```
```python
'
```
```python
numpy
```
```python
.
```
```python
ndarray
```
```python
'>
```
使用matlab检测是如何计算mean_file和std_file的：
```python
% load cifar10 dataset
```
```python
data = load(
```
```python
'cifar10_train_data.mat'
```
```python
);
train_data =
```
```python
data.
```
```python
train_data;
```
```python
disp
```
```python
(
```
```python
size
```
```python
(train_data));
temp = mean(train_data,
```
```python
1
```
```python
);
```
```python
disp
```
```python
(
```
```python
size
```
```python
(temp));
train_data = double(train_data);
```
```python
% compute mean_file
```
```python
mean_val = mean(mean(mean(train_data,
```
```python
1
```
```python
),
```
```python
2
```
```python
),
```
```python
3
```
```python
)/
```
```python
255
```
```python
;
```
```python
% compute std_file
```
```python
temp1 = train_data(:,:,:,
```
```python
1
```
```python
);
std_val1  = std(temp1(:))/
```
```python
255
```
```python
;
temp2 = train_data(:,:,:,
```
```python
2
```
```python
);
std_val2 = std(temp2(:))/
```
```python
255
```
```python
;
temp3 = train_data(:,:,:,
```
```python
3
```
```python
);
std_val3 = std(temp3(:))/
```
```python
255
```
```python
;
mean_val =
```
```python
squeeze
```
```python
(mean_val);
std_val  =
```
```python
[std_val1, std_val2, std_val3]
```
```python
;
```
```python
disp
```
```python
(mean_val);
```
```python
disp
```
```python
(std_val);
```
```python
% result: mean_val: [0.4914, 0.4822, 0.4465]
```
```python
%          std_val: [0.2470, 0.2435, 0.2616]
```
均值计算的过程也可以遵循标准差的计算过程。为 了简单，例如对于一个矩阵，所有元素的均值，等于两个方向上先后均值。所以会直接采用如下的形式：
```python
mean_val
```
```python
=
```
```python
mean(mean(mean(train_data,1),2),3)/255;
```
标准差的计算是每一个通道的对所有样本的求标准差。然后再除以255。

