
# Head Pose in AFLW dataset - 机器学习的小学生 - CSDN博客


2018年09月01日 22:13:06[机器学习的小学生](https://me.csdn.net/xuluhui123)阅读数：345


理解AFLW数据集提供的头部姿态角度。
```python
close all;
close all;
dbpath =
```
```python
'../data/'
```
```python
;
dbfile =
```
```python
'aflw.sqlite'
```
```python
;
model3d = createMeanFace3DModel(fullfile(dbpath,dbfile));
```
```python
% get one face_id
```
```python
mksqlite(
```
```python
'open'
```
```python
,fullfile(dbpath,dbfile));
fidQuery =
```
```python
'SELECT face_id FROM Faces LIMIT 100'
```
```python
;
res = mksqlite(fidQuery);
mksqlite(
```
```python
'close'
```
```python
);
face_id = res(
```
```python
3
```
```python
).face_id;
```
```python
% or alternatively select one here
```
```python
%face_id = 39341;
```
```python
facedata = getFaceDataFromSQLite(
```
```python
[dbpath dbfile]
```
```python
,face_id);
```
```python
%
```
```python
headpose =
```
```python
facedata.
```
```python
pose;
landmark =
```
```python
facedata.
```
```python
pts;
imgpath =
```
```python
facedata.
```
```python
image.
```
```python
filepath;
```
```python
disp
```
```python
(
```
```python
[
```
```python
'headpose: '
```
```python
]
```
```python
);
```
```python
disp
```
```python
(headpose);
feature2dNames = fieldnames(
```
```python
facedata.
```
```python
pts);
num2dPts =
```
```python
size
```
```python
(feature2dNames,
```
```python
1
```
```python
);
pts2d =
```
```python
zeros
```
```python
(num2dPts,
```
```python
2
```
```python
);
pts3d =
```
```python
zeros
```
```python
(num2dPts,
```
```python
3
```
```python
);
```
```python
for
```
```python
i
```
```python
=
```
```python
1
```
```python
:num2dPts
    fn = feature2dNames
```
```python
{i}
```
```python
;
```
```python
if
```
```python
isfield(model3d,fn)
        pts3d(
```
```python
i
```
```python
,:) =
```
```python
model3d.
```
```python
(fn);
        pts2d(
```
```python
i
```
```python
,:) =
```
```python
facedata.
```
```python
pts.
```
```python
(fn);
```
```python
else
```
```python
fprintf(
```
```python
'Error: "%s" is not a feature name in the 3D model\n'
```
```python
,fn);
```
```python
end
```
```python
end
```
```python
% show 3d model
```
```python
%show3DModel(model3d);
```
```python
camera = struct();
```
```python
camera.
```
```python
center =
```
```python
[facedata.image.width/
```
```python
2
```
```python
facedata.image.height/
```
```python
2
```
```python
]
```
```python
;
```
```python
camera.
```
```python
viewPlaneDistance =
```
```python
1.5
```
```python
*
```
```python
facedata.
```
```python
image.
```
```python
width;
```
```python
% web site: http://legacydirs.umiacs.umd.edu/~daniel/Site_2/Code.html
```
```python
[rot1,trans1]
```
```python
= modernPosit(pts2d,pts3d,
```
```python
camera.
```
```python
viewPlaneDistance,
```
```python
camera.
```
```python
center);
```
```python
[rot2,trans2]
```
```python
= classicPosit(pts2d,pts3d,
```
```python
camera.
```
```python
viewPlaneDistance,
```
```python
camera.
```
```python
center);
```
```python
% call modernPosit in this function
```
```python
[rot,trans]
```
```python
= calculateTransformation(camera,pts2d,pts3d,
```
```python
facedata.
```
```python
pose,true);
```
```python
%%%%% version1: matlab function the default order: ZYX %%%%%
```
```python
% roll, yaw , pitch ?
```
```python
ruler = rotm2eul(rot);
ruler_angle1 =
```
```python
[ruler(
```
```python
3
```
```python
) ruler(
```
```python
2
```
```python
) ruler(
```
```python
1
```
```python
)]
```
```python
;
```
```python
%%%%%%%%%%%% version2: %%%%%%%%%%%%%%%%%%
```
```python
% pitch, yaw, roll
```
```python
ruler_angle2 = RotMat2Euler(rot);
```
```python
%%%%%%%%%%%%%%%%%%%  version3 %%%%%%%%%%%%%%
```
```python
% refer to: [从旋转矩阵计算欧拉角] deep studio
```
```python
ruler_angle3 = rotationMatrix2eulerAngles(rot);
```
```python
%%%%%%%%%%%%%%%%%%%%%%%%%  version4 %%%%%%%%%%%%%%%%%%%%%%
```
```python
% refer to: https://stackoverflow.com/questions/15022630/how-to-calculate-the-angle-from-rotation-matrix
```
```python
thetax =
```
```python
atan2
```
```python
(rot(
```
```python
3
```
```python
,
```
```python
2
```
```python
),rot(
```
```python
3
```
```python
,
```
```python
3
```
```python
));
```
```python
% pitch
```
```python
thetay =
```
```python
atan2
```
```python
(-rot(
```
```python
3
```
```python
,
```
```python
1
```
```python
),
```
```python
sqrt
```
```python
(rot(
```
```python
3
```
```python
,
```
```python
2
```
```python
) * rot(
```
```python
3
```
```python
,
```
```python
2
```
```python
) + rot(
```
```python
3
```
```python
,
```
```python
3
```
```python
) * rot(
```
```python
3
```
```python
,
```
```python
3
```
```python
)));
```
```python
% yaw
```
```python
thetaz =
```
```python
atan2
```
```python
(rot(
```
```python
2
```
```python
,
```
```python
1
```
```python
),rot(
```
```python
1
```
```python
,
```
```python
1
```
```python
));
```
```python
% roll
```
```python
ruler_angle4 =
```
```python
[thetax thetay thetaz]
```
```python
;
```
```python
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
```
```python
% rotate model points
```
```python
rotPts = (rot*
```
```python
pts3d'
```
```python
+
```
```python
repmat
```
```python
(trans,
```
```python
[
```
```python
1
```
```python
num2dPts]
```
```python
))
```
```python
';
% project model points
projPts = [rotPts(:,1)./rotPts(:,3) rotPts(:,2)./rotPts(:,3)];
projPts = projPts .* camera.viewPlaneDistance + repmat(camera.center,[num2dPts 1]);
model_center = model3d.center_between_eyes;
%model_center = model3d.center_of_head;
rotCenter = (rot*model_center'
```
```python
+ trans)
```
```python
';
projCenter = [rotCenter(:,1)./rotCenter(:,3) rotCenter(:,2)./rotCenter(:,3)];
projCenter = projCenter .* camera.viewPlaneDistance + camera.center;
rotCenterUp = (rot*(model_center + [0 0.2 0])'
```
```python
+ trans)
```
```python
';
projCenterUp = [rotCenterUp(:,1)./rotCenterUp(:,3) rotCenterUp(:,2)./rotCenterUp(:,3)];
projCenterUp = projCenterUp .* camera.viewPlaneDistance + camera.center;
% show rotated, translated and projected 3d points
%im = imread(imgFile);
im = imread([dbpath facedata.image.db_id '
```
```python
/
```
```python
' facedata.image.filepath]);
disp(facedata.image.filepath);
figure;
imshow(im);
hold on;
showModel = false;
if showModel
    % show whole model
    myworld = vrworld('
```
```python
meanFaceSimplified.
```
```python
wrl'
```
```python
);
    open(myworld);
    view(myworld);
    hold on;
    x = get(myworld);
```
```python
% add my code
```
```python
tmp_debug =
```
```python
x.
```
```python
Nodes(
```
```python
1
```
```python
);
```
```python
%
```
```python
tmp_debug =
```
```python
zeros
```
```python
(
```
```python
1
```
```python
,
```
```python
3
```
```python
);
    tmp_debug(
```
```python
1
```
```python
,:) =
```
```python
model3d.
```
```python
LeftBrowLeftCorner;
```
```python
%
```
```python
%model_pts = x.Nodes(1).point;
```
```python
model_pts = tmp_debug;
    numMPts =
```
```python
size
```
```python
(model_pts,
```
```python
1
```
```python
);
```
```python
% rotate model points
```
```python
rotMPts = (rot*
```
```python
model_pts'
```
```python
+
```
```python
repmat
```
```python
(trans,
```
```python
[
```
```python
1
```
```python
numMPts]
```
```python
))
```
```python
';
    % project model points
    projMPts = [rotMPts(:,1)./rotMPts(:,3) rotMPts(:,2)./rotMPts(:,3)];
    projMPts = projMPts .* camera.viewPlaneDistance + repmat(camera.center,[numMPts 1]);
    plot(projMPts(:,1),projMPts(:,2),'
```
```python
y.'
```
```python
);
    close(myworld);
```
```python
end
```
```python
plot(projPts(
```
```python
1
```
```python
:
```
```python
end
```
```python
,
```
```python
1
```
```python
),projPts(
```
```python
1
```
```python
:
```
```python
end
```
```python
,
```
```python
2
```
```python
),
```
```python
'r.'
```
```python
);
plot(projCenter(
```
```python
1
```
```python
),projCenter(
```
```python
2
```
```python
),
```
```python
'go'
```
```python
);
plot(projCenterUp(
```
```python
1
```
```python
),projCenterUp(
```
```python
2
```
```python
),
```
```python
'bo'
```
```python
);
plot(pts2d(:,
```
```python
1
```
```python
),pts2d(:,
```
```python
2
```
```python
),
```
```python
'b.'
```
```python
);
```
```python
for
```
```python
i
```
```python
=
```
```python
1
```
```python
:num2dPts
    text(pts2d(
```
```python
i
```
```python
,
```
```python
1
```
```python
)+
```
```python
10
```
```python
,pts2d(
```
```python
i
```
```python
,
```
```python
2
```
```python
),feature2dNames
```
```python
{i}
```
```python
,
```
```python
'Color'
```
```python
,
```
```python
'r'
```
```python
);
```
```python
end
```
```python
for
```
```python
i
```
```python
=
```
```python
1
```
```python
:num2dPts
    text(projPts(
```
```python
i
```
```python
,
```
```python
1
```
```python
)+
```
```python
10
```
```python
,projPts(
```
```python
i
```
```python
,
```
```python
2
```
```python
)+
```
```python
5
```
```python
,feature2dNames
```
```python
{i}
```
```python
,
```
```python
'Color'
```
```python
,
```
```python
'b'
```
```python
);
```
```python
end
```
```python
%set(gca,'YDir','reverse');
```
```python
%axis equal;
```
```python
tdx =
```
```python
[]
```
```python
;
tdy =
```
```python
[]
```
```python
;
imgsize =
```
```python
[facedata.image.height, facedata.image.width]
```
```python
;
```
```python
%draw_axis(im, headpose.yaw, headpose.pitch, headpose.roll, tdx, tdy, imgsize)
```
```python
modelCenterDist =
```
```python
sqrt
```
```python
(sum(
```
```python
rotCenter.
```
```python
^
```
```python
2
```
```python
));
cameraModel3dYAngle =
```
```python
atan
```
```python
(rotCenter(
```
```python
2
```
```python
)/
```
```python
sqrt
```
```python
(rotCenter(
```
```python
3
```
```python
)^
```
```python
2
```
```python
+ rotCenter(
```
```python
1
```
```python
)^
```
```python
2
```
```python
));
cameraModel3dXAngle =
```
```python
atan
```
```python
(rotCenter(
```
```python
1
```
```python
)/
```
```python
sqrt
```
```python
(rotCenter(
```
```python
3
```
```python
)^
```
```python
2
```
```python
+ rotCenter(
```
```python
2
```
```python
)^
```
```python
2
```
```python
));
sphereCenterBorderAngle =
```
```python
asin
```
```python
(
```
```python
model3d.
```
```python
sphereRadius/modelCenterDist);
sphereProjTop    =
```
```python
tan
```
```python
(cameraModel3dYAngle - sphereCenterBorderAngle)*
```
```python
camera.
```
```python
viewPlaneDistance;
sphereProjBottom =
```
```python
tan
```
```python
(cameraModel3dYAngle + sphereCenterBorderAngle)*
```
```python
camera.
```
```python
viewPlaneDistance;
sphereProjLeft   =
```
```python
tan
```
```python
(cameraModel3dXAngle - sphereCenterBorderAngle)*
```
```python
camera.
```
```python
viewPlaneDistance;
sphereProjRight  =
```
```python
tan
```
```python
(cameraModel3dXAngle + sphereCenterBorderAngle)*
```
```python
camera.
```
```python
viewPlaneDistance;
sphereProjTop    = sphereProjTop +
```
```python
camera.
```
```python
center(
```
```python
2
```
```python
);
sphereProjBottom = sphereProjBottom +
```
```python
camera.
```
```python
center(
```
```python
2
```
```python
);
sphereProjLeft   = sphereProjLeft +
```
```python
camera.
```
```python
center(
```
```python
1
```
```python
);
sphereProjRight  = sphereProjRight +
```
```python
camera.
```
```python
center(
```
```python
1
```
```python
);
plot(projCenter(
```
```python
1
```
```python
),sphereProjTop,
```
```python
'g.'
```
```python
)
plot(projCenter(
```
```python
1
```
```python
),sphereProjBottom,
```
```python
'g.'
```
```python
)
plot(sphereProjLeft,projCenter(
```
```python
2
```
```python
),
```
```python
'g.'
```
```python
)
plot(sphereProjRight,projCenter(
```
```python
2
```
```python
),
```
```python
'g.'
```
```python
)
```
```python
% rectangle
```
```python
targetCenter =
```
```python
[
```
```python
64
```
```python
37
```
```python
]
```
```python
;
```
```python
% all faces are centered on this point
```
```python
w_out =
```
```python
128
```
```python
;
h_out =
```
```python
128
```
```python
;
normEyeDist =
```
```python
50.0
```
```python
;
scale = max(sphereProjBottom-sphereProjTop,sphereProjRight-sphereProjLeft)/normEyeDist;
x = projCenter(
```
```python
1
```
```python
) - targetCenter(
```
```python
1
```
```python
)*scale;
y = projCenter(
```
```python
2
```
```python
) - targetCenter(
```
```python
2
```
```python
)*scale;
r =
```
```python
[x y w_out*scale h_out*scale]
```
```python
;
rectangle(
```
```python
'Position'
```
```python
,r,
```
```python
'LineWidth'
```
```python
,
```
```python
2
```
```python
,
```
```python
'EdgeColor'
```
```python
,
```
```python
'b'
```
```python
);
img = im(r(
```
```python
2
```
```python
):min(r(
```
```python
2
```
```python
)+r(
```
```python
4
```
```python
),
```
```python
size
```
```python
(im,
```
```python
1
```
```python
)),r(
```
```python
1
```
```python
):min(r(
```
```python
1
```
```python
)+r(
```
```python
3
```
```python
),
```
```python
size
```
```python
(im,
```
```python
2
```
```python
)),:);
imgsize =
```
```python
[size(img,
```
```python
1
```
```python
),size(img,
```
```python
2
```
```python
)]
```
```python
;
figure;
imshow(img);
```
```python
%draw_axis(img, headpose.yaw * 180/pi, headpose.pitch* 180/pi, headpose.roll* 180/pi, tdx, tdy, imgsize)
```
```python
%draw_axis(img, ruler_angles(3), ruler_angles(2), ruler_angles(1), tdx, tdy, imgsize)
```
```python
% error: draw_axis(img, ruler(3), ruler(2), ruler(1), tdx, tdy, imgsize)
```
```python
disp
```
```python
(
```
```python
'yaw, pitch ,roll for ruler_angle0: AFLW提供！'
```
```python
);
```
```python
disp
```
```python
(
```
```python
[headpose.yaw *
```
```python
180
```
```python
/pi,headpose.pitch*
```
```python
180
```
```python
/pi,headpose.roll*
```
```python
180
```
```python
/pi]
```
```python
);
```
```python
% for ruler_angle1
```
```python
% the following computing , refer to : Face-Yaw-Roll-Pitch-from-Pose-Estimation-using-OpenCV-master
```
```python
pitch = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle1(
```
```python
1
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
roll = -(
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle1(
```
```python
3
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
yaw = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle1(
```
```python
2
```
```python
)))) *
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
```
```python
disp
```
```python
(
```
```python
'yaw, pitch ,roll for ruler_angle1: 近似！'
```
```python
);
```
```python
disp
```
```python
(
```
```python
[yaw, pitch, roll]
```
```python
);
```
```python
% for ruler_angle2
```
```python
pitch = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle2(
```
```python
1
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
roll = -(
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle2(
```
```python
3
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
yaw = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle2(
```
```python
2
```
```python
)))) *
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
```
```python
disp
```
```python
(
```
```python
'yaw, pitch ,roll for ruler_angle2: 有点问题！'
```
```python
);
```
```python
disp
```
```python
(
```
```python
[yaw, pitch, roll]
```
```python
);
```
```python
% for ruler_angle3
```
```python
pitch = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle3(
```
```python
1
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
roll = -(
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle3(
```
```python
3
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
yaw = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle3(
```
```python
2
```
```python
)))) *
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
```
```python
disp
```
```python
(
```
```python
'yaw, pitch ,roll for ruler_angle3: 近似！'
```
```python
);
```
```python
disp
```
```python
(
```
```python
[yaw, pitch, roll]
```
```python
);
```
```python
% for ruler_angle4
```
```python
pitch = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle4(
```
```python
1
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
roll = -(
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle4(
```
```python
3
```
```python
))))*
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
yaw = (
```
```python
asin
```
```python
(
```
```python
sin
```
```python
(ruler_angle4(
```
```python
2
```
```python
)))) *
```
```python
180
```
```python
/
```
```python
pi
```
```python
;
```
```python
disp
```
```python
(
```
```python
'yaw, pitch ,roll for ruler_angle4: 近似！'
```
```python
);
```
```python
disp
```
```python
(
```
```python
[yaw, pitch, roll]
```
```python
);

draw_axis(img, yaw, pitch, roll, tdx, tdy, imgsize)
```
```python
disp
```
```python
(
```
```python
''
```
```python
);
```
```python
function
```
```python
Eul
```
```python
=
```
```python
RotMat2Euler
```
```python
(R)
```
```python
% Version 1.000
```
```python
%
```
```python
% Code provided by Graham Taylor, Geoff Hinton and Sam Roweis
```
```python
%
```
```python
% For more information, see:
```
```python
%     http://www.cs.toronto.edu/~gwtaylor/publications/nips2006mhmublv
```
```python
%
```
```python
% Permission is granted for anyone to copy, use, modify, or distribute this
```
```python
% program and accompanying programs and documents for any purpose, provided
```
```python
% this copyright notice is retained and prominently displayed, along with
```
```python
% a note saying that the original programs are available from our
```
```python
% web page.
```
```python
% The programs and documents are distributed without any warranty, express or
```
```python
% implied.  As the programs were written for research purposes only, they have
```
```python
% not been tested to the degree that would be advisable in any important
```
```python
% application.  All use of these programs is entirely at the user's own
```
```python
% risk.
```
```python
%
```
```python
% Finds one of two equivalent Euler angle representations for a Direction
```
```python
% Cosine Matrix
```
```python
% Assumes the DCM is in 'zyx' order
```
```python
% Given R, the rotation matrix
```
```python
% Returns a vector of Euler angles (in radians)
```
```python
%  the first about x axis, the second about y axis, the third about z axis
```
```python
% Based on an article by Gregory G. Slabaugh
```
```python
%
```
```python
% Usage Eul = RotMat2Euler(R)
```
```python
%Note we need to treat the case of cos(E2) = +- pi/2 separately
```
```python
%This corresponds to element R(1,3) = +- 1
```
```python
if
```
```python
R(
```
```python
1
```
```python
,
```
```python
3
```
```python
) ==
```
```python
1
```
```python
| R(
```
```python
1
```
```python
,
```
```python
3
```
```python
) == -
```
```python
1
```
```python
%special case
```
```python
E3 =
```
```python
0
```
```python
;
```
```python
%set arbitrarily
```
```python
dlta =
```
```python
atan2
```
```python
(R(
```
```python
1
```
```python
,
```
```python
2
```
```python
),R(
```
```python
1
```
```python
,
```
```python
3
```
```python
));
```
```python
if
```
```python
R(
```
```python
1
```
```python
,
```
```python
3
```
```python
) == -
```
```python
1
```
```python
E2 =
```
```python
pi
```
```python
/
```
```python
2
```
```python
;
    E1 = E3 + dlta;
```
```python
else
```
```python
E2 = -
```
```python
pi
```
```python
/
```
```python
2
```
```python
;
    E1 = -E3 + dlta;
```
```python
end
```
```python
else
```
```python
E2 = -
```
```python
asin
```
```python
(R(
```
```python
1
```
```python
,
```
```python
3
```
```python
));
  E1 =
```
```python
atan2
```
```python
(R(
```
```python
2
```
```python
,
```
```python
3
```
```python
)/
```
```python
cos
```
```python
(E2), R(
```
```python
3
```
```python
,
```
```python
3
```
```python
)/
```
```python
cos
```
```python
(E2));
  E3 =
```
```python
atan2
```
```python
(R(
```
```python
1
```
```python
,
```
```python
2
```
```python
)/
```
```python
cos
```
```python
(E2), R(
```
```python
1
```
```python
,
```
```python
1
```
```python
)/
```
```python
cos
```
```python
(E2));
```
```python
end
```
```python
Eul =
```
```python
[E1 E2 E3]
```
```python
;
```
```python
end
```
```python
function
```
```python
eulerAngles
```
```python
=
```
```python
rotationMatrix2eulerAngles
```
```python
(R)
```
```python
% eulerAngles = rotationMatrix2eulerAngles(R)
```
```python
%
```
```python
% This function returns the rotation angles in degrees about the x, y and z axis for a
```
```python
% given rotation matrix
```
```python
%
```
```python
% Copyright : This code is written by david zhao from SCUT,1257650237@qq,com. The code
```
```python
%              may be used, modified and distributed for research purposes with
```
```python
%              acknowledgement of the author and inclusion this copyright information.
```
```python
%
```
```python
% Disclaimer : This code is provided as is without any warrantly.
```
```python
if
```
```python
abs
```
```python
(R(
```
```python
3
```
```python
,
```
```python
1
```
```python
)) ~=
```
```python
1
```
```python
theta1 = -
```
```python
asin
```
```python
(R(
```
```python
3
```
```python
,
```
```python
1
```
```python
));
    theta2 =
```
```python
pi
```
```python
- theta1;
    psi1 =
```
```python
atan2
```
```python
(R(
```
```python
3
```
```python
,
```
```python
2
```
```python
)/
```
```python
cos
```
```python
(theta1), R(
```
```python
3
```
```python
,
```
```python
3
```
```python
)/
```
```python
cos
```
```python
(theta1));
    psi2 =
```
```python
atan2
```
```python
(R(
```
```python
3
```
```python
,
```
```python
2
```
```python
)/
```
```python
cos
```
```python
(theta2), R(
```
```python
3
```
```python
,
```
```python
3
```
```python
)/
```
```python
cos
```
```python
(theta2));
    pfi1 =
```
```python
atan2
```
```python
(R(
```
```python
2
```
```python
,
```
```python
1
```
```python
)/
```
```python
cos
```
```python
(theta1), R(
```
```python
1
```
```python
,
```
```python
1
```
```python
)/
```
```python
cos
```
```python
(theta1));
    pfi2 =
```
```python
atan2
```
```python
(R(
```
```python
2
```
```python
,
```
```python
1
```
```python
)/
```
```python
cos
```
```python
(theta2), R(
```
```python
1
```
```python
,
```
```python
1
```
```python
)/
```
```python
cos
```
```python
(theta2));
    theta = theta1;
```
```python
% could be any one of the two
```
```python
psi
```
```python
= psi1;
    pfi = pfi1;
```
```python
else
```
```python
phi =
```
```python
0
```
```python
;
    delta =
```
```python
atan2
```
```python
(R(
```
```python
1
```
```python
,
```
```python
2
```
```python
), R(
```
```python
1
```
```python
,
```
```python
3
```
```python
));
```
```python
if
```
```python
R(
```
```python
3
```
```python
,
```
```python
1
```
```python
) == -
```
```python
1
```
```python
theta =
```
```python
pi
```
```python
/
```
```python
2
```
```python
;
```
```python
psi
```
```python
= phi + delta;
```
```python
else
```
```python
theta = -
```
```python
pi
```
```python
/
```
```python
2
```
```python
;
```
```python
psi
```
```python
= -phi + delta;
```
```python
end
```
```python
end
```
```python
%psi is along x-axis...........theta is along y-axis........pfi is along z
```
```python
%axis
```
```python
eulerAngles =
```
```python
[psi theta pfi]
```
```python
;
```
```python
%for rad;
```
```python
%eulerAngles = [psi*180/pi theta*180/pi pfi*180/pi]; %for degree;
```
```python
end
```
结果：
```python
yaw, pitch ,
```
```python
roll
```
```python
for
```
```python
ruler_angle0: AFLW提供！
  -
```
```python
26.1218
```
```python
-
```
```python
13.7720
```
```python
-
```
```python
0.3973
```
```python
yaw, pitch ,
```
```python
roll
```
```python
for
```
```python
ruler_angle1: 近似！
  -
```
```python
23.2682
```
```python
-
```
```python
14.2231
```
```python
-
```
```python
0.3835
```
```python
yaw, pitch ,
```
```python
roll
```
```python
for
```
```python
ruler_angle2: 有点问题！
  -
```
```python
25.5304
```
```python
15.0904
```
```python
-
```
```python
2.5019
```
```python
yaw, pitch ,
```
```python
roll
```
```python
for
```
```python
ruler_angle3: 近似！
  -
```
```python
24.1540
```
```python
-
```
```python
14.2231
```
```python
-
```
```python
0.3835
```
```python
yaw, pitch ,
```
```python
roll
```
```python
for
```
```python
ruler_angle4: 近似！
  -
```
```python
24.2173
```
```python
-
```
```python
14.2231
```
```python
-
```
```python
0.3835
```

