
# 一小时神经网络从入门到精通(放弃) - 喜欢打酱油的老鸟 - CSDN博客


2018年08月11日 11:37:54[喜欢打酱油的老鸟](https://me.csdn.net/weixin_42137700)阅读数：341


[http://blog.itpub.net/31077337/viewspace-2156393/](http://blog.itpub.net/31077337/viewspace-2156393/)
本文主要是学习BP神经网络的一个总结，其本身也是机器学习中比较基础、适合入门的模型。
目前本人对于机器学习也还只是入门状态，对于很多名词仍然是一知半解(感觉机器学习中的很多术语本身也是模棱两可的)，对于很多公式也是不求甚解，因此这篇文章是尝试用自己的语言和理解来复述所学习到的知识，如果有错误之处还望大牛们不吝斧正。
霍金说过每多一个数学公式，就会少一半的读者，因此这里也会尽量少用公式，要用也只用简单易懂的公式。而且个人觉得神经网络中的很多公式是可以感性地去认识的，能完全明白推导过程自然最好，但在不求甚解的状态下能达到感性的认知也未必不是一个快速掌握的好方法。
另外本文中用到了不少矩阵相关的知识，忘记了的同学可以看附录中的整理。
**神经元与激励函数**
**神经元**
神经元是神经网络的基本组成，如果把它画出来，大概就长成下面这样：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/4cd18cdff7592385.png)
图中神经元左边的x表示对神经元的多个输入，w表示每个输入对应的权重，神经元右边的箭头表示它仅有一个输出。
当然神经元也有很多种，下面介绍两种比较基础的。
神经元1：感知器
神经网络技术起源于上世纪五、六十年代，当时叫感知机(perceptron)，其中的单个神经元我们可以叫作感知器。感知器的特点具有浓厚的时代气息：其输入输出都是二进制形式的(据说由于计算技术的落后，当时感知器传输函数是用线拉动变阻器改变电阻的方法机械实现的)。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/595485d7dc1b5de5.png)
如上图所示，感知器有多个二进制输入(值只能是0或1)X1、X2..Xn，每个输入有对应的权值W1、W2..Wn(图中没画出来)，将每个输入值乘以对应的权值再求和( ∑XjWj )，然后与一个阈值(threshold) 比较，大于阈值则输出1、小于阈值则输出0。 写成公式的话如下：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/3c5ef633016a676b.png)
如果把公式写成矩阵形式，再用b来表示负数的阈值(即b=-threshold)，那就得到了如下公式：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/cc0285e866d8f84c.png)
举个栗子
例如你所在的城市将有一个你的偶像的演唱会，你正决定是否观看，你可能会通过以下三个方面来权衡你的决定：
天气好吗?
你的好基友是否愿意陪你去?
是否这个活动距离公共交通很近?(你自己没车)
我们将这三个因素用对应的二进制变量x1，x2和x3表示。比如，当天气还不错时，我们有x1=1，天气不好时x1=0;相似的，如果好基友愿意去，x2=1，否则x2=0;对于公共交通x3同理赋值。
然后根据你的意愿，比如让天气权重 w1=6，其他条件权重分别为w2=2，w3=2。权重w1值越大表示天气影响最大，比起好基友加入或者交通距离的影响都大。最后，假设你选择5做为感知器阈值(即b为-5)，按照这种选择，这个感知器就能实现这个决策模型：当天气好时候输出1，天气不好时候输出0，无论你的好基友是否愿意去，或者交通是否比较近。
神经元2：Sigmoid神经元
先来认识一个函数：Sigmoid函数，这个单词在某些工具上直译是“乙状结肠”、也还真有某些资料把Sigmoid神经元叫作乙状结肠神经元的。 其实它是一个常用的“S”型函数，可以把变量映射到(0,1)区间内，其公式如下：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/264a5190630f23b2.png)
它的函数图像是如下图如示的“S”型：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/6ba4a732452f5d12.png)
那么Sigmoid神经元是什么呢?与感知器有什么区别?
首先，在Sigmoid神经元中，输入的值不再是二进制，而是0到1之间的任意值。即Xi取值是0到1之间的任意实数。
其次，而Sigmoid神经元的输出也不再是0或1，而是 σ(wx+b)。 注意"wx+b"是简写(矩阵)形式，请对照上面的感知器的公式。
因此我们可以得出Sigmoid神经元的公式：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/f162851ddceab899.png)
可以发现当z=w?x+b是一个大的正数时，那么σ(z)≈1，而当z=w?x+b是一个很小的负数(“绝对值很大的负数”比较好理解)时，σ(z)≈0。处于这两种情况时，Sigmoid神经元的输出跟感知器是很接近的。只有当w?x+b在一个适度的值，sigmoid神经元和感知器偏差才较大。
激励函数
神经元的输入和输出之间具有函数关系，这个函数就称为激励函数。所以上面提到的Sigmoid函数就是激励函数的一种，感知器的那个函数也可以称为阈值(或阶跃)激励函数。
激励函数也叫点火规则，这使它与人脑的工作联系起来。当一个神经元的输入足够大时，就会点火，也就是从它的轴突(输出连接)发送电信号。同样，在人工神经网络中，只要输入超过一定标准时才会产生输出，这就是点火规则的思想。
神经网络的结构
神经网络简单地说就是将多个神经元连接起来、组成一个网络。 本文介绍的是最简单、历史悠久的一种：“多层感知机”(但我们讲的这个它里面的神经元并不是感知器、而是Sigmoid神经元，名词混乱+1)，或称之为“多层向前神经网络(Multilayer Feed-Forward Neural Network)”，它的特点是有多层(废话)，且神经元之间是全连接的，即后一层的神经元会连接到前一层的每个神经元(这里定义下从输入层到输出层为从“后”向“前”)。
一个多层感知机的示意图如下，网络的最左边一层被称为输入层，其中的神经元被称为输入神经元。最右边及输出层包含输出神经元，在这个例子中，只有一个单一的输出神经元，但一般情况下输出层也会有多个神经元。中间层被称为隐含层，因为里面的神经元既不是输入也不是输出。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/295ba4799f93a6df.png)
训练神经网络的意义
现在神经元有了，神经网络的结构也有了，现在回到核心的问题上来：我们拿神经网络干什么? 要怎样使它做到?
训练的目标
按照常识、用人话来说，神经网络的作用就是我们预先给它大量的数据(包含输入和输出)来进行训练，训练完成后，我们希望它对于将来的真实环境的输入也能给出一个令我们满意的输出。
损失函数/代价函数(Loss函数)
那么怎样用数学的方式来表示一个输出有多么令我们满意呢? 这里我们引入损失函数(或称代价函数、Loss函数)的概念。
现假设有n组包含了输入和真实结果(或称期望结果、期望输出)的样本数据，对于每组输入，我们的神经网络输出的结果记为fi，真实结果(期望结果)记为yi。
使用数学工具中的MAE(Mean Absolute Error,平均绝对误差)，可以非常直观地表达出输出结果和真实结果的偏差，因此我们可以用MAE来写出一个下面这样的Loss函数，Loss值越大、说明神经网络的输出结果越远离我们的期望。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/f162851ddceab899.png)
也可以用MSE(Mean Squared Error，均方误差)作为损失函数，MSE能更好地评价数据的变化程度，简单地说因为平方了一下、偏差是会被放大的。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/e8c3653464a7ff32.png)
将Sigmoid神经元的表达式f(x)=σ(wx+b)代入上面的损失函数中，可以发现x(输入)是固定的，yi(期望结果)也是固定的，让我们感性地想象一下：实际上影响Loss的只有w和b，而最重要的任务也就是寻找w和b使得Loss最小。
再具象一点，其实对神经网络进行训练的目的就是为每个神经元找到最适合它的w和b的值，从而使得整个神经网络的输出最接近我们的期望(说“最”其实有点违反广告法，神经网络最终达到的很难说是问题的最优解)。
注：下面将真正用到的损失函数
在实际中，为了方便求导，一般使用如下的Loss函数：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/b7588b2fc546ee01.png)
梯度下降
根据上面的结论，可以把损失(Loss)记作C，而C又只与w和b有关，那么可以看成C是一个关于w和b的函数，如下图所示。注意由于神经网络中其实有大量的“w”和“b”(回忆一下、每个神经元都有多个权重和一个阈值)，因此这里也需要感性的认知。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/7a970d8e8b4aa3fc.png)
如果把图画出来，它可能是下面这样的：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/9e850970a23ff941.png)
我们的目标是找到w和b使C最小，当然上面这张图很容易看出来合适的w和b在哪，但当面对更复杂的情况时、比如下图这样的，应该如何快速地找到C最小的点呢?
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/c57ddbc6b2933a.png)
这里我们引入梯度下降算法，原理很简单：把上图看作是一个丘陵地带，想象我们有一个球放在某个位置，让它“自然地向低处滚”，滚得越低，C就越小，我们就越高兴。
那么怎样使得它往低处滚呢? (注意这里要搬出全文中第一个比较烧脑的概念了) 微分法则告诉我们，当w移动Δw、b移动Δb时，有：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/3d511b4dceae083.png)
由于C表示的是损失，我们想让球往低处滚，当然是希望C不断变小，那ΔC应该恒为负，那么Δw、Δb应该如何取值呢? 梯度下降法是这么设计的：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/68740f05806bbc78.png)
可以看出如此取值可以使ΔC恒为负，其中的η称为学习率。
那么现在问题变成了?C/?w、?C/?b，即 C对w 和 C对b 的偏导，这两个鬼东西要怎么求?
反向传播
反向传播(back propagation)是在这种场景下快速求解?C/?w、?C/?b的算法，用了这个算法的多层感知机--也就是这篇文章讲的神经网络--也就叫作BP神经网络(名词混乱+1)。
这一章包含了比较复杂的公式推导过程，个人认为不了解其细节也没有关系、可以跳过这一章(只看“正向传播”一节就行)，只要知道有个经典的反向传播算法可以快速求解?C/?w、?C/?b，从而算出Δw和Δb，使得ΔC恒为负、即使得Loss越来越小即可。
正向传播
正向传播也可以叫作前馈(所以又有个前馈神经网络的词...)，正向传播就是指给神经网络的输入，然后一层一层向前计算输出，最终得到一个输出，这就是正向传播了。
推导前的基本定义
w、a、b的定义
我们使用 wljk 表示从 (l?1)th 层的 kth 个神经元到 (l)th 层的 jth 个神经元的链接上的权重。例如，下图给出了第二隐藏层的第四个神经元到第三隐藏层的第二个神经元的链接上的权重：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/f16f31234dbd6dde.png)
我们使用 blj 表示在 lth 层 jth 个神经元的偏差，使用 alj 表示 lth 层 jth 个神经元的激活值。下面的图清楚地解释了这样表示的含义：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/922afcb4d6357d3f.png)
基于上面的定义，可以写出关于单个神经元激活值alj的公式，其中sum(l-1)表示(l?1)th 层的神经元数量：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/21ef4d28af31f642.png)
上面w的表示方法或许很奇怪，但我们把它写成矩阵形式或许就能发现它的妙处了。用wl矩阵来表示第(l)th 层的w的值，用j作为行，k行为列，那么上面的神经网络中的w3就可以写成：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/1df94ae378d1bb50.png)
那么也可以用al矩阵来表示第(l)th 层的a的值，用j作为行，但只有一列，那么al其实是一个列向量。那么上面的a2可以写成下面非常形象的列向量形式：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/907cfe6782453e2.png)
同理，b3可以也可以写成一个列向量：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/258a50c9ae026820.png)
那么由上面的单个神经元激活值alj的公式，可以得出al矩阵的公式：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/87c09056d407cb14.png)
单个神经元的带权输入zlj
从上面的公式中可以提取出一个中间量zlj：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/a9f3e5ed9b3a1f30.png)
当然也可以简写成矩阵形式：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/78c8f4e7e5e21c72.png)
zlj其实就是第 l 层第 j 个神经元的激活函数带权输入。
单组数据的损失
前面介绍了损失函数，那么对于某一组输入，其损失(大写的“L”表示输出层)可以写作如下公式(这里比上面的Loss公式少了个n，因为这里只考虑一组输入，而上面的Loss设定是考虑n组数据)。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/e5dcf90384ec9d29.png)
这个公式同样可以写成矩阵的形式，这里用到了矩阵的模(可以看附录)，模的平方即为向量各元素的平方和。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/2bd8f013f8312ea2.png)
单个神经元的误差δlj测试
定义 l 层的第 jth 个神经元上的误差 δlj 为：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/8fffe941805ae5d2.png)
然后可以再推演两步：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/d9689eeb351a8715.png)
推导
输出层的误差矩阵
由上面的单个神经元误差公式，可以得出输出层误差矩阵公式(注意这里使用大写的“L”表示输出层，圆圈表示的Hadamard乘积可以看附录)：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/8b5344143965b7a7.png)
而由于我们采用的损失函数非常容易求出C对aL的导，所以公式可以进一步简化成：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/101006c013d874f2.png)
某一层的误差矩阵
首先推导下单个神经元误差δlj与下一层(l+1层)的关系：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/5cd777aa3e389e95.png)
上面推导中比较难理解的可能是累加k的由来，这是因为第lth层第jth个神经元会影响到第(l+1)th层的所有神经元，所以在反向计算偏导时需要考虑第(l+1)th层的所有神经元。
然后可以得出第lth层的误差矩阵(向量)δl的公式：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/94920f73f683b908.png)
这次变换出现了矩阵转置，可能也比较难以理解其由来。仔细观察上面wkj会发现其中的j与k的顺序与w的原始定义中的顺序发生了对调，这可以理解成转置的原因。自己拿一个示例演算一下也能发现从单个神经元误差到某层神经元的误差矩阵变换时的规律。
误差与权重w的关系
在得到了单个神经元的误差之后，再来看看误差与w的关系：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/9f53682bf768cc87.png)
和上节的推演一样，若写成矩阵，则是如下形式：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/b1882a332f771eaf.png)
误差与偏差b的关系
与上面w的推导过程一致，容易得到误差与b的关系：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/20f5340dc02ad2ff.png)
这个的矩阵形式就很简单了：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/d638e5bc3629f388.png)
总结
通过上面惨无人道的推导，可以发现在经过一次正向传播之后，可以通过输出层的误差、快速求解出C对每个w和b的偏导，即?C/?w、?C/?b，再对每个w和b加上Δw、Δb，从而使得“球往下滚”，C、即Loss越来越小，神经网络在朝着我们期望的方向进行调整。
BP神经网络的训练流程
基于上面的知识，我们现在可以总结出训练一个神经网络的全流程：
初始化神经网络，对每个神经元的w和b赋予随机值;
输入训练样本集合，对于每个样本，将输入给到神经网络的输入层，进行一次正向传播得到输出层各个神经元的输出值;
求出输出层的误差，再通过反向传播算法，向后求出每一层(的每个神经元)的误差;
通过误差可以得出每个神经元的?C/?w、?C/?b，再乘上负的学习率(-η)，就得到了Δw、Δb，将每个神经元的w和b更新为 w+Δw、b+Δb;
完成训练之后，一般情况下我们都能得到一个损失比较小的神经网络。
附录
矩阵
矩阵加法、减法
要求两个矩阵大小(行数、列数)相同，然后相同位置的元素相加/相减。
矩阵乘法
这个应该都还记得，即左边矩阵的一行乘上右边矩阵的一列，因此矩阵相乘要求左边矩阵的列数等于右边矩阵的行数。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_670x502/3209/2d6fe6ff48559e37.png)
转置
把矩阵A的行和列互相交换所产生的矩阵称为A的转置矩阵(即第m行第n列元素转为第n行第m列元素)，用符号T表示：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/41cfca9f060e6279.png)
向量
只有一行的矩阵称为行向量，只有一列的矩阵称为列向量。行向量例如：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/3db132a637edb9b7.png)
列向量例如：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/6e78c05b773f5bb7.png)
PS：向量只是一种特殊的矩阵，矩阵乘法和转置都是可以用在向量上的。
Hadamard乘积：?
假设S和T是两个同样维度的向量，使用S?T来表示按元素的乘积。所以 S?T 的元素就是(S?T)j=SjTj。
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/3a37509c09225fa.png)
向量的模(长度或大小)
在线性代数中，向量的大小用向量两边加双竖线表示，向量的大小就是向量各分量平方和的平方根。如有向量S：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/e7eaa2e521933f29.png)
则其模为：
![一小时神经网络从入门到精通(放弃)](http://image20.it168.com/201806_0x0/3209/c5c6189ee629e18f.png)
参考资料
知乎：CNN(卷积神经网络)、RNN(循环神经网络)、DNN(深度神经网络)的内部网络结构有什么区别?

