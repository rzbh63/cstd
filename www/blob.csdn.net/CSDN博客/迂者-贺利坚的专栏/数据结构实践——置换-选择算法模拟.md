
# 数据结构实践——置换-选择算法模拟 - 迂者-贺利坚的专栏 - CSDN博客

2015年12月09日 21:29:05[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2515


本文是针对[[数据结构基础系列(10)：外部排序](http://edu.csdn.net/course/detail/1765)]中的实践项目。
【项目 】置换-选择算法模拟
编写程序，模拟置换-选择算法生成初始归并段的过程。
设大文件中的记录共有18个:   15 4 97 64 17 32 108 44 76 9 39 82 56 31 80 73 255 68
内存工作区可以容纳5个记录，输出产生的归并段文件。
在模拟中，输入文件数据和输出的归并段数据均直接置在内存中即可。
[参考解答]()
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include <string.h>
```
```python
#include <stdlib.h>
```
```python
#define MaxSize 50
```
```python
//每个文件最多记录数
```
```python
#define MAXKEY 32767
```
```python
//最大关键字值∞
```
```python
#define W 5
```
```python
//内存工作区可容纳的记录个数
```
```python
typedef
```
```python
int
```
```python
LoserTree[W];
```
```python
//败者树是完全二叉树且不含叶子,可采用顺序存储结构
```
```python
typedef
```
```python
int
```
```python
InfoType;
```
```python
//定义其他数据项的类型
```
```python
typedef
```
```python
int
```
```python
KeyType;
```
```python
//定义关键字类型为整型
```
```python
typedef
```
```python
struct
```
```python
//记录类型
```
```python
{
    KeyType key;
```
```python
//关键字项
```
```python
InfoType otherinfo;
```
```python
//其他数据项,具体类型在主程中定义
```
```python
} RecType;
```
```python
typedef
```
```python
struct
```
```python
{
    RecType rec;
```
```python
//存放记录
```
```python
int
```
```python
rnum;
```
```python
//所属归并段的段号
```
```python
} WorkAreaType;
```
```python
typedef
```
```python
WorkAreaType WorkArea[W];
```
```python
//内存工作区,容量为W
```
```python
typedef
```
```python
struct
```
```python
{
    RecType recs[MaxSize];
```
```python
//存放文件中的数据项
```
```python
int
```
```python
length;
```
```python
//存放文件中实际记录个数
```
```python
int
```
```python
currec;
```
```python
//存放当前位置
```
```python
} FileType;
```
```python
//文件类型
```
```python
FileType Fi;
```
```python
//定义输入文件,为全局变量
```
```python
FileType Fo;
```
```python
//定义输出文件,为全局变量
```
```python
void
```
```python
initial()
```
```python
//输入输出文件初始化
```
```python
{
```
```python
int
```
```python
n=
```
```python
19
```
```python
,i;
    KeyType a[]= {
```
```python
15
```
```python
,
```
```python
4
```
```python
,
```
```python
97
```
```python
,
```
```python
64
```
```python
,
```
```python
17
```
```python
,
```
```python
32
```
```python
,
```
```python
108
```
```python
,
```
```python
44
```
```python
,
```
```python
76
```
```python
,
```
```python
9
```
```python
,
```
```python
39
```
```python
,
```
```python
82
```
```python
,
```
```python
56
```
```python
,
```
```python
31
```
```python
,
```
```python
80
```
```python
,
```
```python
73
```
```python
,
```
```python
255
```
```python
,
```
```python
68
```
```python
,MAXKEY};
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
        Fi.recs[i].key=a[i];
    Fi.length=n;
    Fi.currec=-
```
```python
1
```
```python
;
    Fo.currec=-
```
```python
1
```
```python
;
    Fo.length=
```
```python
0
```
```python
;
}
```
```python
void
```
```python
Select_MiniMax(LoserTree ls, WorkArea wa,
```
```python
int
```
```python
q)
```
```python
//从wa[q]起到败者树的根比较选择最小记录,并由q指示它所在的归并段
```
```python
{
```
```python
int
```
```python
p,s,t;
```
```python
for
```
```python
(t=(W+q)/
```
```python
2
```
```python
,p=ls[t]; t>
```
```python
0
```
```python
; t=t/
```
```python
2
```
```python
,p=ls[t])
```
```python
if
```
```python
((wa[p].rnum<wa[q].rnum) || (wa[p].rnum==wa[q].rnum && wa[p].rec.key<wa[q].rec.key))
        {
            s=q;
            q=ls[t];
```
```python
//q指示新的胜者
```
```python
ls[t]=s;
        }
    ls[
```
```python
0
```
```python
]=q;
}
```
```python
void
```
```python
Construct_Loser(LoserTree ls,WorkArea wa)
```
```python
//输入W个记录到内存工作区wa,建败者树ls,选最小的记录并由s指示其在wa中的位置
```
```python
{
```
```python
int
```
```python
i;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<W; i++)
        wa[i].rnum=wa[i].rec.key=ls[i]=
```
```python
0
```
```python
;
```
```python
//工作区初始化
```
```python
for
```
```python
(i=W-
```
```python
1
```
```python
; i>=
```
```python
0
```
```python
; i--)
    {
        Fi.currec++;
```
```python
//从输入文件读入一个记录
```
```python
wa[i].rec=Fi.recs[Fi.currec];
        wa[i].rnum=
```
```python
1
```
```python
;
```
```python
//其段号为1
```
```python
Select_MiniMax(ls,wa,i);
```
```python
//调整败者
```
```python
}
}
```
```python
void
```
```python
get_run(LoserTree ls,WorkArea wa,
```
```python
int
```
```python
rc,
```
```python
int
```
```python
&rmax)
```
```python
//求得一个初始归并段
```
```python
{
```
```python
int
```
```python
q;
    KeyType minimax;
```
```python
//当前最小关键字
```
```python
while
```
```python
(wa[ls[
```
```python
0
```
```python
]].rnum==rc)
```
```python
//选得的当前最小记录属当前段时
```
```python
{
        q=ls[
```
```python
0
```
```python
];
```
```python
//q指示当前最小记录在wa中的位置
```
```python
minimax=wa[q].rec.key;
        Fo.currec++;
```
```python
//将刚选得的当前最小记录写入输出文件
```
```python
Fo.length++;
        Fo.recs[Fo.currec]=wa[q].rec;
        Fi.currec++;
```
```python
//从输入文件读入下一记录
```
```python
wa[q].rec=Fi.recs[Fi.currec];
```
```python
if
```
```python
(Fi.currec>=Fi.length-
```
```python
1
```
```python
)
```
```python
//输入文件结束,虚设记录(属rmax+1段)
```
```python
{
            wa[q].rnum=rmax+
```
```python
1
```
```python
;
            wa[q].rec.key=MAXKEY;
        }
```
```python
else
```
```python
//输入文件非空时
```
```python
{
```
```python
if
```
```python
(wa[q].rec.key<minimax)
            {
                rmax=rc+
```
```python
1
```
```python
;
```
```python
//新读入的记录属下一段
```
```python
wa[q].rnum=rmax;
            }
```
```python
else
```
```python
//新读入的记录属当前段
```
```python
wa[q].rnum=rc;
        }
        Select_MiniMax(ls,wa,q);
```
```python
//选择新的当前最小记录
```
```python
}
}
```
```python
void
```
```python
Replace_Selection(LoserTree ls,WorkArea wa)
```
```python
//在败者树ls和内存工作区wa上用置换－选择排序求初始归并段
```
```python
{
```
```python
int
```
```python
rc,rmax;
    RecType j;
```
```python
//j作为一个关键字最大记录,作为一个输出段结束标志
```
```python
j.key=MAXKEY;
    Construct_Loser(ls,wa);
```
```python
//初建败者树
```
```python
rc=
```
```python
1
```
```python
;
```
```python
//rc指示当前生成的初始归并段的段号
```
```python
rmax=
```
```python
1
```
```python
;
```
```python
//rmax指示wa中关键字所属初始归并段的最大段号
```
```python
while
```
```python
(rc<=rmax)
```
```python
//rc=rmax+1标志输入文件的置换－选择排序已完成
```
```python
{
        get_run(ls,wa,rc,rmax);
```
```python
//求得一个初始归并段
```
```python
Fo.currec++;
```
```python
//将段结束标志写入输出文件
```
```python
Fo.recs[Fo.currec]=j;
        Fo.length++;
        rc=wa[ls[
```
```python
0
```
```python
]].rnum;
```
```python
//设置下一段的段号
```
```python
}
}
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
i=
```
```python
0
```
```python
,rno=
```
```python
1
```
```python
;
    initial();
    LoserTree ls;
    WorkArea wa;
```
```python
printf
```
```python
(
```
```python
"大文件的记录为:\n  "
```
```python
);
```
```python
while
```
```python
(Fi.recs[i].key!=MAXKEY)
    {
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,Fi.recs[i].key);
        i++;
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    Replace_Selection(ls,wa);
```
```python
//用置换-选择排序求初始归并段
```
```python
printf
```
```python
(
```
```python
"产生的归并段文件的记录如下:\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"  归并段%d:"
```
```python
,rno);
```
```python
//输出所有的归并段
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<Fo.length; i++)
```
```python
if
```
```python
(Fo.recs[i].key==MAXKEY)
        {
```
```python
printf
```
```python
(
```
```python
"∞"
```
```python
);
```
```python
if
```
```python
(i<Fo.length-
```
```python
1
```
```python
)
            {
                rno++;
```
```python
printf
```
```python
(
```
```python
"\n  归并段%d:"
```
```python
,rno);
            }
        }
```
```python
else
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,Fo.recs[i].key);
```
```python
printf
```
```python
(
```
```python
"\n  共产生%d个归并段文件\n"
```
```python
,rno);
```
```python
return
```
```python
0
```
```python
;
}
```

