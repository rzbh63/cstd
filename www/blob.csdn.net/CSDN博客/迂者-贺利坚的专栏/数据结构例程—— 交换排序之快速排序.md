
# 数据结构例程—— 交换排序之快速排序 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月30日 15:37:32[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2203


本文是[[数据结构基础系列(9)：排序](http://edu.csdn.net/course/detail/1710)]中第5课时[[ 交换排序之快速排序](http://edu.csdn.net/course/detail/1710/26659)]的例程。
1.以第1个元素作为基准
```python
#include <stdio.h>
```
```python
#define MaxSize 20
```
```python
typedef
```
```python
int
```
```python
KeyType;
```
```python
//定义关键字类型
```
```python
typedef
```
```python
char
```
```python
InfoType[
```
```python
10
```
```python
];
```
```python
typedef
```
```python
struct
```
```python
//记录类型
```
```python
{
    KeyType key;
```
```python
//关键字项
```
```python
InfoType data;
```
```python
//其他数据项,类型为InfoType
```
```python
} RecType;
```
```python
//排序的记录类型定义
```
```python
void
```
```python
QuickSort(RecType R[],
```
```python
int
```
```python
s,
```
```python
int
```
```python
t)
```
```python
//对R[s]至R[t]的元素进行快速排序
```
```python
{
```
```python
int
```
```python
i=s,j=t;
    RecType tmp;
```
```python
if
```
```python
(s<t)
```
```python
//区间内至少存在两个元素的情况
```
```python
{
        tmp=R[s];
```
```python
//用区间的第1个记录作为基准
```
```python
while
```
```python
(i!=j)
```
```python
//从区间两端交替向中间扫描,直至i=j为止
```
```python
{
```
```python
while
```
```python
(j>i && R[j].key>=tmp.key)
                j--;
```
```python
//从右向左扫描,找第1个小于tmp.key的R[j]
```
```python
R[i]=R[j];
```
```python
//找到这样的R[j],R[i]"R[j]交换
```
```python
while
```
```python
(i<j && R[i].key<=tmp.key)
                i++;
```
```python
//从左向右扫描,找第1个大于tmp.key的记录R[i]
```
```python
R[j]=R[i];
```
```python
//找到这样的R[i],R[i]"R[j]交换
```
```python
}
        R[i]=tmp;
        QuickSort(R,s,i-
```
```python
1
```
```python
);
```
```python
//对左区间递归排序
```
```python
QuickSort(R,i+
```
```python
1
```
```python
,t);
```
```python
//对右区间递归排序
```
```python
}
}
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
i,n=
```
```python
10
```
```python
;
    RecType R[MaxSize];
    KeyType a[]= {
```
```python
6
```
```python
,
```
```python
8
```
```python
,
```
```python
7
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
3
```
```python
,
```
```python
2
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
        R[i].key=a[i];
```
```python
printf
```
```python
(
```
```python
"排序前:"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,R[i].key);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    QuickSort(R,
```
```python
0
```
```python
,n-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"排序后:"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,R[i].key);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
2.以中间位置的元素作为基准
```python
#include <stdio.h>
```
```python
#define MaxSize 20
```
```python
typedef
```
```python
int
```
```python
KeyType;
```
```python
//定义关键字类型
```
```python
typedef
```
```python
char
```
```python
InfoType[
```
```python
10
```
```python
];
```
```python
typedef
```
```python
struct
```
```python
//记录类型
```
```python
{
    KeyType key;
```
```python
//关键字项
```
```python
InfoType data;
```
```python
//其他数据项,类型为InfoType
```
```python
} RecType;
```
```python
//排序的记录类型定义
```
```python
void
```
```python
QuickSort1(RecType R[],
```
```python
int
```
```python
s,
```
```python
int
```
```python
t)
```
```python
//对R[s]至R[t]的元素进行快速排序
```
```python
{
```
```python
int
```
```python
i=s,j=t;
    KeyType pivot;
    RecType tmp;
    pivot = R[(s+t)/
```
```python
2
```
```python
].key;
```
```python
//用区间的中间位置的元素作为关键字
```
```python
if
```
```python
(s<t)
```
```python
//区间内至少存在两个元素的情况
```
```python
{
```
```python
while
```
```python
(i!=j)
```
```python
//从区间两端交替向中间扫描,直至i=j为止
```
```python
{
```
```python
while
```
```python
(j>i && R[j].key>pivot)
                j--;
```
```python
//从右向左扫描,找第1个小于基准的R[j]
```
```python
while
```
```python
(i<j && R[i].key<pivot)
                i++;
```
```python
//从左向右扫描,找第1个大于基准记录R[i]
```
```python
if
```
```python
(i<j)
```
```python
//将前后的两个失序元素进行交换
```
```python
{
                tmp=R[i];
                R[i]=R[j];
                R[j]=tmp;
            }
        }
        QuickSort1(R,s,i-
```
```python
1
```
```python
);
```
```python
//对左区间递归排序
```
```python
QuickSort1(R,j+
```
```python
1
```
```python
,t);
```
```python
//对右区间递归排序
```
```python
}
}
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
i,n=
```
```python
10
```
```python
;
    RecType R[MaxSize];
    KeyType a[]= {
```
```python
6
```
```python
,
```
```python
8
```
```python
,
```
```python
7
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
3
```
```python
,
```
```python
2
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
        R[i].key=a[i];
```
```python
printf
```
```python
(
```
```python
"排序前:"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,R[i].key);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    QuickSort1(R,
```
```python
0
```
```python
,n-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"排序后:"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,R[i].key);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```

