
# Sigmund的99行Matlab拓扑优化程序简析 - cocoonyang的专栏 - CSDN博客


2018年05月29日 12:34:42[cocoonyang](https://me.csdn.net/cocoonyang)阅读数：3020



# 引言
Sigmund在2001年在Structural and Multidisciplinary Optimization 发表一篇名为 “A 99 line topology optimization code written in Matlab”论文。该论文附带一个使用Matlab编写的拓扑优化程序。这个只有99行代码的程序基于Matlab环境构建了一个完整的拓扑优化流程：前处理(构建有限元仿真模型), 有限元模型分析计算,拓扑优化迭代和后处理(分析结果显示)。Sigmund在论文中对这个程序的拓扑优化流程做了详细解释。本文仅从程序设计角度解析这段代码。
Sigmund的99行Matlab拓扑优化程序使用模块化方法设计，主要包含以下几个模块：
- 程序主流程
- 有限元模型求解模块
- Filter模块
- 单元刚度阵计算模块：计算平面四边形单元的刚度矩阵
- 优化模块： 使用优化准则法更新设计变量
- 目标函数计算和灵敏度分析模块
下面几个小节首先列出Sigmund99行拓扑优化程序完整代码，接着解释程序中5个全局变量在优化流程中的功用，然后对程序的各个功能模块做详细解析，最后总结程序的局限性并列出扩展程序功能时所需要修改的相应模块。
# 99行拓扑优化代码
Sigmund的99行Matlab拓扑优化程序如下所示
```python
% a 99 line topology optimization code by Ole Sigmund,October 1999
```
```python
clear 
nelx=
```
```python
60
```
```python
; 
nely=
```
```python
40
```
```python
; 
volfrac=
```
```python
0.5
```
```python
; 
penal=
```
```python
3.
```
```python
; 
rmin=
```
```python
1.5
```
```python
;
```
```python
% initialize
```
```python
x(
```
```python
1
```
```python
:nely,
```
```python
1
```
```python
:nelx)=volfrac; 
loop=
```
```python
0
```
```python
; 
change=
```
```python
1
```
```python
;
```
```python
% start ineration
```
```python
while
```
```python
change>
```
```python
0.01
```
```python
loop=loop+
```
```python
1
```
```python
; 
    xold=x;
```
```python
% FE analysis
```
```python
[U]
```
```python
=FE(nelx,nely,x,penal);
```
```python
% objective function and sensitivity analysis
```
```python
[KE]
```
```python
=lk;; 
    c=
```
```python
0.
```
```python
;
```
```python
for
```
```python
ely=
```
```python
1
```
```python
:nely
```
```python
for
```
```python
elx=
```
```python
1
```
```python
:nelx 
            n1=(nely+
```
```python
1
```
```python
)*(elx-
```
```python
1
```
```python
)+ely; 
            n2=(nely+
```
```python
1
```
```python
)*elx    +ely; 
            Ue=U(
```
```python
[
```
```python
2
```
```python
*n1-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1;
```
```python
2
```
```python
*n2-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2;
```
```python
2
```
```python
*n2+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2+
```
```python
2
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
2
```
```python
]
```
```python
,
```
```python
1
```
```python
); 
            c=c+x(ely,elx)^penal*
```
```python
Ue'
```
```python
*KE*Ue; 
            dc(ely,elx)=-penal*x(ely,elx)^(penal-
```
```python
1
```
```python
)*
```
```python
Ue'
```
```python
*KE*Ue;
```
```python
end
```
```python
end
```
```python
% filtering of sensitivities
```
```python
[dc]
```
```python
=check(nelx,nely,rmin,x,dc);
```
```python
% design update by the optimality criteria method
```
```python
[x]
```
```python
=oc(nelx,nely,x,volfrac,dc);
```
```python
% print result
```
```python
change=max(max(x-xold))
```
```python
disp
```
```python
(
```
```python
[
```
```python
'It.:'
```
```python
sprintf(
```
```python
'%4i'
```
```python
,loop)
```
```python
'    Obj.:'
```
```python
sprintf(
```
```python
'   %10.4f'
```
```python
,c) ...
```
```python
'   Vol.:'
```
```python
sprintf(
```
```python
'%6.3f'
```
```python
,sum(sum(x))/(nelx*nely)) ...
```
```python
'   ch.:'
```
```python
sprintf(
```
```python
'%6.3f'
```
```python
,change)]
```
```python
)
```
```python
% plot densities
```
```python
colormap(gray);imagesc(-x);axis equal;axis tight; axis off;pause(
```
```python
1e-6
```
```python
);
```
```python
end
```
```python
% FE analysis
```
```python
function
```
```python
[U]
```
```python
=
```
```python
FE
```
```python
(nelx,nely,x,penal)
```
```python
[KE]
```
```python
=lk; 
K=sparse(
```
```python
2
```
```python
*(nelx+
```
```python
1
```
```python
)*(nely+
```
```python
1
```
```python
),
```
```python
2
```
```python
*(nelx+
```
```python
1
```
```python
)*(nely+
```
```python
1
```
```python
)); 
F=sparse(
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)*(nelx+
```
```python
1
```
```python
),
```
```python
1
```
```python
);
U=sparse(
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)*(nelx+
```
```python
1
```
```python
),
```
```python
1
```
```python
);
```
```python
for
```
```python
elx=
```
```python
1
```
```python
:nelx
```
```python
for
```
```python
ely=
```
```python
1
```
```python
:nely 
        n1=(nely+
```
```python
1
```
```python
)*(elx-
```
```python
1
```
```python
)+ely; 
        n2=(nely+
```
```python
1
```
```python
)*elx    +ely; 
        edof=
```
```python
[
```
```python
2
```
```python
*n1-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1;
```
```python
2
```
```python
*n2-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2;
```
```python
2
```
```python
*n2+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2+
```
```python
2
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
2
```
```python
]
```
```python
; 
        K(edof,edof)=K(edof,edof)+x(ely,elx)^penal*KE;
```
```python
end
```
```python
end
```
```python
% define loads and supports
```
```python
ip=(nelx+
```
```python
1
```
```python
)*(nely+
```
```python
1
```
```python
); 
 F(
```
```python
2
```
```python
*ip,
```
```python
1
```
```python
)=-
```
```python
1
```
```python
;               
fixeddofs =
```
```python
[
```
```python
1
```
```python
:
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)]
```
```python
; 
alldofs   =
```
```python
[
```
```python
1
```
```python
:
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)*(nelx+
```
```python
1
```
```python
)]
```
```python
; 
freedofs  =setdiff(alldofs,fixeddofs);
```
```python
% solving
```
```python
U(freedofs,:)=K(freedofs,freedofs)\F(freedofs,:); 
U(fixeddofs,:)=
```
```python
0
```
```python
;
```
```python
% mesh-independency filter
```
```python
function
```
```python
[dcn]
```
```python
=
```
```python
check
```
```python
(nelx,nely,rmin,x,dc)
```
```python
dcn=
```
```python
zeros
```
```python
(nely,nelx);
```
```python
for
```
```python
i
```
```python
=
```
```python
1
```
```python
:nelx
```
```python
for
```
```python
j
```
```python
=
```
```python
1
```
```python
:nely 
        sum=
```
```python
0.0
```
```python
;
```
```python
for
```
```python
k=max(
```
```python
i
```
```python
-
```
```python
floor
```
```python
(rmin),
```
```python
1
```
```python
):min(
```
```python
i
```
```python
+
```
```python
floor
```
```python
(rmin),nelx)
```
```python
for
```
```python
l=max(
```
```python
j
```
```python
-
```
```python
floor
```
```python
(rmin),
```
```python
1
```
```python
):min(
```
```python
j
```
```python
+
```
```python
floor
```
```python
(rmin),nely) 
                fac=rmin-
```
```python
sqrt
```
```python
((
```
```python
i
```
```python
-k)^
```
```python
2
```
```python
+(
```
```python
j
```
```python
-l)^
```
```python
2
```
```python
); 
                sum=sum+max(
```
```python
0
```
```python
,fac); 
                dcn(
```
```python
j
```
```python
,
```
```python
i
```
```python
)=dcn(
```
```python
j
```
```python
,
```
```python
i
```
```python
)+max(
```
```python
0
```
```python
,fac)*x(l,k)*dc(l,k);
```
```python
end
```
```python
end
```
```python
dcn(
```
```python
j
```
```python
,
```
```python
i
```
```python
)=dcn(
```
```python
j
```
```python
,
```
```python
i
```
```python
)/(x(
```
```python
j
```
```python
,
```
```python
i
```
```python
)*sum);
```
```python
end
```
```python
end
```
```python
% Element stiffness matrix
```
```python
function
```
```python
[KE]
```
```python
=
```
```python
lk
```
```python
E=
```
```python
1.
```
```python
; 
nu=
```
```python
0.3
```
```python
; 
k=
```
```python
[
```
```python
1
```
```python
/
```
```python
2
```
```python
-nu/
```
```python
6
```
```python
1
```
```python
/
```
```python
8
```
```python
+nu/
```
```python
8
```
```python
-
```
```python
1
```
```python
/
```
```python
4
```
```python
-nu/
```
```python
12
```
```python
-
```
```python
1
```
```python
/
```
```python
8
```
```python
+
```
```python
3
```
```python
*nu/
```
```python
8
```
```python
... 
    -
```
```python
1
```
```python
/
```
```python
4
```
```python
+nu/
```
```python
12
```
```python
-
```
```python
1
```
```python
/
```
```python
8
```
```python
-nu/
```
```python
8
```
```python
nu/
```
```python
6
```
```python
1
```
```python
/
```
```python
8
```
```python
-
```
```python
3
```
```python
*nu/
```
```python
8
```
```python
]
```
```python
; 
KE=E/(
```
```python
1
```
```python
-nu^
```
```python
2
```
```python
)*
```
```python
[ k(
```
```python
1
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
8
```
```python
)   
                k(
```
```python
2
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
3
```
```python
) 
                k(
```
```python
3
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
2
```
```python
) 
                k(
```
```python
4
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
5
```
```python
) 
                k(
```
```python
5
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
4
```
```python
) 
                k(
```
```python
6
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
7
```
```python
) 
                k(
```
```python
7
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
6
```
```python
) 
                k(
```
```python
8
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
1
```
```python
)]
```
```python
;
```
```python
% optimality criteria update
```
```python
function
```
```python
[xnew]
```
```python
=
```
```python
oc
```
```python
(nelx,nely,x,volfrac,dc)
```
```python
l1=
```
```python
0
```
```python
;
l2=
```
```python
100000
```
```python
;
move=
```
```python
0.2
```
```python
;
```
```python
while
```
```python
(l2-l1>
```
```python
1e-4
```
```python
) 
    lmid=
```
```python
0.5
```
```python
*(l2+l1); 
    xnew =max(
```
```python
0.001
```
```python
,max(x-move,min(
```
```python
1.
```
```python
,min(x+move,
```
```python
x.
```
```python
*
```
```python
sqrt
```
```python
(-
```
```python
dc.
```
```python
/lmid)))));
```
```python
if
```
```python
sum(sum(xnew))-volfrac*nelx*nely>
```
```python
0
```
```python
; 
        l1=lmid;
```
```python
else
```
```python
l2=lmid;
```
```python
end
```
```python
end
```
# 变量初始化
```python
nelx
```
```python
=
```
```python
60
```
```python
;
```
```python
% x轴方向单元数量
```
```python
nely
```
```python
=
```
```python
40
```
```python
;
```
```python
% y轴方向单元数量
```
```python
volfrac
```
```python
=
```
```python
0.5
```
```python
;
```
```python
% 单元的材料体积比
```
```python
penal
```
```python
=
```
```python
3
```
```python
.;
```
```python
%  惩罚因子，将设计变量从[0,1]转化为指数函数，
```
```python
%  主要目的是使单元材料密度更加"黑白分明",
```
```python
%  惩罚因子就是这个指数函数的指数, 其值越大，效果越明显
```
```python
rmin
```
```python
=
```
```python
1.5
```
```python
;
```
```python
% 过滤半径，目的是预防出现棋盘格现象
```
设计变量初始化
```python
x(
```
```python
1
```
```python
:nely
```
```python
,
```
```python
1
```
```python
:nelx
```
```python
)=volfrac;  % 所有设计变量的赋初始值
```
# 主程序
主程序迭代流程
```python
% start ineration
```
```python
while
```
```python
change>
```
```python
0.01
```
```python
loop=loop+
```
```python
1
```
```python
;
```
```python
% loop是迭代计数
```
```python
xold=x;
```
```python
% 将设计变量保存在 变量xold中
```
```python
% FE analysis
```
```python
[U]
```
```python
=FE(nelx,nely,x,penal);
```
```python
% 有限元模型分析，将计算得到的各个节点位移值保存在数组U中
```
```python
% objective function and sensitivity analysis
```
```python
[KE]
```
```python
=lk;
```
```python
% 计算单元刚度阵
```
```python
c=
```
```python
0.
```
```python
;
```
```python
% 保存目标函数(柔度)的变量，
```
```python
%  遍历所有单元
```
```python
for
```
```python
ely=
```
```python
1
```
```python
:nely
```
```python
for
```
```python
elx=
```
```python
1
```
```python
:nelx
```
```python
% 根据单元在设计域中位置 计算单元节点编号
```
```python
n1=(nely+
```
```python
1
```
```python
)*(elx-
```
```python
1
```
```python
)+ely;
```
```python
% 左上角节点编号
```
```python
n2=(nely+
```
```python
1
```
```python
)*elx    +ely;
```
```python
% 右上角节点编号
```
```python
% 根据以上两个节点的编号 推演出 单元所有节点的自由度编号
```
```python
% 这就限制了此程序只能使用四边形单元剖分四边设计域所得到的有限元模型
```
```python
%
```
```python
% 从数组 U 中根据节点自由度编号 提取该单元的 位移向量
```
```python
Ue=U(
```
```python
[
```
```python
2
```
```python
*n1-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1;
```
```python
2
```
```python
*n2-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2;
```
```python
2
```
```python
*n2+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2+
```
```python
2
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
2
```
```python
]
```
```python
,
```
```python
1
```
```python
);
```
```python
%  计算单元柔度，叠加到目标函数变量中
```
```python
%  使用SIMP(Solid Isotropic Material with Penalization)材料插值模型
```
```python
c=c+x(ely,elx)^penal*
```
```python
Ue'
```
```python
*KE*Ue;
```
```python
%  计算灵敏度
```
```python
dc(ely,elx)=-penal*x(ely,elx)^(penal-
```
```python
1
```
```python
)*
```
```python
Ue'
```
```python
*KE*Ue;
```
```python
end
```
```python
end
```
```python
% filtering of sensitivities
```
```python
[dc]
```
```python
=check(nelx,nely,rmin,x,dc);
```
```python
% design update by the optimality criteria method
```
```python
[x]
```
```python
=oc(nelx,nely,x,volfrac,dc);
```
```python
% print result
```
```python
change=max(max(x-xold))
```
```python
disp
```
```python
(
```
```python
[
```
```python
'It.:'
```
```python
sprintf(
```
```python
'%4i'
```
```python
,loop)
```
```python
'    Obj.:'
```
```python
sprintf(
```
```python
'   %10.4f'
```
```python
,c) ...
```
```python
'   Vol.:'
```
```python
sprintf(
```
```python
'%6.3f'
```
```python
,sum(sum(x))/(nelx*nely)) ...
```
```python
'   ch.:'
```
```python
sprintf(
```
```python
'%6.3f'
```
```python
,change)]
```
```python
)
```
```python
% plot densities
```
```python
colormap(gray);imagesc(-x);axis equal;axis tight; axis off;pause(
```
```python
1e-6
```
```python
);
```
```python
end
```
优化模型为：

$$
\left\{
 \begin{array}{c c c l }
 min & c(x) & = & U^{T}KU = \sum_{e = 1}^{n} (x_{e})^{p} u_{e}^{T}K_{e} u_{e}   \\
 s.t. & & \\
  & \frac{V_{\rho}}{V} & = & f  \\
  & KU & = & F  \\
  & x_{min} & < & x < 1        \\
 \end{array}
 \right.
$$
代码 x(ely,elx)^penal*Ue’*KE*Ue 就是计算$(x_{e})^{p} u_{e}^{T}K_{e} u_{e}$
对$x_{e}$的梯度是

$$
\frac{dc}{dx} = - p (x_{e})^{p-1} u_{e}^{T}K_{e} u_{e}
$$
此程序使用的SIMP(Solid Isotropic Material with Penalization)材料插值模型，具体代码为:
x(ely,elx)^penal ;
网格划分为
```python
1
```
```python
-------(nely+
```
```python
1
```
```python
)+
```
```python
1
```
```python
------------------------------------nely+
```
```python
1
```
```python
)*nelx
|  (
```
```python
1
```
```python
,
```
```python
1
```
```python
)  |
```
```python
2
```
```python
-------(nely+
```
```python
1
```
```python
)+
```
```python
2
```
```python
|
```
```python
...
```
```python
-----------(nely+
```
```python
1
```
```python
)*(elx-
```
```python
1
```
```python
)+ely----(nely+
```
```python
1
```
```python
)*elx+ely    
|                            |       (elx,ely)      |
```
```python
...
```
```python
|
nely+
```
```python
1
```
```python
---(nely+
```
```python
1
```
```python
)*
```
```python
2
```
```python
----------
```
单元节点编号顺序为：
```python
Node_1
```
```python
Node_2
```
```python
(nely
```
```python
+
```
```python
1)*(elx
```
```python
-
```
```python
1)
```
```python
+
```
```python
ely
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
(nely
```
```python
+
```
```python
1)*elx
```
```python
+
```
```python
ely
```
```python
|
```
```python
(elx
```
```python
,
```
```python
ely)
```
```python
|
```
```python
(nely
```
```python
+
```
```python
1)*(elx
```
```python
-
```
```python
1)
```
```python
+
```
```python
ely
```
```python
+
```
```python
1
```
```python
-
```
```python
-
```
```python
-
```
```python
-
```
```python
(nely
```
```python
+
```
```python
1)*elx
```
```python
+
```
```python
ely
```
```python
+
```
```python
1
```
```python
Node_4
```
```python
Node_3
```
# 过滤器模块
```python
%%%
```
```python
%%%
```
```python
%%%
```
```python
%
```
```python
MESH
```
```python
-
```
```python
INDEPENDENCY
```
```python
FILTER
```
```python
%%%
```
```python
%%%
```
```python
%%%
```
```python
%%%
```
```python
%%%
```
```python
%%%
```
```python
%
function [dcn]=check(nelx,nely,rmin,x,dc)
% dcn 清零，dcn 用来保存 更新的 目标函数灵敏度
dcn=zeros(nely,nelx);
% 遍历所有单元
```
```python
for
```
```python
i =
```
```python
1
```
```python
:nelx
```
```python
for
```
```python
j =
```
```python
1
```
```python
:nely
```
```python
sum=
```
```python
0
```
```python
.
```
```python
0
```
```python
;
    % 遍历于这个单元相邻的单元
```
```python
for
```
```python
k = max(i-floor(rmin),
```
```python
1
```
```python
)
```
```python
:min
```
```python
(i+floor(rmin),nelx)
```
```python
for
```
```python
l = max(j-floor(rmin),
```
```python
1
```
```python
)
```
```python
:min
```
```python
(j+floor(rmin),nely)
        %  sqrt((i-k)^
```
```python
2
```
```python
+(j-l)^
```
```python
2
```
```python
) 是计算此单元与相邻单元的距离
        fac = rmin-sqrt((i-k)^
```
```python
2
```
```python
+(j-l)^
```
```python
2
```
```python
);
        sum = sum + max(
```
```python
0
```
```python
,fac);
        dcn(j,i) = dcn(j,i) + max(
```
```python
0
```
```python
,fac)*x(l,k)*dc(l,k);
```
```python
end
```
```python
end
```
```python
dcn(j,i) = dcn(j,i)/(x(j,i)*sum);
```
```python
end
```
```python
end
```
Sigmund的论文中对此函数有详细解释，论文中符号与代码中变量名的对应关系如下表所示:
|变量|论文中符号|
|---|---|
|rmin|r_{min}|
|fac|H_{f}|
|dc|\frac{c}{x_{e}}|
|dcn|\bar {  \frac{c}{x_{e}} }|
# 优化迭代模块
```python
% optimality criteria update
```
```python
function
```
```python
[
```
```python
xnew
```
```python
]=
```
```python
oc
```
```python
(nelx,nely,x,volfrac,dc)
```
```python
l1=
```
```python
0
```
```python
;
l2=
```
```python
100000
```
```python
;
move=
```
```python
0.2
```
```python
; 
while (l2-l1>
```
```python
1e-4
```
```python
) 
    lmid=
```
```python
0.5
```
```python
*(l2+l1); 
    xnew =max(
```
```python
0.001
```
```python
,max(x-move,
```
```python
min
```
```python
(
```
```python
1.
```
```python
,
```
```python
min
```
```python
(x+move,
```
```python
x.
```
```python
*
```
```python
sqrt
```
```python
(-
```
```python
dc.
```
```python
/lmid)))));
```
```python
if
```
```python
sum
```
```python
(
```
```python
sum
```
```python
(xnew))-volfrac*nelx*nely>
```
```python
0
```
```python
; 
        l1=lmid;
```
```python
else
```
```python
l2=lmid;
```
```python
end
```
```python
end
```
这段代码就是实现下面这个方程式:

$$
x_{e}^{new} =
\left \{
\begin{array}{ c c c c l}
max(x_{min}, x_{e} - m) & if &                        &      & x_{e} B_{e}^{\eta} \leq max(x_{min}, x_{e}- m)  \\
x_{e} B_{e}^{\eta}      & if & max(x_{min}, x_{e}- m) & \leq & x_{e} B_{e}^{\eta} \leq min(1, x_{e}+m ) \\
min(1, x_{e}+m )        & if &   min(1, x_{e}+m )     & \leq & x_{e} B_{e}^{\eta} \\
\end{array}
\right  .
$$

# 有限元模型求解模块
```python
% FE analysis
```
```python
function
```
```python
[U]
```
```python
=
```
```python
FE
```
```python
(nelx,nely,x,penal)
```
```python
[KE]
```
```python
=lk;
```
```python
%计算单元刚度矩阵
```
```python
K=sparse(
```
```python
2
```
```python
*(nelx+
```
```python
1
```
```python
)*(nely+
```
```python
1
```
```python
),
```
```python
2
```
```python
*(nelx+
```
```python
1
```
```python
)*(nely+
```
```python
1
```
```python
)); 
F=sparse(
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)*(nelx+
```
```python
1
```
```python
),
```
```python
1
```
```python
);
U=sparse(
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)*(nelx+
```
```python
1
```
```python
),
```
```python
1
```
```python
);
```
```python
%组装整体刚度矩阵
```
```python
for
```
```python
elx=
```
```python
1
```
```python
:nelx
```
```python
for
```
```python
ely=
```
```python
1
```
```python
:nely 
        n1=(nely+
```
```python
1
```
```python
)*(elx-
```
```python
1
```
```python
)+ely; 
        n2=(nely+
```
```python
1
```
```python
)*elx    +ely; 
        edof=
```
```python
[
```
```python
2
```
```python
*n1-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1;
```
```python
2
```
```python
*n2-
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2;
```
```python
2
```
```python
*n2+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n2+
```
```python
2
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
1
```
```python
;
```
```python
2
```
```python
*n1+
```
```python
2
```
```python
]
```
```python
; 
        K(edof,edof)=K(edof,edof)+x(ely,elx)^penal*KE;
```
```python
end
```
```python
end
```
```python
% define loads and supports
```
```python
ip=(nelx+
```
```python
1
```
```python
)*(nely+
```
```python
1
```
```python
); 
 F(
```
```python
2
```
```python
*ip,
```
```python
1
```
```python
)=-
```
```python
1
```
```python
;
```
```python
% 施加载荷
```
```python
% 施加位移约束
```
```python
fixeddofs =
```
```python
[
```
```python
1
```
```python
:
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)]
```
```python
; 
alldofs   =
```
```python
[
```
```python
1
```
```python
:
```
```python
2
```
```python
*(nely+
```
```python
1
```
```python
)*(nelx+
```
```python
1
```
```python
)]
```
```python
;
```
```python
% 所有不受约束的节点自由度
```
```python
freedofs  =setdiff(alldofs,fixeddofs);
```
```python
% solving 求解线性方程组, 得到节点自由度的位移值
```
```python
U(freedofs,:)=K(freedofs,freedofs)\F(freedofs,:); 
U(fixeddofs,:)=
```
```python
0
```
```python
;
```
```python
% 受约束的节点自由度的位移值 设为  0
```
# 单元刚度阵模块
```python
% Element stiffness matrix
```
```python
function
```
```python
[KE]=lk 
E=
```
```python
1.
```
```python
; 
nu=
```
```python
0.3
```
```python
; 
k=[
```
```python
1
```
```python
/
```
```python
2
```
```python
-nu/
```
```python
6
```
```python
1
```
```python
/
```
```python
8
```
```python
+nu/
```
```python
8
```
```python
-
```
```python
1
```
```python
/
```
```python
4
```
```python
-nu/
```
```python
12
```
```python
-
```
```python
1
```
```python
/
```
```python
8
```
```python
+
```
```python
3
```
```python
*nu/
```
```python
8
```
```python
...
```
```python
-
```
```python
1
```
```python
/
```
```python
4
```
```python
+nu/
```
```python
12
```
```python
-
```
```python
1
```
```python
/
```
```python
8
```
```python
-nu/
```
```python
8
```
```python
nu/
```
```python
6
```
```python
1
```
```python
/
```
```python
8
```
```python
-
```
```python
3
```
```python
*nu/
```
```python
8
```
```python
]; 
KE=E/(
```
```python
1
```
```python
-nu^
```
```python
2
```
```python
)*[ k(
```
```python
1
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
8
```
```python
)   
                k(
```
```python
2
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
3
```
```python
) 
                k(
```
```python
3
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
2
```
```python
) 
                k(
```
```python
4
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
5
```
```python
) 
                k(
```
```python
5
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
4
```
```python
) 
                k(
```
```python
6
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
7
```
```python
) 
                k(
```
```python
7
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
8
```
```python
)  k(
```
```python
1
```
```python
)  k(
```
```python
6
```
```python
) 
                k(
```
```python
8
```
```python
)  k(
```
```python
3
```
```python
)  k(
```
```python
2
```
```python
)  k(
```
```python
5
```
```python
)  k(
```
```python
4
```
```python
)  k(
```
```python
7
```
```python
)  k(
```
```python
6
```
```python
)  k(
```
```python
1
```
```python
)];
```
4节点矩形单元的4个节点在单元局部坐标系中坐标分别为：
|Node|x|y|
|---|---|---|
|(x_{1}, y_{1})|0|0|
|(x_{2}, y_{2})|1|0|
|(x_{3}, y_{3})|1|1|
|(x_{4}, y_{4})|0|1|
各节点形函数设为

$$
\left \{
    \begin{array}{c c c c c}
 N_{1}  & =   &  (x - 1 ) (y - 1)  \\  
 N_{2}  & =   & - x (y - 1)  \\ 
 N_{3}  & =  &  x y  \\
 N_{4}  & =  &  -(x - 1 ) y  \\
    \end{array}
  \right .
$$
以各节点形函数为基函数构建线性单元的位移场。单元内任一点$(x,y)$处的位移可由四个节点的变形通过单元形函数求得：

$$
\left \{
    \begin{array}{c c l}
u(x,y) & = & \sum_{i=1}^{4}N_{i}(x,y)u_{i} \\
v(x,y) & = & \sum_{i=1}^{4}N_{i}(x,y)v_{i} \\
    \end{array}
  \right  .
$$
其中$u_{i}, v_{i}$分别为各个节点在单元局部坐标系中$x$坐标轴向和$y$坐标轴向的位移分量。
根据几何方程，应变为：

$$
\xi_{xx} = \frac{\partial u }{\partial x} = \frac{\partial N_{1}}{\partial x} u_{1} + \cdots + \frac{\partial N_{4}}{\partial x} u_{4}\\
$$

$$
\xi_{yy} = \frac{\partial v}{\partial y} = \frac{\partial N_{1}}{\partial y} v_{1} + \cdots + \frac{\partial N_{4}}{\partial y} v_{4} \\
$$

$$
\xi_{xy} = \frac{\partial v}{\partial x} + \frac{\partial u }{\partial y} 
      = \frac{\partial N_{1}}{\partial y} u_{1} + \frac{\partial N_{1}}{\partial x} v_{1} + \cdots 
       + \frac{\partial N_{4}}{\partial y} u_{4} + \frac{\partial N_{4}}{\partial x} v_{4}
$$
则单元B阵为

$$
B =
\left [
    \begin{array}{c c  c}
\frac{\partial N_{1}(x,y)}{\partial x} & \cdots & 0 \\
  0  & \cdots & \frac{\partial N_{4}(x,y)}{\partial y}   \\
\frac{\partial N_{1}(x,y)}{\partial y}   & \cdots & \frac{\partial N_{4}(x,y)}{\partial x}  \\
    \end{array}
  \right ]
$$
材料本构阵为：

$$
D
 =
\frac{E}{1-\nu^{2}}
\left [
    \begin{array}{c c c}
1  &  \nu  & 0 \\
\nu & 1 & 0  \\
0 &  0  & \frac{1-\nu}{2} \\
    \end{array}
  \right ]
$$
单元刚度阵为：

$$
K = \int B^{T} D B ds
$$
其中

$$
K_{11} =\frac{E}{1-\nu^{2}} \int_{0}^{1}\int_{0}^{1} ( (y-1)^{2} + \frac{1-\nu}{2}(x-1)^{2} )dxdy 
= \frac{E}{1-\nu^{2}}( \frac{1}{2} - \frac{ \nu }{6})
$$
其余的$K_{ij}$依次类推。
# 程序的局限性
Sigmund的99行Matlab拓扑优化程序 主要关注于拓扑优化算法是验证.   以牺牲了程序的通用性为代价，短短的99行代码中完成一个完整的拓扑优化流程。整个程序代码简洁、计算高效，但各程序模块的功能能省就省，往往使用最简单最直接的方法实现，存在一定的局限性，例如：
- 设计域默认是矩形
- 只能处理一种单元– 平面四边形单元
- 只能使用一种各向同性材料
- Filter函数依赖于设计域网格划分方式
# 修改程序
如果要改变优化模型和有限元模型，调整项与相应的功能模块如下表所示：
|调整项|功能模块|函数名|
|---|---|---|
|优化模型|主程序|
|优化算法|目标函数计算模块|OC|
|边界条件|有限元模型求解模块|FE|
|材料类型|单元刚度阵模块|lk|
|过滤算法|过滤器模块|check|
|材料插值模型|主程序|

