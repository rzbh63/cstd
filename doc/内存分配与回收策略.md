# 内存分配与回收策略

2018年02月17日 16:46:15

法海你懂不

阅读数：48

 								标签： 																[Java																](http://so.csdn.net/so/search/s.do?q=Java&t=blog)[JVM																](http://so.csdn.net/so/search/s.do?q=JVM&t=blog) 							更多

 								个人分类： 																[Java																](https://blog.csdn.net/u013595419/article/category/7417689) 							

 								所属专栏： 																[深入理解Java虚拟机](https://blog.csdn.net/column/details/19704.html) 																 							

 									

​                   					 					版权声明：本文为博主原创文章，未经博主允许不得转载。					https://blog.csdn.net/u013595419/article/details/79332553				

Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：

- 给对象分配内存
- 回收分配给对象的内存

回收分配给对象的内存在前面几节中已经说明过了。

对象的内存分配简单来说就是按照某种分配策略在堆上分配空间，而分配策略也并不是固定不变的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中内存相关参数的位置。

# 内存分配规则

就目前而言，JVM分代是Java垃圾收集的一大亮点，根据对象的生命周期长短，把堆分为3个代，而内存分配也是根据这三个代来分配的：

- **新生代**：所有新创建的对象都首先在新生代进行内存分配。 
   新生代具体又分为3个区，一个Eden区、一个From Survivor区和一个To Sruvivor区。 
   大部分对象都被分配在Eden区，当Eden区满时，还存活的对象将被复制到From Survivor区，当From  Survivor区满时，此区还存活的对象将被复制到To Survivor区。最后，当To Survivor区也满时，这时从From  Survivor区复制过来并且还存活的对象将被复制到老年代。
- **老年代**：在年轻代中经历了N次（一般是15次）GC后依然存活的对象，就会被放到老年代当中。因此，可以认为老年代是存放一些生命周期较长的对象。
- **持久代**：用于存放静态文件，如Java类等。

## 对象优先在Eden分配

大多数情况下，对象在Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次`Minor GC`。

## 大对象直接进入老年代

所谓的大对象是指，*需要大量连续内存空间的Java对象*，最典型的大对象就是那种很长的字符串以及数组。

大对象对虚拟机的内存分配来说是一个坏消息，经常出现大对象容易导致内存还有不少空间的情况下就提前触发了GC以获取足够的连续空间来“安置”它们。  
 虚拟机提供了一个`-XX:PretenureSizeThreshold`参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区以及两个Survivor区之间发生大量的内存复制。

## 长期存活的对象将进入老年代

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代。

为了做到这一点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一次Minor  GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor  GC，年龄就增加1岁。当它的年龄增加到一定程度（默认是15岁），将会被晋升到老年代。

对象晋升到老年代的阈值可以通过参数`-XX:MaxTenuringThreshold`设置。

### 动态对象年龄判定

为了能更好地适应不同程序的内存情况，虚拟机并不总是要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升老年代。

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到`MaxTenuringThreshold`要求的年龄。

### 空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间。

- 如果这个条件成立，那么Minor GC是确保安全的；

- 如果不成立，则虚拟机会查看

  ```
  HandlePromotionFailure
  ```

  设置值是否允许担保失败（冒险）； 

  - 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小； 
    - 如果大于，将尝试进行一次Minor GC，尽管这次GC是有风险的；
    - 如果小于，或者`HandlePromotionFailure`设置不允许冒险，那这时也要改为进行一次Full GC；

过程如下图所示：

![young-to-old](https://img-blog.csdn.net/20180217163752867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzU5NTQxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> 这里解释下为什么说冒险？ 
>    前面提过，新生代使用复制收集算法，但是为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor  GC后依然存活（最极端就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。但是多少会晋升到老年代在实际内存回收前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均值作为经验值，与老年代剩余空间比较，决定是否进行Full  GC来让老年代腾出更多空间。 
>    取平均值进行比较其实任然是一种动态概率的手段。也就是说某次GC存活后的对象突增，远远高于平均值，依然会导致担保失败（HandlePromotionFailure）。如果出现担保失败，那就只好在失败后重新发起一次Full GC。 
>    担保失败时绕的圈子是最大的，但大部分情况下还是会将`HandlePromotionFailure`打开，避免Full GC过于频繁。