
# UDT 最新源码分析（三） -- UDT Socket 相关函数 - 老雍的博客 - CSDN博客


2019年01月28日 22:57:34[老雍](https://me.csdn.net/yongkai0214)阅读数：128



### UDT 最新源码分析 -- UDT Socket 相关函数
[UDT socket 建立与使用](#UDT_socket__1)
[主要流程](#_2)
[C/S 模式](#CS__3)
[Rendezvous 模式](#Rendezvous__7)
[UDT epoll](#UDT_epoll_10)
[UDT socket 创建](#UDT_socket__14)
[UDT socket setsockopt/getsockopt](#UDT_socket_setsockoptgetsockopt_96)
[UDT socket bind](#UDT_socket_bind_129)
[UDT::listen](#UDTlisten_293)
[UDT connect](#UDT_connect_614)
[UDT accept](#UDT_accept_953)
[总结](#_1065)
[C/S 模式--四次握手](#CS__1070)
[Rendezvous模式--三次握手](#Rendezvous_1083)

# UDT socket 建立与使用
## 主要流程
### C/S 模式
> UDT::socket -> UDT::setsockopt -> UDT::connect -> UDT::send -> UDT::close

> UDT::socket -> UDT::setsockopt -> UDT::bind -> UDT::listen -> UDT::accept -> UDT::recv -> UDT::close

### Rendezvous 模式
> UDT::setsockopt(usock, 0, UDT_RENDEZVOUS, &rendezvous, sizeof(bool))

### UDT epoll
详细源码分析在下一篇文章中。
> UDT::epoll_create -> UDT::epoll_add_usock/epoll_add_ssock -> UDT::epoll_wait/epoll_wait2 -> UDT::epoll_release

## UDT socket 创建
> UDT::socket -> CUDT::socket -> CUDTUnited::newSocket
UDT socket 的创建过程主要分为以下几步:
> 如果GC 线程未启动，则首先启动；

> 新建 CUDTSocket，初始化新建内在变量 m_pUDT，以及地址信息 m_pSelfAddr，UDT socket 的标识 m_SocketID，UDT socket的状态 m_Status 设置为 INIT, m_ListenSocket 初始设置为0；

> 将 UDT socket中信息注册到m_pUDT， 包括 m_SocketID，m_iSockType，m_iIPversion，m_pCache；

> 将 UDT socket加入 全局m_Sockets map;

> 返回标识 m_SocketID。
首先代码分析还是从对外提供的接口调用开始。
```python
UDTSOCKET CUDT
```
```python
:
```
```python
:
```
```python
socket
```
```python
(
```
```python
int
```
```python
af
```
```python
,
```
```python
int
```
```python
type
```
```python
,
```
```python
int
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
!
```
```python
s_UDTUnited
```
```python
.
```
```python
m_bGCStatus
```
```python
)
```
```python
s_UDTUnited
```
```python
.
```
```python
startup
```
```python
(
```
```python
)
```
```python
;
```
```python
// 如果GC 线程未启动，那么首先启动
```
```python
return
```
```python
s_UDTUnited
```
```python
.
```
```python
newSocket
```
```python
(
```
```python
af
```
```python
,
```
```python
type
```
```python
)
```
```python
;
```
```python
//创建一个 UDT socket
```
```python
}
```
接下来是通过 newSocket 创建 UDT socket 的过程。
```python
UDTSOCKET CUDTUnited
```
```python
::
```
```python
newSocket
```
```python
(
```
```python
int
```
```python
af
```
```python
,
```
```python
int
```
```python
type
```
```python
)
```
```python
{
```
```python
CUDTSocket
```
```python
*
```
```python
ns
```
```python
=
```
```python
NULL
```
```python
;
```
```python
try
```
```python
{
```
```python
ns
```
```python
=
```
```python
new
```
```python
CUDTSocket
```
```python
;
```
```python
//新建UDT socket
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
=
```
```python
new
```
```python
CUDT
```
```python
;
```
```python
//CUDT 在创建socket时新建
```
```python
if
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
af
```
```python
)
```
```python
{
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
=
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
(
```
```python
new
```
```python
sockaddr_in
```
```python
)
```
```python
;
```
```python
(
```
```python
(
```
```python
sockaddr_in
```
```python
*
```
```python
)
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
)
```
```python
)
```
```python
-
```
```python
>
```
```python
sin_port
```
```python
=
```
```python
0
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
=
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
(
```
```python
new
```
```python
sockaddr_in6
```
```python
)
```
```python
;
```
```python
//支持IPv6
```
```python
(
```
```python
(
```
```python
sockaddr_in6
```
```python
*
```
```python
)
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
)
```
```python
)
```
```python
-
```
```python
>
```
```python
sin6_port
```
```python
=
```
```python
0
```
```python
;
```
```python
}
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
.
```
```python
.
```
```python
.
```
```python
}
```
```python
CGuard
```
```python
::
```
```python
enterCS
```
```python
(
```
```python
m_IDLock
```
```python
)
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
=
```
```python
--
```
```python
m_SocketID
```
```python
;
```
```python
//在初始化的随机数值上进行递减，作为 UDT socket ID
```
```python
CGuard
```
```python
::
```
```python
leaveCS
```
```python
(
```
```python
m_IDLock
```
```python
)
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
INIT
```
```python
;
```
```python
//设置为 INIT 状态
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_ListenSocket
```
```python
=
```
```python
0
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
=
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
;
```
```python
//将刚刚获得 UDT socket ID 注册到 CUDT中
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iSockType
```
```python
=
```
```python
(
```
```python
SOCK_STREAM
```
```python
==
```
```python
type
```
```python
)
```
```python
?
```
```python
UDT_STREAM
```
```python
:
```
```python
UDT_DGRAM
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
=
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
=
```
```python
af
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_pCache
```
```python
=
```
```python
m_pCache
```
```python
;
```
```python
// protect the m_Sockets structure.
```
```python
CGuard
```
```python
::
```
```python
enterCS
```
```python
(
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
try
```
```python
{
```
```python
m_Sockets
```
```python
[
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
]
```
```python
=
```
```python
ns
```
```python
;
```
```python
//将 UDT socket加入 全局m_Sockets map
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
//failure and rollback
```
```python
.
```
```python
.
```
```python
.
```
```python
}
```
```python
CGuard
```
```python
::
```
```python
leaveCS
```
```python
(
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
return
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
;
```
```python
}
```
m_SocketID 的初始化，在CUDTUnited构造函数中被初始化为一个随机数。构造函数在系统初始化 startup 时被调用。
```python
CUDTUnited
```
```python
::
```
```python
CUDTUnited
```
```python
(
```
```python
)
```
```python
:
```
```python
m_SocketID
```
```python
(
```
```python
0
```
```python
)
```
```python
,
```
```python
{
```
```python
// Socket ID MUST start from a random value
```
```python
srand
```
```python
(
```
```python
(
```
```python
unsigned
```
```python
int
```
```python
)
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
m_SocketID
```
```python
=
```
```python
1
```
```python
+
```
```python
(
```
```python
int
```
```python
)
```
```python
(
```
```python
(
```
```python
1
```
```python
<<
```
```python
30
```
```python
)
```
```python
*
```
```python
(
```
```python
double
```
```python
(
```
```python
rand
```
```python
(
```
```python
)
```
```python
)
```
```python
/
```
```python
RAND_MAX
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
## UDT socket setsockopt/getsockopt
UDT Socket 参数设置。
> CUDT::setsockopt -> CUDT::setOpt

> CUDT::getsockopt -> CUDT::getOpt
UDT 可配置的参数中包括一些系统内部自定义参数，这些参数的定义如下所示：
```python
enum
```
```python
UDTOpt
```
```python
{
```
```python
UDT_MSS
```
```python
,
```
```python
// the Maximum Transfer Unit
```
```python
UDT_SNDSYN
```
```python
,
```
```python
// if sending is blocking
```
```python
UDT_RCVSYN
```
```python
,
```
```python
// if receiving is blocking
```
```python
UDT_CC
```
```python
,
```
```python
// custom congestion control algorithm
```
```python
UDT_FC
```
```python
,
```
```python
// Flight flag size (window size)
```
```python
UDT_SNDBUF
```
```python
,
```
```python
// maximum buffer in sending queue
```
```python
UDT_RCVBUF
```
```python
,
```
```python
// UDT receiving buffer size
```
```python
UDT_LINGER
```
```python
,
```
```python
// waiting for unsent data when closing
```
```python
UDP_SNDBUF
```
```python
,
```
```python
// UDP sending buffer size
```
```python
UDP_RCVBUF
```
```python
,
```
```python
// UDP receiving buffer size
```
```python
UDT_MAXMSG
```
```python
,
```
```python
// maximum datagram message size
```
```python
UDT_MSGTTL
```
```python
,
```
```python
// time-to-live of a datagram message
```
```python
UDT_RENDEZVOUS
```
```python
,
```
```python
// rendezvous connection mode
```
```python
UDT_SNDTIMEO
```
```python
,
```
```python
// send() timeout
```
```python
UDT_RCVTIMEO
```
```python
,
```
```python
// recv() timeout
```
```python
UDT_REUSEADDR
```
```python
,
```
```python
// reuse an existing port or create a new one
```
```python
UDT_MAXBW
```
```python
,
```
```python
// maximum bandwidth (bytes per second) that the connection can use
```
```python
UDT_STATE
```
```python
,
```
```python
// current socket state, see UDTSTATUS, read only
```
```python
UDT_EVENT
```
```python
,
```
```python
// current avalable events associated with the socket
```
```python
UDT_SNDDATA
```
```python
,
```
```python
// size of data in the sending buffer
```
```python
UDT_RCVDATA
```
```python
// size of data available for recv
```
```python
}
```
```python
;
```
## UDT socket bind
> CUDT::bind -> CUDTUnited::bind

> 不同形式
> int CUDTUnited::bind(UDTSOCKET u, UDPSOCKET udpsock)

> int CUDTUnited::bind(const UDTSOCKET u, const sockaddr* name, int namelen)

UDT bind 过程涉及到的模块较多，总的来说，就是将创建的 UDT socket 的信息注册到一个复用器上，如果复用器不存在则创建。每个复用器保证用于一个端口，每个复用器有一个 channel， 用于 udp socket 的创建，端口绑定等，修改 UDT socket 状态, 从 INIT 迁移到 OPENED。
也就是说，UDT socket通过UDT bind 与复用器 CMultiplexer 关联在一起，channel 作为 udp socket 的真正执行者进行运行，通过发送接收的两个工作线程完成数据的收发。发送接收的两个队列属于复用器，但是通过复用器ID使得 UDT socket 发送数据时直接与 channel 打交道，不再需要查找复用器。
```python
int
```
```python
CUDTUnited
```
```python
::
```
```python
bind
```
```python
(
```
```python
const
```
```python
UDTSOCKET u
```
```python
,
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
CUDTSocket
```
```python
*
```
```python
s
```
```python
=
```
```python
locate
```
```python
(
```
```python
u
```
```python
)
```
```python
;
```
```python
CGuard
```
```python
cg
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
// cannot bind a socket more than once
```
```python
if
```
```python
(
```
```python
INIT
```
```python
!=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
open
```
```python
(
```
```python
)
```
```python
;
```
```python
//m_pUDT中一堆参数初始化
```
```python
updateMux
```
```python
(
```
```python
s
```
```python
,
```
```python
name
```
```python
)
```
```python
;
```
```python
//更新复用器
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
OPENED
```
```python
;
```
```python
//更新UDT socket 状态为 OPENED
```
```python
// copy address information of local node
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
getSockAddr
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
)
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
}
```
每个端口可能被多个UDT socket复用，所以绑定端口实际上是注册到端口唯一的复用器上
> void CUDTUnited::updateMux(CUDTSocket* s, const CUDTSocket* ls)

> void CUDTUnited::updateMux(CUDTSocket* s, const sockaddr* addr, const UDPSOCKET* udpsock)

```python
void
```
```python
CUDTUnited
```
```python
::
```
```python
updateMux
```
```python
(
```
```python
CUDTSocket
```
```python
*
```
```python
s
```
```python
,
```
```python
const
```
```python
sockaddr
```
```python
*
```
```python
addr
```
```python
,
```
```python
const
```
```python
UDPSOCKET
```
```python
*
```
```python
udpsock
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
cg
```
```python
(
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bReuseAddr
```
```python
)
```
```python
&&
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
addr
```
```python
)
```
```python
)
```
```python
{
```
```python
int
```
```python
port
```
```python
=
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
?
```
```python
ntohs
```
```python
(
```
```python
(
```
```python
(
```
```python
sockaddr_in
```
```python
*
```
```python
)
```
```python
addr
```
```python
)
```
```python
-
```
```python
>
```
```python
sin_port
```
```python
)
```
```python
:
```
```python
ntohs
```
```python
(
```
```python
(
```
```python
(
```
```python
sockaddr_in6
```
```python
*
```
```python
)
```
```python
addr
```
```python
)
```
```python
-
```
```python
>
```
```python
sin6_port
```
```python
)
```
```python
;
```
```python
// find a reusable address
```
```python
for
```
```python
(
```
```python
map
```
```python
<
```
```python
int
```
```python
,
```
```python
CMultiplexer
```
```python
>
```
```python
::
```
```python
iterator i
```
```python
=
```
```python
m_mMultiplexer
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
i
```
```python
!=
```
```python
m_mMultiplexer
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
i
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
(
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_iIPversion
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
&&
```
```python
(
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_iMSS
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iMSS
```
```python
)
```
```python
&&
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_bReusable
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_iPort
```
```python
==
```
```python
port
```
```python
)
```
```python
//找到端口对应复用器
```
```python
{
```
```python
// reuse the existing multiplexer
```
```python
++
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_iRefCount
```
```python
;
```
```python
//引用计数加一
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_pSndQueue
```
```python
=
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_pSndQueue
```
```python
;
```
```python
//发送队列
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_pRcvQueue
```
```python
=
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_pRcvQueue
```
```python
;
```
```python
//接收队列
```
```python
s
```
```python
-
```
```python
>
```
```python
m_iMuxID
```
```python
=
```
```python
i
```
```python
-
```
```python
>
```
```python
second
```
```python
.
```
```python
m_iID
```
```python
;
```
```python
//将复用器 ID 告知 UDT socket
```
```python
return
```
```python
;
```
```python
}
```
```python
}
```
```python
}
```
```python
}
```
```python
// a new multiplexer is needed
```
```python
CMultiplexer m
```
```python
;
```
```python
m
```
```python
.
```
```python
m_iMSS
```
```python
=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iMSS
```
```python
;
```
```python
m
```
```python
.
```
```python
m_iIPversion
```
```python
=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
;
```
```python
m
```
```python
.
```
```python
m_iRefCount
```
```python
=
```
```python
1
```
```python
;
```
```python
m
```
```python
.
```
```python
m_bReusable
```
```python
=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bReuseAddr
```
```python
;
```
```python
m
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
;
```
```python
// 新建传输channel，设置IP 版本，以及发送接收缓冲大小,默认65536
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
=
```
```python
new
```
```python
CChannel
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
setSndBufSize
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iUDPSndBufSize
```
```python
)
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
setRcvBufSize
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iUDPRcvBufSize
```
```python
)
```
```python
;
```
```python
try
```
```python
{
```
```python
//创建并绑定真正用于传输的 udp socket，保存于 channel 中
```
```python
if
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
udpsock
```
```python
)
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
open
```
```python
(
```
```python
*
```
```python
udpsock
```
```python
)
```
```python
;
```
```python
else
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
open
```
```python
(
```
```python
addr
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
CUDTException
```
```python
&
```
```python
e
```
```python
)
```
```python
{
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
delete
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
;
```
```python
throw
```
```python
e
```
```python
;
```
```python
}
```
```python
//复用器相关参数赋值
```
```python
sockaddr
```
```python
*
```
```python
sa
```
```python
=
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
?
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
new
```
```python
sockaddr_in
```
```python
:
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
new
```
```python
sockaddr_in6
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
getSockAddr
```
```python
(
```
```python
sa
```
```python
)
```
```python
;
```
```python
m
```
```python
.
```
```python
m_iPort
```
```python
=
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
?
```
```python
ntohs
```
```python
(
```
```python
(
```
```python
(
```
```python
sockaddr_in
```
```python
*
```
```python
)
```
```python
sa
```
```python
)
```
```python
-
```
```python
>
```
```python
sin_port
```
```python
)
```
```python
:
```
```python
ntohs
```
```python
(
```
```python
(
```
```python
(
```
```python
sockaddr_in6
```
```python
*
```
```python
)
```
```python
sa
```
```python
)
```
```python
-
```
```python
>
```
```python
sin6_port
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
delete
```
```python
(
```
```python
sockaddr_in
```
```python
*
```
```python
)
```
```python
sa
```
```python
;
```
```python
else
```
```python
delete
```
```python
(
```
```python
sockaddr_in6
```
```python
*
```
```python
)
```
```python
sa
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pTimer
```
```python
=
```
```python
new
```
```python
CTimer
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pSndQueue
```
```python
=
```
```python
new
```
```python
CSndQueue
```
```python
;
```
```python
//新建发送队列
```
```python
m
```
```python
.
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
init
```
```python
(
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
,
```
```python
m
```
```python
.
```
```python
m_pTimer
```
```python
)
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pRcvQueue
```
```python
=
```
```python
new
```
```python
CRcvQueue
```
```python
;
```
```python
//新建接收队列
```
```python
m
```
```python
.
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
init
```
```python
(
```
```python
32
```
```python
,
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iPayloadSize
```
```python
,
```
```python
m
```
```python
.
```
```python
m_iIPversion
```
```python
,
```
```python
1024
```
```python
,
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
,
```
```python
m
```
```python
.
```
```python
m_pTimer
```
```python
)
```
```python
;
```
```python
m_mMultiplexer
```
```python
[
```
```python
m
```
```python
.
```
```python
m_iID
```
```python
]
```
```python
=
```
```python
m
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_pSndQueue
```
```python
=
```
```python
m
```
```python
.
```
```python
m_pSndQueue
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_pRcvQueue
```
```python
=
```
```python
m
```
```python
.
```
```python
m_pRcvQueue
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_iMuxID
```
```python
=
```
```python
m
```
```python
.
```
```python
m_iID
```
```python
;
```
```python
}
```
创建 channel 以后，新建发送接收队列，同时还需要分别调用 init 函数，该方法的主要作用除了对一部分参数初始化外，就是创建工作线程 worker 。
以发送队列举例，接收队列以及具体的使用过程后续文章介绍：
```python
void
```
```python
CSndQueue
```
```python
::
```
```python
init
```
```python
(
```
```python
CChannel
```
```python
*
```
```python
c
```
```python
,
```
```python
CTimer
```
```python
*
```
```python
t
```
```python
)
```
```python
{
```
```python
m_pChannel
```
```python
=
```
```python
c
```
```python
;
```
```python
m_pTimer
```
```python
=
```
```python
t
```
```python
;
```
```python
m_pSndUList
```
```python
=
```
```python
new
```
```python
CSndUList
```
```python
;
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_pWindowLock
```
```python
=
```
```python
&
```
```python
m_WindowLock
```
```python
;
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_pWindowCond
```
```python
=
```
```python
&
```
```python
m_WindowCond
```
```python
;
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_pTimer
```
```python
=
```
```python
m_pTimer
```
```python
;
```
```python
if
```
```python
(
```
```python
0
```
```python
!=
```
```python
pthread_create
```
```python
(
```
```python
&
```
```python
m_WorkerThread
```
```python
,
```
```python
NULL
```
```python
,
```
```python
CSndQueue
```
```python
::
```
```python
worker
```
```python
,
```
```python
this
```
```python
)
```
```python
)
```
```python
{
```
```python
m_WorkerThread
```
```python
=
```
```python
0
```
```python
;
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
3
```
```python
,
```
```python
1
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
对于发送队列的工作线程：
```python
void
```
```python
*
```
```python
CSndQueue
```
```python
::
```
```python
worker
```
```python
(
```
```python
void
```
```python
*
```
```python
param
```
```python
)
```
```python
{
```
```python
CSndQueue
```
```python
*
```
```python
self
```
```python
=
```
```python
(
```
```python
CSndQueue
```
```python
*
```
```python
)
```
```python
param
```
```python
;
```
```python
while
```
```python
(
```
```python
!
```
```python
self
```
```python
-
```
```python
>
```
```python
m_bClosing
```
```python
)
```
```python
//只要队列处于正常状态，就无限循环
```
```python
{
```
```python
uint64_t
```
```python
ts
```
```python
=
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
getNextProcTime
```
```python
(
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ts
```
```python
>
```
```python
0
```
```python
)
```
```python
{
```
```python
// wait until next processing time of the first socket on the list
```
```python
uint64_t
```
```python
currtime
```
```python
;
```
```python
CTimer
```
```python
::
```
```python
rdtsc
```
```python
(
```
```python
currtime
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
currtime
```
```python
<
```
```python
ts
```
```python
)
```
```python
//未到时间，继续等待
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pTimer
```
```python
-
```
```python
>
```
```python
sleepto
```
```python
(
```
```python
ts
```
```python
)
```
```python
;
```
```python
// it is time to send the next pkt
```
```python
sockaddr
```
```python
*
```
```python
addr
```
```python
;
```
```python
CPacket pkt
```
```python
;
```
```python
if
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
pop
```
```python
(
```
```python
addr
```
```python
,
```
```python
pkt
```
```python
)
```
```python
<
```
```python
0
```
```python
)
```
```python
continue
```
```python
;
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
sendto
```
```python
(
```
```python
addr
```
```python
,
```
```python
pkt
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
// wait here if there is no sockets with data to be sent
```
```python
pthread_mutex_lock
```
```python
(
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
self
```
```python
-
```
```python
>
```
```python
m_bClosing
```
```python
&&
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_iLastEntry
```
```python
<
```
```python
0
```
```python
)
```
```python
)
```
```python
pthread_cond_wait
```
```python
(
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowCond
```
```python
,
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowLock
```
```python
)
```
```python
;
```
```python
//条件等待
```
```python
pthread_mutex_unlock
```
```python
(
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowLock
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
return
```
```python
NULL
```
```python
;
```
```python
}
```
## UDT::listen
> CUDT::listen -> CUDTUnited::listen
UDT listen 在 UDT socket 处于OPENED 状态时，开始端口监听，从 UDT bind 可知，此时已经 bind 成功。一个端口上只能有一个 listening socket。这里的 listen 用于 C/S 模式，不支持汇合模式。对于已经处于监听状态的 UDT socket, 不会多次监听。
执行 UDT listen 成功后，m_bListening 修改为 true， UDT socket 状态 m_Status 变成 LISTENING。在 UDT socket 中新建两个集合 m_pQueuedSockets 和 m_pAcceptSockets，分别存放接收但还未来得及处理接受的连接请求 ，或者已经接受的连接请求。使用集合，也是借用集合元素唯一的特性。
实际上，执行 UDT listen 是设置监听到复用器中的接收队列 m_pRcvQueue。在队列的工作线程中，将会根据到来的包的类型进行对应的响应，并发送。
```python
int
```
```python
CUDTUnited
```
```python
::
```
```python
listen
```
```python
(
```
```python
const
```
```python
UDTSOCKET u
```
```python
,
```
```python
int
```
```python
backlog
```
```python
)
```
```python
{
```
```python
CUDTSocket
```
```python
*
```
```python
s
```
```python
=
```
```python
locate
```
```python
(
```
```python
u
```
```python
)
```
```python
;
```
```python
CGuard
```
```python
cg
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
// do nothing if the socket is already listening
```
```python
if
```
```python
(
```
```python
LISTENING
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
return
```
```python
0
```
```python
;
```
```python
// a socket can listen only if is in OPENED status
```
```python
if
```
```python
(
```
```python
OPENED
```
```python
!=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
5
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
// listen is not supported in rendezvous connection setup
```
```python
if
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bRendezvous
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
7
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
backlog
```
```python
<=
```
```python
0
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
3
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_uiBackLog
```
```python
=
```
```python
backlog
```
```python
;
```
```python
try
```
```python
{
```
```python
//新建 接收到但未接受的socket集合与以及接受的集合，使用 set保证每个socket唯一
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
=
```
```python
new
```
```python
set
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pAcceptSockets
```
```python
=
```
```python
new
```
```python
set
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
.
```
```python
.
```
```python
.
```
```python
}
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
listen
```
```python
(
```
```python
)
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
LISTENING
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
}
```
通过接收队列设置UDT 实例中的Listener，实际上是设置到复用器中
```python
void
```
```python
CUDT
```
```python
::
```
```python
listen
```
```python
(
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
cg
```
```python
(
```
```python
m_ConnectionLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
m_bOpened
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_bConnecting
```
```python
||
```
```python
m_bConnected
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
// listen can be called more than once
```
```python
if
```
```python
(
```
```python
m_bListening
```
```python
)
```
```python
return
```
```python
;
```
```python
// if there is already another socket listening on the same port
```
```python
if
```
```python
(
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
setListener
```
```python
(
```
```python
this
```
```python
)
```
```python
<
```
```python
0
```
```python
)
```
```python
// 为CRcvQueue 中 设置  = this
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
11
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
m_bListening
```
```python
=
```
```python
true
```
```python
;
```
```python
//修改监听状态
```
```python
}
```
通过 UDT listen 设置，为复用器设置 Listener，当接收到数据时，将数据分发到对应的 UDT 实例。同时修改UDT 的当前状态。
在 setListener 以后， 非空，在CRcvQueue中线程函数 worker 循环中，会调用recvfrom 接收到连接请求，检查m_Packet.m_iID, 决定是否调用 connect。
```python
void
```
```python
*
```
```python
CRcvQueue
```
```python
::
```
```python
worker
```
```python
(
```
```python
void
```
```python
*
```
```python
param
```
```python
)
```
```python
{
```
```python
CRcvQueue
```
```python
*
```
```python
self
```
```python
=
```
```python
(
```
```python
CRcvQueue
```
```python
*
```
```python
)
```
```python
param
```
```python
;
```
```python
sockaddr
```
```python
*
```
```python
addr
```
```python
=
```
```python
.
```
```python
.
```
```python
.
```
```python
CUDT
```
```python
*
```
```python
u
```
```python
=
```
```python
NULL
```
```python
;
```
```python
int32_t
```
```python
id
```
```python
;
```
```python
while
```
```python
(
```
```python
!
```
```python
self
```
```python
-
```
```python
>
```
```python
m_bClosing
```
```python
)
```
```python
{
```
```python
unit
```
```python
-
```
```python
>
```
```python
m_Packet
```
```python
.
```
```python
setLength
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_iPayloadSize
```
```python
)
```
```python
;
```
```python
// reading next incoming packet, recvfrom returns -1 is nothing has been received
```
```python
if
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
recvfrom
```
```python
(
```
```python
addr
```
```python
,
```
```python
unit
```
```python
-
```
```python
>
```
```python
m_Packet
```
```python
)
```
```python
<
```
```python
0
```
```python
)
```
```python
goto
```
```python
TIMER_CHECK
```
```python
;
```
```python
id
```
```python
=
```
```python
unit
```
```python
-
```
```python
>
```
```python
m_Packet
```
```python
.
```
```python
m_iID
```
```python
;
```
```python
// ID 0 is for connection request, which should be passed to the listening socket or rendezvous sockets
```
```python
if
```
```python
(
```
```python
0
```
```python
==
```
```python
id
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pListener
```
```python
)
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pListener
```
```python
-
```
```python
>
```
```python
listen
```
```python
(
```
```python
addr
```
```python
,
```
```python
unit
```
```python
-
```
```python
>
```
```python
m_Packet
```
```python
)
```
```python
;
```
```python
else
```
```python
if
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
(
```
```python
u
```
```python
=
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pRendezvousQueue
```
```python
-
```
```python
>
```
```python
retrieve
```
```python
(
```
```python
addr
```
```python
,
```
```python
id
```
```python
)
```
```python
)
```
```python
)
```
```python
{
```
```python
// asynchronous connect: call connect here
```
```python
// otherwise wait for the UDT socket to retrieve this packet
```
```python
if
```
```python
(
```
```python
!
```
```python
u
```
```python
-
```
```python
>
```
```python
m_bSynRecving
```
```python
)
```
```python
u
```
```python
-
```
```python
>
```
```python
connect
```
```python
(
```
```python
unit
```
```python
-
```
```python
>
```
```python
m_Packet
```
```python
)
```
```python
;
```
```python
else
```
```python
self
```
```python
-
```
```python
>
```
```python
storePkt
```
```python
(
```
```python
id
```
```python
,
```
```python
unit
```
```python
-
```
```python
>
```
```python
m_Packet
```
```python
.
```
```python
clone
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
}
```
```python
}
```
对于到达的一个连接请求，如果非空，就可以调用 CUDT 中的私有 listen 方法。对到达的建立连接的包进行解析，生成 coockie字符串，如果时正常的连接请求，则调用发送队列 sendto 发送包。如果是响应消息，且通过cookie 验证，则建立新连接。
```python
int
```
```python
CUDT
```
```python
::
```
```python
listen
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
addr
```
```python
,
```
```python
CPacket
```
```python
&
```
```python
packet
```
```python
)
```
```python
{
```
```python
CHandShake hs
```
```python
;
```
```python
hs
```
```python
.
```
```python
deserialize
```
```python
(
```
```python
packet
```
```python
.
```
```python
m_pcData
```
```python
,
```
```python
packet
```
```python
.
```
```python
getLength
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
// SYN cookie
```
```python
char
```
```python
clienthost
```
```python
[
```
```python
NI_MAXHOST
```
```python
]
```
```python
;
```
```python
char
```
```python
clientport
```
```python
[
```
```python
NI_MAXSERV
```
```python
]
```
```python
;
```
```python
getnameinfo
```
```python
(
```
```python
addr
```
```python
,
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
m_iVersion
```
```python
)
```
```python
?
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in
```
```python
)
```
```python
:
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in6
```
```python
)
```
```python
,
```
```python
clienthost
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
clienthost
```
```python
)
```
```python
,
```
```python
clientport
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
clientport
```
```python
)
```
```python
,
```
```python
NI_NUMERICHOST
```
```python
|
```
```python
NI_NUMERICSERV
```
```python
)
```
```python
;
```
```python
int64_t
```
```python
timestamp
```
```python
=
```
```python
(
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
-
```
```python
m_StartTime
```
```python
)
```
```python
/
```
```python
60000000
```
```python
;
```
```python
// secret changes every one minute
```
```python
stringstream cookiestr
```
```python
;
```
```python
cookiestr
```
```python
<<
```
```python
clienthost
```
```python
<<
```
```python
":"
```
```python
<<
```
```python
clientport
```
```python
<<
```
```python
":"
```
```python
<<
```
```python
timestamp
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
cookie
```
```python
[
```
```python
16
```
```python
]
```
```python
;
```
```python
CMD5
```
```python
::
```
```python
compute
```
```python
(
```
```python
cookiestr
```
```python
.
```
```python
str
```
```python
(
```
```python
)
```
```python
.
```
```python
c_str
```
```python
(
```
```python
)
```
```python
,
```
```python
cookie
```
```python
)
```
```python
;
```
```python
// connection request type: 1: regular connection request, 0: rendezvous connection request, -1/-2: response
```
```python
if
```
```python
(
```
```python
1
```
```python
==
```
```python
hs
```
```python
.
```
```python
m_iReqType
```
```python
)
```
```python
{
```
```python
hs
```
```python
.
```
```python
m_iCookie
```
```python
=
```
```python
*
```
```python
(
```
```python
int
```
```python
*
```
```python
)
```
```python
cookie
```
```python
;
```
```python
packet
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
hs
```
```python
.
```
```python
m_iID
```
```python
;
```
```python
int
```
```python
size
```
```python
=
```
```python
packet
```
```python
.
```
```python
getLength
```
```python
(
```
```python
)
```
```python
;
```
```python
hs
```
```python
.
```
```python
serialize
```
```python
(
```
```python
packet
```
```python
.
```
```python
m_pcData
```
```python
,
```
```python
size
```
```python
)
```
```python
;
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
sendto
```
```python
(
```
```python
addr
```
```python
,
```
```python
packet
```
```python
)
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
if
```
```python
(
```
```python
hs
```
```python
.
```
```python
m_iCookie
```
```python
!=
```
```python
*
```
```python
(
```
```python
int
```
```python
*
```
```python
)
```
```python
cookie
```
```python
)
```
```python
{
```
```python
timestamp
```
```python
--
```
```python
;
```
```python
cookiestr
```
```python
<<
```
```python
clienthost
```
```python
<<
```
```python
":"
```
```python
<<
```
```python
clientport
```
```python
<<
```
```python
":"
```
```python
<<
```
```python
timestamp
```
```python
;
```
```python
CMD5
```
```python
::
```
```python
compute
```
```python
(
```
```python
cookiestr
```
```python
.
```
```python
str
```
```python
(
```
```python
)
```
```python
.
```
```python
c_str
```
```python
(
```
```python
)
```
```python
,
```
```python
cookie
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
hs
```
```python
.
```
```python
m_iCookie
```
```python
!=
```
```python
*
```
```python
(
```
```python
int
```
```python
*
```
```python
)
```
```python
cookie
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
}
```
```python
}
```
```python
int32_t
```
```python
id
```
```python
=
```
```python
hs
```
```python
.
```
```python
m_iID
```
```python
;
```
```python
// When a peer side connects in...
```
```python
if
```
```python
(
```
```python
(
```
```python
1
```
```python
==
```
```python
packet
```
```python
.
```
```python
getFlag
```
```python
(
```
```python
)
```
```python
)
```
```python
&&
```
```python
(
```
```python
0
```
```python
==
```
```python
packet
```
```python
.
```
```python
getType
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
{
```
```python
// 控制包，且当前为  Connection Handshake
```
```python
if
```
```python
(
```
```python
(
```
```python
hs
```
```python
.
```
```python
m_iVersion
```
```python
!=
```
```python
m_iVersion
```
```python
)
```
```python
||
```
```python
(
```
```python
hs
```
```python
.
```
```python
m_iType
```
```python
!=
```
```python
m_iSockType
```
```python
)
```
```python
)
```
```python
{
```
```python
// mismatch, reject the request
```
```python
hs
```
```python
.
```
```python
m_iReqType
```
```python
=
```
```python
1002
```
```python
;
```
```python
int
```
```python
size
```
```python
=
```
```python
CHandShake
```
```python
::
```
```python
m_iContentSize
```
```python
;
```
```python
hs
```
```python
.
```
```python
serialize
```
```python
(
```
```python
packet
```
```python
.
```
```python
m_pcData
```
```python
,
```
```python
size
```
```python
)
```
```python
;
```
```python
packet
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
id
```
```python
;
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
sendto
```
```python
(
```
```python
addr
```
```python
,
```
```python
packet
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
int
```
```python
result
```
```python
=
```
```python
s_UDTUnited
```
```python
.
```
```python
newConnection
```
```python
(
```
```python
m_SocketID
```
```python
,
```
```python
addr
```
```python
,
```
```python
&
```
```python
hs
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
result
```
```python
==
```
```python
-
```
```python
1
```
```python
)
```
```python
hs
```
```python
.
```
```python
m_iReqType
```
```python
=
```
```python
1002
```
```python
;
```
```python
// send back a response if connection failed or connection already existed
```
```python
// new connection response should be sent in connect()
```
```python
if
```
```python
(
```
```python
result
```
```python
!=
```
```python
1
```
```python
)
```
```python
{
```
```python
int
```
```python
size
```
```python
=
```
```python
CHandShake
```
```python
::
```
```python
m_iContentSize
```
```python
;
```
```python
hs
```
```python
.
```
```python
serialize
```
```python
(
```
```python
packet
```
```python
.
```
```python
m_pcData
```
```python
,
```
```python
size
```
```python
)
```
```python
;
```
```python
packet
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
id
```
```python
;
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
sendto
```
```python
(
```
```python
addr
```
```python
,
```
```python
packet
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
// a new connection has been created, enable epoll for write
```
```python
s_UDTUnited
```
```python
.
```
```python
m_EPoll
```
```python
.
```
```python
update_events
```
```python
(
```
```python
m_SocketID
```
```python
,
```
```python
m_sPollID
```
```python
,
```
```python
UDT_EPOLL_OUT
```
```python
,
```
```python
true
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
}
```
```python
return
```
```python
hs
```
```python
.
```
```python
m_iReqType
```
```python
;
```
```python
}
```
在上面的代码中，newConnection 主要作用是建立一个新的连接，实质上是将连接的对端信息加入到 UDT 中存放对端连接socket 记录的 m_PeerRec map，并在 m_Sockets 加入新建立的 UDT socket。
首先检查 这个连接是否已经建立，如果已经建立，则返回已经存在 UDT socket 信息；如果当前处于 BROKEN 状态，会修改状态到 CLOSED， 并进行一些清理工作。其余的清理流程在 UDT 关闭过程中处理。
如果是一个新的连接，新建 UDT socket, 初始化部分参数，包括 m_pSelfAddr， m_SocketID， m_ListenSocket，m_PeerID， m_iISN等，然后绑定新的地址到监听socket。修改状态为 CONNECTED。修改 m_PeerRec 与 m_Sockets, 插入socket 进入 m_pQueuedSockets， 更新本地节点信息， 更新事件与定时器。等待 accept 事件到来。
```python
int
```
```python
CUDTUnited
```
```python
::
```
```python
newConnection
```
```python
(
```
```python
const
```
```python
UDTSOCKET listen
```
```python
,
```
```python
const
```
```python
sockaddr
```
```python
*
```
```python
peer
```
```python
,
```
```python
CHandShake
```
```python
*
```
```python
hs
```
```python
)
```
```python
{
```
```python
CUDTSocket
```
```python
*
```
```python
ns
```
```python
=
```
```python
NULL
```
```python
;
```
```python
CUDTSocket
```
```python
*
```
```python
ls
```
```python
=
```
```python
locate
```
```python
(
```
```python
listen
```
```python
)
```
```python
;
```
```python
//在 m_Sockets中查找本地 UDT socket。
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
ls
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
// if this connection has already been processed
```
```python
if
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
(
```
```python
ns
```
```python
=
```
```python
locate
```
```python
(
```
```python
peer
```
```python
,
```
```python
hs
```
```python
-
```
```python
>
```
```python
m_iID
```
```python
,
```
```python
hs
```
```python
-
```
```python
>
```
```python
m_iISN
```
```python
)
```
```python
)
```
```python
)
```
```python
//在 m_PeerRec 与 m_Sockets中查找。
```
```python
{
```
```python
if
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bBroken
```
```python
)
```
```python
{
```
```python
// last connection from the "peer" address has been broken
```
```python
.
```
```python
.
```
```python
.
```
```python
}
```
```python
else
```
```python
{
```
```python
// connection already exist, this is a repeated connection request
```
```python
// respond with existing HS information
```
```python
.
```
```python
.
```
```python
.
```
```python
return
```
```python
0
```
```python
;
```
```python
//except for this situation a new connection should be started
```
```python
}
```
```python
}
```
```python
// exceeding backlog, refuse the connection request
```
```python
if
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
size
```
```python
(
```
```python
)
```
```python
>=
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_uiBackLog
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
try
```
```python
{
```
```python
ns
```
```python
=
```
```python
new
```
```python
CUDTSocket
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
=
```
```python
new
```
```python
CUDT
```
```python
(
```
```python
*
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
)
```
```python
)
```
```python
;
```
```python
.
```
```python
.
```
```python
.
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
=
```
```python
.
```
```python
.
```
```python
.
```
```python
.
```
```python
.
```
```python
.
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
.
```
```python
.
```
```python
.
```
```python
}
```
```python
CGuard
```
```python
::
```
```python
enterCS
```
```python
(
```
```python
m_IDLock
```
```python
)
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
=
```
```python
--
```
```python
m_SocketID
```
```python
;
```
```python
CGuard
```
```python
::
```
```python
leaveCS
```
```python
(
```
```python
m_IDLock
```
```python
)
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_ListenSocket
```
```python
=
```
```python
listen
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
=
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
=
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_PeerID
```
```python
=
```
```python
hs
```
```python
-
```
```python
>
```
```python
m_iID
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_iISN
```
```python
=
```
```python
hs
```
```python
-
```
```python
>
```
```python
m_iISN
```
```python
;
```
```python
int
```
```python
error
```
```python
=
```
```python
0
```
```python
;
```
```python
try
```
```python
{
```
```python
// bind to the same addr of listening socket
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
open
```
```python
(
```
```python
)
```
```python
;
```
```python
updateMux
```
```python
(
```
```python
ns
```
```python
,
```
```python
ls
```
```python
)
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
connect
```
```python
(
```
```python
peer
```
```python
,
```
```python
hs
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
error
```
```python
=
```
```python
1
```
```python
;
```
```python
goto
```
```python
ERR_ROLLBACK
```
```python
;
```
```python
}
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
CONNECTED
```
```python
;
```
```python
// copy address information of local node
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
getSockAddr
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
)
```
```python
;
```
```python
CIPAddress
```
```python
::
```
```python
pton
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pSelfAddr
```
```python
,
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_piSelfIP
```
```python
,
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
;
```
```python
// protect the m_Sockets structure.
```
```python
CGuard
```
```python
::
```
```python
enterCS
```
```python
(
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
try
```
```python
{
```
```python
m_Sockets
```
```python
[
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
]
```
```python
=
```
```python
ns
```
```python
;
```
```python
m_PeerRec
```
```python
[
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_PeerID
```
```python
<<
```
```python
30
```
```python
)
```
```python
+
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_iISN
```
```python
]
```
```python
.
```
```python
insert
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
error
```
```python
=
```
```python
2
```
```python
;
```
```python
}
```
```python
CGuard
```
```python
::
```
```python
leaveCS
```
```python
(
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
CGuard
```
```python
::
```
```python
enterCS
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
try
```
```python
{
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
insert
```
```python
(
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
error
```
```python
=
```
```python
3
```
```python
;
```
```python
}
```
```python
CGuard
```
```python
::
```
```python
leaveCS
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
// acknowledge users waiting for new connections on the listening socket
```
```python
m_EPoll
```
```python
.
```
```python
update_events
```
```python
(
```
```python
listen
```
```python
,
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_sPollID
```
```python
,
```
```python
UDT_EPOLL_IN
```
```python
,
```
```python
true
```
```python
)
```
```python
;
```
```python
CTimer
```
```python
::
```
```python
triggerEvent
```
```python
(
```
```python
)
```
```python
;
```
```python
ERR_ROLLBACK
```
```python
:
```
```python
if
```
```python
(
```
```python
error
```
```python
>
```
```python
0
```
```python
)
```
```python
{
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
CLOSED
```
```python
;
```
```python
ns
```
```python
-
```
```python
>
```
```python
m_TimeStamp
```
```python
=
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
}
```
```python
// wake up a waiting accept() call
```
```python
#
```
```python
ifndef
```
```python
WIN32
```
```python
pthread_mutex_lock
```
```python
(
```
```python
&
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
)
```
```python
;
```
```python
pthread_cond_signal
```
```python
(
```
```python
&
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptCond
```
```python
)
```
```python
)
```
```python
;
```
```python
pthread_mutex_unlock
```
```python
(
```
```python
&
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
)
```
```python
;
```
```python
#
```
```python
else
```
```python
SetEvent
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptCond
```
```python
)
```
```python
;
```
```python
#
```
```python
endif
```
```python
return
```
```python
1
```
```python
;
```
```python
}
```
## UDT connect
> CUDT::connect( api.cpp, CUDT::public method) -> CUDTUnited::connect -> CUDT::connect( core.cpp, CUDT::private method)
如果UDT socket 能够 connect，首先应该处于 INIT 或者 OPENED 状态。如果处于 INIT状态，表明为新创建的UDT Socket，需要初始化 m_pUDT 内参数并注册到复用器，修改状态为 OPENED。如果处于OPENED 状态，可能已经被 bind 过，则可以进入 CONNECTING 状态，并调用 m_pUDT->connect。记录对端地址 m_pPeerAddr到该 UDT socket内部结构。
```python
int
```
```python
CUDTUnited
```
```python
::
```
```python
connect
```
```python
(
```
```python
const
```
```python
UDTSOCKET u
```
```python
,
```
```python
const
```
```python
sockaddr
```
```python
*
```
```python
name
```
```python
,
```
```python
int
```
```python
namelen
```
```python
)
```
```python
{
```
```python
CUDTSocket
```
```python
*
```
```python
s
```
```python
=
```
```python
locate
```
```python
(
```
```python
u
```
```python
)
```
```python
;
```
```python
CGuard
```
```python
cg
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
// a socket can "connect" only if it is in INIT or OPENED status
```
```python
if
```
```python
(
```
```python
INIT
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
!
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bRendezvous
```
```python
)
```
```python
{
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
open
```
```python
(
```
```python
)
```
```python
;
```
```python
updateMux
```
```python
(
```
```python
s
```
```python
)
```
```python
;
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
OPENED
```
```python
;
```
```python
}
```
```python
else
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
8
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
if
```
```python
(
```
```python
OPENED
```
```python
!=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
// connect_complete() may be called before connect() returns.
```
```python
// So we need to update the status before connect() is called,
```
```python
// otherwise the status may be overwritten with wrong value (CONNECTED vs. CONNECTING).
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
CONNECTING
```
```python
;
```
```python
try
```
```python
{
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
connect
```
```python
(
```
```python
name
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
CUDTException e
```
```python
)
```
```python
{
```
```python
s
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
=
```
```python
OPENED
```
```python
;
```
```python
throw
```
```python
e
```
```python
;
```
```python
}
```
```python
// record peer address
```
```python
delete
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pPeerAddr
```
```python
;
```
```python
if
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
s
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
{
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pPeerAddr
```
```python
=
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
(
```
```python
new
```
```python
sockaddr_in
```
```python
)
```
```python
;
```
```python
memcpy
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pPeerAddr
```
```python
,
```
```python
name
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pPeerAddr
```
```python
=
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
(
```
```python
new
```
```python
sockaddr_in6
```
```python
)
```
```python
;
```
```python
memcpy
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pPeerAddr
```
```python
,
```
```python
name
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in6
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
0
```
```python
;
```
```python
}
```
在 CUDT 中， 在private 方法中，connect 有三种形式：
```python
// Functionality:
```
```python
//    Connect to a UDT entity listening at address "peer".
```
```python
// Parameters:
```
```python
//    0) [in] peer: The address of the listening UDT entity.
```
```python
// Returned value:
```
```python
//    None.
```
```python
void
```
```python
CUDT
```
```python
::
```
```python
connect
```
```python
(
```
```python
const
```
```python
sockaddr
```
```python
*
```
```python
serv_addr
```
```python
)
```
```python
// Functionality:
```
```python
//    Process the response handshake packet.
```
```python
// Parameters:
```
```python
//    0) [in] pkt: handshake packet.
```
```python
// Returned value:
```
```python
//    Return 0 if connected, positive value if connection is in progress, otherwise error code.
```
```python
int
```
```python
CUDT
```
```python
::
```
```python
connect
```
```python
(
```
```python
const
```
```python
CPacket
```
```python
&
```
```python
response
```
```python
)
```
```python
throw
```
```python
(
```
```python
)
```
```python
// Functionality:
```
```python
//    Connect to a UDT entity listening at address "peer", which has sent "hs" request.
```
```python
// Parameters:
```
```python
//    0) [in] peer: The address of the listening UDT entity.
```
```python
//    1) [in/out] hs: The handshake information sent by the peer side (in), negotiated value (out).
```
```python
// Returned value:
```
```python
//    None.
```
```python
void
```
```python
CUDT
```
```python
::
```
```python
connect
```
```python
(
```
```python
const
```
```python
sockaddr
```
```python
*
```
```python
peer
```
```python
,
```
```python
CHandShake
```
```python
*
```
```python
hs
```
```python
)
```
在 connect 中调用的 connect 参数为 sockaddr，即第一种形式，这也是从外部接口 UDT::connect 调用后进入的函数：
```python
void
```
```python
CUDT
```
```python
::
```
```python
connect
```
```python
(
```
```python
const
```
```python
sockaddr
```
```python
*
```
```python
serv_addr
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
cg
```
```python
(
```
```python
m_ConnectionLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
m_bOpened
```
```python
)
```
```python
// UDT socket 处于 OPENED 状态
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_bListening
```
```python
)
```
```python
//不能同时 listen 与 connect
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_bConnecting
```
```python
||
```
```python
m_bConnected
```
```python
)
```
```python
//以前没有进行 connect 过
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
m_bConnecting
```
```python
=
```
```python
true
```
```python
;
```
```python
//修改状态，防止被多次 connect
```
```python
// record peer/server address
```
```python
delete
```
```python
m_pPeerAddr
```
```python
;
```
```python
m_pPeerAddr
```
```python
=
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
m_iIPversion
```
```python
)
```
```python
?
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
new
```
```python
sockaddr_in
```
```python
:
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
)
```
```python
new
```
```python
sockaddr_in6
```
```python
;
```
```python
memcpy
```
```python
(
```
```python
m_pPeerAddr
```
```python
,
```
```python
serv_addr
```
```python
,
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
m_iIPversion
```
```python
)
```
```python
?
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in
```
```python
)
```
```python
:
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in6
```
```python
)
```
```python
)
```
```python
;
```
```python
// register this socket in the rendezvous queue
```
```python
// RendezevousQueue is used to temporarily store incoming handshake, non-rendezvous connections also require this function
```
```python
uint64_t
```
```python
ttl
```
```python
=
```
```python
3000000
```
```python
;
```
```python
//这也是关闭时需要额外等3s的原因
```
```python
if
```
```python
(
```
```python
m_bRendezvous
```
```python
)
```
```python
ttl
```
```python
*
```
```python
=
```
```python
10
```
```python
;
```
```python
ttl
```
```python
+
```
```python
=
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
//将 UDT socket 插入一个链表 m_lRendezvousID，临时存储。不管是否汇合模式，都会保存。此处可能导致误解。
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
registerConnector
```
```python
(
```
```python
m_SocketID
```
```python
,
```
```python
this
```
```python
,
```
```python
m_iIPversion
```
```python
,
```
```python
serv_addr
```
```python
,
```
```python
ttl
```
```python
)
```
```python
;
```
```python
// This is my current configurations
```
```python
m_ConnReq
```
```python
.
```
```python
m_iVersion
```
```python
=
```
```python
m_iVersion
```
```python
;
```
```python
m_ConnReq
```
```python
.
```
```python
m_iType
```
```python
=
```
```python
m_iSockType
```
```python
;
```
```python
m_ConnReq
```
```python
.
```
```python
m_iMSS
```
```python
=
```
```python
m_iMSS
```
```python
;
```
```python
m_ConnReq
```
```python
.
```
```python
m_iFlightFlagSize
```
```python
=
```
```python
(
```
```python
m_iRcvBufSize
```
```python
<
```
```python
m_iFlightFlagSize
```
```python
)
```
```python
?
```
```python
m_iRcvBufSize
```
```python
:
```
```python
m_iFlightFlagSize
```
```python
;
```
```python
m_ConnReq
```
```python
.
```
```python
m_iReqType
```
```python
=
```
```python
(
```
```python
!
```
```python
m_bRendezvous
```
```python
)
```
```python
?
```
```python
1
```
```python
:
```
```python
0
```
```python
;
```
```python
m_ConnReq
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
m_SocketID
```
```python
;
```
```python
CIPAddress
```
```python
::
```
```python
ntop
```
```python
(
```
```python
serv_addr
```
```python
,
```
```python
m_ConnReq
```
```python
.
```
```python
m_piPeerIP
```
```python
,
```
```python
m_iIPversion
```
```python
)
```
```python
;
```
```python
// Random Initial Sequence Number
```
```python
srand
```
```python
(
```
```python
(
```
```python
unsigned
```
```python
int
```
```python
)
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
m_iISN
```
```python
=
```
```python
m_ConnReq
```
```python
.
```
```python
m_iISN
```
```python
=
```
```python
(
```
```python
int32_t
```
```python
)
```
```python
(
```
```python
CSeqNo
```
```python
::
```
```python
m_iMaxSeqNo
```
```python
*
```
```python
(
```
```python
double
```
```python
(
```
```python
rand
```
```python
(
```
```python
)
```
```python
)
```
```python
/
```
```python
RAND_MAX
```
```python
)
```
```python
)
```
```python
;
```
```python
m_iLastDecSeq
```
```python
=
```
```python
m_iISN
```
```python
-
```
```python
1
```
```python
;
```
```python
m_iSndLastAck
```
```python
=
```
```python
m_iISN
```
```python
;
```
```python
m_iSndLastDataAck
```
```python
=
```
```python
m_iISN
```
```python
;
```
```python
m_iSndCurrSeqNo
```
```python
=
```
```python
m_iISN
```
```python
-
```
```python
1
```
```python
;
```
```python
m_iSndLastAck2
```
```python
=
```
```python
m_iISN
```
```python
;
```
```python
m_ullSndLastAck2Time
```
```python
=
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
// Inform the server my configurations.
```
```python
CPacket request
```
```python
;
```
```python
char
```
```python
*
```
```python
reqdata
```
```python
=
```
```python
new
```
```python
char
```
```python
[
```
```python
m_iPayloadSize
```
```python
]
```
```python
;
```
```python
request
```
```python
.
```
```python
pack
```
```python
(
```
```python
0
```
```python
,
```
```python
NULL
```
```python
,
```
```python
reqdata
```
```python
,
```
```python
m_iPayloadSize
```
```python
)
```
```python
;
```
```python
//建包
```
```python
// ID = 0, connection request
```
```python
request
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
0
```
```python
;
```
```python
int
```
```python
hs_size
```
```python
=
```
```python
m_iPayloadSize
```
```python
;
```
```python
m_ConnReq
```
```python
.
```
```python
serialize
```
```python
(
```
```python
reqdata
```
```python
,
```
```python
hs_size
```
```python
)
```
```python
;
```
```python
//写入请求
```
```python
request
```
```python
.
```
```python
setLength
```
```python
(
```
```python
hs_size
```
```python
)
```
```python
;
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
sendto
```
```python
(
```
```python
serv_addr
```
```python
,
```
```python
request
```
```python
)
```
```python
;
```
```python
// 发送请求
```
```python
m_llLastReqTime
```
```python
=
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
//更新定时器
```
```python
// asynchronous connect, return immediately
```
```python
if
```
```python
(
```
```python
!
```
```python
m_bSynRecving
```
```python
)
```
```python
{
```
```python
delete
```
```python
[
```
```python
]
```
```python
reqdata
```
```python
;
```
```python
return
```
```python
;
```
```python
}
```
```python
// Wait for the negotiated configurations from the peer side.
```
```python
CPacket response
```
```python
;
```
```python
char
```
```python
*
```
```python
resdata
```
```python
=
```
```python
new
```
```python
char
```
```python
[
```
```python
m_iPayloadSize
```
```python
]
```
```python
;
```
```python
response
```
```python
.
```
```python
pack
```
```python
(
```
```python
0
```
```python
,
```
```python
NULL
```
```python
,
```
```python
resdata
```
```python
,
```
```python
m_iPayloadSize
```
```python
)
```
```python
;
```
```python
CUDTException
```
```python
e
```
```python
(
```
```python
0
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
while
```
```python
(
```
```python
!
```
```python
m_bClosing
```
```python
)
```
```python
// 等待 connect 返回，最多等待3s, 如果没有响应，会重复发送请求
```
```python
{
```
```python
// avoid sending too many requests, at most 1 request per 250ms
```
```python
if
```
```python
(
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
-
```
```python
m_llLastReqTime
```
```python
>
```
```python
250000
```
```python
)
```
```python
{
```
```python
m_ConnReq
```
```python
.
```
```python
serialize
```
```python
(
```
```python
reqdata
```
```python
,
```
```python
hs_size
```
```python
)
```
```python
;
```
```python
request
```
```python
.
```
```python
setLength
```
```python
(
```
```python
hs_size
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_bRendezvous
```
```python
)
```
```python
request
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iID
```
```python
;
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
sendto
```
```python
(
```
```python
serv_addr
```
```python
,
```
```python
request
```
```python
)
```
```python
;
```
```python
m_llLastReqTime
```
```python
=
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
response
```
```python
.
```
```python
setLength
```
```python
(
```
```python
m_iPayloadSize
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
recvfrom
```
```python
(
```
```python
m_SocketID
```
```python
,
```
```python
response
```
```python
)
```
```python
>
```
```python
0
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
connect
```
```python
(
```
```python
response
```
```python
)
```
```python
<=
```
```python
0
```
```python
)
```
```python
break
```
```python
;
```
```python
// new request/response should be sent out immediately on receving a response
```
```python
m_llLastReqTime
```
```python
=
```
```python
0
```
```python
;
```
```python
}
```
```python
if
```
```python
(
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
>
```
```python
ttl
```
```python
)
```
```python
{
```
```python
// timeout
```
```python
e
```
```python
=
```
```python
CUDTException
```
```python
(
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
break
```
```python
;
```
```python
}
```
```python
}
```
```python
delete
```
```python
[
```
```python
]
```
```python
reqdata
```
```python
;
```
```python
delete
```
```python
[
```
```python
]
```
```python
resdata
```
```python
;
```
```python
if
```
```python
(
```
```python
e
```
```python
.
```
```python
getErrorCode
```
```python
(
```
```python
)
```
```python
==
```
```python
0
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
m_bClosing
```
```python
)
```
```python
// if the socket is closed before connection...
```
```python
e
```
```python
=
```
```python
CUDTException
```
```python
(
```
```python
1
```
```python
)
```
```python
;
```
```python
else
```
```python
if
```
```python
(
```
```python
1002
```
```python
==
```
```python
m_ConnRes
```
```python
.
```
```python
m_iReqType
```
```python
)
```
```python
// connection request rejected
```
```python
e
```
```python
=
```
```python
CUDTException
```
```python
(
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
else
```
```python
if
```
```python
(
```
```python
(
```
```python
!
```
```python
m_bRendezvous
```
```python
)
```
```python
&&
```
```python
(
```
```python
m_iISN
```
```python
!=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iISN
```
```python
)
```
```python
)
```
```python
// secuity check
```
```python
e
```
```python
=
```
```python
CUDTException
```
```python
(
```
```python
1
```
```python
,
```
```python
4
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
}
```
```python
if
```
```python
(
```
```python
e
```
```python
.
```
```python
getErrorCode
```
```python
(
```
```python
)
```
```python
!=
```
```python
0
```
```python
)
```
```python
throw
```
```python
e
```
```python
;
```
```python
}
```
发出 connect 连接请求以后，如果属于同步方式，将等待返回，超时时间设置为3s，并会间隔250ms 不断发送请求，直至收到响应。接收到响应以后， connect(response)， 即为 第二种 connect 方法。
建立连接的过程可以参考 TCP 的半连接的思想。这第二次的connect 实际上就是 第二个半连接的建立过程，也是最后一个协商过程。对于非汇合模式，从 m_lRendezvousID 中移除，重新配置所有的连接参数， 为UDT socket 建立对应的各种数据结构，包括 发送接收buffer，丢失链表，窗口等，这些是数据传输过程中需要使用的内部结构，服务于 UDT 的核心传输算法，包括拥塞避免，重传等。所以也会初始化拥塞控制相关参数，最后，设置当前状态 为已连接状态。通过 connect_complete 与 update_events 通知管理模块与epool 状态更新。
```python
int
```
```python
CUDT
```
```python
::
```
```python
connect
```
```python
(
```
```python
const
```
```python
CPacket
```
```python
&
```
```python
response
```
```python
)
```
```python
throw
```
```python
(
```
```python
)
```
```python
{
```
```python
// this is the 2nd half of a connection request. If the connection is setup successfully this returns 0.
```
```python
// returning -1 means there is an error.
```
```python
// returning 1 or 2 means the connection is in process and needs more handshake
```
```python
if
```
```python
(
```
```python
!
```
```python
m_bConnecting
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
if
```
```python
(
```
```python
m_bRendezvous
```
```python
&&
```
```python
(
```
```python
(
```
```python
0
```
```python
==
```
```python
response
```
```python
.
```
```python
getFlag
```
```python
(
```
```python
)
```
```python
)
```
```python
||
```
```python
(
```
```python
1
```
```python
==
```
```python
response
```
```python
.
```
```python
getType
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
&&
```
```python
(
```
```python
0
```
```python
!=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iType
```
```python
)
```
```python
)
```
```python
{
```
```python
//a data packet or a keep-alive packet comes, which means the peer side is already connected
```
```python
// in this situation, the previously recorded response will be used
```
```python
goto
```
```python
POST_CONNECT
```
```python
;
```
```python
}
```
```python
if
```
```python
(
```
```python
(
```
```python
1
```
```python
!=
```
```python
response
```
```python
.
```
```python
getFlag
```
```python
(
```
```python
)
```
```python
)
```
```python
||
```
```python
(
```
```python
0
```
```python
!=
```
```python
response
```
```python
.
```
```python
getType
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
m_ConnRes
```
```python
.
```
```python
deserialize
```
```python
(
```
```python
response
```
```python
.
```
```python
m_pcData
```
```python
,
```
```python
response
```
```python
.
```
```python
getLength
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_bRendezvous
```
```python
)
```
```python
{
```
```python
// regular connect should NOT communicate with rendezvous connect
```
```python
// rendezvous connect require 3-way handshake
```
```python
if
```
```python
(
```
```python
1
```
```python
==
```
```python
m_ConnRes
```
```python
.
```
```python
m_iReqType
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
if
```
```python
(
```
```python
(
```
```python
0
```
```python
==
```
```python
m_ConnReq
```
```python
.
```
```python
m_iReqType
```
```python
)
```
```python
||
```
```python
(
```
```python
0
```
```python
==
```
```python
m_ConnRes
```
```python
.
```
```python
m_iReqType
```
```python
)
```
```python
)
```
```python
{
```
```python
m_ConnReq
```
```python
.
```
```python
m_iReqType
```
```python
=
```
```python
-
```
```python
1
```
```python
;
```
```python
// the request time must be updated so that the next handshake can be sent out immediately.
```
```python
m_llLastReqTime
```
```python
=
```
```python
0
```
```python
;
```
```python
return
```
```python
1
```
```python
;
```
```python
}
```
```python
}
```
```python
else
```
```python
{
```
```python
// set cookie
```
```python
if
```
```python
(
```
```python
1
```
```python
==
```
```python
m_ConnRes
```
```python
.
```
```python
m_iReqType
```
```python
)
```
```python
{
```
```python
m_ConnReq
```
```python
.
```
```python
m_iReqType
```
```python
=
```
```python
-
```
```python
1
```
```python
;
```
```python
m_ConnReq
```
```python
.
```
```python
m_iCookie
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iCookie
```
```python
;
```
```python
m_llLastReqTime
```
```python
=
```
```python
0
```
```python
;
```
```python
return
```
```python
1
```
```python
;
```
```python
}
```
```python
}
```
```python
POST_CONNECT
```
```python
:
```
```python
// Remove from rendezvous queue
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
removeConnector
```
```python
(
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
// Re-configure according to the negotiated values.
```
```python
m_iMSS
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iMSS
```
```python
;
```
```python
m_iFlowWindowSize
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iFlightFlagSize
```
```python
;
```
```python
m_iPktSize
```
```python
=
```
```python
m_iMSS
```
```python
-
```
```python
28
```
```python
;
```
```python
m_iPayloadSize
```
```python
=
```
```python
m_iPktSize
```
```python
-
```
```python
CPacket
```
```python
::
```
```python
m_iPktHdrSize
```
```python
;
```
```python
m_iPeerISN
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iISN
```
```python
;
```
```python
m_iRcvLastAck
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iISN
```
```python
;
```
```python
m_iRcvLastAckAck
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iISN
```
```python
;
```
```python
m_iRcvCurrSeqNo
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iISN
```
```python
-
```
```python
1
```
```python
;
```
```python
m_PeerID
```
```python
=
```
```python
m_ConnRes
```
```python
.
```
```python
m_iID
```
```python
;
```
```python
memcpy
```
```python
(
```
```python
m_piSelfIP
```
```python
,
```
```python
m_ConnRes
```
```python
.
```
```python
m_piPeerIP
```
```python
,
```
```python
16
```
```python
)
```
```python
;
```
```python
// Prepare all data structures
```
```python
try
```
```python
{
```
```python
m_pSndBuffer
```
```python
=
```
```python
new
```
```python
CSndBuffer
```
```python
(
```
```python
32
```
```python
,
```
```python
m_iPayloadSize
```
```python
)
```
```python
;
```
```python
m_pRcvBuffer
```
```python
=
```
```python
new
```
```python
CRcvBuffer
```
```python
(
```
```python
&
```
```python
(
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
m_UnitQueue
```
```python
)
```
```python
,
```
```python
m_iRcvBufSize
```
```python
)
```
```python
;
```
```python
// after introducing lite ACK, the sndlosslist may not be cleared in time, so it requires twice space.
```
```python
m_pSndLossList
```
```python
=
```
```python
new
```
```python
CSndLossList
```
```python
(
```
```python
m_iFlowWindowSize
```
```python
*
```
```python
2
```
```python
)
```
```python
;
```
```python
m_pRcvLossList
```
```python
=
```
```python
new
```
```python
CRcvLossList
```
```python
(
```
```python
m_iFlightFlagSize
```
```python
)
```
```python
;
```
```python
m_pACKWindow
```
```python
=
```
```python
new
```
```python
CACKWindow
```
```python
(
```
```python
1024
```
```python
)
```
```python
;
```
```python
m_pRcvTimeWindow
```
```python
=
```
```python
new
```
```python
CPktTimeWindow
```
```python
(
```
```python
16
```
```python
,
```
```python
64
```
```python
)
```
```python
;
```
```python
m_pSndTimeWindow
```
```python
=
```
```python
new
```
```python
CPktTimeWindow
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
.
```
```python
.
```
```python
.
```
```python
)
```
```python
{
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
3
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
}
```
```python
CInfoBlock ib
```
```python
;
```
```python
ib
```
```python
.
```
```python
m_iIPversion
```
```python
=
```
```python
m_iIPversion
```
```python
;
```
```python
CInfoBlock
```
```python
::
```
```python
convert
```
```python
(
```
```python
m_pPeerAddr
```
```python
,
```
```python
m_iIPversion
```
```python
,
```
```python
ib
```
```python
.
```
```python
m_piIP
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_pCache
```
```python
-
```
```python
>
```
```python
lookup
```
```python
(
```
```python
&
```
```python
ib
```
```python
)
```
```python
>=
```
```python
0
```
```python
)
```
```python
{
```
```python
m_iRTT
```
```python
=
```
```python
ib
```
```python
.
```
```python
m_iRTT
```
```python
;
```
```python
m_iBandwidth
```
```python
=
```
```python
ib
```
```python
.
```
```python
m_iBandwidth
```
```python
;
```
```python
}
```
```python
m_pCC
```
```python
=
```
```python
m_pCCFactory
```
```python
-
```
```python
>
```
```python
create
```
```python
(
```
```python
)
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
m_UDT
```
```python
=
```
```python
m_SocketID
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
setMSS
```
```python
(
```
```python
m_iMSS
```
```python
)
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
setMaxCWndSize
```
```python
(
```
```python
m_iFlowWindowSize
```
```python
)
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
setSndCurrSeqNo
```
```python
(
```
```python
m_iSndCurrSeqNo
```
```python
)
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
setRcvRate
```
```python
(
```
```python
m_iDeliveryRate
```
```python
)
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
setRTT
```
```python
(
```
```python
m_iRTT
```
```python
)
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
setBandwidth
```
```python
(
```
```python
m_iBandwidth
```
```python
)
```
```python
;
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
init
```
```python
(
```
```python
)
```
```python
;
```
```python
m_ullInterval
```
```python
=
```
```python
(
```
```python
uint64_t
```
```python
)
```
```python
(
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
m_dPktSndPeriod
```
```python
*
```
```python
m_ullCPUFrequency
```
```python
)
```
```python
;
```
```python
m_dCongestionWindow
```
```python
=
```
```python
m_pCC
```
```python
-
```
```python
>
```
```python
m_dCWndSize
```
```python
;
```
```python
// And, I am connected too.
```
```python
m_bConnecting
```
```python
=
```
```python
false
```
```python
;
```
```python
m_bConnected
```
```python
=
```
```python
true
```
```python
;
```
```python
// register this socket for receiving data packets
```
```python
m_pRNode
```
```python
-
```
```python
>
```
```python
m_bOnList
```
```python
=
```
```python
true
```
```python
;
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
setNewEntry
```
```python
(
```
```python
this
```
```python
)
```
```python
;
```
```python
// acknowledge the management module.
```
```python
s_UDTUnited
```
```python
.
```
```python
connect_complete
```
```python
(
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
// 更新m_pSndQueue->m_pChannel本地节点信息，设置状态为 CONNECTED
```
```python
// acknowledde any waiting epolls to write
```
```python
s_UDTUnited
```
```python
.
```
```python
m_EPoll
```
```python
.
```
```python
update_events
```
```python
(
```
```python
m_SocketID
```
```python
,
```
```python
m_sPollID
```
```python
,
```
```python
UDT_EPOLL_OUT
```
```python
,
```
```python
true
```
```python
)
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
}
```
## UDT accept
> UDT::accept -> CUDT::accept -> CUDTUnited::accept
UDT accept 与 TCP socket 中 的accept一样，在socket bind 以后就可以使用，等待其他连接到来。所以当前的 UDT Listener 的状态为 LISTENING。 仅在非汇合模式下使用。
主要的过程是一个while 循环，等待accept事件。当到来以后，删除 m_pQueuedSockets中的节点，插入 m_pAcceptSockets。update_events 发给 epool事件更新。存储对端地址。
```python
UDTSOCKET CUDTUnited
```
```python
::
```
```python
accept
```
```python
(
```
```python
const
```
```python
UDTSOCKET listen
```
```python
,
```
```python
sockaddr
```
```python
*
```
```python
addr
```
```python
,
```
```python
int
```
```python
*
```
```python
addrlen
```
```python
)
```
```python
{
```
```python
CUDTSocket
```
```python
*
```
```python
ls
```
```python
=
```
```python
locate
```
```python
(
```
```python
listen
```
```python
)
```
```python
;
```
```python
// the "listen" socket must be in LISTENING status
```
```python
if
```
```python
(
```
```python
LISTENING
```
```python
!=
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
// no "accept" in rendezvous connection setup
```
```python
if
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bRendezvous
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
7
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
UDTSOCKET u
```
```python
=
```
```python
CUDT
```
```python
::
```
```python
INVALID_SOCK
```
```python
;
```
```python
bool
```
```python
accepted
```
```python
=
```
```python
false
```
```python
;
```
```python
// !!only one conection can be set up each time!!
```
```python
#
```
```python
ifndef
```
```python
WIN32
```
```python
while
```
```python
(
```
```python
!
```
```python
accepted
```
```python
)
```
```python
//循环等待连接到来 accepted = true 时退出
```
```python
{
```
```python
pthread_mutex_lock
```
```python
(
```
```python
&
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
(
```
```python
LISTENING
```
```python
!=
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
||
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bBroken
```
```python
)
```
```python
{
```
```python
// This socket has been closed.
```
```python
accepted
```
```python
=
```
```python
true
```
```python
;
```
```python
}
```
```python
else
```
```python
if
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
size
```
```python
(
```
```python
)
```
```python
>
```
```python
0
```
```python
)
```
```python
{
```
```python
//更新 m_pAcceptSockets 和 m_pQueuedSockets
```
```python
u
```
```python
=
```
```python
*
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
begin
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pAcceptSockets
```
```python
-
```
```python
>
```
```python
insert
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pAcceptSockets
```
```python
-
```
```python
>
```
```python
end
```
```python
(
```
```python
)
```
```python
,
```
```python
u
```
```python
)
```
```python
;
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
erase
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
begin
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
accepted
```
```python
=
```
```python
true
```
```python
;
```
```python
}
```
```python
else
```
```python
if
```
```python
(
```
```python
!
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bSynRecving
```
```python
)
```
```python
{
```
```python
accepted
```
```python
=
```
```python
true
```
```python
;
```
```python
}
```
```python
if
```
```python
(
```
```python
!
```
```python
accepted
```
```python
&&
```
```python
(
```
```python
LISTENING
```
```python
==
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
)
```
```python
pthread_cond_wait
```
```python
(
```
```python
&
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptCond
```
```python
)
```
```python
,
```
```python
&
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
empty
```
```python
(
```
```python
)
```
```python
)
```
```python
m_EPoll
```
```python
.
```
```python
update_events
```
```python
(
```
```python
listen
```
```python
,
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_sPollID
```
```python
,
```
```python
UDT_EPOLL_IN
```
```python
,
```
```python
false
```
```python
)
```
```python
;
```
```python
pthread_mutex_unlock
```
```python
(
```
```python
&
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
#
```
```python
else
```
```python
while
```
```python
(
```
```python
!
```
```python
accepted
```
```python
)
```
```python
{
```
```python
WaitForSingleObject
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
,
```
```python
INFINITE
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
size
```
```python
(
```
```python
)
```
```python
>
```
```python
0
```
```python
)
```
```python
{
```
```python
u
```
```python
=
```
```python
*
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
begin
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pAcceptSockets
```
```python
-
```
```python
>
```
```python
insert
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pAcceptSockets
```
```python
-
```
```python
>
```
```python
end
```
```python
(
```
```python
)
```
```python
,
```
```python
u
```
```python
)
```
```python
;
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
erase
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
begin
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
accepted
```
```python
=
```
```python
true
```
```python
;
```
```python
}
```
```python
else
```
```python
if
```
```python
(
```
```python
!
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bSynRecving
```
```python
)
```
```python
accepted
```
```python
=
```
```python
true
```
```python
;
```
```python
ReleaseMutex
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
accepted
```
```python
&
```
```python
(
```
```python
LISTENING
```
```python
==
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
)
```
```python
WaitForSingleObject
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptCond
```
```python
,
```
```python
INFINITE
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
(
```
```python
LISTENING
```
```python
!=
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_Status
```
```python
)
```
```python
||
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bBroken
```
```python
)
```
```python
{
```
```python
// Send signal to other threads that are waiting to accept.
```
```python
SetEvent
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_AcceptCond
```
```python
)
```
```python
;
```
```python
accepted
```
```python
=
```
```python
true
```
```python
;
```
```python
}
```
```python
if
```
```python
(
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pQueuedSockets
```
```python
-
```
```python
>
```
```python
empty
```
```python
(
```
```python
)
```
```python
)
```
```python
m_EPoll
```
```python
.
```
```python
update_events
```
```python
(
```
```python
listen
```
```python
,
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_sPollID
```
```python
,
```
```python
UDT_EPOLL_IN
```
```python
,
```
```python
false
```
```python
)
```
```python
;
```
```python
}
```
```python
#
```
```python
endif
```
```python
if
```
```python
(
```
```python
u
```
```python
==
```
```python
CUDT
```
```python
::
```
```python
INVALID_SOCK
```
```python
)
```
```python
{
```
```python
// non-blocking receiving, no connection available
```
```python
if
```
```python
(
```
```python
!
```
```python
ls
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_bSynRecving
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
6
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
// listening socket is closed
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
}
```
```python
// 存储对端的地址
```
```python
if
```
```python
(
```
```python
(
```
```python
addr
```
```python
!=
```
```python
NULL
```
```python
)
```
```python
&&
```
```python
(
```
```python
addrlen
```
```python
!=
```
```python
NULL
```
```python
)
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
AF_INET
```
```python
==
```
```python
locate
```
```python
(
```
```python
u
```
```python
)
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
*
```
```python
addrlen
```
```python
=
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in
```
```python
)
```
```python
;
```
```python
else
```
```python
*
```
```python
addrlen
```
```python
=
```
```python
sizeof
```
```python
(
```
```python
sockaddr_in6
```
```python
)
```
```python
;
```
```python
// copy address information of peer node
```
```python
memcpy
```
```python
(
```
```python
addr
```
```python
,
```
```python
locate
```
```python
(
```
```python
u
```
```python
)
```
```python
-
```
```python
>
```
```python
m_pPeerAddr
```
```python
,
```
```python
*
```
```python
addrlen
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
u
```
```python
;
```
```python
}
```
# 总结
UDT支持两种连接模式：C/S 模式和汇合模式。UDT client 发送一个握手消息（type为 0 的控制报文）给 server 或者 peer。消息携带信息格式见文章[UDT最新协议分析](https://blog.csdn.net/yongkai0214/article/details/85322548)。
## C/S 模式–四次握手
如果一个UDT socket 作为server，会建立一个UDT实体， 并作为 Listener 监听绑定的端口，当有新的连接请求到来时，就会新创建一个 UDT socket，并初始化相关信息，并将新的 UDT socket 相关的信息写入到 Listener。这就是一个连接的建立过程，和TCP的连接过程比较相似。
> 当 UDT client 要对一个UDT server建立连接的时候，会在3s内每间隔 250ms 连续发送握手报文，直到收到server反馈回来的握手的报文或者连接超时。

> 当 UDT server 第一次接收到来自 UDT client 的握手连接请求的时候，它会根据 client 的 address 和一个 secret key 产生一个 cookie 值，然后发送给 client。

> 当 UDT client 收到回应以后，必须把收到的 cookie 再返回发送给 server。

> 当 UDT server 接收到一个握手报文和正确的 cookie 时，协商包大小与最大窗口，并把协商结果发送给 client。

> UDT server 将握手报文中的 packet size 和 maximum window size 信息提取出来，并同 server 端自己的 packet size 和 maximum window size信息相比较，将较小的 packet size 和 maximum window size 信息赋值给自己。

> UDT server 把包大小与最大窗口等结果发送给client端，并携带上 server 的版本号和初始序列号。为防止丢包，如果后续还接收到同一对端其他握手消息时，仍需要继续发送响应。

> UDT server 准备接收发送数据。

> UDT client 收到 server 发送的握手包，开始发送接收数据，如果还有其他握手消息，不再回应。

## Rendezvous模式–三次握手
汇合模式下，两端均为客户端，需要两端同时调用udt::connect, 主要用于NAT穿透的情况。
> 两个UDT client 同时向对方发起连接请求，发送握手包。连接类型初始值为0。

> UDT client 收到对端发送的连接请求后，检查连接类型

> 如果连接类型为0，那么响应报文中会被设置成-1。

> 如果连接类型为-1，那么响应报文中会被设置成-2。

> 如果连接类型为-2，那么将不会有任何反馈信息。


