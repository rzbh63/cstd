
# 【算法设计与数据结构】URAL 1152.False Mirrors（状态压缩dp+dfs） - jiange_zh的博客 - CSDN博客


2015年12月06日 20:57:02[jiange_zh](https://me.csdn.net/jiange_zh)阅读数：619



## 题目链接
[http://acm.timus.ru/problem.aspx?space=1&num=1152](http://acm.timus.ru/problem.aspx?space=1&num=1152)
## 题目大意
n个阳台（3<=n<=20）围成一个圈，每个阳台里有若干只怪兽（1~100）。中间有一个勇士，他每次开炮摧毁阳台i，则与i相邻的2个阳台也会跟着被摧毁（第一个阳台与第n个阳台是相邻的），摧毁后相应阳台里的怪兽都会死去。每一次开炮之后，幸存的怪兽会对他展开一次反击，每只怪兽会对他造成1点伤害值。求消灭所有怪兽时，勇士受到的最小伤害。
## 思路
对于每个阳台，只有已经被摧毁和未被摧毁两种可能，而且n最大为20，所以可以考虑用状态压缩dp。我们使用dp[sta]来表示sta状态下发起进攻后取得的最少伤害值，则dp[sta] = min{dp[next_sta]+damage}，next_sta表示在状态sta下发起攻击后得到的状态，damage则表示这一轮受到的伤害值。
## 算法步骤
1） 初始化边界条件：
memset(dp, INF, sizeof(dp));
dp[0] = 0;
2） 根据状态转移方程动态规划求解：
状态转移方程为：
dp[sta] = min{dp[next_sta]+damage}；
其中dp[next_sta]递归地求解。
## 源程序
```python
#include<iostream>
```
```python
#include<algorithm>
```
```python
#include<cstring>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
const
```
```python
int
```
```python
MAXN =
```
```python
25
```
```python
;
```
```python
const
```
```python
int
```
```python
INF =
```
```python
0x3f3f3f3f
```
```python
;
```
```python
int
```
```python
a[MAXN];
```
```python
int
```
```python
dp[(
```
```python
1
```
```python
<<
```
```python
20
```
```python
)+
```
```python
5
```
```python
];
```
```python
int
```
```python
n;
```
```python
//sta从低位到高位表示位置1~n的状态，0表示已摧毁，1表示未摧毁
```
```python
int
```
```python
dfs(
```
```python
int
```
```python
sta)
{
```
```python
if
```
```python
(dp[sta] != INF)
```
```python
return
```
```python
dp[sta];
```
```python
//每一层遍历每种可能的摧毁方式
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i <= n; i++)
    {
```
```python
//如果第i位已经被摧毁了，那么它的左右也必定被摧毁，故寻找未摧毁的。
```
```python
if
```
```python
(sta & (
```
```python
1
```
```python
<<(i-
```
```python
1
```
```python
)))  
        {
```
```python
int
```
```python
l, r, tmp;
            tmp = sta;
```
```python
//找出i的左右邻居
```
```python
if
```
```python
(i ==
```
```python
1
```
```python
)
                l = n;
```
```python
else
```
```python
l = i-
```
```python
1
```
```python
;
```
```python
if
```
```python
(i == n)
                r =
```
```python
1
```
```python
;
```
```python
else
```
```python
r = i+
```
```python
1
```
```python
;
```
```python
//攻击i
```
```python
tmp -= (
```
```python
1
```
```python
<<(i-
```
```python
1
```
```python
));
```
```python
//如果左邻居存在，攻击
```
```python
if
```
```python
(tmp&(
```
```python
1
```
```python
<<(l-
```
```python
1
```
```python
)))  
                tmp -= (
```
```python
1
```
```python
<<(l-
```
```python
1
```
```python
));
```
```python
//如果右邻居存在，攻击
```
```python
if
```
```python
(tmp&(
```
```python
1
```
```python
<<(r-
```
```python
1
```
```python
)))  
                tmp -= (
```
```python
1
```
```python
<<(r-
```
```python
1
```
```python
));
```
```python
int
```
```python
damage =
```
```python
0
```
```python
;
```
```python
//求出这一轮受到的伤害值
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
1
```
```python
; j <= n; j++)
```
```python
if
```
```python
(tmp & (
```
```python
1
```
```python
<<(j-
```
```python
1
```
```python
)))
                    damage += a[j];
```
```python
//状态转移
```
```python
dp[sta] = min(dp[sta],dfs(tmp)+damage);  
                }  
    }
```
```python
return
```
```python
dp[sta];
}
```
```python
int
```
```python
main()
{
```
```python
cin
```
```python
>>n;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i <= n; i++)
```
```python
cin
```
```python
>>a[i];
```
```python
memset
```
```python
(dp, INF,
```
```python
sizeof
```
```python
(dp));
    dp[
```
```python
0
```
```python
] =
```
```python
0
```
```python
;
```
```python
cout
```
```python
<<dfs((
```
```python
1
```
```python
<<n)-
```
```python
1
```
```python
)<<endl;
```
```python
return
```
```python
0
```
```python
;
}
```

