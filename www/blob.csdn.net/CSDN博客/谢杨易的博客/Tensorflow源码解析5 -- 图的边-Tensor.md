
# Tensorflow源码解析5 -- 图的边 - Tensor - 谢杨易的博客 - CSDN博客

2018年11月16日 18:49:49[谢杨易](https://me.csdn.net/u013510838)阅读数：893标签：[tensorflow																](https://so.csdn.net/so/search/s.do?q=tensorflow&t=blog)[源码																](https://so.csdn.net/so/search/s.do?q=源码&t=blog)[边																](https://so.csdn.net/so/search/s.do?q=边&t=blog)[tensor																](https://so.csdn.net/so/search/s.do?q=tensor&t=blog)[Variable																](https://so.csdn.net/so/search/s.do?q=Variable&t=blog)[
							](https://so.csdn.net/so/search/s.do?q=tensor&t=blog)[
																					](https://so.csdn.net/so/search/s.do?q=边&t=blog)个人分类：[深度学习																](https://blog.csdn.net/u013510838/article/category/7566761)
[
																								](https://so.csdn.net/so/search/s.do?q=边&t=blog)
[
				](https://so.csdn.net/so/search/s.do?q=源码&t=blog)
[
			](https://so.csdn.net/so/search/s.do?q=源码&t=blog)
[
		](https://so.csdn.net/so/search/s.do?q=tensorflow&t=blog)

Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)
# 1 概述
前文两篇文章分别讲解了TensorFlow核心对象Graph，和Graph的节点Operation。Graph另外一大成员，即为其边Tensor。边用来表示计算的数据，它经过上游节点计算后得到，然后传递给下游节点进行运算。本文讲解Graph的边Tensor，以及TensorFlow中的变量。

# 2 前端边Tensor数据结构
Tensor作为Graph的边，使得节点Operation之间建立了连接。上游源节点Operation经过计算得到数据Tensor，然后传递给下游目标节点，是一个典型的生产者-消费者关系。下面来看Tensor的数据结构
```python
@tf_export
```
```python
(
```
```python
"Tensor"
```
```python
)
```
```python
class
```
```python
Tensor
```
```python
(
```
```python
_TensorLike
```
```python
)
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
,
```
```python
op
```
```python
,
```
```python
value_index
```
```python
,
```
```python
dtype
```
```python
)
```
```python
:
```
```python
# 源节点，tensor的生产者，会计算得到tensor
```
```python
self
```
```python
.
```
```python
_op
```
```python
=
```
```python
op
```
```python
# tensor在源节点的输出边集合中的索引。源节点可能会有多条输出边
```
```python
# 利用op和value_index即可唯一确定tensor。
```
```python
self
```
```python
.
```
```python
_value_index
```
```python
=
```
```python
value_index
```
```python
# tensor中保存的数据的数据类型
```
```python
self
```
```python
.
```
```python
_dtype
```
```python
=
```
```python
dtypes
```
```python
.
```
```python
as_dtype
```
```python
(
```
```python
dtype
```
```python
)
```
```python
# tensor的shape，可以得到张量的rank，维度等信息
```
```python
self
```
```python
.
```
```python
_shape_val
```
```python
=
```
```python
tensor_shape
```
```python
.
```
```python
unknown_shape
```
```python
(
```
```python
)
```
```python
# 目标节点列表，tensor的消费者，会使用该tensor来进行计算
```
```python
self
```
```python
.
```
```python
_consumers
```
```python
=
```
```python
[
```
```python
]
```
```python
#
```
```python
self
```
```python
.
```
```python
_handle_data
```
```python
=
```
```python
None
```
```python
self
```
```python
.
```
```python
_id
```
```python
=
```
```python
uid
```
```python
(
```
```python
)
```
Tensor中主要包含两类信息，一个是Graph结构信息，如边的源节点和目标节点。另一个则是它所保存的数据信息，例如数据类型，shape等。

# 3 后端边Edge数据结构
后端中的Graph主要成员也是节点node和边edge。节点node为计算算子Operation，边Edge为算子所需要的数据，或者代表节点间的依赖关系。这一点和Python中的定义相似。边Edge的持有它的源节点和目标节点的指针，从而将两个节点连接起来。下面看Edge类的定义。
```python
class Edge
```
```python
{
```
```python
private
```
```python
:
```
```python
Edge
```
```python
(
```
```python
)
```
```python
{
```
```python
}
```
```python
friend class EdgeSetTest
```
```python
;
```
```python
friend class Graph
```
```python
;
```
```python
// 源节点, 边的数据就来源于源节点的计算。源节点是边的生产者
```
```python
Node
```
```python
*
```
```python
src_
```
```python
;
```
```python
// 目标节点，边的数据提供给目标节点进行计算。目标节点是边的消费者
```
```python
Node
```
```python
*
```
```python
dst_
```
```python
;
```
```python
// 边id，也就是边的标识符
```
```python
int
```
```python
id_
```
```python
;
```
```python
// 表示当前边为源节点的第src_output_条边。源节点可能会有多条输出边
```
```python
int
```
```python
src_output_
```
```python
;
```
```python
// 表示当前边为目标节点的第dst_input_条边。目标节点可能会有多条输入边。
```
```python
int
```
```python
dst_input_
```
```python
;
```
```python
}
```
```python
;
```
Edge既可以承载tensor数据，提供给节点Operation进行运算，也可以用来表示节点之间有依赖关系。对于表示节点依赖的边，其`src_output_, dst_input_`均为-1，此时边不承载任何数据。

# 4 常量constant
TensorFlow的常量constant，最终包装成了一个Tensor。通过tf.constant(10)，返回一个Tensor对象。
```python
@tf_export
```
```python
(
```
```python
"constant"
```
```python
)
```
```python
def
```
```python
constant
```
```python
(
```
```python
value
```
```python
,
```
```python
dtype
```
```python
=
```
```python
None
```
```python
,
```
```python
shape
```
```python
=
```
```python
None
```
```python
,
```
```python
name
```
```python
=
```
```python
"Const"
```
```python
,
```
```python
verify_shape
```
```python
=
```
```python
False
```
```python
)
```
```python
:
```
```python
# 算子注册到默认Graph中
```
```python
g
```
```python
=
```
```python
ops
```
```python
.
```
```python
get_default_graph
```
```python
(
```
```python
)
```
```python
# 对常量值value的处理
```
```python
tensor_value
```
```python
=
```
```python
attr_value_pb2
```
```python
.
```
```python
AttrValue
```
```python
(
```
```python
)
```
```python
tensor_value
```
```python
.
```
```python
tensor
```
```python
.
```
```python
CopyFrom
```
```python
(
```
```python
tensor_util
```
```python
.
```
```python
make_tensor_proto
```
```python
(
```
```python
value
```
```python
,
```
```python
dtype
```
```python
=
```
```python
dtype
```
```python
,
```
```python
shape
```
```python
=
```
```python
shape
```
```python
,
```
```python
verify_shape
```
```python
=
```
```python
verify_shape
```
```python
)
```
```python
)
```
```python
# 对常量值的类型dtype进行处理
```
```python
dtype_value
```
```python
=
```
```python
attr_value_pb2
```
```python
.
```
```python
AttrValue
```
```python
(
```
```python
type
```
```python
=
```
```python
tensor_value
```
```python
.
```
```python
tensor
```
```python
.
```
```python
dtype
```
```python
)
```
```python
# 构造并注册类型为“Const”的算子到Graph中，从算子的outputs中取出输出的tensor。
```
```python
const_tensor
```
```python
=
```
```python
g
```
```python
.
```
```python
create_op
```
```python
(
```
```python
"Const"
```
```python
,
```
```python
[
```
```python
]
```
```python
,
```
```python
[
```
```python
dtype_value
```
```python
.
```
```python
type
```
```python
]
```
```python
,
```
```python
attrs
```
```python
=
```
```python
{
```
```python
"value"
```
```python
:
```
```python
tensor_value
```
```python
,
```
```python
"dtype"
```
```python
:
```
```python
dtype_value
```
```python
}
```
```python
,
```
```python
name
```
```python
=
```
```python
name
```
```python
)
```
```python
.
```
```python
outputs
```
```python
[
```
```python
0
```
```python
]
```
```python
return
```
```python
const_tensor
```
tf.constant的过程为
获取默认graph
对常量值value和常量值的类型dtype进行处理
构造并注册类型为“Const”的算子到默认graph中，从算子的outputs中取出输出的tensor。
此时只是图的构造过程，tensor并未承载数据，仅表示Operation输出的一个符号句柄。经过tensor.eval()或session.run()后，才会启动graph的执行，并得到数据。

# 5 变量Variable
### Variable构造器
通过tf.Variable()构造一个变量，代码如下，我们仅分析入参。
```python
@tf_export
```
```python
(
```
```python
"Variable"
```
```python
)
```
```python
class
```
```python
Variable
```
```python
(
```
```python
object
```
```python
)
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
,
```
```python
initial_value
```
```python
=
```
```python
None
```
```python
,
```
```python
trainable
```
```python
=
```
```python
True
```
```python
,
```
```python
collections
```
```python
=
```
```python
None
```
```python
,
```
```python
validate_shape
```
```python
=
```
```python
True
```
```python
,
```
```python
caching_device
```
```python
=
```
```python
None
```
```python
,
```
```python
name
```
```python
=
```
```python
None
```
```python
,
```
```python
variable_def
```
```python
=
```
```python
None
```
```python
,
```
```python
dtype
```
```python
=
```
```python
None
```
```python
,
```
```python
expected_shape
```
```python
=
```
```python
None
```
```python
,
```
```python
import_scope
```
```python
=
```
```python
None
```
```python
,
```
```python
constraint
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
# initial_value: 初始值，为一个tensor，或者可以被包装为tensor的值
```
```python
# trainable：是否可以训练，如果为false，则训练时不会改变
```
```python
# collections：变量要加入哪个集合中，有全局变量集合、本地变量集合、可训练变量集合等。默认加入全局变量集合中
```
```python
# dtype：变量的类型
```
主要的入参代码中已经给出了注释。Variable可以接受一个tensor或者可以被包装为tensor的值，来作为初始值。事实上，Variable可以看做是Tensor的包装器，它重载了Tensor的几乎所有操作，是对Tensor的进一步封装。
### Variable初始化
变量只有初始化后才能使用，初始化时将initial_value初始值赋予Variable内部持有的Tensor。通过运行变量的初始化器可以对变量进行初始化，也可以执行全局初始化器。如下
```python
y
```
```python
=
```
```python
tf
```
```python
.
```
```python
Variable
```
```python
(
```
```python
[
```
```python
5.3
```
```python
]
```
```python
)
```
```python
with
```
```python
tf
```
```python
.
```
```python
Session
```
```python
(
```
```python
)
```
```python
as
```
```python
sess
```
```python
:
```
```python
initialization
```
```python
=
```
```python
tf
```
```python
.
```
```python
global_variables_initializer
```
```python
(
```
```python
)
```
```python
print
```
```python
sess
```
```python
.
```
```python
run
```
```python
(
```
```python
y
```
```python
)
```
### Variable集合
Variable被划分到不同的集合中，方便后续操作。常见的集合有
全局变量：全局变量可以在不同进程中共享，可运用在分布式环境中。变量默认会加入到全局变量集合中。通过tf.global_variables()可以查询全局变量集合。其op标示为GraphKeys.GLOBAL_VARIABLES
@tf_export("global_variables")defglobal_variables(scope=None):returnops.get_collection(ops.GraphKeys.GLOBAL_VARIABLES,scope)
本地变量：运行在进程内的变量，不能跨进程共享。通常用来保存临时变量，如训练迭代次数epoches。通过tf.local_variables()可以查询本地变量集合。其op标示为GraphKeys.LOCAL_VARIABLES
@tf_export("local_variables")deflocal_variables(scope=None):returnops.get_collection(ops.GraphKeys.LOCAL_VARIABLES,scope)
可训练变量：一般模型参数会放到可训练变量集合中，训练时，做这些变量会得到改变。不在这个集合中的变量则不会得到改变。默认会放到此集合中。通过tf.trainable_variables()可以查询。其op标示为GraphKeys.TRAINABLE_VARIABLES
@tf_export("trainable_variables")deftrainable_variables(scope=None):returnops.get_collection(ops.GraphKeys.TRAINABLE_VARIABLES,scope)
其他集合还有model_variables，moving_average_variables。
Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)

