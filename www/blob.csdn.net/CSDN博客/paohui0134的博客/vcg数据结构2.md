
# vcg数据结构2 - paohui0134的博客 - CSDN博客


2016年11月13日 15:54:57[paohui0134](https://me.csdn.net/paohui0134)阅读数：335


# vcg数据结构2
主要是used_types.h文件中定义的一些类
## UsedTypes类
定义如下
```python
template
```
```python
<
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
A = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
B = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
C = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
D = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
E = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
F = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
G = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
H = DefaultDeriver >
```
```python
class
```
```python
UsedTypes:
```
```python
public
```
```python
Arity12<DummyTypes,
Use<Vertex<UsedTypes<A,B,C,D,E,F,G,H>>> ::
```
```python
template
```
```python
AsVertexType,
Use<Edge<UsedTypes<A,B,C,D,E,F,G,H>>>::
```
```python
template
```
```python
AsEdgeType,
Use<Face<UsedTypes<A,B,C,D,E,F,G,H>>>::
```
```python
template
```
```python
AsFaceType,
Use<HEdge<UsedTypes<A,B,C,D,E,F,G,H>>>::
```
```python
template
```
```python
AsHEdgeType,
A, B, C, D, E, F, G, H>  
{};
```
UsedTypes继承于Arity12，而Arity12类之前有分析过，就是一连串的继承链表，现在设
```python
T1=Use<Vertex<UsedTypes<A,B,
```
```python
C
```
```python
,
```
```python
D
```
```python
,
```
```python
E
```
```python
,F,G,H>>>::template AsVertexType
T2=Use<Edge<UsedTypes<A,B,
```
```python
C
```
```python
,
```
```python
D
```
```python
,
```
```python
E
```
```python
,F,G,H>>>::template AsEdgeType
T3=Use<Face<UsedTypes<A,B,
```
```python
C
```
```python
,
```
```python
D
```
```python
,
```
```python
E
```
```python
,F,G,H>>>::template AsFaceType
T4=Use<HEdge<UsedTypes<A,B,
```
```python
C
```
```python
,
```
```python
D
```
```python
,
```
```python
E
```
```python
,F,G,H>>>:: template AsHEdgeType
```
那么UsedTypes类的继承关系大致如下：
```python
UsedTypes：Arity12：H：Arity11：G：Arity10：F：Arity9：
```
```python
E
```
```python
：Arity8：
```
```python
D
```
```python
：Arity7：
```
```python
C
```
```python
：Arity6：B：Arity5：A：Arity4
而Arity4的模板参数为：
Arity4<DummyTypes,T1,T2,T3,T4>
```
那么可以推测，类T1 T2 T3 T4都是模板类且继承于模板参数类，事实也是如此，以T1为例：
```python
Use<Vertex<UsedTypes<A,B,
```
```python
C
```
```python
,
```
```python
D
```
```python
,
```
```python
E
```
```python
,F,G,H>>>::template AsVertexType
设Vertex<UsedTypes<A,B,
```
```python
C
```
```python
,
```
```python
D
```
```python
,
```
```python
E
```
```python
,F,G,H>>为X1，T1为
Use<X1>::template AsVertexType
```
AsVertexType的定义如下：
```python
template
```
```python
<
```
```python
class
```
```python
T>
```
```python
struct
```
```python
AsVertexType:
```
```python
public
```
```python
T{
```
```python
typedef
```
```python
A VertexType;
```
```python
typedef
```
```python
VertexType * VertexPointer  ;};
对于Use<X1>，此处的A=X1
```
也就是说T1确实是一个模板类，且继承于模板类参数，那么继承链表在Arity4就可以继续向下去了，所以整个继承链表如下：
```python
UsedTypes：Arity12：H：Arity11：G：Arity10：F：Arity9：
```
```python
E
```
```python
：Arity8：
```
```python
D
```
```python
：Arity7：
```
```python
C
```
```python
：Arity6：B：Arity5：A：Arity4：T4：Arity3：T3：Arity2：T2：Arity1：T1：DummyTypes
```
DummyTypes类定义如下：
```python
struct
```
```python
DummyTypes{
```
```python
typedef
```
```python
_Vertex VertexType;
```
```python
// simplex types
```
```python
typedef
```
```python
_Edge EdgeType;
```
```python
typedef
```
```python
_Face FaceType;
```
```python
typedef
```
```python
char
```
```python
TetraType;
```
```python
typedef
```
```python
_HEdge HEdgeType;
```
```python
// connector types
```
```python
typedef
```
```python
vcg::Point3<
```
```python
bool
```
```python
> CoordType;
```
```python
typedef
```
```python
char
```
```python
ScalarType;
```
```python
typedef
```
```python
VertexType * VertexPointer;
```
```python
typedef
```
```python
EdgeType *  EdgePointer     ;
```
```python
typedef
```
```python
FaceType * FacePointer      ;
```
```python
typedef
```
```python
TetraType * TetraPointer    ;
```
```python
typedef
```
```python
HEdgeType * HEdgePointer    ;
```
```python
static
```
```python
void
```
```python
Name(
```
```python
std
```
```python
::
```
```python
vector
```
```python
<
```
```python
std
```
```python
::
```
```python
string
```
```python
>
```
```python
&
```
```python
/*name*/
```
```python
){}
```
```python
template
```
```python
<
```
```python
class
```
```python
LeftV>
```
```python
void
```
```python
ImportData(
```
```python
const
```
```python
LeftV  &
```
```python
/*left*/
```
```python
) {}
};
```
主要是一些类型的定义(typedef)，可以推测，整个继承链的作用之一就是覆盖这个类的一些类型定义。
那么第一个其覆盖作用的就是T1,T2,T3,T4这4个类，此处以T4为例做分析：
```python
T4=Use<HEdge<UsedTypes<A,B,C,D,E,F,G,H>>>::
```
```python
template
```
```python
AsHEdgeType
```
```python
template
```
```python
<
```
```python
class
```
```python
T>
```
```python
struct
```
```python
AsHEdgeType:
```
```python
public
```
```python
T{
```
```python
typedef
```
```python
A HEdgeType;
```
```python
typedef
```
```python
HEdgeType * HEdgePointer        ;};
```
可以看到该类覆盖了基类的两个定义：
```python
typedef
```
```python
A HEdgeType;
```
```python
typedef
```
```python
HEdgeType * HEdgePointer
```
T1 T2 T3类似，那么到这一步，可以看到我们分析的这个UsedTypes类主要就是定义了几种类型，当然目前只是默认情况，事实上根据用户选择使用的模板参数，会再次覆盖基类的定义。
## 顶点类型的定义
现在接着上面的分析，来看一下顶点到底是什么。
此时要回到最开始，vcg定义了_UsedTypes
```python
struct
```
```python
_UsedTypes:
```
```python
public
```
```python
UsedTypes<
    Use<_Vertex>::AsVertexType,
    Use<_Edge  >::AsEdgeType,
    Use<_Face  >::AsFaceType,
    Use<_HEdge >::AsHEdgeType
>{};
```
```python
struct
```
```python
_Vertex:
```
```python
public
```
```python
Vertex<_UsedTypes>{};
```
```python
struct
```
```python
_Edge  :
```
```python
public
```
```python
Edge<_UsedTypes>{};
```
```python
struct
```
```python
_Face  :
```
```python
public
```
```python
Face<_UsedTypes>{};
```
```python
struct
```
```python
_HEdge :
```
```python
public
```
```python
HEdge<_UsedTypes>{};
```
_UsedTypes给模板参数A B C D赋了值，而A B C D将会导致VertexType等类型被覆盖，也就是说最终_UsedTypes中的类型定义如下，以顶点类型为例
```python
typedef
```
```python
A VertexType;
```
```python
typedef
```
```python
VertexType * VertexPointer  ;
此处的A为_Vertex
```
那么再来看`_Vertex: public  Vertex<_UsedTypes>{};`定义如下
```python
template
```
```python
<
```
```python
class
```
```python
UserTypes,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
A=DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
B = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
C=DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
D = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
E=DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
F = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
G=DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
H = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
I=DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
J = DefaultDeriver,
```
```python
template
```
```python
<
```
```python
typename
```
```python
>
```
```python
class
```
```python
K = DefaultDeriver>
```
```python
class
```
```python
Vertex:
```
```python
public
```
```python
VertexArityMax<UserTypes, A, B, C, D, E, F, G, H, I, J, K>  {
```
```python
public
```
```python
:
```
```python
typedef
```
```python
AllTypes::AVertexType IAm;
```
```python
typedef
```
```python
UserTypes TypesPool;
}
```
```python
// end namespace
```
类本身只有两个定义：
```python
typedef
```
```python
AllTypes::AVertexType IAm;
```
```python
typedef
```
```python
UserTypes TypesPool;
其中UserTypes 为_UsedTypes。
```
继续分析AVertexType ，会发现`VertexArityMax：public Arity12<vertex::EmptyCore<UserTypes>, A, B, C, D, E, F, G, H, I, J, K, L>`
HEdgeArityMax本身也是有内容的，主要是一些标记位的方法与定义，这里就不展开了。
最终，会继承于`vertex::EmptyCore<UserTypes>`
```python
template
```
```python
<
```
```python
class
```
```python
TT>
```
```python
template
```
```python
<
```
```python
class
```
```python
TT>
```
```python
class
```
```python
EmptyCore:
```
```python
public
```
```python
TT 
此时模板参数TT=UsedTypes<A,B,C,D,E,F,G,H>
可以看到EmptyCore类定义了许多方法，但都是一些简单的实现。
```
那么现在来看一下`TT=_UsedTypes`
此时就要回到最开始的定义了，_UsedTypes: public UsedTypes
这样，每种类型本身优会包含其它类型的定义了。
总的来说，vcg的_UsedTypes与_Vertex等只是继承了基本类型，并没有什么实质性的实现。

