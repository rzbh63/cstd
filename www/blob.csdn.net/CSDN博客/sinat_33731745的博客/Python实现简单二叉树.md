
# Python实现简单二叉树 - sinat_33731745的博客 - CSDN博客

2018年02月13日 00:22:32[Tao-Tao-Tao](https://me.csdn.net/sinat_33731745)阅读数：1009



```python
class
```
```python
BinaryTree
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(self,rootObj)
```
```python
:
```
```python
self.root = rootObj
        self.leftChild =
```
```python
None
```
```python
self.rightChild =
```
```python
None
```
```python
def
```
```python
insertLeft
```
```python
(self,newNode)
```
```python
:
```
```python
if
```
```python
self.leftChild ==
```
```python
None
```
```python
:
            self.leftChild = BinaryTree(newNode)
```
```python
else
```
```python
:
            print(
```
```python
'The leftChild is not None.You can not insert'
```
```python
)
```
```python
def
```
```python
insertRight
```
```python
(self,newNode)
```
```python
:
```
```python
if
```
```python
self.rightChild ==
```
```python
None
```
```python
:
            self.rightChild = BinaryTree(newNode)
```
```python
else
```
```python
:
            print(
```
```python
'The rightChild is not None.You can not insert'
```
```python
)
```
构建了一个简单的二叉树类，它的初始化函数，将传入的rootObj赋值给self.root，作为根节点，leftChild和rightChild都默认为None。
函数insertLeft为向二叉树的左子树赋值，若leftChild为空，则先构造一个BinaryTree(newNode)，即实例化一个新的二叉树，然后将这棵二叉树赋值给原来的二叉树的leftChild。此处递归调用了BinaryTree这个类。
若不为空 则输出：The rightChild is not None.You can not insert
执行下述语句
```python
r = BinaryTree(
```
```python
'a'
```
```python
)
```
```python
print
```
```python
(
```
```python
'root:'
```
```python
,r.root,
```
```python
';'
```
```python
,
```
```python
'leftChild:'
```
```python
,r.leftChild,
```
```python
';'
```
```python
,
```
```python
'rightChild:'
```
```python
,r.rightChild)
```
输出
```python
root
```
```python
:
```
```python
a ; leftChild: None ; rightChild: None
```
即我们构造了一颗二叉树，根节点为a，左右子树均为None
然后执行下述语句
```python
r.insertLeft(
```
```python
'b'
```
```python
)
```
```python
print
```
```python
(
```
```python
'root:'
```
```python
,r.root,
```
```python
';'
```
```python
,
```
```python
'leftChild:'
```
```python
,r.leftChild,
```
```python
';'
```
```python
,
```
```python
'rightChild:'
```
```python
,r.rightChild)
```
```python
print
```
```python
(
```
```python
'root:'
```
```python
,r.root,
```
```python
';'
```
```python
,
```
```python
'leftChild.root:'
```
```python
,r.leftChild.root,
```
```python
';'
```
```python
,
```
```python
'rightChild:'
```
```python
,r.rightChild)
```
输出
```python
root
```
```python
:
```
```python
a ; leftChild: <__main__.BinaryTree object at 0x000002431E4A0DA0> ; rightChild: None
```
```python
root
```
```python
:
```
```python
a ; leftChild.root: b ; rightChild: None
```
我们向r插入了一个左节点，查看输出的第一句话，可以看到左节点其实也是一个BinaryTree，这是因为插入时，递归生成的。
第二句输出，可以查看左节点的值
最后执行
```python
r
```
```python
.insertLeft
```
```python
(
```
```python
'c'
```
```python
)
```
```python
The leftChild
```
```python
is
```
```python
not
```
```python
None
```
```python
.You can
```
```python
not
```
```python
insert
```
可以看到，我们无法再向左节点插入了，因为该节点已经有值了

