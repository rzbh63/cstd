# 最近整理的一些常见的面试题，面试大全，黑马程序员面试宝典题库---最新技术--篇

2018年09月06日 10:11:57 [高数老师](https://me.csdn.net/qq_29073921) 阅读数：424



版权声明：代码共享，欢迎copy	https://blog.csdn.net/qq_29073921/article/details/82354607

#  第八章 最新技术（评论区留言获取原件）

##  一、 Redis

###  1. Redis 的特点？

​       Redis 是由意大利人 Salvatore Sanfilippo（网名： antirez）开发的一款内存高速缓存数据库。 Redis 全称为：Remote Dictionary Server（远程数据服务），该软件使用 C 语言编写，典型的 NoSQL 数据库服务器， Redis 是一个 key-value 存储系统，它支持丰富的数据类型，如： string、 list、 set、 zset(sorted set)、 hash。
​        Redis 本质上是一个 Key-Value 类型的内存数据库，很像 memcached，整个 数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘 上进行保存。因为是纯内存操作， Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value DB。
​        Redis 的出色之处不仅仅是性能， Redis 最大的魅力是支持保存多种数据结构，此外单 个 value 的最大限制是1GB，不像 memcached 只能保存 1MB 的数据，另外 Redis 也可以对存入的 Key-Value 设置 expire 时间。
​        Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。

###  2. 为什么 redis 需要把所有数据放到内存中？

​        Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和
数据持久化的特征。如果不将数据放在内存中，磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，
redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。

###  3. Redis 常见的性能问题都有哪些？如何解决？

（1）、 Master 写内存快照， save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。
（2）、 Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大， AOF 文件过大会影响 Master 重启的恢复速度。 Master 最好不要做任何持久化工作，包括内存快照和 AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。
（3）、 Master 调用 BGREWRITEAOF 重写 AOF 文件， AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。
（4）、 Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性， Slave 和 Master 最好在同一个局域网内。

###  4. Redis 最适合的场景有哪些？

（1）、会话缓存（Session Cache）
（2）、全页缓存（FPC）
（3）、队列
（4）、排行榜/计数器
（5）、发布/订阅

###  5. Memcache 与 Redis 的区别都有哪些？

（1）、存储方式不同， Memcache 是把数据全部存在内存中，数据不能超过内存的大小，断电后数据库会挂掉。Redis 有部分存在硬盘上，这样能保证数据的持久性。
（2）、数据支持的类型不同 memcahe 对数据类型支持相对简单， redis 有复杂的数据类型。
（3）、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
（4）、支持的 value 大小不一样 redis 最大可以达到 1GB，而 memcache 只有 1MB。

###  6. Redis 用过 RedisNX 吗？ Redis 有哪几种数据结构？

反正我是不知道 redisnx 是什么，度娘也不清楚，如果面试中问道自己没有接触过或者没有听过的技术可以直接
大胆的告诉他，没有接触过，或者没有听过。


Redis 的数据结构有五种，分别是：
**String——字符串**
String 数据结构是简单的 key-value 类型， value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候 encoding 就是整型，其他都存储在 sdshdr 当做字符串）。
**Hash——字典**
在 Memcached 中，我们经常将一些结构化的信息打包成 hashmap，在客户端序列化后存储为一个字符串的值
（一般是 JSON 格式），比如用户的昵称、年龄、性别、积分等。
**List——列表**
List 说白了就是链表（redis 使用双端链表实现的 List），相信学过数据结构知识的人都应该能理解其结构。
**Set——集合**
Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。
**Sorted Set——有序集合**
和 Sets 相比， Sorted Sets 是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，
\1. 带有权重的元素，比如一个游戏的用户得分排行榜
2.比较复杂的数据结构，一般用到的场景不算太多

###  7. Redis 的优缺点

**优点：**
a) 性能极高 – Redis 能支持超过 100K+ 每秒的读写频率。
b) 丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
c) 原子 – Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。
attention 原子性定义：例如， A 想要从自己的帐户中转 1000 块钱到 B 的帐户里。那个从 A 开始转帐，到转帐结束的这一个过程，称之为一个事务。如果在 A 的帐户已经减去了 1000 块钱的时候，忽然发生了意外，比如停电什么的，导致转帐事务意外终止了，而此时 B 的帐户里还没有增加 1000 块钱。那么，我们称这个操作失败了，要进行回滚。回滚就是回到事务开始之前的状态，也就是回到 A 的帐户还没减 1000 块的状态， B 的帐户的原来的状态。此时A 的帐户仍然有 3000 块， B 的帐户仍然有 2000 块。我们把这种要么一起成功（A 帐户成功减少 1000，同时 B 帐户成功增加 1000），要么一起失败（A 帐户回到原来状态， B 帐户也回到原来状态）的操作叫原子性操作。如果把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行，这种特性就叫原子性。
·d）丰富的特性 – Redis 还支持 publish/subscribe, 通知, key 过期等等特性。
**缺点：**
a） . 由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 redis 本身有 key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
b). 如果进行完整重同步，由于需要生成 rdb 文件，并进行传输，会占用主机的 CPU，并会消耗现网的带宽。不过 redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
c). 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中， redis 不能提供服务。

###  8. Redis 的持久化

**RDB 持久化**：该机制可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。
**AOF 持久化**：记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小无持久化：让数据只在服务器运行时存在。
**同时应用 AOF 和 RDB**：当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。
**RDB 的优缺点：**
优点： RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。 RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。 RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
缺点：如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为 RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。每次保存 RDB 的时候， Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。
**AOF 的优缺点：**
优点：1、使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟fsync 一次，在这种配置下， Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。 AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。
2、 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕， Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。

##  二、 消息队列 ActiveMQ

### 1. 如何使用 ActiveMQ 解决分布式事务？

在互联网应用中，基本都会有用户注册的功能。在注册的同时，我们会做出如下操作：
1.收集用户录入信息，保存到数据库
2.向用户的手机或邮箱发送验证码
等等…
如果是传统的集中式架构，实现这个功能非常简单：开启一个本地事务，往本地数据库中插入一条用户数据，发送验证
码，提交事物。
但是在分布式架构中，用户和发送验证码是两个独立的服务，它们都有各自的数据库，那么就不能通过本地事物保证操作的原子性。这时我们就需要用到 ActiveMQ（消息队列）来为我们实现这个需求。
在用户进行注册操作的时候，我们为该操作创建一条消息，当用户信息保存成功时，把这条消息发送到消息队列。验证码系统会监听消息，一旦接受到消息，就会给该用户发送验证码。
问题：
1.如何防止消息重复发送？
解决方法很简单：增加消息状态表。通俗来说就是一个账本，用来记录消息的处理状态，每次处理消息之前，都去状态表中查询一次，如果已经有相同的消息存在，那么不处理，可以防止重复发送。

###  2. 了解哪些消息队列？

**ActiveMQ、 RabbitMQ、 kafka。**
**RabbitMQ**
RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议： AMQP， XMPP, SMTP, STOMP，也正因如此，它非常重量级，更适合于企业级的开发。同时实现了 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队。对路由，负载均衡或者数据持久化都有很好的支持。
**ActiveMQ**
ActiveMQ 是 Apache 下的一个子项目。 类似于 ZeroMQ，它能够以代理人和点对点的技术实现队列。同时类似于RabbitMQ，它少量代码就可以高效地实现高级应用场景。
**Kafka/Jafka**
Kafka 是 Apache 下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而 Jafka 是在 Kafka 之上孵化而来的，即 Kafka 的一个升级版。具有以下特性：快速持久化，可以在 O(1)的系统开销下进行消息持久化；高吞吐，在一台普通的服务器上既可以达到 10W/s 的吞吐速率；完全的分布式系统， Broker、 Producer、 Consumer 都原生自动支持分布式，自动实现负载均衡；支持 Hadoop 数据并行加载，对于像 Hadoop 的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。 Kafka 通过 Hadoop 的并行加载机制统一了在线和离线的消息处理。 Apache Kafka 相对于 ActiveMQ 是一个非常轻量级的消息系统，除了性能非常好之外，还是一个工作良好的分布式系统。
MQ 选型对比图

![img](https://img-blog.csdn.net/20180906094522200?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MDczOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

###  3. ActiveMQ 如果消息发送失败怎么办？

Activemq 有两种通信方式，点到点形式和发布订阅模式。
如果是点到点模式的话，如果消息发送不成功此 消息默认会保存到 activemq 服务端知道有消费者将其消费，所以此时消息是不会丢失的。
如果是发布订阅模式的通信方式，默认情况下只通知一次，如果接收不到此消息就没有了。这种场景只适 用于对消息送达率要求不高的情况。如果要求消息必须送达不可以丢失的话，需要配置持久订阅。每个订阅端定义一个 id，在订阅是向 activemq 注册。发布消息和接收消息时需要配置发送模式为持久化。此时 如果客户端接收不到消息，消息会持久化到服务端，直到客户端正常接收后为止。

##  三、 Dubbo

## 1. Dubbo 的容错机制有哪些。

Dubbo 官网提出总共有六种容错策略
Failover Cluster 模式
失败自动切换，当出现失败，重试其它服务器。 (默认)
Failfast Cluster
快速失败，只发起一次调用，失败立即报错。 通常用于非幂等性的写操作，比如新增记录。
Failsafe Cluster
失败安全，出现异常时，直接忽略。 通常用于写入审计日志等操作。
Failback Cluster
失败自动恢复，后台记录失败请求，定时重发。 通常用于消息通知操作。
Forking Cluster
并行调用多个服务器，只要一个成功即返回。 通常用于实时性要求较高的读操作，但需要浪费更多服务资源。
可通过 forks=” 2”来设置最大并行数。
Broadcast Cluster
广播调用所有提供者，逐个调用，任意一台报错则报错。 (2.1.0 开始支持) 通常用于通知所有提供者更新缓存或日志等本地资源信息。
**总结：** 在实际应用中查询语句容错策略建议使用默认 Failover Cluster ，而增删改建议使用 Failfast Cluster 或者 使用 Failover Cluster（retries=” 0”） 策略 防止出现数据 重复添加等等其它问题！建议在设计接口时候把查询接口方法单独做一个接口提供查询。

###  2. 使用 dubbo 遇到过哪些问题？

1.增加提供服务版本号和消费服务版本号.
这个具体来说不算是一个问题,而是一种问题的解决方案,在我们的实际工作中会面临各种环境资源短缺的问题,也是很实际的问题,刚开始我们还可以提供一个服务进行相关的开发和测试,但是当有多个环境多个版本,多个任务的时候就不满足我们的需求,这时候我们可以通过给提供方增加版本的方式来区分.这样能够剩下很多的物理资源,同时为今后更换接口定义发布在线时，可不停机发布，使用版本号.
引用只会找相应版本的服务,例如
<dubbo:serviceinterface=“com.xxx.XxxService” ref=“xxxService” version=“1.0” />
<dubbo:referenceid=“xxxService” interface=“com.xxx.XxxService” version=“1.0” />


2.dubbo reference 注解问题
@Reference 只能在 springbean 实例对应的当前类中使用，暂时无法在父类使用；如果确实要在父类声明一个引用，可通过配置文件配置 dubbo:reference，然后在需要引用的地方跟引用 springbean 一样就可以了.


3.出现 RpcException: No provider available for remote service 异常，表示没有可用的服务提供者。
1). 检查连接的注册中心是否正确
2). 到注册中心查看相应的服务提供者是否存在
3). 检查服务提供者是否正常运行
\4. 服务提供者没挂，但在注册中心里看不到
首先，确认服务提供者是否连接了正确的注册中心，不只是检查配置中的注册中心地址，而且要检查实际的网络连接。其次，看服务提供者是否非常繁忙，比如压力测试，以至于没有 CPU 片段向注册中心发送心跳，这种情况，减小压力，将自动恢复。

###  3. Dubbo 的连接方式有哪些？

Dubbo 的客户端和服务端有三种连接方式，分别是：广播，直连和使用 zookeeper 注册中心。
3.1、 Dubbo 广播
这种方式是 dubbo 官方入门程序所使用的连接方式，但是这种方式有很多问题。
在企业开发中，不使用广播的方式。
taotao-manager 服务端配置：

```
<!-- applicationContext-service.xml 文件中 -->



<!-- 提供方应用信息，用于计算机依赖关系 -->



<dubbo:application name=”taotao-manager-service” />



<!-- 使用 multicast 广播暴露服务地址 -->



<dubbo:registry address=”multicast://224.5.6.7:1234” />



<!-- 使用 dubbo 协议在 20880 协议暴露服务 -->



<dubbo:protocol name=”dubbo” port=”20880” />



<!-- 声明需要暴露的服务接口 -->



<dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” />



</bean>
```


客户端配置 taotao-manager-web 的配置如下：

```
<!--springMVC.xml 文件中 -->



<!-- 配置 dubbo 服务 -->



<dubbp:application name=”taotao-manager-web” />



<!-- 使用 multicast 广播暴露服务地址 -->



<dubbo:registry address=”multicast://224.5.6.7:1234” />



<!-- 声明要调用的服务 timeout 是设置连接超时最长时间，如果不设置，默认超时时间为 3 秒 -->



<dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService”



timeout=”10000000” />



</bean>
```


3.2、 Dubbo 直连
这种方式在企业中一般在开发中环境中使用，但是生产环境很少使用，因为服务是直接调用，没有使用注册中心，很难对服务进行管理。 Dubbo 直连，首先要取消广播，然后客户端直接到指定需要的服务的 url 获取服务即可。
服务端配置： taotao-manager 的修改如下，取消广播，注册中心地址为 N/A

```
<!-- applicationContext-service.xml 文件中 -->



<!-- 提供方应用信息，用于计算机依赖关系 -->



<dubbo:application name=”taotao-manager-service” />



<!-- <dubbo:registry address=”multicast://224.5.6.7:1234” /> -->



<!-- 使用 multicast 广播暴露服务地址 -->



<dubbo:registry address=”N/A” />



<!-- 使用 dubbo 协议在 20880 协议暴露服务 -->



<dubbo:protocol name=”dubbo” port=”20880” />



<!-- 声明需要暴露的服务接口 -->



<dubbo:service interface=”com.taotao.manager.service.TestService” ref=”testServiceImpl” />



</bean>
```


客户端配置： taotao-manager-web 配置如下，取消广播，从指定的 url 中获取服务

```
<!--springMVC.xml 文件中 -->



<!-- 配置 dubbo 服务 -->



<dubbp:application name=”taotao-manager-web” />



<!-- 使用 multicast 广播暴露服务地址 -->



<!-- <dubbo:registry address=”multicast://224.5.6.7:1234” /> -->



<!-- 声明要调用的服务 timeout 是设置连接超时最长时间，如果不设置，默认超时时间为 3 秒 -->



<dubbo:service interface=”com.taotao.manager.service.TestService” id=”testService”



timeout=”10000000” />



</bean>
```


3.3、 Dubbo 注册中心
Dubbo 注册中心和广播注册中心配置类似，不过需要指定注册中心类型和注册中心地址，这个时候就不是把服务信息进行广播了，而是告诉给注册中心进行管理，这个时候我们就需要有一个注册中心。
官方推荐使用 zookeeper 作为注册中心。


3.31、 Zookeeper 介绍
zookeeper 在 dubbo 所处的位置：

![img](https://img-blog.csdn.net/20180906095337211?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MDczOTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**Provider: 暴露服务的服务提供方。Consumer: 调用远程服务的服务消费方。Registry: 服务注册与发现的注册中心。Monitor: 统计服务的调用次调和调用时间的监控中心。Container: 服务运行容器。**

调用关系说明：
0 .服务容器负责启动，加载，运行服务提供者。
1. 服务提供者在启动时，向注册中心注册自己提供的服务。
2. 服务消费者在启动时，向注册中心订阅自己所需的服务。
3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一
台调用。
5. 服务消费者和提供者， 在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

##  四、 并发相关

### 1. 如何测试并发量？

可以使用 apache 提供的 ab 工具测试。
参考资料： <https://blog.csdn.net/whynottrythis/article/details/46495309>

##  五、 Nginx

### 1. Nginx 反向代理为什么能够提升服务器性能？

​        对于后端是动态服务来说，比如 Java 和 PHP。这类服务器(如 JBoss 和 PHP-FPM)的 IO 处理能力往往不高。Nginx 有个好处是它会把 Request 在读取完整之前 buffer 住，这样交给后端的就是一个完整的 HTTP请求，从而提高后端的效率，而不是[断断续续](https://www.baidu.com/s?wd=%E6%96%AD%E6%96%AD%E7%BB%AD%E7%BB%AD&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)的传递(互联网上连接速度一般比较慢)。 同样， Nginx 也可以把response 给 buffer 住，同样也是减轻后端的压力。


\2. Nginx 和 Apache 各有什么优缺点?


nginx 相对 apache 的优点:
轻量级，同样起 web 服务，比 apache 占用更少的内存及资源
抗并发， nginx 处理请求是异步非阻塞的，而 apache 则是阻塞型的，在高并发下 nginx 能保持低资源低消耗高性能
高度模块化的设计，编写模块相对简单
社区活跃，各种高性能模块出品迅速啊
apache 相对 nginx 的优点:
ewrite，比 nginx 的 rewrite 强大
模块超多，基本想到的都可以找到
少 bug， nginx 的 bug 相对较多
超稳定
一般来说，需要性能的 web 服务，用 nginx 。 如果不需要性能只求稳定，那就 apache 吧。

###  3. Nginx 多进程模型是如何实现高并发的？

​        进程数与并发数不存在很直接的关系。这取决取 server 采用的工作方式。如果一个 server 采用一个进程负责一个 request 的方式，那么进程数就是并发数。那么[显而易见](https://www.baidu.com/s?wd=%E6%98%BE%E8%80%8C%E6%98%93%E8%A7%81&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)的，就是会有很多进程在等待中。等什么？最多的应该是等待网络传输。
​        Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。 apache 是如何利用的呢，简单来说：同样的 4 个进程，如果采用一个进程负责一个 request 的方式，那么，同时进来 4 个 request 之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第 5 个 request 进来了。就无法及时反应了，因为 4 个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个 request，就新开个进程来处理。 nginx 不这样，每进来一个 request，会有一个 worker 进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发 request，并等待请求返回。那么，这个处理的 worker 不会这么傻等着，他会在发送完请求后，注册一个事件： “如果 upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有 request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件， worker 才会来接手，这个 request 才会接着往下走。
​        由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中，实际上花费在 server 机器
上的时间片不多。这是几个进程就解决高并发的秘密所在。 webserver 刚好属于网络 io 密集型应用，不算是计算密
集型。异步，非阻塞，使用 epoll，和大量细节处的优化。也正是 nginx 之所以然的技术基石。

##  六、 Zookeeper

### 1. 简单介绍一下 zookeeper 以及 zookeeper 的原理。

​        ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括:配置维护、域名服务、分布式同步、组服务等。
ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、 功能稳定的系统提供给用户。
ZooKeeper 包含一个简单的原语集， 提供 Java 和 C 的接口。
ZooKeeper 代码版本中，提供了分布式独享锁、选举、队列的接口，代码在 zookeeper-3.4.3\src\recipes。其中分布锁和队列有 Java 和 C 两个版本，选举只有 Java 版本。
原理：
ZooKeeper 是以 Fast Paxos 算法为基础的， Paxos 算法存在活锁的问题，即当有多个 proposer 交错提交时，有可能互相排斥导致没有一个 proposer 能提交成功，而 Fast Paxos 作了一些优化，通过选举产生一个 leader (领导者)，只有 leader 才能提交 proposer，具体 算法可见 Fast Paxos。因此，要想弄懂 ZooKeeper 首先得对 Fast Paxos 有所了解。


**ZooKeeper 的基本运转流程:**1、选举 Leader。 2、同步数据。 3、选举 Leader 过程中算法有很多，但要达到的选举标准是一致的。 4、 Leader 要具有最高的执行 ID，类似 root 权限。 5、集群中大多数的机器得到响应并 follow 选出的 Leader。

##  七、 solr

### 1. 简单介绍一下 solr

​        Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于 Web-service 的 API 接口。 用户可以通过 http 请求，向搜索引擎服务器提交一定格式的 XML 文件，生成索引;也可以 通过 Http Get 操作提出查找请求，并得到 XML格式的返回结果。
特点:
Solr 是一个高性能，采用 Java5 开发，基于 Lucene 的全文搜索服务器。同时对其进行 了扩展，提供了比 Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能 进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。
工作方式:
文档通过 Http 利用 XML 加到一个搜索集合中。查询该集合也是通过 http 收到一个 XML/JSON 响应来实现。它的主要特性包括:高效、灵活的缓存功能，垂直搜索功能，高亮 显示搜索结果，通过索引复制来提高可用性，提供一套强大 Data Schema 来定义字段，类 型和设置文本分析，提供基于 Web 的管理界面等。

###  2. solr 怎么设置搜索结果排名靠前？

可以设置文档中域的 boost 值， boost 值越高，计算出来的相关度得分就越高， 排名也就越靠前。此方法可以把热点商品或者推广商品的排名提高。

###  3. solr 中 IK 分词器原理是什么？

Ik 分词器的分词原理本质上是词典分词。 先在内存中初始化一个词典，然后在分词过程中挨个读取字符，和字典中的字符相匹配，把文档中的所有的词语拆分出来的过程。

##  八、 webService

### 1. 什么是 webService？

WebService 是一种跨编程语言和跨操作系统平台的远程调用技术。所谓跨编程语言和跨操作平台，就是说服务端程序采用 java 编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上。

###  2. 常见的远程调用技术

​        RMI 是 java 语言本身提供的远程通讯协议，稳定高效，是 EJB 的基础。但它只能用于 JAVA 程序之间的通讯。
​        Hessian 和 Burlap 是 caucho 公司提供的开源协议，基于 HTTP 传输，服务端不用开防火墙端口。协议的规范公开，可以用于任意语言。跨平台有点小问题。
​       Httpinvoker 是 SpringFramework 提供的远程通讯协议，只能用于 JAVA 程序间的通讯，且服务端和客户端必须使用 SpringFramework。
​         Web service 是连接异构系统或异构语言的首选协议，它使用 SOAP 形式通讯，可以用于任何语言，目前的许多开发工具对其的支持也很好。
效率相比： RMI > Httpinvoker >= Hessian >> Burlap >> web service 什么是 Highcharts

##  九、 Restful

### 1. 谈谈你对 restful 的理解以及在项目中的使用？


注意：下面回答内容来自百度百科。
一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。 REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。
给大家推荐如下一篇博客，该博客从多个维度讲解了什么是 Restful 并且给了 Restful 风格样式的 API 接口。
<https://blog.csdn.net/liuwenbiao1203/article/details/52351129>


**OTHER:**
一、 传统项目（2017-12-5-lyq）
\1. 什么是 BOS？
ERP 系统是企业资源计划(Enterprise Resource Planning )的简称。
BOSS(Business & Operation Support )指的是业务运营支撑系统。
BOS 是 ERP 的集成与应用平台。 BOS 遵循面向服务的架构体系，是一个面向业务的可视化开发平台；是一个
ERP 和第三方应用集成的技术平台。它有效的解决了 ERP 应用的最主要矛盾－－－用户需求个性化和传统 ERP 软
件标准化之间的矛盾。
BOS 与 ERP 是什么关系？
ERP 是企业管理信息化的全面解决方案， ERP 是基于 BOS 构建的。 ERP 满足企业全面业务的标准应用； BOS
确保了企业 ERP 应用中的个性化需求完美实现。基于 BOS 的 ERP，可以为不同行业不同发展阶段的企业构建灵活
的、可扩展的、全面集成的整体解决方案。
\2. Activity 工作流
2.1 什么是工作流？
（举个栗子） 现在大多数公司的请假流程是这样的：员工打电话（或网聊）向上级提出请假申请——上级口头同
意——上级将请假记录下来——月底将请假记录上交公司——公司将请假录入电脑。采用工作流技术的公司的请假流
程是这样的：员工使用账户登录系统——点击请假——上级登录系统点击允许。就这样，一个请假流程就结束了。有
人会问，那上级不用向公司提交请假记录？公司不用将记录录入电脑？答案是，用的。但是这一切的工作都会在上级
感恩于心，回报于行。 面试宝典系列-Java
http://www.itheima.com Copyright© 2017 [黑马程序员](https://www.baidu.com/s?wd=%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)
410
点击允许后自动运行！这就是工作流技术。
Georgakopoulos 给出的工作流定义是： 工作流是将一组任务组织起来以完成某个经营过程：定义了任务的触
发顺序和触发条件，每个任务可以由一个或多个软件系统完成，也可以由一个或一组人完成，还可以由一个或多个人
与软件系统协作完。
2.2 工作流技术的优点
从上面的例子，很容易看出，工作流系统实现了工作流程的自动化，提高了企业运营效率、改善企业资源利
用、提高企业运作的灵活性和适应性、提高量化考核业务处理的效率、减少浪费（时间就是金钱）。而手工处理工
作流程，一方面无法对整个流程状况进行有效跟踪、了解，另一方面难免会出现人为的失误和时间上的延时导致
效率低下，特别是无法进行量化统计，不利于查询、报表及绩效评估。
2.3 工作流生命周期
除了我们自行启动（start）或者结束（finish）一个 Activity，我们并不能直接控制一个 Activity 的生
命状态， 我们只能通过实现 Activity 生命状态的表现——即回调方法来达到管理 Activity 生命周期的变化。