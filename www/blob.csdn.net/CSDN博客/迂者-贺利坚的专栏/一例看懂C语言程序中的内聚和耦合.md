
# 一例看懂C语言程序中的内聚和耦合 - 迂者-贺利坚的专栏 - CSDN博客

2018年02月28日 15:56:11[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：3471



## （一）原理篇
（清楚相关原理的读者，请直接看第二部分示例篇）
在软件工程中，模块的内聚和耦合是度量模块化质量的标准之一。内聚是指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。耦合是程序中各模块之间相互联系紧密程度的一种度量。各模块之间联系越紧密，其耦合性就越强。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。
在程序设计中提倡的是[高内聚低耦合](https://baike.baidu.com/item/高内聚低耦合/5227009?fr=aladdin)。所谓高内聚，是指模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则，这样的模块，无论从设计、实现还是阅读，都能体现出其保持专一性带来的好处。而低耦合，是指模块之间尽可能的使其独立存在，模块之间不产生联系不可能，但模块与模块之间的接口应该尽量少而简单。这样，高内聚从整个程序中每一个模块的内部特征角度，低耦合从程序中各个模块之间的关联关系角度，对我们的设计提出了要求。
程序设计和软件工程发展过程中产生的很多技术、设计原则，都可以从内聚和耦合的角度进行解读。作为C语言程序设计的初学者，结合当前对于函数的理解可达到的程度，我们探讨一下如何做到高内聚低耦合。
针对低耦合。耦合程度最低的是**非直接耦合**，指两个函数之间的联系完全是通过共同的调用函数的控制和调用来实现的，耦合度最弱，函数的独立性最强。但一组函数之间没有数据传递显然不现实，次之追求**数据耦合**，调用函数和被调用函数之间只传递简单的数据参数，例如采用值传递方式的函数。有些函数数在调用时，利用形式参数传地址的方式，在函数体内通过指针可以修改其指向的作用域以外的存储单元，这构成了更强的耦合，称为**特征耦合**，在这里，使函数之间产生联系的是地址这样的特征标识。另外，有两个函数可能会打开同一个文件进行操作，这也构成了特征耦合的一种形式。更强的耦合是**外部耦合**，这里，一组模块都访问同一全局变量，而且不通过参数表传递该全局变量的信息，当发现程序执行结果异常时，很难定位到是在哪个函数中出了差错。不少初学者觉得参数传递麻烦，将要处理的数据尽可能地定义为全局变量，这样，函数之间的接口简单了，但形成的是耦合性很强的结构。在C语言中，还可以通过静态局部变量，在同一个程序的两次调用之间共享数据，这也可以视为是一种外部耦合，只不过静态局部变量的作用域限于函数内部，其影响也只在函数内部，耦合程度比使全局变量也还是弱很多。由此，我们可以理解前述在使用全局变量、静态局部变量时提出的“用在合适的时候，不滥用”的原则。
针对高内聚。内聚程度最高的是**功能内聚**，模块内所有元素的各个组成部分全部都为完成同一个功能而存在，共同完成一个单一的功能，模块已不可再分。这样的函数功能非常清晰、明确，一般出现在程序结构图的较低被调用的层次上。次之的是**顺序内聚**，一个函数中各个处理元素和同一个功能密切相关，通常前一个处理元素的输出是后一个处理元素的输入。对于这样的函数，如果不致于产生高耦合的话，可以分开两个函数实现。有的函数，其中的不同处理功能仅仅是由于都访问某一个公用数据而发生关联，这称为**通信内聚**和**信息内聚**，内聚程度进一步下降。内聚程度再低的情况就不再一一列举，最差的**偶然内聚**中，一个函数内的各处理元素之间没有任何联系，只是偶然地被凑到一起。可以想像这样的模块东一榔头西一锤子，类似一个毫无凝聚力的团伙，对应的是低质量。总之，在解决问题划分函数时，要遵循“一个函数，一个功能”的原则，尽可能使模块达到功能内聚。
要做到高内聚低耦合，重点是要在写代码之前花些时间做好设计。在下面的例子中，将讨论结合具体的问题，如何将以上的因素考虑进去。
## （二）示例篇
本例受裘宗燕老师《从问题到程序——程序设计与C语言引论启发》。
### 任务
> 输出200以内的完全平方数（一个数如果是另一个整数的完全平方，那么我们就称这个数为完全平方数，也叫做平方数），要求每隔5个数据要输出一个换行。

### 解决方案及点评
对于这个简单任务，我们在一个main函数中完成了任务。程序如方案1：
```python
//方案
```
```python
1
```
```python
：内聚性较高的单模块实现方案
```
```python
#include <stdio.h>
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
m
```
```python
, num=
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
m
```
```python
=
```
```python
1
```
```python
;
```
```python
m
```
```python
*
```
```python
m
```
```python
<=
```
```python
200
```
```python
;
```
```python
m
```
```python
++)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
"
```
```python
,
```
```python
m
```
```python
*
```
```python
m
```
```python
);
        num++;
```
```python
if
```
```python
(num
```
```python
%5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
由于任务本身简单，将之在一个main函数中实现后，这个函数的内聚程度接近功能内聚，已经相当高了，就任务本身，不需再进行分解。为使读者能深入理解模块质量方面的技术，我们将试图将内聚程序再提高一些，然后考察耦合程度不同的各种解决方案。
要提高上面解决方案中函数（仅main一个函数）的内聚程度，我们考察程度的功能“找出完全平方数并输出”——“找出完全平方数”和“输出”这本身就是两个功能，再细分输出时还有“要求5个数据在一行”的要求，这些功能的实现细节都在一个函数当中，可见是有余地再提高内聚程度的。在实现的应用中，几乎所有的处理都可以分解为“输入-计算-输出”的模式，优秀的解决方案往往至少要将这三个模块都独立出来，对于“计算”模块而言，其内部不再包括输入输出，专门接受输入的数据，计算完成后返回结果即可。当然，对于复杂的问题，在各个环节上可能还需要再做分解。
下面，我们探讨将“找出完全平方数输出”和“每5个数据后换行”分开实现的方案。这样的分解有助于提高内聚性，与此同时，分解后的两个模块间的耦合程度，成为我们要关注的焦点。
现在将“找出完全平方数并输出”的功能仍放在main函数中（独立成为单独的函数也可以，但不必要了），而“每5个数据后换行”的功能，设计一个名称为format的函数，它每调用一次就输出一个空格作为两个完全平方数间的分隔，而每调用到第5次时，输出的是一个换行。这两个模块之间，需要有一个“现在是第几次调用”的信息需要传递，不可能用耦合程度最松散的非直接耦合.我们考虑数据耦合，用简单形式参数传值，得到方案2。
```python
//方案
```
```python
2
```
```python
：一个耦合度低，但不能完成功能要求的解决方案
```
```python
#include <stdio.h>
```
```python
void
```
```python
format
```
```python
(
```
```python
int
```
```python
);
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
m
```
```python
, num=
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
m
```
```python
=
```
```python
1
```
```python
;
```
```python
m
```
```python
*
```
```python
m
```
```python
<=
```
```python
200
```
```python
;
```
```python
m
```
```python
++)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
"
```
```python
,
```
```python
m
```
```python
*
```
```python
m
```
```python
);
```
```python
format
```
```python
(num);
    }
```
```python
return
```
```python
0
```
```python
;
}
void
```
```python
format
```
```python
(
```
```python
int
```
```python
n)
{
    n++;
```
```python
if
```
```python
(n
```
```python
%5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
" "
```
```python
);
```
```python
return
```
```python
;
}
```
在这个程序结构中，format与main函数的耦合程度为数据耦合。在main中定义了局部变量num，在一次都未输出时，置初值为0是合理的。在调用format时，将num传递来的表示第几次输出（第几个完全平方数）的形式参数n，n自增1，然后再控制输出空格或换行。
然而分析和运行程序发现，“每隔5个数据输出一个换行”的功能并未实现。因为形式参数n在函数format内的改变对应的实在参数num占不同的内存空间，n++修改的结果，对num无任何的影响，导致了在下一次调用时，丢失了“输出的是第几个”的重要信息。
一个补救的方法，是由format将变化后的n值作为返回值，再传回给main函数，得到如下方案3的程序：
```python
//方案
```
```python
3
```
```python
：利用了返回值使耦合度增大，但功能得以实现的方案
```
```python
#include <stdio.h>
```
```python
int
```
```python
format
```
```python
(
```
```python
int
```
```python
);
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
m
```
```python
, num=
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
m
```
```python
=
```
```python
1
```
```python
;
```
```python
m
```
```python
*
```
```python
m
```
```python
<=
```
```python
200
```
```python
;
```
```python
m
```
```python
++)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
"
```
```python
,
```
```python
m
```
```python
*
```
```python
m
```
```python
);
        num =
```
```python
format
```
```python
(num);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
format
```
```python
(
```
```python
int
```
```python
n)
{
    n++;
```
```python
if
```
```python
(n
```
```python
%5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
" "
```
```python
);
```
```python
return
```
```python
n;
}
```
维持原函数返回值为void，而将参数改为传地址，得到下面的方案4。这个方案的耦合度更高一些，但功能还是能够实现的。
```python
//方案
```
```python
4
```
```python
：传地址实现功能的方案，耦合度更大
```
```python
#include <stdio.h>
```
```python
void
```
```python
format
```
```python
(
```
```python
int
```
```python
*)
```
```python
;
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
m
```
```python
, num=
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
m
```
```python
=
```
```python
1
```
```python
;
```
```python
m
```
```python
*
```
```python
m
```
```python
<=
```
```python
200
```
```python
;
```
```python
m
```
```python
++)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
"
```
```python
,
```
```python
m
```
```python
*
```
```python
m
```
```python
);
```
```python
format
```
```python
(&num);
    }
```
```python
return
```
```python
0
```
```python
;
}
void
```
```python
format
```
```python
(
```
```python
int
```
```python
*p
```
```python
)
{
    (
```
```python
*p
```
```python
)++;
```
```python
if
```
```python
((
```
```python
*p
```
```python
)
```
```python
%5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
" "
```
```python
);
```
```python
return
```
```python
;
}
```
一定有人想到了用全局变量的解决方案。这样，可以将num定义为全局变量，num的生存周期不再依赖于函数调用，其值也能在函数的调用之间保持不变（只要其间没有另外给它赋值），从而可以完成传递信息的任务。这时，format因为无需参数传递，可以设计为无参函数，得到如下方案5的程序：
```python
//方案
```
```python
5
```
```python
：耦合度最高的全局变量方案
```
```python
#include <stdio.h>
```
```python
void
```
```python
format
```
```python
();
```
```python
int
```
```python
num=
```
```python
0
```
```python
;
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
m
```
```python
;
```
```python
for
```
```python
(
```
```python
m
```
```python
=
```
```python
1
```
```python
;
```
```python
m
```
```python
*
```
```python
m
```
```python
<=
```
```python
200
```
```python
;
```
```python
m
```
```python
++)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
"
```
```python
,
```
```python
m
```
```python
*
```
```python
m
```
```python
);
```
```python
format
```
```python
();
    }
```
```python
return
```
```python
0
```
```python
;
}
void
```
```python
format
```
```python
()
{
    num++;
```
```python
if
```
```python
(num
```
```python
%5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
" "
```
```python
);
```
```python
return
```
```python
;
}
```
这是解决这个问题的耦合程度最高的一个方案。将num定义为外部变量，意味着如果还有其他函数，num是可以被任何函数修改的，当发 format 计数错误时，寻找错误困难，而修改后又可能会带来其他地方的错误。在这么一个短小的程序中，这种方案可能尚可接受，当程度的规模稍变大，可能带来的问题必须高度重视。因此，在实际应用中，强调全局变量要慎用（不是不用）。
考虑到num是在format中应用的私用数据——只有format才关心这到底是第几个数据，main本来都不用关心的。这样，可以考虑将num定义为format中的局部静态变量，得到方案6的程序：
```python
//方案
```
```python
6
```
```python
：用静态局部变量，耦合度偏高但封装性最好的方案
```
```python
#include <stdio.h>
```
```python
void
```
```python
format
```
```python
();
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
m
```
```python
;
```
```python
for
```
```python
(
```
```python
m
```
```python
=
```
```python
1
```
```python
;
```
```python
m
```
```python
*
```
```python
m
```
```python
<=
```
```python
200
```
```python
;
```
```python
m
```
```python
++)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
"
```
```python
,
```
```python
m
```
```python
*
```
```python
m
```
```python
);
```
```python
format
```
```python
();
    }
```
```python
return
```
```python
0
```
```python
;
}
void
```
```python
format
```
```python
()
{
    static
```
```python
int
```
```python
num=
```
```python
0
```
```python
;
    num++;
```
```python
if
```
```python
(num
```
```python
%5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
" "
```
```python
);
```
```python
return
```
```python
;
}
```
在这里，静态局部变量num的作用域是局部的，定义在函数体里，封装性在所有方案里是最好的，从而能保证信息的隐蔽性，避免其他函数无意的越权访问；不过，num的生存期是全局的，可以跨越函数的不同次调用，在两次调用间传递信息，耦合程度（自己和自己的耦合）要高一些，但使main函数和format函数的耦合达到了最理想的程度，既保证了功能的正确，又保证了局部数据的安全性，表现出静态局部变量的优势。
综上所述，在解决一个问题时，存在着诸多的方案。方案1可以接受，但希望提高内聚性而做出改进；方案2用简单的参数传值方式实现耦合程度低，但很可惜不能完成功能；在其他方案中，对于这个问题，选择的优先顺序是：
方案6、方案3 > 方案4 > 方案5
建议读者回顾前面的内容，想一想这样排序的理由。
在上述探讨各个方案的过程中，我们应该体会到在程序设计能力提高的过程中，不断地学习新的技术，懂得新的评判标准，这也就是一个不断拓宽眼蜀的过程。在稍后的练习中，不妨多想一些方案，也能够从专业的角度评判方案的优劣，最终做到的，就是出手就是最佳方案的专业水平。
（全文完）

