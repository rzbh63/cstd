
# c++的虚拟继承 的一些思考吧 - 高科的专栏 - CSDN博客

2013年11月25日 15:51:26[高科](https://me.csdn.net/pbymw8iwm)阅读数：5883个人分类：[C/C++																](https://blog.csdn.net/pbymw8iwm/article/category/910215)


虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类。实现的代码如下：
class A
class B1:public virtual A;
class B2:public virtual A;
class D:public B1,public B2;
虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。
![虚基类和非虚基类的区别](http://e.hiphotos.baidu.com/baike/s%3D220/sign=90e4f8fee4cd7b89ed6c3d813f254291/2f738bd4b31c8701e5684ad2257f9e2f0708ff2c.jpg)

前端时间看到这样几个面试题目：
> 第一种情况：　　　　　　　　 第二种情况：　　　　　　　　　　第三种情况　　　　　　　　　　　　第四种情况：

> class a　　　　　　　　　　　class a　　　　　　　　　　　　  class a　　　　　　　　　　　　　　class a

> {　　　　　　　　　　　　　 {　　　　　　　　　　　　　　　 {　　　　　　　　　　　　　　　　　{

> virtual void func();　　　　　　virtual void func();　　　　　　　virtual void func();　　　　　　　　virtual void func();

> };　　　　　　　　　　　　　 };　　　　　　　　　　　　　　　　　 char x;　　　　　　　　　　　　　　char x;

> class b:public virtual a　　　class b :public a　　　　　　　    };　　　　　　　　　　　　　　　　};

> {　　　　　　　　　　　　　　{　　　　　　　　　　　　　　 　class b:public virtual a　　　　　 class b:public a

> virtual void foo();　　　　　　  virtual void foo();　　　　　            {　　　　　　　　　　　　　　　　 {

> };　　　　　　　　　　　　　 };　　　　　　　　　　　　　　　　　　virtual void foo();　　　　　　　　virtual void foo();

> };　　　　　　　　　　　　　　　　};

如果对这四种情况分别求sizeof(a）,  sizeof(b)。结果是什么样的呢？
第一种：4，12
第二种：4，4
第三种：8，16
第四种：8，8
有人很坚定的说就是这个结果。但是我这里要指出的是没有绝对的事情，不同的编译器或者版本不同，你的运行结果是不同的，但是运行结果的第一个sizeof（a）相信大家都没有意见，但是第二个，我相信有很多人都在苦恼那么这里我给大家先分享一下VC（VS）编译器和Gcc编译器 的处理机制：
1、 单个虚拟继承

（1）VS编译器：无论有无虚函数，必然含有虚基类表指针。虚基类表中的内容为本类实例的偏移和基类实例的相对偏移值。如果有虚函数，那么基类的虚函数表跟派生类的虚函数表是分开的。
在内存布局上，地址从低到高，顺序如下：派生类的虚函数表指针+虚基类表指针+派生类的成员变量+“间隔”（4个字节）+基类的虚函数表指针+基类的成员变量。派生类跟基类实例的位置关系跟普通继承正好相反。
说明：“间隔”产生的原因是派生类重写了基类的虚函数。如果没重写，则这一项没有。"本类地址"指的是包含有虚基类的对象（或部分对象），也就是继承链上的直接子类对象的地址，本例比较简单，就是派生类对象地址。“本类地址跟虚基类表指针地址只差”，这个值经常是-4、0，-4表明“本类”还有一个虚函数表指针；0则表明“本类”的第一个4字节保存的就是虚基类表指针，没有虚函数表指针。
![](http://pic002.cnblogs.com/images/2010/104985/2010100809450028.gif)
图 1 VS编译器—单个虚拟继承
（2）GNU的GCC编译器：跟VS的编译器类似，有不同的地方是，虚基类表跟派生类的虚函数表合并。另外通过虚基类表指针往正负两个方向寻址，可以获得不同偏移值，也就是说有两个功能一样的虚函数表。不过在实际应用的时候，不知道虚基类表是否真的有用，测试了简单的情况发现编译器做了优化，根本就没有用虚基类表来寻址虚基类实例。
![](http://pic002.cnblogs.com/img/%E7%83%9B%E7%A7%8B/201008/2010082001552729.jpg)
图 2 GCC编译器—单个虚拟继承
2、 虚拟继承多个基类
虚基类表要增加内容，有N个虚基类就有N项基类实例偏移值，再加上1项本类实例的偏移值，也就是N+1。
假设C虚拟继承了A类和B类，考虑最复杂的情况（都有虚函数），那么C类对象的内存布局如下
（VS编译器）：
C类虚函数表指针+虚基类表指针+C类成员变量+A类间隔（4个字节） + A类虚函数表指针+ A类成员变量+ B类间隔（4个字节）+B类虚函数表指针+ B类成员变量。
说明：当派生类重写了该基类的虚函数，才会有“间隔”。“间隔”属于虚函数被重新实现了的虚基类，可能是一个标志，也有可能是在函数调用的时候用上。不是很清楚。
![](http://pic002.cnblogs.com/images/2010/104985/2010100809474795.gif)
图 3 VS编译器—虚拟继承多个基类
（GCC编译器）：
C类虚函数表指针(包含虚基类表) + C类成员变量 + A类虚函数表指针 +  A类成员变量 + B类虚函数表指针 + B类成员变量。
相比较执行，使用GCC编译器，派生类对象小一些。（图略）
3、 虚拟继承之菱形继承
这里的菱形继承指的是：B、C虚拟继承A，然后D普通继承B、C。
D类的对象的内存布局如下
（VS编译器）
B类虚函数表指针（该虚函数表包含D类独有的虚函数的地址）+B类虚基类表指针+B类成员变量+C类虚函数表指针+C类虚基类表指针+C类成员变量+D类成员变量+“间隔”+A类虚函数表指针+A类成员变量。
说明：如果A类的虚函数没有被重写，那么就没有“间隔”。
![](http://pic002.cnblogs.com/img/%E7%83%9B%E7%A7%8B/201008/2010082001555237.jpg)
图 4 VS编译器—菱形继承
（GCC编译器）
把B、C类的虚函数表跟虚基类表合并就是了。（图略）
4、VS编译器，“间隔”的疑问
“间隔”的问题，在没有虚函数的情况下，重写是没有“间隔”的，所以觉得可能跟虚函数有关，也就是说是为了实现多态，具体是用在哪个地方，做了简单的反汇编调试（父类指针指向子类对象，调用被子类重写了的虚函数），并没有发现哪里用到了“间隔”，可能要在复杂的调用才会用上吧，目前搞不清楚。
5、虚基类表的问题
通过反汇编调试发现在使用多态的时候，VS编译器会去使用虚基类表，用于寻址虚基类地址。而GCC编译器则没有这么做，测试了比较简单的情况，发现它做了优化，并没有利用虚基类表，而是直接在派生类对象地址上加上一个常数，获得虚基类实例的地址。


