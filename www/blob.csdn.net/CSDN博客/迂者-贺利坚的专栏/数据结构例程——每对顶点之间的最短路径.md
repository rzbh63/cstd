
# 数据结构例程——每对顶点之间的最短路径 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月15日 09:24:46[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2345


本文是[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]中第14课时[[每对顶点之间的最短路径](http://edu.csdn.net/course/detail/1595/24604)]的例程。
![这里写图片描述](https://img-blog.csdn.net/20151115091719452)
[Floyd算法实现]
（程序中graph.h是图存储结构的“算法库”中的头文件，详情请[单击链接…](http://blog.csdn.net/sxhelijian/article/details/49591419)）
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
#define MaxSize 100
```
```python
void
```
```python
Ppath(
```
```python
int
```
```python
path[][MAXV],
```
```python
int
```
```python
i,
```
```python
int
```
```python
j)
```
```python
//前向递归查找路径上的顶点
```
```python
{
```
```python
int
```
```python
k;
    k=path[i][j];
```
```python
if
```
```python
(k==-
```
```python
1
```
```python
)
```
```python
return
```
```python
;
```
```python
//找到了起点则返回
```
```python
Ppath(path,i,k);
```
```python
//找顶点i的前一个顶点k
```
```python
printf
```
```python
(
```
```python
"%d,"
```
```python
,k);
    Ppath(path,k,j);
```
```python
//找顶点k的前一个顶点j
```
```python
}
```
```python
void
```
```python
Dispath(
```
```python
int
```
```python
A[][MAXV],
```
```python
int
```
```python
path[][MAXV],
```
```python
int
```
```python
n)
{
```
```python
int
```
```python
i,j;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<n; j++)
        {
```
```python
if
```
```python
(A[i][j]==INF)
            {
```
```python
if
```
```python
(i!=j)
```
```python
printf
```
```python
(
```
```python
"从%d到%d没有路径\n"
```
```python
,i,j);
            }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"  从%d到%d=>路径长度:%d 路径:"
```
```python
,i,j,A[i][j]);
```
```python
printf
```
```python
(
```
```python
"%d,"
```
```python
,i);
```
```python
//输出路径上的起点
```
```python
Ppath(path,i,j);
```
```python
//输出路径上的中间点
```
```python
printf
```
```python
(
```
```python
"%d\n"
```
```python
,j);
```
```python
//输出路径上的终点
```
```python
}
        }
}
```
```python
void
```
```python
Floyd(MGraph g)
{
```
```python
int
```
```python
A[MAXV][MAXV],path[MAXV][MAXV];
```
```python
int
```
```python
i,j,k;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
        {
            A[i][j]=g.edges[i][j];
            path[i][j]=-
```
```python
1
```
```python
;
        }
```
```python
for
```
```python
(k=
```
```python
0
```
```python
; k<g.n; k++)
    {
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
```
```python
if
```
```python
(A[i][j]>A[i][k]+A[k][j])
                {
                    A[i][j]=A[i][k]+A[k][j];
                    path[i][j]=k;
                }
    }
    Dispath(A,path,g.n);
```
```python
//输出最短路径
```
```python
}
```
```python
int
```
```python
main()
{
    MGraph g;
```
```python
int
```
```python
A[
```
```python
4
```
```python
][
```
```python
4
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
5
```
```python
,INF,
```
```python
7
```
```python
},
        {INF,
```
```python
0
```
```python
,
```
```python
4
```
```python
,
```
```python
2
```
```python
},
        {
```
```python
3
```
```python
,
```
```python
3
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
},
        {INF,INF,
```
```python
1
```
```python
,
```
```python
0
```
```python
}
    };
    ArrayToMat(A[
```
```python
0
```
```python
],
```
```python
4
```
```python
, g);
    Floyd(g);
```
```python
return
```
```python
0
```
```python
;
}
```
注：例程中的测试图见上面算法思想截图

