
# C语言OJ项目参考（2013）一元二次方程Ⅱ - 迂者-贺利坚的专栏 - CSDN博客

2016年10月12日 20:59:17[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：1604


**（2013）一元二次方程Ⅱ**
**Description**
求一元二次方程$ax^2+bx+c=0$的解。a,b,c为任意实数。
**Input**
输入数据有一行，包括a b c的值。
**Output**
按以下格式输出方程的根x1和x2。x1和x2之间有一个空格。 x1 x2
（1）如果x1和x2为实根，则以x1>=x2输出。
（2）如果方程是共轭复根，x1=m+ni，x2=m-ni，其中n>0。 其中x1, x2, m,n均保留2位小数。
**Sample Input**
1 2 3
**Sample Output**
-1.00+1.41i -1.00-1.41i
[参考解答]
```python
#include <stdio.h>
```
```python
#include <math.h>
```
```python
int
```
```python
main ( )
{
    float a,b,c,d,pr,pi,x1,x2;
    scanf(
```
```python
"
```
```python
%f
```
```python
%f
```
```python
%f
```
```python
"
```
```python
,&a,&b,&c);
    d=b
```
```python
*b
```
```python
-
```
```python
4
```
```python
*a
```
```python
*c
```
```python
;
```
```python
if
```
```python
(d>=
```
```python
0
```
```python
)
    {
        x1=(-b+
```
```python
sqrt
```
```python
(d))/(
```
```python
2
```
```python
*a
```
```python
);
        x2=(-b-
```
```python
sqrt
```
```python
(d))/(
```
```python
2
```
```python
*a
```
```python
);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f
```
```python
%.
```
```python
2f\n"
```
```python
,x1,x2);
    }
```
```python
else
```
```python
{
        pr=-b/(
```
```python
2
```
```python
*a
```
```python
);
        pi=
```
```python
sqrt
```
```python
(-d)/(
```
```python
2
```
```python
*a
```
```python
);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f+
```
```python
%.
```
```python
2fi "
```
```python
,pr,pi);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f-
```
```python
%.
```
```python
2fi\n"
```
```python
,pr,pi);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
**完善：**
以上结果提交OJ顺利通过，尽管自知对共轭复根处的处理有点太简单，但通过了，也乐得不追究了。
今天（2016年10月13日）上机课上，崔翔童鞋问我，题目中有“（2）如果方程是共轭复根……，其中n>0”，那个n>0怎么整，惊出一身冷汗：老贺想逃避，休想！
读上面的程序，其实可以看到，当a<0时，共轭复根的虚部pi<0，于是输出的结果，就会很难看。确切的说，是错的！
如下图：
![这里写图片描述](https://img-blog.csdn.net/20161013213625555)[ ](https://img-blog.csdn.net/20161013213625555)
这样的输出，太低级了。我们想要的是：
![这里写图片描述](https://img-blog.csdn.net/20161013215114300)[ ](https://img-blog.csdn.net/20161013215114300)
但是，最爱在输出格式上和人较劲的OJ，是怎么容忍这样的错误的？很简单，没有提供a<0时的测试数据，自然就让人能蒙混过关了。OJ啊，你那严格的名声来之不易，咋能不珍惜呢？
不管你OJ了，老贺决定认真点。你让人犯错，咱也不降低对自己的要求了。上代码：
```python
#include <stdio.h>
```
```python
#include <math.h>
```
```python
int
```
```python
main ( )
{
    float a,b,c,d,pr,pi,x1,x2;
    scanf(
```
```python
"
```
```python
%f
```
```python
%f
```
```python
%f
```
```python
"
```
```python
,&a,&b,&c);
    d=b
```
```python
*b
```
```python
-
```
```python
4
```
```python
*a
```
```python
*c
```
```python
;
```
```python
if
```
```python
(d>=
```
```python
0
```
```python
)
    {
        x1=(-b+
```
```python
sqrt
```
```python
(d))/(
```
```python
2
```
```python
*a
```
```python
);
        x2=(-b-
```
```python
sqrt
```
```python
(d))/(
```
```python
2
```
```python
*a
```
```python
);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f
```
```python
%.
```
```python
2f\n"
```
```python
,x1,x2);
    }
```
```python
else
```
```python
{
        pr=-b/(
```
```python
2
```
```python
*a
```
```python
);
        pi=
```
```python
sqrt
```
```python
(-d)/(
```
```python
2
```
```python
*a
```
```python
);
```
```python
if
```
```python
(a>
```
```python
0
```
```python
)
        {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f+
```
```python
%.
```
```python
2fi "
```
```python
,pr,pi);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f-
```
```python
%.
```
```python
2fi\n"
```
```python
,pr,pi);
        }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f+
```
```python
%.
```
```python
2fi "
```
```python
,pr,-pi);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f-
```
```python
%.
```
```python
2fi\n"
```
```python
,pr,-pi);
        }
    }
```
```python
return
```
```python
0
```
```python
;
}
```
其实，考虑共轭复根的对称性，可以如下省点代码（读起来难懂，就运行观察观察，再想想）：
```python
#include <stdio.h>
```
```python
#include <math.h>
```
```python
int
```
```python
main ( )
{
    float a,b,c,d,pr,pi,x1,x2;
    scanf(
```
```python
"
```
```python
%f
```
```python
%f
```
```python
%f
```
```python
"
```
```python
,&a,&b,&c);
    d=b
```
```python
*b
```
```python
-
```
```python
4
```
```python
*a
```
```python
*c
```
```python
;
```
```python
if
```
```python
(d>=
```
```python
0
```
```python
)
    {
        x1=(-b+
```
```python
sqrt
```
```python
(d))/(
```
```python
2
```
```python
*a
```
```python
);
        x2=(-b-
```
```python
sqrt
```
```python
(d))/(
```
```python
2
```
```python
*a
```
```python
);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f
```
```python
%.
```
```python
2f\n"
```
```python
,x1,x2);
    }
```
```python
else
```
```python
{
        pr=-b/(
```
```python
2
```
```python
*a
```
```python
);
        pi=
```
```python
sqrt
```
```python
(-d)/(
```
```python
2
```
```python
*a
```
```python
);
```
```python
if
```
```python
(a<
```
```python
0
```
```python
) //这儿利用了共轭复根的对称性，反正输出那个形式就行
            pi=-pi;
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f+
```
```python
%.
```
```python
2fi "
```
```python
,pr,pi);
```
```python
printf
```
```python
(
```
```python
"
```
```python
%.
```
```python
2f-
```
```python
%.
```
```python
2fi\n"
```
```python
,pr,pi);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
[
						](https://img-blog.csdn.net/20161013215114300)
[
	](https://img-blog.csdn.net/20161013215114300)
