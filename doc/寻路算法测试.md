# 寻路算法测试

## 寻路基本工具类定义 Point.h

```
 1 #ifndef __POINT__H
 2 #define __POINT__H
 3 
 4 template<typename T>
 5 struct Point
 6 {
 7     Point():x(0),y(0){}
 8     Point(const T _x, const T _y):x(_x),y(_y){}
 9     inline void set(const int _x, const int _y){x = _x; y = _y;}
10     inline void set(const Point<T> &point){x = point.x; y = point.y;}
11     T x;
12     T y;
13 };
14 
15 typedef Point<int> PointI;
16 typedef Point<float> PointF;
17 
18 #endif
```



## 寻路基本工具类定义 Path.h



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 #ifndef __PATH__H
 2 #define __PATH__H
 3 
 4 #include <list>
 5 #include "Point.h"
 6 
 7 class Path
 8 {
 9 public:
10     typedef std::list<PointI> PathList;
11     typedef PathList::const_iterator Iterator;
12 public:
13     Path():m_find(false),m_step(0),m_dis(0.0f){}
14     Path(bool find, float dis):m_find(find),m_step(0),m_dis(dis){}
15     explicit Path(const Path &path)
16     {
17         m_find = path.m_find;
18         m_step = path.m_step;
19         m_dis = path.m_dis;
20         Iterator iter;
21         for(iter = path.m_path.begin(); iter != path.m_path.end(); ++iter)
22         {
23             m_path.push_back(*iter);
24         }
25     }
26     inline void push_back(PointI point){m_path.push_back(point);m_step += 1;}
27     inline void push_front(PointI point){m_path.push_front(point);m_step += 1;}
28     inline void setDis(float dis){m_dis = dis;}
29 
30     inline bool getFind()const{return m_find;}
31     inline int getStep()const{return m_step;}
32     inline float getDis()const{return m_dis;}
33     inline Iterator begin(){return m_path.begin();}
34     inline Iterator end(){return m_path.end();}
35 public:
36     bool    m_find;
37     int        m_step;
38     float   m_dis;
39 private:
40     PathList m_path;
41 };
42 
43 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

## 寻路基本工具类定义 PriorityQueue.h



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 #ifndef __PRIORITYQUEUE__H
 2 #define __PRIORITYQUEUE__H
 3 
 4 #include <deque>
 5 
 6 template<typename T, typename Pr = std::less<T>, typename Container = std::deque<T> >
 7 class PriorityQueue
 8 {
 9 public:
10     bool empty() const
11     {
12         return (m_container.empty());
13     }
14 
15     unsigned int size() const
16     {
17         return (m_container.size());
18     }
19 
20     const T top() const
21     {
22         return m_container.front();
23     }
24 
25     T top()
26     {
27         return m_container.front();
28     }
29 
30     void push(const T &val)
31     {
32         Container::const_iterator iter = m_container.begin();
33         for(; iter != m_container.end(); ++iter)
34         {
35             if(!m_cmp(*iter, val))
36             {
37                 break;
38             }
39         }
40         m_container.insert(iter, val);
41     }
42 
43     void pop()
44     {
45         m_container.pop_front();
46     }
47 
48     void remove(const T &val)
49     {
50         Container::iterator iter;
51         for(iter = m_container.begin(); iter != m_container.end(); ++iter)
52         {
53             if((*iter) == val)
54             {
55                 m_container.erase(iter);
56                 break;
57             }
58         }
59     }
60 private:
61     Container   m_container;
62     Pr          m_cmp;
63 };
64 
65 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  寻路基本工具类定义 AIDefine.h



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 #ifndef __AIDEFINE__H
 2 #define __AIDEFINE__H
 3 
 4 #include <math.h>
 5 #include "../Common/Path.h"
 6 
 7 #define MATH_SQRT2 1.4142135623731f
 8 enum EFindType
 9 {
10     EFIND_TYPE4 = 4,//must be 4
11     EFIND_TYPE8 = 8//must be 8
12 };
13 extern PointI AI_FindHelpPoint[8];
14 typedef float (*AI_DitanceFun)(int,int,int,int);
15 typedef bool (*AI_VisitFun)(int,int);
16 inline int AI_ABS(int data){return data >= 0?data:-data;}
17 inline float AI_ABS(float data){return data >= 0?data:-data;}
18 inline float AI_Ditance1(int x1, int y1, int x2, int y2)
19 {
20     if(x1 == x2 || y1 == y2){return 1;}
21     return MATH_SQRT2;
22 }
23 inline float AI_Ditance2(int x1, int y1, int x2, int y2)
24 {
25     return (float)sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
26 }
27 inline bool AI_CheckVisit(int x,int y,const PointI &size,bool(*visit)(int,int))
28 {
29     if(x < 0 || y < 0 || x >= size.x || y >= size.y){return false;}
30     return visit(x,y);
31 }
32 inline bool AI_CheckPass(int x1,int y1,int x2,int y2,AI_VisitFun visit)
33 {
34     if(0 != (x1 - x2) * (y1 - y2))
35     {
36         return visit(x2, y2) && (visit(x2, y1) && visit(x1, y2));
37     }
38     return visit(x2, y2);
39 }
40 inline bool AI_CheckPass(const PointI &p1, const PointI &p2, AI_VisitFun visit)
41 {
42     return AI_CheckPass(p1.x, p1.y, p2.x, p2.y, visit);
43 }
44 inline bool AI_CheckRange(const PointI &p, const PointI &size)
45 {
46     return !(p.x < 0 || p.y < 0 || p.x >= size.x || p.y >= size.y);
47 }
48 
49 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  寻路基本工具类定义 AIDefine.cpp



```
1 #include "AIDefine.h"
2 
3 PointI AI_FindHelpPoint[8] = {PointI(-1,0),PointI(0,-1),PointI(1,0),PointI(0,1),PointI(-1,-1),PointI(1,-1),PointI(1,1),PointI(-1,1)};
```

 



## 寻路算法 AStar.h



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
  1 #ifndef __ASTAR__H
  2 #define __ASTAR__H
  3 
  4 #include "AIDefine.h"
  5 #include "../Common/PriorityQueue.h"
  6 
  7 class AStar
  8 {
  9 private:
 10     AStar();
 11 public:
 12     static bool find(const PointI &size, const PointI &start, const PointI &end, AI_VisitFun visitFun, Path **path = NULL, 
 13         EFindType findType = EFIND_TYPE8, AI_DitanceFun funH = AI_Ditance2, AI_DitanceFun funG = AI_Ditance1)
 14     {
 15         if(size.x <= 0 || size.y <= 0 || !AI_CheckRange(start, size) || !AI_CheckRange(end, size) ||
 16             !visitFun(start.x, start.y), !visitFun(end.x, end.y))
 17         {
 18             if(NULL != path){*path = new Path(false, 0.0f);}
 19             return false;
 20         }
 21         if(start.x == end.x && start.y == end.y)
 22         {
 23             if(NULL != path){*path = new Path(true, 0.0f);}
 24             return true;
 25         }
 26 
 27         PriorityQueue<Info*, InfoCmp> visit;
 28         Info *nodeArr = new Info[size.x * size.y];
 29         Info *cur, *next;
 30         PointI pos;
 31 
 32         cur = &nodeArr[size.x * start.y + start.x];
 33         cur->x = start.x; cur->y = start.y; cur->g = 0;
 34         cur->h = funH(cur->x, cur->y, end.x, end.y); cur->f = cur->g + cur->h;
 35         visit.push(cur);
 36         float cost_g, cost_h;
 37         while(!visit.empty())
 38         {
 39             cur = visit.top(); visit.pop(); cur->isopen = false; cur->closed = true;
 40             if(cur->x == end.x && cur->y == end.y)
 41             {
 42                 if(NULL != path)
 43                 {
 44                     *path = new Path(true, cur->f);
 45                     while (NULL != cur)
 46                     {
 47                         (*path)->push_front(PointI(cur->x, cur->y));
 48                         cur = cur->parent;
 49                     }
 50                 }
 51                 if(NULL != nodeArr){delete[] nodeArr;}
 52                 return true;
 53             }
 54             for(int i = 0; i < findType; ++i)
 55             {
 56                 pos.x = cur->x + AI_FindHelpPoint[i].x;pos.y = cur->y + AI_FindHelpPoint[i].y;
 57                 if(AI_CheckRange(pos,size) && !nodeArr[size.x * pos.y + pos.x].closed && AI_CheckPass(cur->x, cur->y, pos.x, pos.y, visitFun))
 58                 {
 59                     next = &nodeArr[size.x * pos.y + pos.x];
 60                     next->x = pos.x; next->y = pos.y;
 61                     cost_g = funG(cur->x, cur->y, next->x, next->y);
 62                     cost_h = funH(next->x, next->y, end.x, end.y);
 63                     if(next->isopen)
 64                     {
 65                         if(next->f > cur->g + cost_g + cost_h)
 66                         {
 67                             visit.remove(next);
 68                         }else
 69                         {
 70                             continue;
 71                         }
 72                     }
 73                     next->g = cur->g + cost_g; next->h = cost_h;
 74                     next->f = next->g + next->h;
 75                     next->isopen = true;next->parent = cur;visit.push(next);
 76                 }
 77             }
 78         }
 79         if(NULL != path){*path = new Path(false, 0.0f);}
 80         if(NULL != nodeArr){delete[] nodeArr;}
 81         return false;
 82     }
 83 private:
 84     struct Info
 85     {
 86         Info()
 87         {
 88             x = y = 0;
 89             g = h = f = 0.0f;
 90             isopen = closed = false;
 91             parent = NULL;
 92         }
 93         int x,y;
 94         float g,h,f;
 95         bool isopen,closed;
 96         Info *parent;
 97     };
 98     struct InfoCmp
 99     {
100         bool operator () (const Info *p1, const Info *p2)
101         {
102             return p1->f < p2->f;
103         }
104     };
105 };
106 
107 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  寻路算法 BStar.h



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
  1 #ifndef __BSTAR__H
  2 #define __BSTAR__H
  3 
  4 #include "AIDefine.h"
  5 #include <vector>
  6 
  7 class BStar
  8 {
  9 private:
 10     BStar();
 11 public:
 12     static bool find(const PointI &size, const PointI &start, const PointI &end, AI_VisitFun visitFun, Path **path = NULL)
 13     {
 14         if(size.x <= 0 || size.y <= 0 || start.x < 0 || start.y < 0 || end.x < 0 || end.y < 0 ||
 15             start.x >= size.x || start.y >= size.y || end.x >= size.x || end.y >= size.y ||
 16             !visitFun(start.x, start.y), !visitFun(end.x, end.y))
 17         {
 18             if(NULL != path){*path = new Path(false, 0.0f);}
 19             return false;
 20         }
 21         if(start.x == end.x && start.y == end.y)
 22         {
 23             if(NULL != path){*path = new Path(true, 0.0f);}
 24             return true;
 25         }
 26 
 27         EDIRTYPE curDir = DIR_LEFT, nextDir = DIR_NONE;
 28         if(AI_ABS(end.x - start.x) >= AI_ABS(end.y - start.y))
 29         {
 30             if(end.x > start.x){curDir = DIR_RIGHT;}
 31             else{curDir = DIR_LEFT;}
 32         }else
 33         {
 34             if(end.y > start.y){curDir = DIR_DOWN;}
 35             else{curDir = DIR_UP;}
 36         }
 37 
 38         std::vector<Info*> visit;
 39         std::vector<Info*>::iterator iter;
 40         Info *nodeArr = new Info[size.x * size.y];
 41         Info *cur, *next;
 42         PointI pos;
 43 
 44         cur = &nodeArr[size.x * start.y + start.x];
 45         cur->x = start.x; cur->y = start.y; cur->visited = true;cur->dir = curDir;
 46         visit.push_back(cur);
 47 
 48         while(!visit.empty())
 49         {
 50             iter = visit.end(); --iter; cur = *iter;curDir = cur->dir;
 51             if(cur->x == end.x && cur->y == end.y)
 52             {
 53                 if(NULL != path)
 54                 {
 55                     *path = new Path(true, 0.0f);
 56                     for(iter = visit.begin(); iter != visit.end(); ++iter)
 57                     {
 58                         (*path)->push_back(PointI((*iter)->x, (*iter)->y));
 59                     }
 60                 }
 61                 if(NULL != nodeArr){delete[] nodeArr;}
 62                 return true;
 63             }
 64             if(DIR_LEFT == curDir){pos.x = cur->x - 1;pos.y = cur->y;}
 65             else if(DIR_RIGHT == curDir){pos.x = cur->x + 1;pos.y = cur->y;}
 66             else if(DIR_DOWN == curDir){pos.x = cur->x;pos.y = cur->y + 1;}
 67             else if(DIR_UP == curDir){pos.x = cur->x;pos.y = cur->y - 1;}
 68             if(AI_CheckRange(pos,size) && !nodeArr[size.x * pos.y + pos.x].visited && visitFun(pos.x, pos.y))
 69             {
 70                 next = &nodeArr[size.x * pos.y + pos.x];
 71                 next->x = pos.x; next->y = pos.y; next->visited = true;next->dir = curDir;
 72                 visit.push_back(next);
 73                 if(DIR_LEFT == curDir || DIR_RIGHT == curDir)
 74                 {
 75                     if(next->x == end.x)
 76                     {
 77                         if(end.y >= cur->y)
 78                         {
 79                             pos.x = cur->x; pos.y = cur->y + 1;
 80                             if(AI_CheckRange(pos,size) && !nodeArr[size.x * pos.y + pos.x].visited && visitFun(pos.x, pos.y))
 81                             {
 82                                 next->dir = curDir = DIR_DOWN;
 83                             }
 84                         }else
 85                         {
 86                             pos.x = cur->x; pos.y = cur->y - 1;
 87                             if(AI_CheckRange(pos,size) && !nodeArr[size.x * pos.y + pos.x].visited && visitFun(pos.x, pos.y))
 88                             {
 89                                 next->dir = curDir = DIR_UP;
 90                             }
 91                         }
 92                     }
 93                 }else if(DIR_DOWN == curDir || DIR_UP == curDir)
 94                 {
 95                     if(next->y == end.y)
 96                     {
 97                         if(end.x >= cur->x)
 98                         {
 99                             pos.x = cur->x + 1; pos.y = cur->y;
100                             if(AI_CheckRange(pos,size) && !nodeArr[size.x * pos.y + pos.x].visited && visitFun(pos.x, pos.y))
101                             {
102                                 next->dir = curDir = DIR_RIGHT;
103                             }
104                         }else
105                         {
106                             pos.x = cur->x - 1; pos.y = cur->y;
107                             if(AI_CheckRange(pos,size) && !nodeArr[size.x * pos.y + pos.x].visited && visitFun(pos.x, pos.y))
108                             {
109                                 next->dir = curDir = DIR_LEFT;
110                             }
111                         }
112                     }
113                 }
114             }else
115             {
116                 if(DIR_LEFT == curDir || DIR_RIGHT == curDir)
117                 {
118                     if(end.y >= cur->y)
119                     {
120                         pos.x = cur->x; pos.y = cur->y + 1;nextDir = DIR_DOWN;
121                         if(!AI_CheckRange(pos,size) || nodeArr[size.x * pos.y + pos.x].visited || !visitFun(pos.x, pos.y))
122                         {
123                             pos.x = cur->x; pos.y = cur->y - 1;nextDir = DIR_UP;
124                         }
125                     }else
126                     {
127                         pos.x = cur->x; pos.y = cur->y - 1;nextDir = DIR_UP;
128                         if(!AI_CheckRange(pos,size) || nodeArr[size.x * pos.y + pos.x].visited || !visitFun(pos.x, pos.y))
129                         {
130                             pos.x = cur->x; pos.y = cur->y + 1;nextDir = DIR_DOWN;
131                         }
132                     }
133                 }else if(DIR_DOWN == curDir || DIR_UP == curDir)
134                 {
135                     if(end.x >= cur->x)
136                     {
137                         pos.x = cur->x + 1; pos.y = cur->y;nextDir = DIR_RIGHT;
138                         if(!AI_CheckRange(pos,size) || nodeArr[size.x * pos.y + pos.x].visited || !visitFun(pos.x, pos.y))
139                         {
140                             pos.x = cur->x - 1; pos.y = cur->y;nextDir = DIR_LEFT;
141                         }
142                     }else
143                     {
144                         pos.x = cur->x - 1; pos.y = cur->y;nextDir = DIR_LEFT;
145                         if(!AI_CheckRange(pos,size) || nodeArr[size.x * pos.y + pos.x].visited || !visitFun(pos.x, pos.y))
146                         {
147                             pos.x = cur->x + 1; pos.y = cur->y;nextDir = DIR_RIGHT;
148                         }
149                     }
150                 }
151                 if(!AI_CheckRange(pos,size) || nodeArr[size.x * pos.y + pos.x].visited || !visitFun(pos.x, pos.y))
152                 {
153                     visit.pop_back();
154                 }else
155                 {
156                     next = &nodeArr[size.x * pos.y + pos.x];
157                     next->x = pos.x; next->y = pos.y; next->visited = true;next->dir = nextDir;
158                     visit.push_back(next);
159                 }
160             }
161         }
162         if(NULL != path){*path = new Path(false, 0.0f);}
163         if(NULL != nodeArr){delete[] nodeArr;}
164         return false;
165     }
166 private:
167     enum EDIRTYPE
168     {
169         DIR_NONE,
170         DIR_LEFT,
171         DIR_RIGHT,
172         DIR_UP,
173         DIR_DOWN
174     };
175     struct Info
176     {
177         Info():visited(false),x(0),y(0),dir(DIR_NONE){}
178         bool visited;
179         int x,y;
180         EDIRTYPE dir;
181     };
182 };
183 
184 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  寻路算法 BFS.h



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 #ifndef __BFS__H
 2 #define __BFS__H
 3 
 4 #include "AIDefine.h"
 5 #include <queue>
 6 
 7 class BFS
 8 {
 9 private:
10     BFS();
11 public:
12     static bool find(const PointI &size, const PointI &start, const PointI &end, AI_VisitFun visitFun, Path **path = NULL,
13         EFindType findType = EFIND_TYPE8, AI_DitanceFun fun = AI_Ditance1)
14     {
15         if(size.x <= 0 || size.y <= 0 || start.x < 0 || start.y < 0 || end.x < 0 || end.y < 0 ||
16             start.x >= size.x || start.y >= size.y || end.x >= size.x || end.y >= size.y ||
17             !visitFun(start.x, start.y), !visitFun(end.x, end.y))
18         {
19             if(NULL != path){*path = new Path(false, 0.0f);}
20             return false;
21         }
22         if(start.x == end.x && start.y == end.y)
23         {
24             if(NULL != path){*path = new Path(true, 0.0f);}
25             return true;
26         }
27 
28         std::priority_queue<Info*, std::vector<Info*>, InfoCmp> visit;
29         Info *nodeArr = new Info[size.x * size.y];
30         Info *cur, *next;
31         PointI pos;
32 
33         cur = &nodeArr[size.x * start.y + start.x];
34         cur->x = start.x; cur->y = start.y; cur->visited = true; cur->f = 0;
35         visit.push(cur);
36 
37         while(!visit.empty())
38         {
39             cur = visit.top();
40             visit.pop();
41             if(cur->x == end.x && cur->y == end.y)
42             {
43                 if(NULL != path)
44                 {
45                     *path = new Path(true, cur->f);
46                     while (NULL != cur)
47                     {
48                         (*path)->push_front(PointI(cur->x, cur->y));
49                         cur = cur->parent;
50                     }
51                 }
52                 if(NULL != nodeArr){delete[] nodeArr;}
53                 return true;
54             }
55             for(int i = 0; i < findType; ++i)
56             {
57                 pos.x = cur->x + AI_FindHelpPoint[i].x; pos.y = cur->y + AI_FindHelpPoint[i].y;
58                 if(pos.x >= 0 && pos.y >= 0 && pos.x < size.x && pos.y < size.y
59                     && !nodeArr[size.x * pos.y + pos.x].visited && AI_CheckPass(cur->x, cur->y, pos.x, pos.y, visitFun))
60                 {
61                     next = &nodeArr[size.x * pos.y + pos.x];
62                     next->visited = true; next->x = pos.x; next->y = pos.y; 
63                     next->f = cur->f + fun(cur->x, cur->y, next->x, next->y);
64                     next->parent = cur;
65                     visit.push(next);
66                 }
67             }
68         }
69 
70         if(NULL != nodeArr){delete[] nodeArr;}
71         return false;
72     }
73 private:
74     struct Info
75     {
76         Info():visited(false),x(0),y(0),f(0.0f),parent(NULL){}
77         bool visited;
78         int x,y;
79         float f;
80         Info *parent;
81     };
82     struct InfoCmp
83     {
84         bool operator () (const Info *p1, const Info *p2)
85         {
86             return p1->f > p2->f;
87         }
88     };
89 };
90 
91 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  寻路算法 Dijkstra.h





```
  1 #ifndef __DIJKSTRA__H
  2 #define __DIJKSTRA__H
  3 
  4 #include "AIDefine.h"
  5 #include <queue>
  6 
  7 class Dijkstra
  8 {
  9 private:
 10 #define MAXNUM 0x7FFFFFFF
 11 public:
 12     Dijkstra()
 13     {
 14         m_nodeArr = NULL;
 15         m_able = false;
 16     }
 17     ~Dijkstra()
 18     {
 19         if(NULL != m_nodeArr)
 20         {
 21             delete[] m_nodeArr;
 22             m_nodeArr = NULL;
 23         }
 24     }
 25     static bool find(const PointI &size, const PointI &start, const PointI &end, AI_VisitFun visitFun, Path **path = NULL,
 26         EFindType findType = EFIND_TYPE8, AI_DitanceFun fun = AI_Ditance1)
 27     {
 28         Dijkstra dijkstra;
 29         if(dijkstra.init(size, end, visitFun, findType, fun))
 30         {
 31             return dijkstra.findPath(start, path);
 32         }
 33         if(NULL != path){*path = new Path(false, 0.0f);}
 34         return false;
 35     }
 36     bool init(const PointI &size, const PointI &end, AI_VisitFun visitFun, EFindType findType = EFIND_TYPE8, AI_DitanceFun fun = AI_Ditance1)
 37     {
 38         if(size.x <= 0 || size.y <= 0 || end.x < 0 || end.y < 0 || end.x >= size.x || end.y >= size.y)
 39         {
 40             m_able = false;
 41             return false;
 42         }
 43         m_able = true;
 44         m_size.x = size.x; m_size.y = size.y;
 45         m_end.x = end.x; m_end.y = end.y;
 46         if(NULL != m_nodeArr){delete m_nodeArr; m_nodeArr = NULL;}
 47         m_nodeArr = new Info[size.x * size.y];
 48         Info *cur, *next;
 49         PointI pos;
 50         int i;
 51         PriorityQueue<Info*, InfoCmp> visit;
 52         //std::priority_queue<Info*, std::vector<Info*>, InfoCmp> visit;
 53         for(i = 0; i < findType; ++i)
 54         {
 55             pos.x = end.x + AI_FindHelpPoint[i].x;pos.y = end.y + AI_FindHelpPoint[i].y;
 56             if(pos.x >= 0 && pos.x <size.x && pos.y >= 0 && pos.y < size.y && AI_CheckPass(end.x, end.y, pos.x, pos.y, visitFun))
 57             {
 58                 cur = &m_nodeArr[pos.y * size.x + pos.x];
 59                 cur->x = pos.x; cur->y = pos.y;
 60                 cur->dis = fun(end.x, end.y, cur->x, cur->y);
 61                 cur->path.x = end.x; cur->path.y = end.y; cur->hasPath = true;
 62                 visit.push(cur);
 63             }
 64         }
 65         cur = &m_nodeArr[end.y * size.x + end.x];
 66         cur->dis = 0; cur->visited = true;
 67         cur->path.x = end.x; cur->path.y = end.y; cur->hasPath = true;
 68         cur->x = end.x; cur->y = end.y;
 69 
 70         float cost;
 71         while(!visit.empty())
 72         {
 73             cur = visit.top();visit.pop();
 74             cur->visited = true;
 75             for(i = 0; i < findType; ++i)
 76             {
 77                 pos.x = cur->x + AI_FindHelpPoint[i].x;pos.y = cur->y + AI_FindHelpPoint[i].y;
 78                 if(pos.x >= 0 && pos.x <size.x && pos.y >= 0 && pos.y < size.y)
 79                 {
 80                     next = &m_nodeArr[pos.y * size.x + pos.x];
 81                     next->x = pos.x; next->y = pos.y;
 82                     cost = fun(cur->x, cur->y, next->x, next->y);
 83                     if(!next->visited && AI_CheckPass(cur->x, cur->y, next->x, next->y, visitFun) && cur->dis + cost < next->dis)
 84                     {
 85                         next->dis = cur->dis + cost;
 86                         next->path.x = cur->x; next->path.y = cur->y; next->hasPath = true;
 87                         visit.push(next);
 88                     }
 89                 }
 90             }
 91         }
 92         return true;
 93     }
 94     bool getDis(const PointI &start, float &dis)
 95     {
 96         dis = 0;
 97         if(m_able)
 98         {
 99             if(start.x == m_end.x && start.y == m_end.y)
100             {
101                 return true;
102             }
103             if(start.x < 0 || start.x >= m_size.x || start.y < 0 || start.y >= m_size.y)
104             {
105                 return false;
106             }
107             dis = m_nodeArr[start.y * m_size.x + start.x].dis;
108             return true;
109         }
110         return false;
111     }
112     bool findPath(const PointI &start, Path **path = NULL, bool isStart = true)
113     {
114         bool result = false;
115         if(m_able)
116         {
117             Path *_path = new Path(true, 0.0f);
118             if(start.x == m_end.x && start.y == m_end.y)
119             {
120                 if(NULL != path){*path = _path;}else{delete _path;}
121                 return true;
122             }
123             Info *cur;
124             _path->push_front(PointI(start.x, start.y));
125             cur = &m_nodeArr[start.y * m_size.x + start.x];
126             _path->setDis(cur->dis);
127             while(cur->hasPath)
128             {
129                 if(cur->path.x == m_end.x && cur->path.y == m_end.y)
130                 {
131                     result = true;
132                     break;
133                 }
134                 if(isStart){_path->push_back(PointI(cur->path.x, cur->path.y));}
135                 else{_path->push_front(PointI(cur->path.x, cur->path.y));}
136                 cur = &m_nodeArr[cur->path.y * m_size.x + cur->path.x];
137             }
138             if(!result){delete _path; _path = new Path(false, MAXNUM);}
139             else
140             {
141                 if(isStart){_path->push_back(PointI(m_end.x, m_end.y));}
142                 else{_path->push_front(PointI(m_end.x, m_end.y));}
143             }
144             if(NULL != path){*path = _path;}else{delete _path;}
145         }
146         return result;
147     }
148 private:
149     struct Info
150     {
151         Info():dis(MAXNUM),visited(false), hasPath(false){}
152         int x, y;
153         PointI path;
154         float dis;
155         bool visited;
156         bool hasPath;
157     };
158     struct InfoCmp
159     {
160         bool operator () (const Info *p1, const Info *p2)
161         {
162             return p1->dis < p2->dis;
163         }
164     };
165 private:
166     Info     *m_nodeArr;
167     PointI    m_size;
168     PointI    m_end;
169     bool     m_able;
170 };
171 
172 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  寻路算法 SPFA.h





```
  1 #ifndef __SPFA__H
  2 #define __SPFA__H
  3 
  4 #include <deque>
  5 #include "AIDefine.h"
  6 
  7 class SPFA
  8 {
  9 public:
 10     SPFA()
 11     {
 12         m_nodeArr = NULL;
 13         m_able = false;
 14     }
 15     ~SPFA()
 16     {
 17         if(NULL != m_nodeArr)
 18         {
 19             delete[] m_nodeArr;
 20             m_nodeArr = NULL;
 21         }
 22     }
 23     static bool find(const PointI &size, const PointI &start, const PointI &end, AI_VisitFun visitFun, Path **path = NULL,
 24         EFindType findType = EFIND_TYPE8, AI_DitanceFun fun = AI_Ditance1)
 25     {
 26         SPFA spfa;
 27         if(spfa.init(size, end, visitFun, findType, fun))
 28         {
 29             return spfa.findPath(start, path);
 30         }
 31         if(NULL != path){*path = new Path(false, 0.0f);}
 32         return false;
 33     }
 34     bool init(const PointI &size, const PointI &end, AI_VisitFun visitFun, EFindType findType = EFIND_TYPE8, AI_DitanceFun fun = AI_Ditance1)
 35     {
 36         if(size.x <= 0 || size.y <= 0 || end.x < 0 || end.y < 0 || end.x >= size.x || end.y >= size.y)
 37         {
 38             return false;
 39         }
 40         m_able = true;
 41         m_size.x = size.x; m_size.y = size.y;
 42         m_end.x = end.x; m_end.y = end.y;
 43         if(NULL != m_nodeArr){delete m_nodeArr; m_nodeArr = NULL;}
 44         m_nodeArr = new Info[size.x * size.y];
 45         std::deque<Info*> Q;
 46         Info *cur, *temp;
 47         PointI pos;
 48         cur = &m_nodeArr[end.y * size.x + end.x];
 49         cur->x = end.x; cur->y = end.y; cur->dis = 0; cur->visit = 1; cur->visited = true;
 50         cur->path.x = end.x; cur->path.y = end.y; cur->hasPath = true;
 51         Q.push_back(cur);
 52 
 53         float cost;
 54         while(!Q.empty())
 55         {
 56             cur = Q.front();
 57             Q.pop_front();
 58             for(int i = 0; i < findType; ++i)
 59             {
 60                 pos.x = cur->x + AI_FindHelpPoint[i].x;pos.y = cur->y + AI_FindHelpPoint[i].y;
 61                 if(pos.x >= 0 && pos.x < size.x && pos.y >= 0 && pos.y < size.y)
 62                 {
 63                     temp = &m_nodeArr[pos.y * size.x + pos.x];
 64                     temp->x = pos.x; temp->y = pos.y;
 65                     cost = fun(cur->x, cur->y, temp->x, temp->y);
 66                     if(!temp->visited && AI_CheckPass(cur->x, cur->y, pos.x, pos.y, visitFun) && cur->dis + cost < temp->dis)
 67                     {
 68                         temp->dis = cur->dis + cost;
 69                         temp->visit += 1; temp->visited = true;
 70                         temp->path.x = cur->x; temp->path.y = cur->y; temp->hasPath = true;
 71                         if(temp->visit > 8)
 72                         {
 73                             return false;
 74                         }
 75                         if(!Q.empty())
 76                         {
 77                             if(temp->dis < Q.front()->dis){Q.push_front(temp);}
 78                             else{Q.push_back(temp);}
 79                         }else{Q.push_back(temp);}
 80                     }
 81                 }
 82             }
 83             cur->visited = false;
 84         }
 85 
 86         return true;
 87     }
 88     bool getDis(const PointI &start, float &dis)
 89     {
 90         dis = 0;
 91         if(m_able)
 92         {
 93             if(start.x == m_end.x && start.y == m_end.y)
 94             {
 95                 return true;
 96             }
 97             if(start.x < 0 || start.x >= m_size.x || start.y < 0 || start.y >= m_size.y)
 98             {
 99                 return false;
100             }
101             dis = m_nodeArr[start.y * m_size.x + start.x].dis;
102             return true;
103         }
104         return false;
105     }
106     bool findPath(const PointI &start, Path **path = NULL, bool isStart = true)
107     {
108         bool result = false;
109         if(m_able)
110         {
111             Path *_path = new Path(true, 0.0f);
112             if(start.x == m_end.x && start.y == m_end.y)
113             {
114                 if(NULL != path){*path = _path;}else{delete _path;}
115                 return true;
116             }
117             Info *cur;
118             _path->push_back(PointI(start.x, start.y));
119             cur = &m_nodeArr[start.y * m_size.x + start.x];
120             _path->setDis(cur->dis);
121             while(true)
122             {
123                 if(cur->path.x == m_end.x && cur->path.y == m_end.y)
124                 {
125                     result = true;
126                     break;
127                 }
128                 if(isStart){_path->push_back(PointI(cur->path.x, cur->path.y));}
129                 else{_path->push_front(PointI(cur->path.x, cur->path.y));}
130                 cur = &m_nodeArr[cur->path.y * m_size.x + cur->path.x];
131             }
132             if(!result){delete _path; _path = new Path(false, 0.0f);}
133             else
134             {
135                 if(isStart){_path->push_back(PointI(m_end.x, m_end.y));}
136                 else{_path->push_front(PointI(m_end.x, m_end.y));}
137             }
138             if(NULL != path){*path = _path;}else{delete _path;}
139         }
140         return result;
141     }
142 private:
143     struct Info
144     {
145         Info():visit(0),dis(0x7FFFFFFF),visited(false),hasPath(false){}
146         int x, y, visit;
147         float dis;
148         bool visited, hasPath;
149         PointI path;
150     };
151 private:
152     Info     *m_nodeArr;
153     PointI    m_size;
154     PointI    m_end;
155     bool     m_able;
156 };
157 
158 #endif
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

##  寻路算法 Floyd.h



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
  1 #ifndef __FLOYD__H
  2 #define __FLOYD__H
  3 
  4 #include "AIDefine.h"
  5 
  6 class Floyd
  7 {
  8 private:
  9 #define MAXNUM 0x7FFFFFFF
 10 public:
 11     Floyd()
 12     {
 13         m_nodeArr = NULL;
 14         m_path = NULL;
 15         m_able = false;
 16     }
 17     ~Floyd()
 18     {
 19         if(NULL != m_nodeArr){delete[] m_nodeArr; m_nodeArr = NULL;}
 20         if(NULL != m_path){delete[] m_path; m_path = NULL;}
 21     }
 22 public:
 23     static bool find(const PointI &size, const PointI &start, const PointI &end, AI_VisitFun visitFun, Path **path = NULL,
 24         EFindType findType = EFIND_TYPE8, AI_DitanceFun fun = AI_Ditance1)
 25     {
 26         Floyd floyd;
 27         if(floyd.init(size, visitFun, findType, fun))
 28         {
 29             return floyd.findPath(start, end, path);
 30         }
 31         if(NULL != path){*path = new Path(false, 0.0f);}
 32         return false;
 33     }
 34     bool init(const PointI &size, AI_VisitFun visitFun, EFindType findType = EFIND_TYPE8, AI_DitanceFun fun = AI_Ditance1)
 35     {
 36         if(NULL != m_nodeArr){delete[] m_nodeArr; m_nodeArr = NULL;}
 37         if(NULL != m_path){delete[] m_path; m_path = NULL;}
 38         if(size.x <= 0 || size.y <= 0)
 39         {
 40             m_able = false;
 41             return false;
 42         }
 43         m_able = true;
 44         m_size.x = size.x; m_size.y = size.y;
 45         int count = size.x * size.y;
 46         m_nodeArr = new Info[count * count];
 47         m_path = new int[count * count];
 48         bool *visitArr = new bool[count];
 49 
 50         int i, j, k, index1, index2, index3;
 51         PointI pos;
 52         for(i = 0; i < size.y; ++i)
 53         {
 54             for(j = 0; j < size.x; ++j)
 55             {
 56                 index1 = i * size.x + j;
 57                 visitArr[index1] = visitFun(j, i);
 58                 if(visitArr[index1])
 59                 {
 60                     for(k = 0; k < findType; ++k)
 61                     {
 62                         pos.x = j + AI_FindHelpPoint[k].x;pos.y = i + AI_FindHelpPoint[k].y;
 63                         index2 = pos.y * size.x + pos.x;
 64                         if(AI_CheckRange(pos,size) && AI_CheckPass(j, i, pos.x, pos.y, visitFun))
 65                         {
 66                             index3 = index1 * count + index2;
 67                             m_nodeArr[index3].dis = fun(j,i,pos.x,pos.y);
 68                             m_nodeArr[index3].assign = true;
 69                             m_path[index3] = index2;
 70 
 71                             index3 = index2 * count + index1;
 72                             m_nodeArr[index3].dis = fun(j,i,pos.x,pos.y);
 73                             m_nodeArr[index3].assign = true;
 74                             m_path[index3] = index1;
 75                         }
 76                     }
 77                     index3 = index1 * count + index1;
 78                     m_nodeArr[index3].dis = 0;
 79                     m_nodeArr[index3].assign = true;
 80                     m_path[index3] = index1;
 81                 }
 82             }
 83         }
 84         for(k = 0; k < count; ++k)
 85         {
 86             if(!visitArr[k]){continue;}
 87             for(i = 0; i < count; ++i)
 88             {
 89                 if(!visitArr[i] || i == k){continue;}
 90                 for(j = 0; j < i; ++j)
 91                 {
 92                     if(!visitArr[j] || i == j || j == k){continue;}
 93 
 94                     if(m_nodeArr[i * count + k].assign && m_nodeArr[k * count + j].assign &&
 95                         m_nodeArr[i * count + j].dis > m_nodeArr[i * count + k].dis + m_nodeArr[k * count + j].dis)
 96                     {
 97                         m_nodeArr[i * count + j].dis = m_nodeArr[i * count + k].dis + m_nodeArr[k * count + j].dis;
 98                         m_nodeArr[i * count + j].assign = true;
 99                         m_path[i * count + j] = m_path[i * count + k];
100 
101 
102                         m_nodeArr[j * count + i].dis = m_nodeArr[i * count + j].dis;
103                         m_nodeArr[j * count + i].assign = true;
104                         m_path[j * count + i] = m_path[j * count + k];
105                     }
106                 }
107             }
108         }
109         delete[] visitArr;
110         return true;
111     }
112     bool findPath(const PointI &start, const PointI &end, Path **path = NULL)
113     {
114         if(!m_able)
115         {
116             if(NULL != path){*path = new Path(false, 0.0f);}
117             return false;
118         }
119         bool result = false;
120         if(start.x < 0 || start.y < 0 || start.x >= m_size.x || start.y >= m_size.y || 
121             end.x < 0 || end.y < 0 || end.x >= m_size.x || end.y >= m_size.y ||
122             (start.x == end.x && start.y == end.y))
123         {
124             if(NULL != path){*path = new Path(false, 0.0f);}
125             return false;
126         }else
127         {
128             int index1, index2, index3;
129             int count = m_size.x * m_size.y;
130             index1 = start.y * m_size.x + start.x;
131             index2 = end.y * m_size.x + end.x;
132             index3 = index1 * count + index2;
133             Path *_path = new Path(true, 0.0f);
134             if(m_nodeArr[index3].assign)
135             {
136                 result = true;
137                 _path->setDis(m_nodeArr[index3].dis);
138                 _path->push_back(PointI(start.x, start.y));
139                 int i, j;
140                 int cur = m_path[index3];
141                 while(true)
142                 {
143                     i = (int)(cur / m_size.x);
144                     j = cur % m_size.x;
145                     _path->push_back(PointI(j, i));
146                     if(i == end.y && j == end.x){break;}
147                     cur = m_path[cur * count + index2];
148                 }
149             }
150             if(!result){delete _path; _path = new Path(false, 0.0f);}
151             if(NULL != path){*path = _path;}
152         }
153         return result;
154     }
155 private:
156     struct Info
157     {
158         Info():dis(MAXNUM),assign(false){}
159         float dis;
160         bool assign;
161     };
162 private:
163     Info    *m_nodeArr;
164     int     *m_path;
165     PointI   m_size;
166     bool    m_able;
167 };
168 
169 #endif
```



 



## 实用场合



如果你只需要知道是否存在一条路径就选BStar Bstar能快速找到一条路径，只是99%不是最短路径。

如果你要找一条最短路径 可以用AStar BFS算法，在地图比较简单AStar效率高，如果地图复杂还是选BFS吧（AStar要为自己的聪明付出代价）。

如果你要寻很多条路但他们的起点或终点一样就选Dijkstra SPFA算法，因为他们一次寻路就把所有到相同目标的路径都算出来了，Dijkstra算法稳定，SPFA算法不稳定，但我测试基本都是SPFA要快那么一点。

至于Floyd算法基本不实用，虽然一次计算把地图任意点对路径都算出来了，但效率实在太低。算法复杂度是格子数的3次方。







# [效率测试](https://www.cnblogs.com/liusijian/p/3438567.html)



[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```cpp
 1 void main()
 2 {
 3     Path *path;
 4     time_t t1,t2;
 5     int i, times = 10000;
 6 
 7     t1 = clock();
 8     for(i = 0; i < times; ++i)
 9     {
10         AStar::find(_size, _start, _end, visit, &path);
11     }
12     t2 = clock();cout<<"A* "<<t2-t1<<endl;
13 
14     t1 = clock();
15     for(i = 0; i < times; ++i)
16     {
17         BStar::find(_size, _start, _end, visit, &path);
18     }
19     t2 = clock();cout<<"B* "<<t2-t1<<endl;
20 
21     t1 = clock();
22     for(i = 0; i < times; ++i)
23     {
24         BFS::find(_size, _start, _end, visit, &path);
25     }
26     t2 = clock();cout<<"BFS "<<t2-t1<<endl;
27 
28     t1 = clock();
29     for(i = 0; i < times; ++i)
30     {
31         Dijkstra::find(_size, _start, _end, visit, &path);
32     }
33     t2 = clock();cout<<"Dijkstra "<<t2-t1<<endl;
34 
35     t1 = clock();
36     Dijkstra dij;
37     dij.init(_size, _end, visit);
38     for(i = 0; i < times; ++i)
39     {
40         dij.findPath(_start, &path);
41     }
42     t2 = clock();cout<<"Dijkstra1 "<<t2-t1<<endl;
43 
44     t1 = clock();
45     for(i = 0; i < times; ++i)
46     {
47         SPFA::find(_size, _start, _end, visit, &path);
48     }
49     t2 = clock();cout<<"SPFA "<<t2-t1<<endl;
50     
51     t1 = clock();
52     SPFA spfa;
53     spfa.init(_size, _end, visit);
54     for(i = 0; i < times; ++i)
55     {
56         spfa.findPath(_start, &path);
57     }
58     t2 = clock();cout<<"Dijkstra1 "<<t2-t1<<endl;
59 
60     t1 = clock();
61     Floyd::find(_size, _start, _end, visit, &path);
62     t2 = clock();cout<<"Floyd "<<t2-t1<<endl;
63 
64     printPath(path);
65 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
B*110
BFS 687
Dijkstra 3156
Dijkstral 32
SPFA 1078
Dijkstral 31
Floyd 453
```

地图还算简单我寻路10000次。

别怪我吐槽A*算法，居然比SPFA还慢，人家SPFA可是把所有到终点的路径都算好了哦。

 

 

这里我要说下Dijkstra为什么都3156了那是我的优先队列太垃圾了，

PriorityQueue<Info*, InfoCmp> visit;
//std::priority_queue<Info*, std::vector<Info*>, InfoCmp> visit;

我用了我自己的PriorityQueue，如果用std的priority_queue只要1375ms。

那你问我为什么不用std的priority_queue，那是我在做跨平台是运行错误了。不得已自己写的。

你可以自己测试，注意我自己的PriorityQueue和std的比较函数是反的，发现路径不对把下面的比较函数颠倒下就可以了。

 

```cpp
   struct InfoCmp
    {
        bool operator () (const Info *p1, const Info *p2)
        {
            return p1->dis > p2->dis;
        }
    };
```

 

 

你看你看到Floyd怎么才453ms，那是我只寻了一次，你也知道它有多慢了。

那你觉得Floyd是不是就没用了？