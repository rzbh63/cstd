
# 20160212.CCPP体系详解(0022天) - 尹成的技术博客 - CSDN博客

置顶2016年03月01日 13:52:22[尹成](https://me.csdn.net/yincheng01)阅读数：2146个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)



程序片段(01):01.二维数组.c
内容概要:**二维数组**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.关于栈内存开辟数组:
```
```python
//  诀窍:将所有维度的数组看做为一维数组,
```
```python
//      然后再采用指向该数组当中首个元素的指针(变量|常量)
```
```python
//  秘诀:原始数组数组名称替换法:
```
```python
//      就可以直接得到指向数组的指针(将数组名称-->替换为-->(*pArr))
```
```python
//  特点:指针变量可以不用最高维度,
```
```python
//      但是类型转换必须加上表示最高维度的中括号!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//int arrArr[3][4];//位于栈内存:
```
```python
int
```
```python
* p1 = (
```
```python
int
```
```python
[]) {
```
```python
0
```
```python
};
```
```python
//一维数组-->栈上开辟
```
```python
int
```
```python
(*p2)[
```
```python
4
```
```python
] = (
```
```python
int
```
```python
[][
```
```python
4
```
```python
]) {
```
```python
0
```
```python
};
```
```python
//二维数组-->栈上开辟
```
```python
int
```
```python
(*p3)[
```
```python
3
```
```python
][
```
```python
4
```
```python
] = (
```
```python
int
```
```python
[][
```
```python
3
```
```python
][
```
```python
4
```
```python
]) {
```
```python
0
```
```python
};
```
```python
//三维数组-->栈上开辟
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.堆栈开辟指针数组以及指针数组的回收顺序!
```
```python
//  1.防止内存泄露现象的产生
```
```python
//  2.动态数组可以按照静态数组的方式进行访问!
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//堆内存开辟数组!
```
```python
int
```
```python
** pp =
```
```python
calloc
```
```python
(
```
```python
3
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
*));
```
```python
//分配指针数组[一级指针数组!]
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
        pp[i] =
```
```python
malloc
```
```python
(
```
```python
4
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//每个指针必须分配内存!
```
```python
}
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
//&pp[i]-->pp+i
```
```python
//&pp[i][j]-->*(pp+i)+j
```
```python
//pp[i]-->*(pp+i)
```
```python
//pp[i][j]-->*(*(pp+i)+j);
```
```python
//printf("%4d", pp[i][j] = num++);
```
```python
printf
```
```python
(
```
```python
"%4d"
```
```python
, *(*(pp + i) + j));
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
//严格注意堆内存当中数组的回收顺序!
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
free
```
```python
(pp[i]);
```
```python
//先回收一级指针所指向的内存块儿-->防止堆内存泄露
```
```python
}
```
```python
free
```
```python
(pp);
```
```python
//再释放指针数组
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.栈上开辟二维数组:
```
```python
//  注:在进行栈内存的类型转换的时候,需要一个准确的数组!
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
//栈上开辟二维数组
```
```python
int
```
```python
(*p)[
```
```python
4
```
```python
] = (
```
```python
int
```
```python
[
```
```python
3
```
```python
][
```
```python
4
```
```python
]) {
```
```python
0
```
```python
};
```
```python
//栈上开辟二维数组,自动回收
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, p[i][j] = num++);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.分块儿数组的逐级回收特点!
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
//分块儿内存切忌要逐级进行内存回收!
```
```python
int
```
```python
(*pArr)[
```
```python
4
```
```python
] =
```
```python
malloc
```
```python
(
```
```python
3
```
```python
*
```
```python
4
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//堆内存:呈线性存储的二维数组
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d \n"
```
```python
, pArr[i][j] = num++);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
free
```
```python
(pArr);
```
```python
//根据指向堆内存的连续存储的二维数组指针,进行堆内存二维数组的回收操作!
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):01.函数指针.c
内容概要:**函数指针**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
void
```
```python
runmsg()
{
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"您好!"
```
```python
,
```
```python
"天朝城管的全家!"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
void
```
```python
print()
{
```
```python
printf
```
```python
(
```
```python
"%s, %s \n"
```
```python
,
```
```python
"您好!"
```
```python
,
```
```python
"天朝城管的全家!"
```
```python
);
}
```
```python
//01.严格区分函数指针变量和函数指针常量:
```
```python
//  函数名的本质:函数指针常量,存储的是代码区函数实体的入口点!
```
```python
//  函数指针的本质:存储函数指针常量的数据|存储代码区函数实体的入口点
```
```python
//      通过修改函数指针变量所存储的入口点,让函数指针变量可以调用
```
```python
//      代码区当中不同的函数实体,从而实现改变函数行为的现象!
```
```python
//02.对函数名的几种操作:
```
```python
//  &funName--funName--*funName
```
```python
//注:这几种方式所得到的值相同,都是同一个函数实体的入口点地址!
```
```python
//      区分函数声明入口点地址和函数调用地址!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//函数指针变量:自己存储与数据区当中,只是存储了代码区的入口点(函数指针常量)
```
```python
//runmsg = runmsg;//函数名的本质:函数指针常量,存储的是代码区函数体的入口点儿
```
```python
void
```
```python
(*pFun)() = runmsg;
```
```python
//通过函数指针变量存储函数指针产量的值|存储代码区函数实体的调用地址
```
```python
pFun();
```
```python
//通过函数指针变量实现函数的间接调用
```
```python
pFun = print;
```
```python
//修改函数指针变量所存储的函数指针常量,从而实现调用行为的改变
```
```python
pFun();
```
```python
printf
```
```python
(
```
```python
"%p, %p, %p \n"
```
```python
, &runmsg, runmsg, *runmsg);
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, print);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.对于代码区而言:
```
```python
//  1.函数指针有类型之分-->函数指针声明格式的类型说明!
```
```python
//  2.对函数名的几种取值操作所得到的值的性质一样
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"%p, %p, %p \n"
```
```python
, &runmsg, runmsg, *runmsg);
```
```python
//对于代码区而言,函数指针有类型区分
```
```python
//&runmsg = runmsg;//编译器原理:获取函数指针的地址,和函数地址一样
```
```python
//*runmsg = *(&runmsg)=runmsg
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(03):01.DllInject.c
内容概要:**非法调用**
```python
//moveto(int z, int x, int y);//跨点函数:所跨越的维度为三维
```
```python
_declspec(dllexport)
```
```python
void
```
```python
main()
{
```
```python
void
```
```python
(*pFun)(
```
```python
void
```
```python
) =
```
```python
0x0134110E
```
```python
;
```
```python
//声明一个函数指针变量,用于间接调用函数实体
```
```python
pFun();
```
```python
//调用
```
```python
}
```
程序片段(04):01.数组名.c+02.二维数组.c
内容概要:**数组名作为函数参数**
```python
///01.数组名.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//数组名作为函数的参数,会退化为指针
```
```python
void
```
```python
run01(
```
```python
int
```
```python
a[
```
```python
5
```
```python
])
```
```python
//一维数组没有副本机制,作为参数退化为一级指针
```
```python
{
```
```python
printf
```
```python
(
```
```python
"\n run=%d"
```
```python
,
```
```python
sizeof
```
```python
(a));
```
```python
//大小是4
```
```python
a = a +
```
```python
1
```
```python
;
```
```python
//数组名可以进行改变,因为已经变为了指针变量的类型
```
```python
//int b[5];
```
```python
//b = b + 1;
```
```python
}
```
```python
void
```
```python
run02(
```
```python
int
```
```python
*p)
```
```python
//一位数组名作为该函数的参数同样会退化为一级指针,所以这里采用一级指针进行接收
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; i++)
    {
```
```python
printf
```
```python
(
```
```python
"\n %d"
```
```python
, p[i]);
    }
}
```
```python
void
```
```python
rev(
```
```python
int
```
```python
*p,
```
```python
int
```
```python
length)
{
```
```python
//指针法,由于下标,表现对指针的熟练度
```
```python
for
```
```python
(
```
```python
int
```
```python
*phead = p, *pback = p + length -
```
```python
1
```
```python
; phead < pback; phead++, pback--)
    {
```
```python
int
```
```python
temp = *phead;
        *phead = *pback;
        *pback = temp;
    }
}
```
```python
void
```
```python
show(
```
```python
int
```
```python
*p,
```
```python
int
```
```python
length)
```
```python
//一位数组名作为函数的参数进行传递会自动退化为一级指针
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < length; i++)
    {
```
```python
printf
```
```python
(
```
```python
"\n %d"
```
```python
, p[i]);
    }
}
```
```python
void
```
```python
main01()
{
```
```python
int
```
```python
a[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
//a=1;
```
```python
printf
```
```python
(
```
```python
"%d"
```
```python
,
```
```python
sizeof
```
```python
(a));
    run02(a);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
main02()
{
```
```python
int
```
```python
a[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
int
```
```python
*p = (
```
```python
int
```
```python
[]){
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
};
    rev(a,
```
```python
5
```
```python
);
    show(a,
```
```python
5
```
```python
);
```
```python
printf
```
```python
(
```
```python
"\n\n"
```
```python
);
    rev(p,
```
```python
6
```
```python
);
    show(p,
```
```python
6
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.二维数组.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.在C语言当中的static关键字用途:
```
```python
//  限定(变量|函数)只能作用于本文件;
```
```python
//  相当于缩小全局变量的作用范围!
```
```python
//02.数组作为函数形参的退化指针规律:
```
```python
//  将所有数组看做为一维数组;
```
```python
//  那么指向该数组当中首个元素的指针(变量|常量)
```
```python
//  的指针就是该数组所退化成为的指针
```
```python
//03.如何快速定位堆上数组的解析方式?
```
```python
//  开辟几位数组就采用指向几位数组的指针进行解析!
```
```python
//  至于指针的声明格式采用上一个说明规律!
```
```python
static
```
```python
void
```
```python
show(
```
```python
int
```
```python
(*pArr)[
```
```python
4
```
```python
])
{
```
```python
printf
```
```python
(
```
```python
"run: sizeof(pArr) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(pArr));
```
```python
//pArr = pArr + 1;//变量指针:数组名作为函数指针将退化成为变量指针!
```
```python
int
```
```python
res =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
4
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, res += pArr[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"平均分 = %d \n"
```
```python
, res /=
```
```python
3
```
```python
);
```
```python
//统计所用总分/人数
```
```python
}
```
```python
void
```
```python
search(
```
```python
int
```
```python
(* pArr)[
```
```python
4
```
```python
],
```
```python
int
```
```python
ifind)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, pArr[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
void
```
```python
get(
```
```python
int
```
```python
(*pArr)[
```
```python
4
```
```python
])
{
```
```python
int
```
```python
flag = -
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
        flag =
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
if
```
```python
(*(*(pArr + i) + j) <
```
```python
60
```
```python
)
            {
                flag =
```
```python
0
```
```python
;
```
```python
break
```
```python
;
            }
        }
```
```python
if
```
```python
(flag)
        {
```
```python
printf
```
```python
(
```
```python
"%d号学生的成绩及格! \n"
```
```python
, i);
        }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"%d号学生的成绩不及格! \n"
```
```python
, i);
        }
    }
}
```
```python
//04.关于数组内存的开辟方式:
```
```python
//  1.按照所属内存区块儿:
```
```python
//      栈内存+堆内存
```
```python
//  2.按照解析方式:
```
```python
//      标准二维数组+分块数组模型
```
```python
//  注:位于栈内存的数组都是连续存储的,位于堆内存的数组视情况而定(指针决定对该片儿内存的解析方式)
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arrArr[
```
```python
3
```
```python
][
```
```python
4
```
```python
] = {
```
```python
89
```
```python
,
```
```python
78
```
```python
,
```
```python
55
```
```python
,
```
```python
71
```
```python
,
```
```python
82
```
```python
,
```
```python
54
```
```python
,
```
```python
53
```
```python
,
```
```python
70
```
```python
,
```
```python
100
```
```python
,
```
```python
98
```
```python
,
```
```python
99
```
```python
,
```
```python
91
```
```python
};
```
```python
//这样分配的二维数组是位于堆内存的连续存储空间(整体连续),而采用二级指针所指向的数组是非整体连续的
```
```python
int
```
```python
(*pArr)[
```
```python
4
```
```python
] = (
```
```python
int
```
```python
[][
```
```python
4
```
```python
]) {
```
```python
89
```
```python
,
```
```python
78
```
```python
,
```
```python
65
```
```python
,
```
```python
71
```
```python
,
```
```python
82
```
```python
,
```
```python
94
```
```python
,
```
```python
93
```
```python
,
```
```python
70
```
```python
,
```
```python
100
```
```python
,
```
```python
98
```
```python
,
```
```python
99
```
```python
,
```
```python
91
```
```python
};
```
```python
//栈上的二维数组
```
```python
show(pArr);
    search(pArr,
```
```python
2
```
```python
);
    get(pArr);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):01.函数指针.c
内容概要:**函数指针强化**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//
```
```python
01
```
```python
.在C语言当中,当形参位于函数声明位置的时候:
```
```python
//
```
```python
可以不用指明形参名称;但是函数实现的时候需要指明形参名称!
```
```python
int
```
```python
add(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
int
```
```python
add(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a + b;
}
```
```python
int
```
```python
sub
```
```python
(int a, int b)
{
```
```python
return
```
```python
a - b;
}
```
```python
int
```
```python
mul(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a * b;
}
```
```python
int
```
```python
divv(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a / b;
}
```
```python
int
```
```python
getmin(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a < b ? a : b;
}
```
```python
int
```
```python
getmax(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a > b ? a : b;
}
//
```
```python
02
```
```python
.采用函数指针作为形参可以实现固化接口的作用
//  固化接口+动化逻辑!
void op(
```
```python
int
```
```python
(
```
```python
*pFun
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
),
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, pFun(a, b));
}
//
```
```python
02
```
```python
.只要作为声明的格式,就可以进行函数形参的省略!
```
```python
//
```
```python
1
```
```python
.区分函数调用和读取函数指针常量所存储的函数入口点地址
//
```
```python
2
```
```python
.对于函数指针变量没有自变的说法,因为毫无意义!
```
```python
//
```
```python
03
```
```python
.区分函数指针变量和函数指针变量的类型!
```
```python
//
```
```python
诀窍:挖取函数指针变量声明格式当中的函数变量名就是
//      该函数指针的具体类型!
```
```python
int
```
```python
main01(void)
{
```
```python
//
```
```python
错误的定义方式,因为类型不匹配
    //
```
```python
int
```
```python
(
```
```python
*pFun
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = add(
```
```python
1
```
```python
,
```
```python
2
```
```python
);
```
```python
//
```
```python
不行:函数调用-->返回结果-->被当做函数调用地址!-->错误现象
    //参数名可以省略,声明的结构
```
```python
int
```
```python
(
```
```python
*pFun
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = add;
```
```python
//p
```
```python
1++;
```
```python
//
```
```python
函数指针变量,没有变的说法!
```
```python
//p
```
```python
2++;
```
```python
//p
```
```python
3 + n;
```
```python
//int
```
```python
(
```
```python
*pFun
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//
```
```python
函数指针
    //
```
```python
int
```
```python
(
```
```python
*)
```
```python
(
```
```python
int
```
```python
,
```
```python
int
```
```python
)//函数指针的类型
```
```python
int
```
```python
(* get() )(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//
```
```python
一个返回值为函数指针,参数为void类型的函数常量指着
    //难度解析:规律剖析
    //  原始:
```
```python
int
```
```python
(
```
```python
*get
```
```python
(
```
```python
int
```
```python
(
```
```python
*y
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
), double))(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//
```
```python
剖析:
```
```python
int
```
```python
(*        get(
```
```python
int
```
```python
(
```
```python
*y
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
), double      )       )(
```
```python
int
```
```python
,
```
```python
int
```
```python
)
    //  解析:一个返回值为函数指针(
```
```python
int
```
```python
(
```
```python
*)
```
```python
(
```
```python
int
```
```python
,
```
```python
int
```
```python
)),参数为函数指针(
```
```python
int
```
```python
(
```
```python
*y
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
))和双精度浮点型(double)的函数指针常量
    //  特点:函数实现的时候,所有形参必须具备形参名称!
```
```python
//
```
```python
作为函数的返回值类型声明不需要进行名称说明!
```
```python
//
```
```python
拓展:指向该函数指针的函数指针变量声明格式
    //
```
```python
int
```
```python
(
```
```python
*(
```
```python
*pFun
```
```python
)(
```
```python
int
```
```python
(
```
```python
*y
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
), double))(
```
```python
int
```
```python
,
```
```python
int
```
```python
)-->该函数指针常量所对应的函数指针变量类型
    //
```
```python
int
```
```python
(* (* const pFun)(
```
```python
int
```
```python
(
```
```python
*y
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
), double))(
```
```python
int
```
```python
,
```
```python
int
```
```python
)-->该函数指针常量所对应的函数指针类型
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):函数指针数组.c
内容概要:**函数指针数组与指向函数指针的指针**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
getmin(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a < b ? a : b;
}
```
```python
int
```
```python
getmax(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a > b ? a : b;
}
```
```python
int
```
```python
add(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a + b;
}
```
```python
int
```
```python
sub
```
```python
(int a, int b)
{
```
```python
return
```
```python
a - b;
}
```
```python
int
```
```python
mul(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a * b;
}
```
```python
int
```
```python
divv(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b)
{
```
```python
return
```
```python
a / b;
}
//
```
```python
01
```
```python
.数组格式的规律:
```
```python
//
```
```python
在数组所存储元素的定义格式基础上,在数组元素名称的末尾添加中括号[数组元素个数];
```
```python
//
```
```python
该数组元素名称成为数组名称
//
```
```python
02
```
```python
.函数指针的规律:
```
```python
//
```
```python
在函数声明格式的基础之上,将函数名称直接替换为(
```
```python
*pFun
```
```python
),那么pFun
//      就是指向该函数的函数指针(
```
```python
*pFun
```
```python
)-->函数变量指针;(* const pFun)函数常量指针,如同数组名
```
```python
int
```
```python
main01(void)
{
```
```python
//int
```
```python
a;
```
```python
//int
```
```python
a[
```
```python
10
```
```python
];
```
```python
//int
```
```python
*p
```
```python
;
```
```python
//int
```
```python
*arrP
```
```python
[
```
```python
10
```
```python
];
```
```python
int
```
```python
(
```
```python
*funP
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = getmax;
```
```python
//
```
```python
函数指针数组
```
```python
int
```
```python
(
```
```python
*funPArr
```
```python
[
```
```python
10
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = { getmin, getmax, add,
```
```python
sub
```
```python
, mul, divv };
```
```python
//funPArr是函数指针数组的数组名,二级函数指针可以直接存储一个一级函数指针数组的首地址
    //
```
```python
int
```
```python
(
```
```python
**
```
```python
funP1)(
```
```python
int
```
```python
,
```
```python
int
```
```python
)<=>
```
```python
int
```
```python
(
```
```python
*funP2
```
```python
[
```
```python
6
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
)
    //  funP1是二级函数变量指针+funP2是二级函数常量指着
    //注:凡是设计数组名都是常量指针
    //
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, sizeof(funP1));
```
```python
//fun
```
```python
P2 = funP1;
```
```python
//fun
```
```python
P2是一个常量指针
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
6
```
```python
; ++i)
    {
```
```python
//
```
```python
索引遍历
        //
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, funPArr[i](
```
```python
1
```
```python
,
```
```python
2
```
```python
));
```
```python
//fun
```
```python
PArr[i]代表函数指针变量本身
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, (
```
```python
*(
```
```python
funPArr + i))(
```
```python
1
```
```python
,
```
```python
2
```
```python
));
```
```python
//fun
```
```python
PArr[i]=>
```
```python
*(
```
```python
funPArr + i)
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = funPArr; funPP < funPArr +
```
```python
6
```
```python
; ++funPP)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
"
```
```python
, (
```
```python
*funPP
```
```python
)(
```
```python
100
```
```python
,
```
```python
10
```
```python
));
    }
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
//
```
```python
03
```
```python
.函数指针相关概念!
```
```python
//int
```
```python
(
```
```python
*funP
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
)
//  funP是一级函数变量指针
//
```
```python
int
```
```python
(
```
```python
*funPArr
```
```python
[
```
```python
10
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
)
//  funPArr是二级函数常量指针
//
```
```python
int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
)
//  funPP是二级函数变量指针
//
```
```python
04
```
```python
.所有数组的推导特点
//
```
```python
int
```
```python
a;
```
```python
//int
```
```python
a[
```
```python
10
```
```python
];
```
```python
//int
```
```python
* a;
```
```python
//int
```
```python
* p1;
```
```python
//int
```
```python
* p1[
```
```python
10
```
```python
];
```
```python
//int
```
```python
**
```
```python
p1;
```
```python
int
```
```python
main02(void)
{
```
```python
//int
```
```python
intArr[
```
```python
6
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
};
```
```python
int
```
```python
(
```
```python
*funPArr
```
```python
[
```
```python
6
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = { getmin, getmax, add,
```
```python
sub
```
```python
, mul ,divv };
```
```python
//intArr和funPArr都属于常量指针:作为数值而言,都是存储与代码区符号表当中
    //
```
```python
int
```
```python
* p = (
```
```python
int
```
```python
[]){
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
}//栈上开辟一个一维数组
    //
```
```python
int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//
```
```python
二级函数变量指针,存储函数指针数组的数组名
    //
```
```python
int
```
```python
(
```
```python
*[
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//
```
```python
函数指针数组类型
```
```python
int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = (
```
```python
int
```
```python
(
```
```python
*[
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
)) { add,
```
```python
sub
```
```python
, mul, div };
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
4
```
```python
; ++i)
    {
```
```python
//printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, funPP[i](
```
```python
100
```
```python
,
```
```python
10
```
```python
));
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
,(
```
```python
*(
```
```python
funPP + i))(
```
```python
100
```
```python
,
```
```python
10
```
```python
));
    }
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main03(void)
{
```
```python
int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
) = malloc(
```
```python
4
```
```python
* sizeof(
```
```python
int
```
```python
(
```
```python
*)
```
```python
(
```
```python
int
```
```python
,
```
```python
int
```
```python
)));
```
```python
//
```
```python
在堆内存开辟一个一级函数指针数组
```
```python
*funPP
```
```python
= add;
```
```python
*(
```
```python
funPP +
```
```python
1
```
```python
) =
```
```python
sub
```
```python
;
```
```python
*(
```
```python
funPP +
```
```python
2
```
```python
) = mul;
```
```python
*(
```
```python
funPP +
```
```python
3
```
```python
) = divv;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
4
```
```python
; ++i)
    {
```
```python
//printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, funPP[i](
```
```python
100
```
```python
,
```
```python
10
```
```python
));
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, (
```
```python
*(
```
```python
funPP + i))(
```
```python
100
```
```python
,
```
```python
10
```
```python
));
    }
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
//
```
```python
05
```
```python
.变量+变量数组+指向变量的变量:
```
```python
//
```
```python
三种形式的推导规律
//
```
```python
int
```
```python
* p;------->
```
```python
int
```
```python
(
```
```python
*funP
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//int
```
```python
* p[
```
```python
10
```
```python
];--->
```
```python
int
```
```python
(
```
```python
*funP
```
```python
[
```
```python
10
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//int
```
```python
**
```
```python
pp;----->
```
```python
int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
)
//
```
```python
06
```
```python
.typedef的强大作用:
```
```python
//
```
```python
某些情况之下的复杂函数指针必须通过typedef进行别名定义!
```
```python
//int
```
```python
a;
```
```python
//typedef
```
```python
int
```
```python
a;
```
```python
//int
```
```python
b[
```
```python
10
```
```python
];
```
```python
//typedef
```
```python
int
```
```python
b[
```
```python
10
```
```python
];
```
```python
//double
```
```python
* d;
```
```python
//typedef
```
```python
double * d;
```
```python
//int
```
```python
(* funP )(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//typedef
```
```python
int
```
```python
(
```
```python
*funP
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//int
```
```python
(
```
```python
*funP
```
```python
[
```
```python
10
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//typedef
```
```python
int
```
```python
(
```
```python
*funP
```
```python
[
```
```python
10
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//typedef
```
```python
int
```
```python
(
```
```python
**
```
```python
funPP)(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//typedef
```
```python
终极规律:
```
```python
//
```
```python
先定义变量名:类型+变量名
//  再使用前置typedef:于是变量名就成为了类型别名
//注:typedef并不是生产出一个新类型,而是为已有类型领取一个简洁的别名
//  编译后期操作类型-->某些情况之下的复杂函数指针不得不使用typedef关键字
//  进行别名定义!
```
```python
int
```
```python
main04(void)
{
```
```python
//a
```
```python
a1;
```
```python
//b
```
```python
b1;
```
```python
//d
```
```python
d1;
```
```python
//p
```
```python
d1 = add;
```
```python
//px
```
```python
px1 = { add,
```
```python
sub
```
```python
, mul, divv };
```
```python
//pp pp1 = (px){ add,
```
```python
sub
```
```python
};
```
```python
//
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\n"
```
```python
, sizeof(px1));
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
//
```
```python
07
```
```python
.函数指针终极形式!
```
```python
//
```
```python
原始:
```
```python
int
```
```python
(
```
```python
**
```
```python
x
```
```python
(
```
```python
int
```
```python
(
```
```python
*z
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
),
```
```python
int
```
```python
,double))(
```
```python
int
```
```python
);
```
```python
//
```
```python
返回值:
```
```python
int
```
```python
(
```
```python
**
```
```python
x
```
```python
(
```
```python
int
```
```python
(
```
```python
*z
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
),
```
```python
int
```
```python
,double)   )(
```
```python
int
```
```python
)
//  形参:
```
```python
int
```
```python
(
```
```python
**
```
```python
x
```
```python
(
```
```python
int
```
```python
(
```
```python
*z
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
),
```
```python
int
```
```python
,
```
```python
int
```
```python
)   )(
```
```python
int
```
```python
)
//  解读:
```
```python
//
```
```python
函数名:
```
```python
x
```
```python
是一个函数的名称,属于函数常量指针
//      返回值:
```
```python
int
```
```python
(
```
```python
**
```
```python
)(
```
```python
int
```
```python
),是一个函数二级函数指针
//      形参:
```
```python
int
```
```python
(
```
```python
*z
```
```python
)(
```
```python
int
```
```python
,
```
```python
int
```
```python
),
```
```python
int
```
```python
, double,有三个形式参数
//           分别是函数指针类型+
```
```python
int
```
```python
类型+double类型
//注:区分数组指针和函数指针
//  数组指针:
```
```python
//
```
```python
int
```
```python
arrArr[a][b]-->
```
```python
int
```
```python
(
```
```python
*p
```
```python
)[a][b];
```
```python
//
```
```python
注:指向N维数组的指针声明规律:
```
```python
//
```
```python
只需要将数组名称替换为(
```
```python
*p
```
```python
)
//08.数组指针和函数指针的区别:
```
```python
//
```
```python
1
```
```python
.都含有(
```
```python
*p
```
```python
)说明特点
//
```
```python
2
```
```python
.各自的后续内容不一样:
```
```python
//
```
```python
数组指针跟的是中括号!
```
```python
//
```
```python
函数指针跟的是小括号!
```
```python
//
```
```python
注:所有指向数组类型的指针定义绝招!
```
```python
//
```
```python
先写出数组的声明格式,再将数组名称替换为(
```
```python
*pArr
```
```python
);
```
```python
//
```
```python
注:所有指向函数类型的指针定义绝招!
```
```python
//
```
```python
先写出函数的声明格式,再将函数名称提花为(
```
```python
*Fun
```
```python
);
```
```python
int
```
```python
main05(void)
{
```
```python
int
```
```python
(
```
```python
*funPArr
```
```python
[
```
```python
10
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
int
```
```python
(
```
```python
*(
```
```python
*pFunPArr
```
```python
)[
```
```python
10
```
```python
])(
```
```python
int
```
```python
,
```
```python
int
```
```python
);
```
```python
//
```
```python
指向函数数组的指针
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
```
程序片段(07):dialog.cpp
内容概要:**PingWindows**
```python
#include "dialog.h"
```
```python
#include <QApplication>
```
```python
void
```
```python
run()
{
```
```python
//01.在栈内存当中创建对话框容易自动回收掉!
```
```python
//Dialog w;
```
```python
//w.show();
```
```python
//02.在堆内存当中创建的对话框需要手动回收!
```
```python
//Dialog * p = new Dialog;
```
```python
//(*p).show();
```
```python
//p->show();
```
```python
//03.同样是在栈内存当中创建的对话框
```
```python
//Dialog ws[10];
```
```python
//for (int i = 0; i < 10; ++i)
```
```python
//{
```
```python
//    ws[i].resize(100, 100);
```
```python
//    ws[i].move(100*i, 100*i);
```
```python
//    ws[i].show();
```
```python
}
```
```python
//04.逐个在堆内存当中创建对话框,不会被自动回收掉!
```
```python
//Dialog * p[10];
```
```python
//for (int i = 0; i < 10; ++i)
```
```python
//{
```
```python
//   p[i] = new Dialog;
```
```python
//   p[i]->resize(100, 100);
```
```python
//   p[i]->move(100*i, 100*i);
```
```python
//   p[i]->show();
```
```python
//}
```
```python
//5.创建50个位于堆内存当中的对话框
```
```python
//Dialog *px[5][10];
```
```python
//for(int i=0;i<5;i++)
```
```python
//{
```
```python
//    for(int j=0;j<10;j++)
```
```python
//    {
```
```python
//        px[i][j]=new Dailog;
```
```python
//        px[i][j]->resize(100,100);
```
```python
//        px[i][j]->move(100*i,100*j);
```
```python
//        px[i][j]->show();
```
```python
//    }
```
```python
//}
```
```python
}
```
```python
int
```
```python
main(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
*argv[])
{
    QApplication a(argc,argv);
```
```python
//run();
```
```python
Dialog w;
    w.show();
```
```python
return
```
```python
a.exec();
}
```
程序片段(08):01.多线程.c
内容概要:**函数指针数组与多线程**
```python
///
```
```python
01.多线程.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
void
```
```python
run01(
```
```python
void
```
```python
* p)
{
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"1"
```
```python
,
```
```python
"1"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
void
```
```python
run02(
```
```python
void
```
```python
* p)
{
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"2"
```
```python
,
```
```python
"2"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
void
```
```python
run03(
```
```python
void
```
```python
* p)
{
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"3"
```
```python
,
```
```python
"3"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
//01.多线程内容:
```
```python
//  1.关于模式的不同:
```
```python
//      单线程模式:只能实现单线程,不能实现多线程
```
```python
//      多线程模式:技能实现单线程,又能实现多线程
```
```python
//  2.关于多线程的等待特点:
```
```python
//      无限等待:-->如同单线程
```
```python
//      有限等待:-->定时等待!
```
```python
//  3.多线程情况下的主辅线程特点:
```
```python
//      主线程进行全局控制
```
```python
//      辅助线程进行独立控制
```
```python
//  4.线程句柄数组的使用:管理线程
```
```python
//      可以实现同时等待多条线程
```
```python
//02.关于是否需要对栈内存数组进行强制转换的问题:
```
```python
//  指向数组的指针,无需进行类型转换
```
```python
//  指向指针的指针,需要进行类型转换
```
```python
//03.关于多线程的调度问题:
```
```python
//  需要使用到线程句柄数组进行管理
```
```python
//  WaitForMutipleObjects(arg1,arg2,arg3,arg4);
```
```python
//      arg1:线程句柄个数
```
```python
//      arg2:线程句柄数组名
```
```python
//      arg3:等待单个还是多个?-->竞赛最快的那个!-->可以等待单个!
```
```python
//      arg4:等待时间
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//run01(NULL);
```
```python
//run02(NULL);
```
```python
//run03(NULL);//-->单线程模式
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
        HANDLE hd = _beginthread(run01,
```
```python
0
```
```python
, NULL);
```
```python
//WaitForSingleObject(hd, INFINITE);//无限同步等待
```
```python
WaitForSingleObject(hd,
```
```python
3000
```
```python
);
```
```python
//有限同步等待!
```
```python
}
```
```python
//HANDLE hd[3] = {0};//声明线程句柄数组
```
```python
//HANDLE * hd = malloc(12);
```
```python
HANDLE * hd = malloc(
```
```python
3
```
```python
*
```
```python
sizeof
```
```python
(HANDLE));
```
```python
//void(*funPArr[3])(void *) = { run01, run02, run03 };//函数指针数组
```
```python
//采用二级函数变量指针进行指向一个栈内存的函数指针数组
```
```python
void
```
```python
(**funPP)(
```
```python
void
```
```python
*) = (
```
```python
void
```
```python
(*[])(
```
```python
void
```
```python
*)) { run01, run02, run03 };
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
        hd[i] = _beginthread(funPP[i],
```
```python
0
```
```python
, NULL);
    }
```
```python
//TRUE等待所有线程,false表示等待单个
```
```python
WaitForMultipleObjects(
```
```python
3
```
```python
, hd, FALSE, INFINITE);
```
```python
//无限等待多个线程结束
```
```python
//主线程,控制全局
```
```python
system(
```
```python
"pause"
```
```python
);
```
```python
//卡顿主线程-->让主线程不要提前执行完毕
```
```python
}
```
```python
///
```
```python
/线程既可以同步,也可以异步
```
```python
///
```
```python
/WaitForSingleObject(hd,300);//3000等待3秒
```
```python
///
```
```python
/主线程,控制全局
```
```python
///
```
```python
/WaitForMultipleObjects(3,hd,TRUE,INFINITE);
```
程序片段(09):01.Alloca.c
内容概要:**栈内存分配**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <malloc.h>
```
```python
//01.关于堆内存开辟四大函数和栈内存开辟单函数:
```
```python
//  堆内存:malloc-->calloc-->realloc-->_recalloc
```
```python
//  栈内存:alloca-->位于malloc.h头文件
```
```python
//注:栈内存没有对应的内存回收函数,堆内存才有对应
```
```python
//  的内存回收函数!!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
* p = alloca(
```
```python
10
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//超过栈内存尺寸上限
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        p[i] = i;
    }
```
```python
//free(p);//栈内存没有回收的free();函数
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
show()
{
```
```python
int
```
```python
* p = alloca(
```
```python
10
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//超过栈内存大小
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        p[i] = i;
    }
```
```python
//free(p);//栈内存没有匹配的free函数-->自动回收所属内存
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    show();
```
```python
printf
```
```python
(
```
```python
"\n\n"
```
```python
);
```
```python
//促进内存回收动作的发生
```
```python
show();
```
```python
//检验栈内存数组的自动回收特点
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
//注意编译器的优化情况
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(10):main.c
内容概要:**GccArray**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.GCC支持栈内存的动态数组的实现原理就是
```
```python
//  位于malloc.h头文件当中的alloca函数!
```
```python
//02.VC编译器不支持位于栈内存的动态数组!
```
```python
int
```
```python
main01()
{
```
```python
printf
```
```python
(
```
```python
"Hello world! \n"
```
```python
);
```
```python
//GCC当中的实现原理就是C语言当中的Alloc,但是这种规则不是C语言的标准机试
```
```python
int
```
```python
num=
```
```python
20
```
```python
;
```
```python
int
```
```python
a[num];
```
```python
// a=a;
```
```python
return
```
```python
0
```
```python
;
}
```
程序片段(11):01.Main.c
内容概要:**获取参数**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.定义主函数的格式:
```
```python
//  无形参形式:
```
```python
//      void main(void);
```
```python
//      int main(void);
```
```python
//  有形参形式:
```
```python
//      void main(int argc, char * args[]);
```
```python
//      int main(int argc, char * args[]);
```
```python
//02.标准主函数声明格式详解:
```
```python
//  int main(int argc, char * args[], char * envp[]);
```
```python
//      返回值:int-->体现跨平台特性
```
```python
//      参数1:argc-->说明了有效参数个数
```
```python
//      参数2:args-->说明了有效参数列表
```
```python
//          该字符指针数组当中的第一个字符指针所指向的字符串是当前所运行程序的程序名称(代码区常量池"字符串")
```
```python
//          该字符指针数组当中的第二个字符指针开始之后的指针表示的是当前程序运行时所指定的附加参数!
```
```python
//      参数3:表示环境变量列表!
```
```python
//          一个字符指针描述一个环境变量!
```
```python
int
```
```python
main01(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[])
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < argc; ++i)
    {
```
```python
puts
```
```python
(args[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp[])
{
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(envp));
```
```python
//凡是数组作为函数形参,该数组都将会被退化为指针(统统只会占用4个内存字节!)
```
```python
//for (int i = 0; i < 100; ++i)
```
```python
//{
```
```python
//  puts(envp[i]);
```
```python
//}
```
```python
char
```
```python
**pp = envp;
```
```python
while
```
```python
(NULL != *pp)
    {
```
```python
puts
```
```python
(*pp);
        ++pp;
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(12):01.返回.c
内容概要:**返回指针**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
#include <time.h>
```
```python
//01.对字符数组除了定义并初始化格式之外的字符串赋值方式!
```
```python
//  必须借助strcpy();函数进行对字符数组的赋值操作!
```
```python
//注:所以数组的数组名都绝对是一个常量指针!
```
```python
//02.被掉函数在进行返回指针的时候绝对不能够返回指向栈内存
```
```python
//  的指针!切忌这一点儿
```
```python
char
```
```python
* get()
{
```
```python
char
```
```python
str[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//栈内存-->字符数组
```
```python
strcpy
```
```python
(str,
```
```python
"Hello ZhouRuiFu"
```
```python
);
```
```python
//为字符数组赋予字符串
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
, str);
```
```python
return
```
```python
str;
}
```
```python
//03.如何快速定位某个数组的两种形式:
```
```python
//  1.数组的两种形式:分别用指针形式进行表述
```
```python
//      普通数组形式-->指向数组的指针
```
```python
//      指针数组形式-->指向指针的指针
```
```python
//  2.任何数组都可以用两种形式的指针进行指向!
```
```python
//      规律总结:针对任何一个维度的数组!
```
```python
//      普通数组形式-->指向数组的指针:将数组名直接替换为(*arrP)
```
```python
//      指针数组形式-->指向指针的指针:将数组名以及最高维度直接替换为(*pArr)
```
```python
int
```
```python
* rungetmin()
{
```
```python
int
```
```python
* p =
```
```python
calloc
```
```python
(
```
```python
10
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//不会进行自动回收!
```
```python
time_t te;
```
```python
unsigned
```
```python
int
```
```python
seed = (
```
```python
unsigned
```
```python
int
```
```python
)time(&te);
    srand(seed);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, p[i] = rand() %
```
```python
100
```
```python
+
```
```python
1
```
```python
);
    }
```
```python
int
```
```python
minIndex =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
if
```
```python
(p[i] < p[minIndex])
            minIndex = i;
    }
```
```python
//p + minIndex = &p[minIndex];
```
```python
//p[minIndex] = *(p + minIndex)
```
```python
return
```
```python
p + minIndex;
}
```
```python
//04.printf();函数针对于字符串的解析特点:
```
```python
//  字符数组:按照字符数组的长度+直接解析到'\0'
```
```python
//      如果没有解析到'\0'就会出现烫烫...
```
```python
//  字符指针:解析字符指针所指向的字符串本身+直接解析到'\0'
```
```python
//      分字符指针所指向的内存空间
```
```python
//          如果是栈内存和堆内存-->有可能字字符串没有字符串结尾标识符'\0'
```
```python
//          如果是代码区常量池-->就一定会有字符串结尾标识符'\0'
```
```python
int
```
```python
main01(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp[])
{
```
```python
char
```
```python
str[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
strcpy
```
```python
(str,
```
```python
"Hello ZhouRuiFu"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
, str);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//05.迷途指针
```
```python
int
```
```python
main02(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* argv[],
```
```python
char
```
```python
* envp[])
{
```
```python
char
```
```python
* p = get();
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
, p);
```
```python
//函数在返回指针的时候,不可以返回指向栈内存空间的指针
```
```python
//因为有可能出现迷途指针
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main03(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* argv[],
```
```python
char
```
```python
* envp[])
{
```
```python
printf
```
```python
(
```
```python
"最小的是%d \n"
```
```python
, *rungetmin());
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(13):01.函数返回.c
内容概要:**函数返回值**
```python
//#include <stdio.h>
```
```python
//#include <stdlib.h>
```
```python
//
```
```python
///
```
```python
/01.函数返回值,存在副本机制!
```
```python
///
```
```python
/    高端CPU:CPU-Cache
```
```python
///
```
```python
/    底端CPU:MEM-Cache
```
```python
///
```
```python
/注:副本数据和副本本身!
```
```python
///
```
```python
/    副本数据不可以获取地址!
```
```python
///
```
```python
/    副本本身没有操作权限!
```
```python
///
```
```python
/    原本只是在已经被回收的栈内存!
```
```python
//02.原本本身-->原本数据-->副本本身-->副本数据!
```
```python
//int get()
```
```python
//{
```
```python
//  int a = 5;
```
```python
//  return a;
```
```python
//}
```
```python
//
```
```python
//int main(int argc, char * args[], char * envp[])
```
```python
//{
```
```python
//  //&get();//get();该操作所对应的返回值位于寄存器高速缓存(高级CPU),(低级CPU)会将内存某段儿空间当中存储
```
```python
//  //  但是同样不允许进行访问操作!-->针对对于数值本身而言就是副本数据!
```
```python
//  printf("%d \n", get());//返回的是副本数据
```
```python
//
```
```python
//  system("pause");
```
```python
//}
```
程序片段(14):Mem.c
内容概要:**左值右值与内存实体**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.左右值:
```
```python
//  左值:
```
```python
//      1.能够出现在赋值号左边的值
```
```python
//      2.存在有效的内存实体
```
```python
//      3.变量
```
```python
//  右值:
```
```python
//      1.只能够出现在赋值号右边的值
```
```python
//      2.不存在有效的内存实体
```
```python
//      3.常量+表达式(寄存器操作)
```
```python
int
```
```python
main01(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp)
{
```
```python
int
```
```python
a =
```
```python
1
```
```python
;
    a = a +
```
```python
10
```
```python
;
    a = a +
```
```python
8
```
```python
;
```
```python
//a = 3;
```
```python
//&5;
```
```python
//&(a + 1);
```
```python
a = a;
```
```python
//左值都存在内存实体
```
```python
//右值一般是出于寄存器当中,左值也可以当做右值进行使用
```
```python
//a + 1 = 3;
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp)
{
```
```python
int
```
```python
a =
```
```python
10
```
```python
;
```
```python
int
```
```python
b =
```
```python
20
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, &a, &b);
```
```python
int
```
```python
* p;
```
```python
//指针变量
```
```python
p = &a;
    p = &b;
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.取地址符(&)取值之后的地址数值具备类型特点!
```
```python
//  指针常量(数值不可变)+常量指针(指向不可变)
```
```python
int
```
```python
main(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp)
{
```
```python
//int num;//num是左值
```
```python
//const int num;//num是左值-->存在内存实体-->常变量
```
```python
const
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
//&num-->int const * num:
```
```python
*(
```
```python
int
```
```python
*)(&num) =
```
```python
4
```
```python
;
```
```python
//取地址之后的所得到的地址数值存在类型特点
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main04(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp[])
{
```
```python
//注意指针类型的统一!
```
```python
int
```
```python
* p = (
```
```python
int
```
```python
*)
```
```python
3
```
```python
;
```
```python
//地址意义!
```
```python
*p =
```
```python
3
```
```python
;
}
```
```python
//03.区分两个概念:(空类型的指针+空指针)
```
```python
//  空类型的指针:
```
```python
//       实质:空类型的指针变量
```
```python
//  空指针:
```
```python
//      用于标识指针变量没有任何指向!
```
```python
int
```
```python
main05(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* argv[],
```
```python
char
```
```python
* envp[])
{
```
```python
int
```
```python
* p = NULL;
```
```python
//标识P这个指针变量没有任何指向
```
```python
int
```
```python
num =
```
```python
20
```
```python
;
```
```python
void
```
```python
* pv = &num;
```
```python
//任何类型的地址(只是用于存储地址,但是不知道如何进行解析!)
```
```python
*(
```
```python
int
```
```python
*)pv;
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(15):01内存.c
内容概要:**Malloc.Calloc.Realloc**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <malloc.h>
```
```python
//01.内存五大开辟函数总结:
```
```python
//  堆内存:
```
```python
//      malloc:不会初始化内存+整体内存尺寸
```
```python
//      calloc:会初始化内存+元素个数+单个内存尺寸
```
```python
//      realloc:不会初始化内存+原始指针+拓展后的总体大小
```
```python
//      _recalloc:会初始化内存+原始指针+拓展后的元素个数+拓展后的单个内存尺寸
```
```python
//  栈内存:
```
```python
//      alloca:
```
```python
//          位于malloc.h头文件
```
```python
//          实际占用的内存总尺寸!
```
```python
int
```
```python
main01(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp)
{
```
```python
int
```
```python
* p =
```
```python
calloc
```
```python
(
```
```python
25
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//在堆内存开辟一个普通类型的一维数组,会自动初始化为0
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, p);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
25
```
```python
; ++i)
    {
        p[i] = i;
    }
    p = _recalloc(p,
```
```python
50
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//内存推展+内存清零操作
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
25
```
```python
; i <
```
```python
50
```
```python
; ++i)
    {
        p[i] = i;
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp)
{
```
```python
int
```
```python
* p =
```
```python
malloc
```
```python
(
```
```python
10
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//只能使用这片儿内存
```
```python
int
```
```python
* p_p =
```
```python
malloc
```
```python
(
```
```python
100
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, p[i] = i);
    }
```
```python
printf
```
```python
(
```
```python
"p = %p \n"
```
```python
, p);
```
```python
int
```
```python
* px = realloc(p,
```
```python
200
```
```python
);
```
```python
//拓展内存,内存不会清零
```
```python
//返回值为内存地址,拓展成功,后续地址拓展,拓展不成功,将会重新开辟
```
```python
//原始的内存空间将会自动回收
```
```python
printf
```
```python
(
```
```python
"px= %p \n"
```
```python
, px);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
50
```
```python
; ++i)
    {
        px[i] = i;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, px[i]);
    }
    p[
```
```python
2398787
```
```python
] =
```
```python
10
```
```python
;
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main03(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp)
{
```
```python
//int * p = malloc(100);//malloc不会初始化内存,是整体内存尺寸!
```
```python
int
```
```python
* p =
```
```python
calloc
```
```python
(
```
```python
25
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//calloc会初始化参内存,个数+尺寸
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, p);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
25
```
```python
; ++i)
    {
        p[i] = i;
    }
```
```python
int
```
```python
* p = alloca(
```
```python
123
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(16):01.c
内容概要:**Test**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <malloc.h>
```
```python
//01.在栈内存开辟4个字节的内存空间:
```
```python
//  注:指针可以指向四区的任何位置,只是指针的类型不一样而已!
```
```python
int
```
```python
* run()
{
```
```python
int
```
```python
* p = alloca(
```
```python
4
```
```python
);
    *p =
```
```python
4
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *p);
```
```python
return
```
```python
p;
}
```
```python
int
```
```python
main01(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp[])
{
```
```python
int
```
```python
* px = run();
```
```python
//返回指向栈内存的指针是错误的做法!
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *px);
```
```python
//栈内存在函数出栈之后,立即进行回收!
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.关于多维数组获取其所存储数据的规律:
```
```python
//  一维数组:一颗星
```
```python
//  二维数组:两颗星
```
```python
//  三维数组:三颗星
```
```python
//  N维数组:N颗星...
```
```python
//注:获取的对象既可以是常量指针,也可以是变量指针!
```
```python
//  无论常量指针还是变量指针都会被当做数组名对待!
```
```python
int
```
```python
main02(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp[])
{
```
```python
int
```
```python
arrArr[
```
```python
3
```
```python
][
```
```python
4
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
,
```
```python
11
```
```python
,
```
```python
12
```
```python
};
```
```python
//栈内存-->二维数组-->静态初始化!-->代码块儿直接初始化!
```
```python
//printf("%d \n", arrArr[1][1]);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *(arrArr +
```
```python
1
```
```python
)[
```
```python
1
```
```python
]);
```
```python
//[]的优先级既大于星号("*")又大于点号(".")
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *(*(arrArr +
```
```python
1
```
```python
) +
```
```python
1
```
```python
));
}
```
程序片段(17):01.Search.c
内容概要:**内存模型大数据**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
#define srcPath "E:\\Resource\\TestData\\BigDB\\1EQQBig.txt"
```
```python
//01.内存架构:文件缓冲于内存当中,将内存用作数据临时缓冲!
```
```python
char
```
```python
** g_pp;
```
```python
//全局二级指针变量
```
```python
int
```
```python
imax =
```
```python
84357147
```
```python
;
```
```python
//文件总行数
```
```python
int
```
```python
jmax =
```
```python
20027
```
```python
;
```
```python
//文件最宽列数
```
```python
int
```
```python
getimax()
{
```
```python
int
```
```python
hang = -
```
```python
1
```
```python
;
    FILE * pf = fopen(srcPath,
```
```python
"r"
```
```python
);
```
```python
if
```
```python
(NULL == pf)
    {
```
```python
printf
```
```python
(
```
```python
"文件读取失败! \n"
```
```python
);
```
```python
return
```
```python
-
```
```python
1
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"开始读取! \n"
```
```python
);
        hang =
```
```python
0
```
```python
;
```
```python
while
```
```python
(!feof(pf))
```
```python
//到了文件末尾返回1,没有到文件末尾返回0
```
```python
{
```
```python
char
```
```python
readStr[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
            fgets(readStr,
```
```python
1024
```
```python
-
```
```python
1
```
```python
, pf);
```
```python
//一次读取一样进缓冲区
```
```python
++hang;
```
```python
//自增
```
```python
}
        fclose(pf);
    }
```
```python
return
```
```python
hang;
}
```
```python
int
```
```python
getjmax()
{
```
```python
int
```
```python
width = -
```
```python
1
```
```python
;
    FILE * pf = fopen(srcPath,
```
```python
"r"
```
```python
);
```
```python
if
```
```python
(NULL == pf)
    {
```
```python
printf
```
```python
(
```
```python
"文件读取失败! \n"
```
```python
);
```
```python
return
```
```python
-
```
```python
1
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"开始读取! \n"
```
```python
);
```
```python
while
```
```python
(!feof(pf))
        {
```
```python
char
```
```python
readStr[
```
```python
30000
```
```python
] = {
```
```python
0
```
```python
};
            fgets(readStr,
```
```python
30000
```
```python
-
```
```python
1
```
```python
, pf);
```
```python
//每次读取一行的数据到手动字符数组缓冲区当中
```
```python
int
```
```python
strLength =
```
```python
strlen
```
```python
(readStr);
```
```python
if
```
```python
(strLength >
```
```python
50
```
```python
)
```
```python
//字符串筛选
```
```python
{
```
```python
//pus(readstr);
```
```python
if
```
```python
(strLength > width)
                {
                    width = strLength;
                }
            }
        }
        fclose(pf);
```
```python
printf
```
```python
(
```
```python
"结束读取! \n"
```
```python
);
    }
```
```python
return
```
```python
width;
}
```
```python
//02.字符串函数的处理特点:
```
```python
//  不仅可以处理字符数组还可以处理字符指针!
```
```python
//  兼容C语言当中的两种字符串表示方式!
```
```python
//加载待读取的文件数据进内存,构建内存架构模型
```
```python
void
```
```python
loadFromFile()
{
```
```python
//声明并初始化指针数组
```
```python
g_pp = (
```
```python
char
```
```python
**)
```
```python
malloc
```
```python
(imax *
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
*));
```
```python
//分配指针数组
```
```python
memset
```
```python
(g_pp,
```
```python
'\0'
```
```python
, imax *
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
*));
```
```python
//清空指针数组
```
```python
FILE * pf = fopen(srcPath,
```
```python
"r"
```
```python
);
```
```python
if
```
```python
(NULL == pf)
    {
```
```python
printf
```
```python
(
```
```python
"文件读取失败! \n"
```
```python
);
```
```python
return
```
```python
-
```
```python
1
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < imax; ++i)
        {
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
            fgets(str,
```
```python
1024
```
```python
-
```
```python
1
```
```python
, pf);
```
```python
//(按行+个数)进行字符串读取
```
```python
int
```
```python
strLength =
```
```python
strlen
```
```python
(str);
```
```python
if
```
```python
(strLength <
```
```python
50
```
```python
)
            {
                g_pp[i] =
```
```python
malloc
```
```python
((strLength +
```
```python
1
```
```python
)*
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
));
```
```python
strcpy
```
```python
(g_pp[i], str);
            }
        }
        fclose(pf);
    }
}
```
```python
//03.在内存架构模型当中执行检索操作!
```
```python
void
```
```python
search(
```
```python
char
```
```python
* str)
{
```
```python
if
```
```python
(NULL == g_pp)
```
```python
return
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < imax; ++i)
    {
```
```python
if
```
```python
(NULL != g_pp[i])
        {
```
```python
char
```
```python
* p =
```
```python
strstr
```
```python
(g_pp[i], str);
```
```python
if
```
```python
(NULL != p)
            {
```
```python
puts
```
```python
(g_pp[i]);
            }
        }
    }
}
```
```python
int
```
```python
main01(
```
```python
int
```
```python
argc,
```
```python
char
```
```python
* args[],
```
```python
char
```
```python
* envp[])
{
```
```python
//printf("imax = %d \n", getimax());
```
```python
//printf("jmax = %d \n", getjmax());
```
```python
loadFromFile();
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
char
```
```python
str[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
scanf
```
```python
(
```
```python
"%s"
```
```python
, str);
        search(str);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(18):01.KaiFang.c
内容概要:**开放数据检索**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
#include <string.h>
```
```python
#define srcPath "E:\\Resource\\TestData\\BigDB\\KaiFang.txt"
```
```python
char
```
```python
** g_pp;
```
```python
int
```
```python
imax =
```
```python
20151574
```
```python
;
```
```python
int
```
```python
getimax()
{
    FILE * pf = fopen(srcPath,
```
```python
"r"
```
```python
);
```
```python
if
```
```python
(NULL == pf)
    {
```
```python
printf
```
```python
(
```
```python
"读取文件失败! \n"
```
```python
);
```
```python
return
```
```python
-
```
```python
1
```
```python
;
    }
```
```python
printf
```
```python
(
```
```python
"读取文件成功! \n"
```
```python
);
```
```python
int
```
```python
hang =
```
```python
0
```
```python
;
```
```python
while
```
```python
(!feof(pf))
    {
```
```python
char
```
```python
readStr[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
        fgets(readStr,
```
```python
1023
```
```python
, pf);
        ++hang;
    }
    fclose(pf);
```
```python
return
```
```python
hang;
}
```
```python
void
```
```python
loadfromfile()
{
    g_pp = (
```
```python
char
```
```python
**)
```
```python
malloc
```
```python
(imax *
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
*));
```
```python
memset
```
```python
(g_pp,
```
```python
0
```
```python
, imax *
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
*));
    FILE * pf = fopen(srcPath,
```
```python
"r"
```
```python
);
```
```python
if
```
```python
(NULL == pf)
    {
```
```python
printf
```
```python
(
```
```python
"打开文件失败! \n"
```
```python
);
```
```python
return
```
```python
-
```
```python
1
```
```python
;
    }
```
```python
printf
```
```python
(
```
```python
"打开文件成功! \n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < imax; ++i)
    {
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
        fgets(str,
```
```python
1023
```
```python
, pf);
```
```python
int
```
```python
strLength =
```
```python
strlen
```
```python
(str);
        g_pp[i] = (
```
```python
char
```
```python
*)
```
```python
malloc
```
```python
((strLength +
```
```python
1
```
```python
) *
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
));
```
```python
if
```
```python
(NULL != g_pp[i])
```
```python
strcpy
```
```python
(g_pp[i], str);
    }
    fclose(pf);
}
```
```python
void
```
```python
searchStr(
```
```python
char
```
```python
* str)
{
```
```python
char
```
```python
strPath[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
sprintf
```
```python
(strPath,
```
```python
"E:\\Resource\\TestData\\Test\\%s.txt"
```
```python
, str);
    FILE * pf = fopen(strPath,
```
```python
"w"
```
```python
);
```
```python
if
```
```python
(NULL == g_pp)
```
```python
return
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < imax; ++i)
    {
```
```python
if
```
```python
(NULL == g_pp[i])
```
```python
continue
```
```python
;
```
```python
char
```
```python
* p =
```
```python
strstr
```
```python
(g_pp[i], str);
```
```python
if
```
```python
(p == NULL)
```
```python
continue
```
```python
;
```
```python
puts
```
```python
(g_pp[i]);
```
```python
fputs
```
```python
(g_pp[i], pf);
    }
    fclose(pf);
    system(strPath);
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//printf("imax = %d \n", getimax());
```
```python
loadfromfile();
```
```python
printf
```
```python
(
```
```python
"内存数据库架构完成! \n"
```
```python
);
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
char
```
```python
str[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
scanf
```
```python
(
```
```python
"%s"
```
```python
, str);
        searchStr(str);
    }
    system(
```
```python
"pause"
```
```python
);
}
```

