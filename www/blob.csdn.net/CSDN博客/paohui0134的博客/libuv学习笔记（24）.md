
# libuv学习笔记（24） - paohui0134的博客 - CSDN博客


2016年07月02日 16:49:17[paohui0134](https://me.csdn.net/paohui0134)阅读数：3569标签：[libuv																](https://so.csdn.net/so/search/s.do?q=libuv&t=blog)[线程同步																](https://so.csdn.net/so/search/s.do?q=线程同步&t=blog)[
							](https://so.csdn.net/so/search/s.do?q=libuv&t=blog)个人分类：[libuv学习笔记																](https://blog.csdn.net/paohui0134/article/category/6266738)



# libuv学习笔记（24）
## 线程相关数据结构与函数（2）
### 数据结构
```python
typedef
```
```python
union
```
```python
{
```
```python
//读写锁
```
```python
struct
```
```python
{
```
```python
unsigned
```
```python
int
```
```python
num_readers_;
    CRITICAL_SECTION num_readers_lock_;
    HANDLE write_semaphore_;
  } state_;
```
```python
/* TODO: remove me in v2.x. */
```
```python
struct
```
```python
{
    SRWLOCK unused_;
  } unused1_;
```
```python
/* TODO: remove me in v2.x. */
```
```python
struct
```
```python
{
    uv_mutex_t unused1_;
    uv_mutex_t unused2_;
  } unused2_;
} uv_rwlock_t;
```
```python
typedef
```
```python
HANDLE uv_sem_t;
```
```python
//信号量
```
```python
typedef
```
```python
union
```
```python
{
```
```python
//线程池同步管理
```
```python
CONDITION_VARIABLE cond_var;
```
```python
//调用系统API实现
```
```python
struct
```
```python
{
```
```python
//libuv自己实现
```
```python
unsigned
```
```python
int
```
```python
waiters_count;
    CRITICAL_SECTION waiters_count_lock;
    HANDLE signal_event;
    HANDLE broadcast_event;
  } fallback;
} uv_cond_t;
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
unsigned
```
```python
int
```
```python
n;
```
```python
unsigned
```
```python
int
```
```python
count;
  uv_mutex_t mutex;
  uv_sem_t turnstile1;
  uv_sem_t turnstile2;
} uv_barrier_t;
```
### 读写锁相关函数
#### 初始化
```python
int uv_rwlock_init(uv_rwlock_t
```
```python
*
```
```python
rwlock) {
```
```python
//创建信号量，最大资源数和可用资源数都为1
```
```python
HANDLE
```
```python
handle
```
```python
=
```
```python
CreateSemaphoreW(
```
```python
NULL
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
NULL
```
```python
);
```
```python
if
```
```python
(
```
```python
handle
```
```python
==
```
```python
NULL
```
```python
)
```
```python
return
```
```python
uv_translate_sys_error(GetLastError());
  rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
write_semaphore_
```
```python
=
```
```python
handle
```
```python
;
```
```python
//初始化临界区
```
```python
InitializeCriticalSection(
```
```python
&
```
```python
rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
num_readers_lock_);
```
```python
//初始化读请求的数量
```
```python
rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
num_readers_
```
```python
=
```
```python
0
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
#### 释放读写锁
```python
void
```
```python
uv_rwlock_destroy(uv_rwlock_t* rwlock)
```
```python
{
```
```python
DeleteCriticalSection(&rwlock->state_.num_readers_lock_)
```
```python
;
```
```python
CloseHandle(rwlock->state_.write_semaphore_)
```
```python
;
}
```
#### 读锁定
```python
void
```
```python
uv_rwlock_rdlock(uv_rwlock_t* rwlock) {
```
```python
//进入临界区
```
```python
EnterCriticalSection(&rwlock->state_.num_readers_lock_);
```
```python
//递增读请求数量
```
```python
if
```
```python
(++rwlock->state_.num_readers_ ==
```
```python
1
```
```python
) {
```
```python
//如果为1，说明没有其他的地方读锁定了，等待资源可用
```
```python
DWORD r = WaitForSingleObject(rwlock->state_.write_semaphore_, INFINITE);
```
```python
if
```
```python
(r != WAIT_OBJECT_0)
      uv_fatal_error(GetLastError(),
```
```python
"WaitForSingleObject"
```
```python
);
  }
```
```python
//离开临界区
```
```python
LeaveCriticalSection(&rwlock->state_.num_readers_lock_);
}
```
#### 尝试读锁定
```python
int
```
```python
uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {
```
```python
int
```
```python
err;
```
```python
//尝试进入临界区
```
```python
if
```
```python
(!TryEnterCriticalSection(&rwlock->state_.num_readers_lock_))
```
```python
return
```
```python
UV_EBUSY;
  err =
```
```python
0
```
```python
;
```
```python
if
```
```python
(rwlock->state_.num_readers_ ==
```
```python
0
```
```python
) {
```
```python
//获取资源
```
```python
DWORD r = WaitForSingleObject(rwlock->state_.write_semaphore_,
```
```python
0
```
```python
);
```
```python
if
```
```python
(r == WAIT_OBJECT_0)
      rwlock->state_.num_readers_++;
```
```python
else
```
```python
if
```
```python
(r == WAIT_TIMEOUT)
      err = UV_EBUSY;
```
```python
else
```
```python
if
```
```python
(r == WAIT_FAILED)
      uv_fatal_error(GetLastError(),
```
```python
"WaitForSingleObject"
```
```python
);
  }
```
```python
else
```
```python
{
    rwlock->state_.num_readers_++;
  }
  LeaveCriticalSection(&rwlock->state_.num_readers_lock_);
```
```python
return
```
```python
err;
}
```
#### 释放读锁定
```python
void
```
```python
uv_rwlock_rdunlock(uv_rwlock_t
```
```python
*
```
```python
rwlock) {
```
```python
//进入临界区
```
```python
EnterCriticalSection(
```
```python
&
```
```python
rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
num_readers_lock_);
```
```python
if
```
```python
(
```
```python
--
```
```python
rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
num_readers_
```
```python
==
```
```python
0
```
```python
) {
```
```python
//没有都请求了，释放资源
```
```python
if
```
```python
(
```
```python
!
```
```python
ReleaseSemaphore(rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
write_semaphore_,
```
```python
1
```
```python
,
```
```python
NULL
```
```python
))
      uv_fatal_error(GetLastError(),
```
```python
"ReleaseSemaphore"
```
```python
);
  }
```
```python
//离开临界区
```
```python
LeaveCriticalSection(
```
```python
&
```
```python
rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
num_readers_lock_);
}
```
#### 写锁定
```python
void
```
```python
uv_rwlock_wrlock(uv_rwlock_t
```
```python
*
```
```python
rwlock) {
```
```python
//等待资源可用
```
```python
DWORD r
```
```python
=
```
```python
WaitForSingleObject(rwlock
```
```python
->
```
```python
state_
```
```python
.
```
```python
write_semaphore_, INFINITE);
```
```python
if
```
```python
(r
```
```python
!=
```
```python
WAIT_OBJECT_0)
    uv_fatal_error(GetLastError(),
```
```python
"WaitForSingleObject"
```
```python
);
}
```
#### 尝试写锁定
```python
int
```
```python
uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {
  DWORD r = WaitForSingleObject(rwlock->
```
```python
state
```
```python
_
```
```python
.write_semaphore
```
```python
_
```
```python
,
```
```python
0
```
```python
);
```
```python
if
```
```python
(r == WAIT_OBJECT_
```
```python
0
```
```python
)
```
```python
return
```
```python
0
```
```python
;
```
```python
else
```
```python
if
```
```python
(r == WAIT_TIMEOUT)
```
```python
return
```
```python
UV_EBUSY;
```
```python
else
```
```python
uv_fatal_error(GetLastError(),
```
```python
"WaitForSingleObject"
```
```python
);
}
```
#### 解除写锁定
```python
void
```
```python
uv_rwlock_wrunlock(uv_rwlock_t* rwlock)
```
```python
{
```
```python
//释放信号量
```
```python
if (!
```
```python
ReleaseSemaphore(rwlock->state_.write_semaphore_,
```
```python
1
```
```python
, NULL)
```
```python
)
```
```python
uv_fatal_error(
```
```python
GetLastError()
```
```python
,
```
```python
"ReleaseSemaphore"
```
```python
)
```
```python
;
}
```
### 信号量相关API
#### 初始化
```python
int
```
```python
uv_sem_init(uv_sem_t* sem,
```
```python
unsigned
```
```python
int
```
```python
value) {
  *sem = CreateSemaphore(
```
```python
NULL
```
```python
, value, INT_MAX,
```
```python
NULL
```
```python
);
```
```python
//创建信号量
```
```python
if
```
```python
(*sem ==
```
```python
NULL
```
```python
)
```
```python
return
```
```python
uv_translate_sys_error(GetLastError());
```
```python
else
```
```python
return
```
```python
0
```
```python
;
}
```
#### 释放信号量
```python
void
```
```python
uv_sem_destroy(uv_sem_t* sem)
```
```python
{
  if (!
```
```python
CloseHandle(*sem)
```
```python
)
```
```python
//关闭句柄
```
```python
abort()
```
```python
;
}
```
#### 发送
```python
void
```
```python
uv_sem_post(uv_sem_t
```
```python
*
```
```python
sem) {
```
```python
if
```
```python
(
```
```python
!
```
```python
ReleaseSemaphore(
```
```python
*
```
```python
sem,
```
```python
1
```
```python
,
```
```python
NULL
```
```python
))
```
```python
//释放一个资源
```
```python
abort
```
```python
();
}
```
#### 等待
```python
void
```
```python
uv_sem_wait(uv_sem_t
```
```python
*
```
```python
sem) {
```
```python
if
```
```python
(WaitForSingleObject(
```
```python
*
```
```python
sem, INFINITE)
```
```python
!=
```
```python
WAIT_OBJECT_0)
```
```python
abort
```
```python
();
}
```
#### 尝试等待
```python
int
```
```python
uv_sem_trywait(uv_sem_t* sem) {
  DWORD r = WaitForSingleObject(*sem,
```
```python
0
```
```python
);
```
```python
if
```
```python
(r == WAIT_OBJECT_0)
```
```python
return
```
```python
0
```
```python
;
```
```python
if
```
```python
(r == WAIT_TIMEOUT)
```
```python
return
```
```python
UV_EAGAIN;
```
```python
abort
```
```python
();
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
/* Satisfy the compiler. */
```
```python
}
```
### 线程池同步相关API
#### 初始化
```python
int
```
```python
uv_cond_init(uv_cond_t* cond) {
  uv__once_init();
```
```python
//调用uv_init全局初始化
```
```python
if
```
```python
(HAVE_CONDVAR_API())
```
```python
//系统支持相关的API
```
```python
return
```
```python
uv_cond_condvar_init(cond);
```
```python
else
```
```python
return
```
```python
uv_cond_fallback_init(cond);
}
```
系统支持
```python
static
```
```python
int
```
```python
uv_cond_condvar_init(uv_cond_t* cond) {
```
```python
//调用InitializeConditionVariable初始化
```
```python
pInitializeConditionVariable(&cond->cond_var);
```
```python
return
```
```python
0
```
```python
;
}
```
系统不支持
```python
static int uv_cond_fallback_init(uv_cond_t
```
```python
*
```
```python
cond) {
  int err;
  cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count
```
```python
=
```
```python
0
```
```python
;
```
```python
//初始化临界区
```
```python
InitializeCriticalSection(
```
```python
&
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count_lock);
```
```python
//新建一个自动还原状态的事件，初始化为无信号
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
signal_event
```
```python
=
```
```python
CreateEvent(
```
```python
NULL
```
```python
,
```
```python
/* no security */
```
```python
FALSE
```
```python
,
```
```python
/* auto-reset event */
```
```python
FALSE
```
```python
,
```
```python
/* non-signaled initially */
```
```python
NULL
```
```python
);
```
```python
/* unnamed */
```
```python
if
```
```python
(
```
```python
!
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
signal_event) {
    err
```
```python
=
```
```python
GetLastError();
    goto error2;
  }
```
```python
//创建一个需要手动改变状态的事件
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
broadcast_event
```
```python
=
```
```python
CreateEvent(
```
```python
NULL
```
```python
,
```
```python
/* no security */
```
```python
TRUE
```
```python
,
```
```python
/* manual-reset */
```
```python
FALSE
```
```python
,
```
```python
/* non-signaled */
```
```python
NULL
```
```python
);
```
```python
/* unnamed */
```
```python
if
```
```python
(
```
```python
!
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
broadcast_event) {
    err
```
```python
=
```
```python
GetLastError();
    goto error;
  }
```
```python
return
```
```python
0
```
```python
;
error:
  CloseHandle(cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
signal_event);
error2:
  DeleteCriticalSection(
```
```python
&
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count_lock);
```
```python
return
```
```python
uv_translate_sys_error(err);
}
```
#### 释放
```python
void
```
```python
uv_cond_destroy(uv_cond_t* cond)
```
```python
{
  if (
```
```python
HAVE_CONDVAR_API()
```
```python
)
```
```python
//根据系统的支持情况释放资源
```
```python
uv_cond_condvar_destroy(cond)
```
```python
;
  else
```
```python
uv_cond_fallback_destroy(cond)
```
```python
;
}
```
#### 设为有信号状态
```python
void
```
```python
uv_cond_signal(uv_cond_t* cond)
```
```python
{
  if (
```
```python
HAVE_CONDVAR_API()
```
```python
)
```
```python
uv_cond_condvar_signal(cond)
```
```python
;
  else
```
```python
uv_cond_fallback_signal(cond)
```
```python
;
}
```
使用系统API
```python
static
```
```python
void
```
```python
uv_cond_condvar_signal(uv_cond_t* cond)
```
```python
{
```
```python
pWakeConditionVariable(&cond->cond_var)
```
```python
;
```
```python
//唤醒
```
```python
}
```
libuv自己实现
```python
static
```
```python
void
```
```python
uv_cond_fallback_signal(uv_cond_t
```
```python
*
```
```python
cond) {
  int have_waiters;
  EnterCriticalSection(
```
```python
&
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count_lock);
  have_waiters
```
```python
=
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count
```
```python
>
```
```python
0
```
```python
;
  LeaveCriticalSection(
```
```python
&
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count_lock);
```
```python
if
```
```python
(have_waiters)
```
```python
//将signal_event设为有信号，这样等待该event的线程中的一个将会唤醒
```
```python
SetEvent(cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
signal_event);
}
```
#### 广播通知（所有等待的线程都被唤醒）
```python
void
```
```python
uv_cond_broadcast(uv_cond_t* cond)
```
```python
{
  if (
```
```python
HAVE_CONDVAR_API()
```
```python
)
```
```python
uv_cond_condvar_broadcast(cond)
```
```python
;
  else
```
```python
uv_cond_fallback_broadcast(cond)
```
```python
;
}
```
使用系统API实现
```python
static
```
```python
void
```
```python
uv_cond_condvar_broadcast(uv_cond_t* cond)
```
```python
{
```
```python
pWakeAllConditionVariable(&cond->cond_var)
```
```python
;
```
```python
//唤醒所有线程
```
```python
}
```
libuv自己实现
```python
static
```
```python
void
```
```python
uv_cond_fallback_broadcast(uv_cond_t
```
```python
*
```
```python
cond) {
  int have_waiters;
  EnterCriticalSection(
```
```python
&
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count_lock);
  have_waiters
```
```python
=
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count
```
```python
>
```
```python
0
```
```python
;
  LeaveCriticalSection(
```
```python
&
```
```python
cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
waiters_count_lock);
```
```python
if
```
```python
(have_waiters)
```
```python
//所有等待broadcast_event的线程都被唤醒
```
```python
SetEvent(cond
```
```python
->
```
```python
fallback
```
```python
.
```
```python
broadcast_event);
}
```
#### 等待
```python
void
```
```python
uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex)
```
```python
{
  if (
```
```python
HAVE_CONDVAR_API()
```
```python
)
```
```python
uv_cond_condvar_wait(cond, mutex)
```
```python
;
  else
```
```python
uv_cond_fallback_wait(cond, mutex)
```
```python
;
}
```
通过系统API实现
```python
static
```
```python
void
```
```python
uv_cond_condvar_wait(uv_cond_t* cond, uv_mutex_t* mutex)
```
```python
{
```
```python
//等待cond_var，并离开临界区mutex
```
```python
if (!
```
```python
pSleepConditionVariableCS(&cond->cond_var, mutex, INFINITE)
```
```python
)
```
```python
abort()
```
```python
;
}
```
libuv自己实现
```python
static
```
```python
int
```
```python
uv_cond_wait_helper(uv_cond_t* cond, uv_mutex_t* mutex,
    DWORD dwMilliseconds) {
  DWORD result;
```
```python
int
```
```python
last_waiter;
  HANDLE handles[
```
```python
2
```
```python
] = {
    cond->fallback
```
```python
.signal_event
```
```python
,
    cond->fallback
```
```python
.broadcast_event
```
```python
};
  EnterCriticalSection(&cond->fallback
```
```python
.waiters_count_lock
```
```python
);
  cond->fallback
```
```python
.waiters_count
```
```python
++;
```
```python
//等待的线程计数加一
```
```python
LeaveCriticalSection(&cond->fallback
```
```python
.waiters_count_lock
```
```python
);
```
```python
//离开临界区
```
```python
uv_mutex_unlock(mutex);
```
```python
//等待任意一个event为有信号状态
```
```python
result = WaitForMultipleObjects(
```
```python
2
```
```python
, handles,
```
```python
FALSE
```
```python
, dwMilliseconds);
  EnterCriticalSection(&cond->fallback
```
```python
.waiters_count_lock
```
```python
);
  cond->fallback
```
```python
.waiters_count
```
```python
--;
```
```python
//如果信号是broadcast_event并且没有等待者了，说明这是最后一个等待的线程
```
```python
last_waiter = result == WAIT_OBJECT_0 +
```
```python
1
```
```python
&& cond->fallback
```
```python
.waiters_count
```
```python
==
```
```python
0
```
```python
;
  LeaveCriticalSection(&cond->fallback
```
```python
.waiters_count_lock
```
```python
);
```
```python
//对于最后一个等待线程，手动将broadcast_event设为无信号
```
```python
if
```
```python
(last_waiter) {
    ResetEvent(cond->fallback
```
```python
.broadcast_event
```
```python
);
  }
  uv_mutex_lock(mutex);
```
```python
if
```
```python
(result == WAIT_OBJECT_0 || result == WAIT_OBJECT_0 +
```
```python
1
```
```python
)
```
```python
return
```
```python
0
```
```python
;
```
```python
if
```
```python
(result == WAIT_TIMEOUT)
```
```python
return
```
```python
UV_ETIMEDOUT;
  abort();
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
/* Satisfy the compiler. */
```
```python
}
```
#### 等待指定时间，与上面的函数相比，多了一个超时参数
```python
int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex,
    uint64_t
```
```python
timeout
```
```python
) {
```
```python
if
```
```python
(HAVE_CONDVAR_API())
```
```python
return
```
```python
uv_cond_condvar_timedwait(cond, mutex,
```
```python
timeout
```
```python
);
```
```python
else
```
```python
return
```
```python
uv_cond_fallback_timedwait(cond, mutex,
```
```python
timeout
```
```python
);
}
```
### barrier相关函数
#### 初始化
```python
int
```
```python
uv_barrier_init(uv_barrier_t*
```
```python
barrier
```
```python
, unsigned
```
```python
int
```
```python
count) {
```
```python
int
```
```python
err;
```
```python
barrier
```
```python
->n = count;
```
```python
//任务数量
```
```python
barrier
```
```python
->count =
```
```python
0
```
```python
;
  err = uv_mutex_init(&
```
```python
barrier
```
```python
->mutex);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
err;
  err = uv_sem_init(&
```
```python
barrier
```
```python
->turnstile1,
```
```python
0
```
```python
);
```
```python
if
```
```python
(err)
    goto error2;
  err = uv_sem_init(&
```
```python
barrier
```
```python
->turnstile2,
```
```python
1
```
```python
);
```
```python
if
```
```python
(err)
    goto error;
```
```python
return
```
```python
0
```
```python
;
error:
  uv_sem_destroy(&
```
```python
barrier
```
```python
->turnstile1);
error2:
  uv_mutex_destroy(&
```
```python
barrier
```
```python
->mutex);
```
```python
return
```
```python
err;
}
```
#### 释放
```python
void
```
```python
uv_barrier_destroy(uv_barrier_t*
```
```python
barrier
```
```python
) {
  uv_sem_destroy(&
```
```python
barrier
```
```python
->turnstile2);
  uv_sem_destroy(&
```
```python
barrier
```
```python
->turnstile1);
  uv_mutex_destroy(&
```
```python
barrier
```
```python
->mutex);
}
```
#### 等待
```python
int
```
```python
uv_barrier_wait(uv_barrier_t*
```
```python
barrier
```
```python
) {
```
```python
int
```
```python
serial_thread;
  uv_mutex_lock(&
```
```python
barrier
```
```python
->mutex);
```
```python
//进入临界区
```
```python
if
```
```python
(++
```
```python
barrier
```
```python
->count ==
```
```python
barrier
```
```python
->n) {
```
```python
//最后一个任务
```
```python
uv_sem_wait(&
```
```python
barrier
```
```python
->turnstile2);
```
```python
//等待第二个信号量
```
```python
uv_sem_post(&
```
```python
barrier
```
```python
->turnstile1);
```
```python
//释放第一个信号量
```
```python
}
  uv_mutex_unlock(&
```
```python
barrier
```
```python
->mutex);
  uv_sem_wait(&
```
```python
barrier
```
```python
->turnstile1);
```
```python
//等待第一个信号量
```
```python
uv_sem_post(&
```
```python
barrier
```
```python
->turnstile1);
```
```python
//释放第一个信号量
```
```python
uv_mutex_lock(&
```
```python
barrier
```
```python
->mutex);
```
```python
//进入临界区
```
```python
serial_thread = (--
```
```python
barrier
```
```python
->count ==
```
```python
0
```
```python
);
```
```python
if
```
```python
(serial_thread) {
```
```python
//最后一个任务
```
```python
uv_sem_wait(&
```
```python
barrier
```
```python
->turnstile1);/等待第一个
    uv_sem_post(&
```
```python
barrier
```
```python
->turnstile2);
```
```python
//释放第二个
```
```python
}
  uv_mutex_unlock(&
```
```python
barrier
```
```python
->mutex);
  uv_sem_wait(&
```
```python
barrier
```
```python
->turnstile2);
```
```python
//等待第二个
```
```python
uv_sem_post(&
```
```python
barrier
```
```python
->turnstile2);
```
```python
//释放第二个
```
```python
return
```
```python
serial_thread;
}
```
当某一线程需要等待其他一些线程任务完成之后才能继续运行时，可以使用barrier。
流程如下：
a.所有的相关线程都调用uv_barrier_wait等待同一个uv_barrier_t，此时除了最后一个，都会在等待第一个信号量的地方阻塞。
b.最后一个调用uv_barrier_wait的线程会等待第二个信号量，此时第二个信号量没有资源，然后释放第一个信号量。
c.之前阻塞在等待第一个信号量的线程中的一个获取信号量，继续运行，接着释放第一个信号量，这导致所有阻塞的进程都会因此一个一个的继续运行
d.接着除了最后一个线程，所有的线程都会阻塞在等待第二个信号量的地方。
e.最后一个线程，等待第一个信号量，此时第一个信号量重新变为没有资源，接着释放第二个信号量，激活其他等待的线程
f.其他阻塞在等待第二个信号量的线程，一个一个的唤醒，最终第二个信号量的资源为一，所有的线程继续运行
注意，最后一个线程是指逻辑上的最后一个，并不是确定的。
如果线程数比初始化时设置的任务数少，那么都会阻塞
如果线程池数比任务数多，那么等待任务数量的线程之后就会继续运行。

