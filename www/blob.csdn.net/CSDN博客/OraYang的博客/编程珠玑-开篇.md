
# 编程珠玑-开篇 - OraYang的博客 - CSDN博客

2017年09月29日 09:13:41[OraYang](https://me.csdn.net/u010665216)阅读数：246所属专栏：[基础算法](https://blog.csdn.net/column/details/16604.html)



> 本书的中心思想：对实例研究的深入思考不仅有趣，而且可以获得实际的益处

### 归并排序
**定义**：归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
**过程**：比较a[i]和b[j]的大小，若a[i]≤b[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素b[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。
### 原理
> 正确的问题

> 位图数据结构

> 多趟算法

> 时间-空间折中与双赢：减少程序的空间需求也会减少其运行时间；当然了只有原始的设计远非最佳方案时，才有可能时空双赢

> 简单的设计

### 习题（节选）
问题1：这个问题中C++的set容器实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。
问题2：这个问题问你如何使用为逻辑运算实现位向量，核心思想就是，建立一个数据，数组大小为$1+N/32$，其中N表示号码数量，那么定义数组$a[1+N/32]$我们有a[0]存储0-31，a[1]存储32-63……依次类推。
问题6：针对一个整数不只出现一次的情况，我们的解决方法是使用额外的位来表示一个整数出现了几次。
问题9：这个问题的解答很巧妙，就是借助两个额外的n元向量，from、to和整数top,变量top初始为0，下面的代码实现对数组元素的首次访问：
```python
from
```
```python
[i] = top
```
```python
to
```
```python
[top] = i
```
```python
data
```
```python
[i] = 0
```
```python
top
```
```python
++
```
### 总结
> 程序员的主要问题与其说是技术问题，还不如说是心理问题：他不能解决问题，是因为他企图解决错误的问题。问题的最终解决，是通过打破他的概念壁垒，进而去解决一个较简单的问题而实现的。


