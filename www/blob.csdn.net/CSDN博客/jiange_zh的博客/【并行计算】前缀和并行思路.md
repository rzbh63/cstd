
# 【并行计算】前缀和并行思路 - jiange_zh的博客 - CSDN博客


2015年12月16日 16:49:58[jiange_zh](https://me.csdn.net/jiange_zh)阅读数：2482



## 一.定义
如果给定一个数列a[n]，令S[k] ＝ a[0]+a[1]+…+a[k]，（k = 0, 1, 2…n-1），数列S[k]即为数列a[n]的前缀和。
## 二.串行算法
很容易就能想到串行的算法：
```python
S[
```
```python
0
```
```python
] = a[
```
```python
0
```
```python
];
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i < n; i++)
    S[i] = S[i-
```
```python
1
```
```python
] + a[i];
```
## 三.并行算法
我们用一个实际的例子来说明本问题的并行解题思路。
假设有4个处理器要计算以下16个整数的前缀和：
1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16
1.将上面数据平分成4组，每个处理器计算一组数据的前缀和（单个处理器内部串行计算，多个处理器并行）：
（1   2   3   4） （5   6   7   8） （9   10   11   12） （13   14   15   16）
—>
（1   3   6   10） （5   11   18   26） （9   19   30   42） （13   27   42   58）
2.选取每组的最后一个数据，对这几个数据计算前缀和：
（1  3  6   10） （5   11   18   26） （9   19   30   42） （13   27   42  58）
–>
（1  3  6   10） （5   11   18   36） （9   19   30   78） （13   27   42  136）
此时，每组最后一个数据的值已经变成了原始数据在它所处位置之前（包含本位置）的所有数据的和。例如：
36 ＝ 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8
78 = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12
3.从第2组数开始，将每组中的数（除最后一个数外）加上它的前一组数的最后一个数，即可得到所有数的前缀和：
(1 3 6 10) (5+10 11+10 18+10 36) (9+36 19+36 30+36 78)  (13+78 27+78 42+78 136）
–>
(1  3  6  10)  (15  21  28  36)  (45  55  66  78)  (91  105  120  136）
至此，并行前缀和计算结束，实际应用中我们推广到p个处理器，n个数即可。
**在并行计算中，我们应该使用尽量多的处理器，这样子才能发挥出并行的优势！（如果处理器过少，通信成本以及其他并行开销将使得算法效率不如串行算法）

