
# 漫步最优化二十二——收敛速率 - 蜗牛 - CSDN博客


2017年09月26日 19:49:48[会敲键盘的猩猩](https://me.csdn.net/u010182633)阅读数：867



$\textbf{未来的你已在我的身边，}$
$\textbf{虽然经过了很多个弯；}$
$\textbf{现在的我已经没了号码牌，}$
$\textbf{虽然已经相伴了很多年。}$
$\textbf{遇见你，是我最美的意外。}$
$\quad\textbf{——畅宝宝的傻逼哥哥}$
大部分算法计算效率是有很大差别的，高效或者快速的算法仅需要少量的迭代就能收敛到解，并且计算量也很小。从经济的角度来说，我们会选择选择最有效的算法，因此我们就需要度量算法收敛速率的定量指标或准则。
最基本的准则是序列的收敛阶，如果$\{x_k\}_{k=0}^{\infty}$是实数序列，那么它的收敛阶就是最大的非负整数$p$，满足关系

$$
0\leq\beta<\infty
$$
其中

$$
\begin{equation}
\beta=\lim_{k\to\infty}\frac{|x_{k+1}-\hat{x}|}{|x_k-\hat{x}|^p}\tag1
\end{equation}
$$
$\hat{x}$是$k\to\infty$的极限，参数$\beta$称为收敛比。
$\textbf{例1：}$如果
x_k=\gamma^k,\ for\ 0<\gamma<1
x_k=\gamma^{2^k},\ for\ 0<\gamma<1
那么求出序列$\{x_k\}_{k=0}^{\infty}$的收敛阶与收敛比。
$\textbf{解：}$(a)因为$\hat{x}=0$，所以

$$
\beta=\lim_{k\to\infty}\gamma^{k(1-p)+1}
$$
对于$p=0,1,2$，我们有$\beta=0,\gamma,\infty$，所以$p=1,\beta=\gamma$。
(b)

$$
\beta=\lim_{k\to\infty}\frac{\gamma^{2^{(k+1)}}}{\gamma^{2^kp}}=\lim_{k\to\infty}\{\gamma^{2^k(2-p)}\}
$$
对于$p=0,1,2,3$，我们有$\beta=0,0,1,\infty$，所以$p=2,\beta=1$。
如果等式(1)的极限存在，那么

$$
\lim_{k\to\infty}|x_k-\hat{x}|=\varepsilon
$$
其中$\varepsilon<1$，所以

$$
\lim_{k\to\infty}|x_{k+1}-\hat{x}|=\beta\varepsilon^p
$$
所以$p$增加或者$\beta$减少的话，收敛速率在增加。如果$\rho=0.8$，那么(a)(b)的序列分别为

$$
\{x_k\}_k^{\infty}=\{1,0.8,0.64.0.512,0.409,\ldots,0\}
$$
与

$$
\{x_k\})_{k=0}^{\infty}=\{1,0.64,0.409,0.167,0.023,\ldots,0\}
$$
第二个序列的收敛速率比第一个更快。
如果$p=1,\beta<1$，那么我们称序列是线性收敛的；如果$p=1,\beta=0$或者$p\geq2$，那么称序列是超线性收敛的。
大部分非线性规划算法都是线性收敛的，因此他们的比较都是基于$\beta$值。
另一种度量序列收敛速率的是平均收敛阶数，也就是满足关系

$$
\rho=\lim_{k\to\infty}|x_k-\hat{x}|^{1/(p+1)^k}=1
$$
的最小非负整数。如果不存在$p>0$，那么收敛的阶数为无穷大。
$\textbf{例2：}$找出序列$\{x_k\}_{k=0}^{\infty}$的平均收敛阶数
x_k=\gamma^k,\ for\ 0<\gamma<1
x_k=\gamma^{2^k},\ for\ 0<\gamma<1
$\textbf{解：}$(a)因为$\hat{x}=0$，

$$
\rho=\lim_{k\to\infty}(\rho^k)^{1/(p+1)^k}=1
$$
所以对于$p=0,1,2$，我们有$\rho=0,1,1$，因此$p=1$。
(b)

$$
\rho=\lim_{k\to\infty}(\rho^{2^k})^{1/(p+1)^k}=1
$$
所以对于$p=0,1,2,3$，我们有$\rho=0,\rho,1,1$，因此$p=2$。
如果收敛的平均阶数是单位1，那么我们称序列是平均线性收敛，平均线性收敛定义为

$$
\rho=\lim_{k\to\infty}|x_k-\hat{x}|^{1/k}
$$
上面的讨论中，我们考虑的是数列的收敛性。随着越来越靠近解，这样的序列可能由目标函数的值构成，这时候我们度量目标函数靠近其最小值的速度。或者说，如果我们想知道问题靠近最优解有多快，可以用向量$\mathbf{x}_k-\mathbf{\hat{x}}$的长度或长度的平方，即$\lVert\mathbf{x}_k-\mathbf{\hat{x}}\rVert$或者$\lVert\mathbf{x}_k-\mathbf{\hat{x}}\rVert^2$。
上面收敛速率的度量中，重点都是在解邻域内考虑算法的有效性。通常而言优化的大部分计算都花在解的邻域内，所以上面的度量是很有意义的。然而偶尔会有些算法在解的邻域内有效而其他地方无效。这时候上面的判别准则会误导我们，所以需要改用其他的准则。

