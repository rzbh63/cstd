
# 负载均衡算法详解与实践 - bitcarmanlee的博客 - CSDN博客


2018年06月21日 18:26:39[bitcarmanlee](https://me.csdn.net/bitcarmanlee)阅读数：400


负载均衡算法在实际中使用及其广泛，比如某个大型网站或者某个大型服务，服务器的数量可能成百上千台，这个时候是一定会有负载均衡算法的。现在总结一下常见的几种负载均衡算法。
## 1.轮询法(RoundRobin)
轮询法是一种比较简单的算法，也比较好理解。假设后台有N台服务器，那么来请求以后，按照请求到达的先后顺序，将流量分配到服务器上，这样后端服务器上的流量都是相同的。这种方式的好处是不用关注服务器本身的负载，链接数等信息。但是坏处也比较明显，如果每台服务器的处理能力不一样，那比较强的服务器就无法发挥优势。Nginx中默认的就是轮询法。
```python
import
```
```python
java.util.Arrays;
```
```python
import
```
```python
java.util.List;
```
```python
/**
 * Created by WangLei on 18-6-21.
 */
```
```python
public
```
```python
class
```
```python
RoundRobin
```
```python
{
```
```python
private
```
```python
static
```
```python
List<String> servers = Arrays.asList(
```
```python
"192.168.0.1"
```
```python
,
```
```python
"192.168.0.2"
```
```python
,
```
```python
"192.168.0.3"
```
```python
,
```
```python
"192.168.0.4"
```
```python
);
```
```python
private
```
```python
static
```
```python
Integer pos =
```
```python
0
```
```python
;
```
```python
public
```
```python
static
```
```python
String
```
```python
getServer
```
```python
() {
        String server =
```
```python
null
```
```python
;
```
```python
synchronized
```
```python
(pos) {
```
```python
if
```
```python
(pos == servers.size()) {
                pos =
```
```python
0
```
```python
;
            }
            server = servers.get(pos);
            pos++;
        }
```
```python
return
```
```python
server;
    }
```
```python
public
```
```python
static
```
```python
void
```
```python
main
```
```python
(String[] args) {
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<
```
```python
10
```
```python
; i++) {
            System.out.println(RoundRobin.getServer());
        }
    }
}
```
运行结果：
```python
192.168.0.1
192.168.0.2
192.168.0.3
192.168.0.4
192.168.0.1
192.168.0.2
192.168.0.3
192.168.0.4
192.168.0.1
192.168.0.2
```
代码里面需要注意的是对于pos参数的处理，因为实际中并发的场景很常见，所以用synchronized将pos包起来，这样保证pos每次只被一个线程修改。
## 2.随机法
随机的方式也比较容易理解。将流量随机分配到后端某一台服务器上。根据简单的统计理论可以得知，随着流量越来越大，随机分配的实际效果越来越接近平均分配，最终的实际效果跟轮询一致。
```python
import
```
```python
java.util.Arrays;
```
```python
import
```
```python
java.util.List;
```
```python
import
```
```python
java.util.Random;
```
```python
/**
 * Created by WangLei on 18-6-21.
 */
```
```python
public
```
```python
class
```
```python
RandomMethod
```
```python
{
```
```python
private
```
```python
static
```
```python
List<String> servers = Arrays.asList(
```
```python
"192.168.0.1"
```
```python
,
```
```python
"192.168.0.2"
```
```python
,
```
```python
"192.168.0.3"
```
```python
,
```
```python
"192.168.0.4"
```
```python
);
```
```python
private
```
```python
static
```
```python
int
```
```python
pos =
```
```python
0
```
```python
;
```
```python
public
```
```python
static
```
```python
String
```
```python
getServer
```
```python
() {
        String server =
```
```python
null
```
```python
;
        Random random =
```
```python
new
```
```python
Random();
```
```python
int
```
```python
randomPos = random.nextInt(servers.size());
        server = servers.get(randomPos);
```
```python
return
```
```python
server;
    }
```
```python
public
```
```python
static
```
```python
void
```
```python
main
```
```python
(String[] args) {
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<
```
```python
10
```
```python
; i++) {
            System.out.println(RandomMethod.getServer());
        }
    }
}
```
```python
192.168.0.4
192.168.0.4
192.168.0.1
192.168.0.4
192.168.0.3
192.168.0.1
192.168.0.4
192.168.0.3
192.168.0.1
192.168.0.3
```
根据代码可以看出，在并发的情况下，随机方式不需要像轮询一样加锁，并发能力比轮询要强。
## 3.主备算法
这个算法核心的思想是将请求尽量的放到某个固定机器的服务上，而其他机器的服务则用来做备份，如果出现问题就切换到另外的某台机器的服务上。这么做的好处之一就是每个流量分配到哪个服务器上是固定的，在某些场合会比较方便。
比如我们下面实现一个简单的主备，根据客户端的ip将流量分配到固定的机器上。
```python
import
```
```python
java.util.Arrays;
```
```python
import
```
```python
java.util.List;
```
```python
/**
 * Created by WangLei on 18-6-21.
 */
```
```python
public
```
```python
class
```
```python
HashMethod
```
```python
{
```
```python
private
```
```python
static
```
```python
List<String> servers = Arrays.asList(
```
```python
"192.168.0.1"
```
```python
,
```
```python
"192.168.0.2"
```
```python
,
```
```python
"192.168.0.3"
```
```python
,
```
```python
"192.168.0.4"
```
```python
);
```
```python
private
```
```python
static
```
```python
int
```
```python
pos =
```
```python
0
```
```python
;
```
```python
public
```
```python
static
```
```python
String
```
```python
getServer
```
```python
(String ip) {
        String server =
```
```python
null
```
```python
;
```
```python
int
```
```python
hashCode = ip.hashCode();
        pos = hashCode % servers.size();
        server = servers.get(pos);
```
```python
return
```
```python
server;
    }
```
```python
public
```
```python
static
```
```python
void
```
```python
main
```
```python
(String[] args) {
        String ip =
```
```python
"192.168.255.254"
```
```python
;
        System.out.println(HashMethod.getServer(ip));
    }
}
```
```python
192.168.0.3
```
## 4.一致性Hash
一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到后端服务器的Hash映射。如果是缓存服务，实现的则是Key到缓存服务器的Hash映射。从网上找了一张示意图。
![这里写图片描述](https://img-blog.csdn.net/20180621181006794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpdGNhcm1hbmxlZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
算法的具体逻辑如下：将[0,2^32)所有的整数投射到一个圆上，然后再将你的机器的唯一编码（比如：IP）通过hash运算得到的整数也投射到这个圆上（Node-A、Node-B）。如果一个请求来了，就将这个请求的唯一编码（比如：用户id）通过hash算法运算得到的整数也投射到这个圆上（request-1、request-2），通过顺时针方向，找到第一个对应的机器。
一致性Hash需要解决的是以下两个问题：
1、散列的不变性：就是同一个请求（比如：同一个用户id）尽量的落入到一台机器，不要因为时间等其他原因，落入到不同的机器上了；
2、异常以后的分散性：当某些机器坏掉（或者增加机器），原来落到同一台机器的请求（比如：用户id为1，101，201），尽量分散到其他机器，不要都落入其他某一台机器。这样对于系统的冲击和影响最小。
一致Hash算法用的最多的场景，就是分配cache服务。将某一个用户的数据缓存在固定的某台服务器上，那么我们基本上就不用多台机器都缓存同样的数据，这样对我们提高缓存利用率有极大的帮助。
(此部分来自[https://blog.csdn.net/zgwangbo/article/details/51533657](https://blog.csdn.net/zgwangbo/article/details/51533657)）
先看一个一致性Hash的简单实现版本。
```python
import
```
```python
java.util.Arrays;
```
```python
import
```
```python
java.util.List;
```
```python
import
```
```python
java.util.SortedMap;
```
```python
import
```
```python
java.util.TreeMap;
```
```python
/**
 * Created by WangLei on 18-6-21.
 */
```
```python
public
```
```python
class
```
```python
ConsisentHashNoVirtualNode
```
```python
{
```
```python
private
```
```python
static
```
```python
String[] serversarray = {
```
```python
"192.168.0.0:111"
```
```python
,
```
```python
"192.168.0.1:111"
```
```python
,
```
```python
"192.168.0.2:111"
```
```python
,
```
```python
"192.168.0.3:111"
```
```python
,
```
```python
"192.168.0.4:111"
```
```python
};
```
```python
private
```
```python
static
```
```python
List<String> servers = Arrays.asList(serversarray);
```
```python
private
```
```python
static
```
```python
SortedMap<Integer, String> sortedMap =
```
```python
new
```
```python
TreeMap<>();
```
```python
static
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<servers.size(); i++) {
```
```python
int
```
```python
hash = hashCode(servers.get(i));
            System.out.println(servers.get(i) +
```
```python
" join collections, hashcode is: "
```
```python
+ hash);
            sortedMap.put(hash, servers.get(i));
        }
        System.out.println();
    }
```
```python
// 重写hashcode方法，使用FNV1_32_HASH算法，让节点在hash环上分布更均匀。
```
```python
private
```
```python
static
```
```python
int
```
```python
hashCode
```
```python
(String ip) {
```
```python
final
```
```python
int
```
```python
p =
```
```python
16777619
```
```python
;
```
```python
int
```
```python
hash = (
```
```python
int
```
```python
)
```
```python
2166136261
```
```python
L;
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<ip.length(); i++) {
            hash = (hash ^ ip.charAt(i)) * p;
        }
        hash += hash <<
```
```python
13
```
```python
;
        hash ^= hash >>
```
```python
7
```
```python
;
        hash += hash <<
```
```python
3
```
```python
;
        hash ^= hash >>
```
```python
17
```
```python
;
        hash += hash <<
```
```python
5
```
```python
;
```
```python
if
```
```python
(hash <
```
```python
0
```
```python
) {
            hash = Math.abs(hash);
        }
```
```python
return
```
```python
hash;
    }
```
```python
private
```
```python
static
```
```python
String
```
```python
getServer
```
```python
(String client) {
```
```python
int
```
```python
hash = hashCode(client);
```
```python
// 得到大于该Hash值的所有Map。注意有可能subMap一个值没有，此时默认分给第一个server。
```
```python
SortedMap<Integer, String> subMap = sortedMap.tailMap(hash);
```
```python
if
```
```python
(subMap !=
```
```python
null
```
```python
&& subMap.size() >
```
```python
0
```
```python
) {
```
```python
int
```
```python
i = subMap.firstKey();
```
```python
return
```
```python
subMap.get(i);
        }
```
```python
else
```
```python
{
```
```python
return
```
```python
sortedMap.get(hashCode(servers.get(
```
```python
0
```
```python
)));
        }
    }
```
```python
public
```
```python
static
```
```python
void
```
```python
main
```
```python
(String[] args) {
        String[] clients =  {
```
```python
"127.0.0.1:22"
```
```python
,
```
```python
"221.226.0.1:80"
```
```python
,
```
```python
"10.211.0.1:8080"
```
```python
};
```
```python
//String[] clients =  {"127.0.0.1:22", "221.226.0.1:80"};
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<clients.length; i++) {
            System.out.println(clients[i] +
```
```python
" hashcode is: "
```
```python
+ hashCode(clients[i]) +
```
```python
", the router node is: "
```
```python
+ getServer(clients[i]));
        }
    }
}
```
运行结果：
```python
192.168
```
```python
.0
```
```python
.0
```
```python
:
```
```python
111
```
```python
join
```
```python
collections, hashcode
```
```python
is
```
```python
:
```
```python
575774686
```
```python
192.168
```
```python
.0
```
```python
.1
```
```python
:
```
```python
111
```
```python
join
```
```python
collections, hashcode
```
```python
is
```
```python
:
```
```python
8518713
```
```python
192.168
```
```python
.0
```
```python
.2
```
```python
:
```
```python
111
```
```python
join
```
```python
collections, hashcode
```
```python
is
```
```python
:
```
```python
1361847097
```
```python
192.168
```
```python
.0
```
```python
.3
```
```python
:
```
```python
111
```
```python
join
```
```python
collections, hashcode
```
```python
is
```
```python
:
```
```python
1171828661
```
```python
192.168
```
```python
.0
```
```python
.4
```
```python
:
```
```python
111
```
```python
join
```
```python
collections, hashcode
```
```python
is
```
```python
:
```
```python
1764547046
```
```python
127.0
```
```python
.0
```
```python
.1
```
```python
:
```
```python
22
```
```python
hashcode
```
```python
is
```
```python
:
```
```python
1739501660
```
```python
, the router node
```
```python
is
```
```python
:
```
```python
192.168
```
```python
.0
```
```python
.4
```
```python
:
```
```python
111
```
```python
221.226
```
```python
.0
```
```python
.1
```
```python
:
```
```python
80
```
```python
hashcode
```
```python
is
```
```python
:
```
```python
99109700
```
```python
, the router node
```
```python
is
```
```python
:
```
```python
192.168
```
```python
.0
```
```python
.0
```
```python
:
```
```python
111
```
```python
10.211
```
```python
.0
```
```python
.1
```
```python
:
```
```python
8080
```
```python
hashcode
```
```python
is
```
```python
:
```
```python
1976495495
```
```python
, the router node
```
```python
is
```
```python
:
```
```python
192.168
```
```python
.0
```
```python
.0
```
```python
:
```
```python
111
```
上面的一致性Hash算法实现，可以在很大程度上解决很多分布式环境下不好的路由算法导致系统伸缩性差的问题，但是会带来另外一个问题：负载不均。
比如说有Hash环上有A、B、C三个服务器节点，分别有100个请求会被路由到相应服务器上。现在在A与B之间增加了一个节点D，这导致了原来会路由到B上的部分节点被路由到了D上，这样A、C上被路由到的请求明显多于B、D上的，原来三个服务器节点上均衡的负载被打破了。某种程度上来说，这失去了负载均衡的意义，因为负载均衡的目的本身就是为了使得目标服务器均分所有的请求。
解决这个问题的办法是引入虚拟节点，其工作原理是：将一个物理节点拆分为多个虚拟节点，并且同一个物理节点的虚拟节点尽量均匀分布在Hash环上。采取这样的方式，就可以有效地解决增加或减少节点时候的负载不均衡的问题。
```python
import
```
```python
java.util.LinkedList;
```
```python
import
```
```python
java.util.List;
```
```python
import
```
```python
java.util.SortedMap;
```
```python
import
```
```python
java.util.TreeMap;
```
```python
/**
 * Created by WangLei on 18-6-21.
 */
```
```python
public
```
```python
class
```
```python
ConsisenthashWithVituralNode
```
```python
{
```
```python
private
```
```python
static
```
```python
String[] serversarray = {
```
```python
"192.168.0.1"
```
```python
,
```
```python
"192.168.0.2"
```
```python
,
```
```python
"192.168.0.3"
```
```python
,
```
```python
"192.168.0.4"
```
```python
};
```
```python
private
```
```python
static
```
```python
List<String> realservers =
```
```python
new
```
```python
LinkedList<>();
```
```python
private
```
```python
static
```
```python
final
```
```python
int
```
```python
VIRTUAL_NUM =
```
```python
5
```
```python
;
```
```python
private
```
```python
static
```
```python
SortedMap<Integer, String> sortedMap =
```
```python
new
```
```python
TreeMap<>();
```
```python
static
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<serversarray.length; i++) {
            realservers.add(serversarray[i]);
        }
```
```python
//双层循环，每个实际节点都添加对应的虚拟节点
```
```python
for
```
```python
(String ip : realservers) {
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < VIRTUAL_NUM; i++) {
                String virtualNode = ip +
```
```python
"#"
```
```python
+ String.valueOf(i);
```
```python
int
```
```python
hash = hashCode(virtualNode);
                System.out.println(
```
```python
"virtual node of "
```
```python
+ virtualNode +
```
```python
" add, hash is: "
```
```python
+ hash);
                sortedMap.put(hash, virtualNode);
            }
        }
        System.out.println();
    }
```
```python
private
```
```python
static
```
```python
int
```
```python
hashCode
```
```python
(String input) {
```
```python
final
```
```python
int
```
```python
p =
```
```python
16777619
```
```python
;
```
```python
int
```
```python
hash = (
```
```python
int
```
```python
)
```
```python
2166136261
```
```python
L;
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<input.length(); i++) {
            hash = (hash ^ input.charAt(i)) * p;
        }
        hash += hash <<
```
```python
13
```
```python
;
        hash ^= hash >>
```
```python
7
```
```python
;
        hash += hash <<
```
```python
3
```
```python
;
        hash ^= hash >>
```
```python
17
```
```python
;
        hash += hash <<
```
```python
5
```
```python
;
```
```python
if
```
```python
(hash <
```
```python
0
```
```python
) {
            hash = Math.abs(hash);
        }
```
```python
return
```
```python
hash;
    }
```
```python
private
```
```python
static
```
```python
String
```
```python
getServer
```
```python
(String client) {
        String virtualNode =
```
```python
null
```
```python
;
```
```python
int
```
```python
hash = hashCode(client);
        SortedMap<Integer, String> subMap = sortedMap.tailMap(hash);
```
```python
if
```
```python
(subMap !=
```
```python
null
```
```python
&& subMap.size() >
```
```python
0
```
```python
) {
```
```python
int
```
```python
i = subMap.firstKey();
            virtualNode = subMap.get(i);
        }
```
```python
else
```
```python
{
            virtualNode = sortedMap.get(serversarray[
```
```python
0
```
```python
]);
        }
```
```python
return
```
```python
virtualNode.substring(
```
```python
0
```
```python
, virtualNode.indexOf(
```
```python
"#"
```
```python
));
    }
```
```python
public
```
```python
static
```
```python
void
```
```python
main
```
```python
(String[] args) {
        String[] clients =  {
```
```python
"127.0.0.1:22"
```
```python
,
```
```python
"110.226.0.1:80"
```
```python
,
```
```python
"255.21.0.1:8080"
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<clients.length; i++) {
            System.out.println(clients[i] +
```
```python
" hashcode is: "
```
```python
+ hashCode(clients[i]) +
```
```python
" the router node is: "
```
```python
+ getServer(clients[i]));
        }
    }
}
```
运行结果：
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.1
```
```python
#0
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1267794962
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.1
```
```python
#1
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1405473402
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.1
```
```python
#2
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
520282580
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.1
```
```python
#3
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
902681916
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.1
```
```python
#4
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
705135863
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.2
```
```python
#0
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
938864723
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.2
```
```python
#1
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
697737174
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.2
```
```python
#2
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
758522939
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.2
```
```python
#3
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1305037326
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.2
```
```python
#4
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1002536378
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.3
```
```python
#0
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
392944983
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.3
```
```python
#1
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
2046386183
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.3
```
```python
#2
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1604877649
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.3
```
```python
#3
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
95135893
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.3
```
```python
#4
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
2030051947
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.4
```
```python
#0
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1614569944
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.4
```
```python
#1
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
744068005
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.4
```
```python
#2
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1628537157
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.4
```
```python
#3
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
537291676
```
```python
virtual
```
```python
node
```
```python
of
```
```python
192.168
```
```python
.
```
```python
0.4
```
```python
#4
```
```python
add
```
```python
, hash
```
```python
is
```
```python
:
```
```python
1173079769
```
```python
127.0
```
```python
.
```
```python
0.1
```
```python
:
```
```python
22
```
```python
hashcode
```
```python
is
```
```python
:
```
```python
1739501660
```
```python
the router node
```
```python
is
```
```python
:
```
```python
192.168
```
```python
.
```
```python
0.3
```
```python
110.226
```
```python
.
```
```python
0.1
```
```python
:
```
```python
80
```
```python
hashcode
```
```python
is
```
```python
:
```
```python
1320900860
```
```python
the router node
```
```python
is
```
```python
:
```
```python
192.168
```
```python
.
```
```python
0.1
```
```python
255.21
```
```python
.
```
```python
0.1
```
```python
:
```
```python
8080
```
```python
hashcode
```
```python
is
```
```python
:
```
```python
1187650066
```
```python
the router node
```
```python
is
```
```python
:
```
```python
192.168
```
```python
.
```
```python
0.1
```

