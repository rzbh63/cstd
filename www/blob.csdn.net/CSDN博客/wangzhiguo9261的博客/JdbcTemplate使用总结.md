
# JdbcTemplate使用总结 - wangzhiguo9261的博客 - CSDN博客


2018年03月27日 13:42:31[码里偷闲王果果](https://me.csdn.net/wangzhiguo9261)阅读数：2030


版权声明：本文为博主原创文章，未经博主允许不得转载。                https://blog.csdn.net/Mr_zhaoz/article/details/77724831
目录[(?)](https://blog.csdn.net/Mr_zhaoz/article/details/77724831)[[+]](https://blog.csdn.net/Mr_zhaoz/article/details/77724831#)


## 1.JdbcTemplate简介
Spring提供的一个操作数据库的技术JdbcTemplate，是对Jdbc的封装。语法风格非常接近DBUtils。
JdbcTemplate可以直接操作数据库，加快效率，而且学这个JdbcTemplate也是为声明式事务做准备，毕竟要对数据库中的数据进行操纵！
JdbcTemplate中并没有提供一级缓存，以及类与类之间的关联关系！就像是spring提供的一个DBUtils。
Spring对数据库的操作使用JdbcTemplate来封装JDBC，结合Spring的注入特性可以很方便的实现对数据库的访问操作。使用JdbcTemplate可以像JDBC一样来编写数据库的操作代码
## 2.为啥要使用Jdbc_template进行开发呢？
Spring对数据库的操作在jdbc上面做了深层次的封装，使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中。
Spring提供的JdbcTemplate对jdbc做了封装，大大简化了数据库的操作。找到Spring JdbcTemplate源码，可以看到如下方法：
```python
Connection con
```
```python
=
```
```python
DataSourceUtils.getConnection(getDataSource());
```
1
如果直接使用JDBC的话，需要我们加载数据库驱动、创建连接、释放连接、异常处理等一系列的动作；繁琐且代码看起来不直观。
此外，Spring提供的JdbcTempate能直接数据对象映射成实体类，不再需要获取ResultSet去获取值/赋值等操作，提高开发效率；
如下：`return (User) jdbcTemplate.queryForObject("select * from tb_test1 where id = 100", User.class)`
## 3.配置环境
①导入jar包
IOC容器需要的jar包
commons-logging-1.1.3.jar
spring-aop-4.0.0.RELEASE.jar  //注解会使用到的包
spring-beans-4.0.0.RELEASE.jar
spring-context-4.0.0.RELEASE.jar
spring-core-4.0.0.RELEASE.jar
spring-expression-4.0.0.RELEASE.jar
MySQL驱动、C3P0jar包
c3p0-0.9.1.2.jar
mysql-connector-java-5.1.37-bin.jar
JdbcTemplate需要的jar包
spring-jdbc-4.0.0.RELEASE.jar
spring-orm-4.0.0.RELEASE.jar
spring-tx-4.0.0.RELEASE.jar
②在IOC容器中配置数据源
```python
<!-- 加载properties文件中 信息 -->
```
```python
<
```
```python
context:property-placeholder
```
```python
location
```
```python
=
```
```python
"classpath:jdbc.properties"
```
```python
/>
```
```python
<!-- 配置数据源 -->
```
```python
<
```
```python
bean
```
```python
id
```
```python
=
```
```python
"comboPooledDataSource"
```
```python
class
```
```python
=
```
```python
"com.mchange.v2.c3p0.ComboPooledDataSource"
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"user"
```
```python
value
```
```python
=
```
```python
"${jdbc.user}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"password"
```
```python
value
```
```python
=
```
```python
"${jdbc.passowrd}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"jdbcUrl"
```
```python
value
```
```python
=
```
```python
"${jdbc.url}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"driverClass"
```
```python
value
```
```python
=
```
```python
"${jdbc.driver}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
</
```
```python
bean
```
```python
>
```
其中jdbc.properties文件内容：
jdbc.user=root
jdbc.passowrd=123456
jdbc.url=jdbc:mysql://localhost:3306/student
jdbc.driver=com.mysql.jdbc.Driver
③在IOC容器中配置JdbcTemplate对象的bean，并将数据源对象装配到JdbcTemplate对象中.
```python
<!-- 配置JdbcTemplate对应的bean， 并装配dataSource数据源属性-->
```
```python
<
```
```python
bean
```
```python
id
```
```python
=
```
```python
"jdbcTemplate"
```
```python
class
```
```python
=
```
```python
"org.springframework.jdbc.core.JdbcTemplate"
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"dataSource"
```
```python
ref
```
```python
=
```
```python
"comboPooledDataSource"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
</
```
```python
bean
```
```python
>
```
## 4.实验：
实验1：测试数据源
```python
@Test
```
```python
public
```
```python
void
```
```python
test
```
```python
()
```
```python
throws
```
```python
SQLException {
        ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
        DataSource bean = ioc.getBean(DataSource.class);
        System.out.println(bean.getConnection());
    }
```
实验2：将sid=21020的记录的salary字段更新为1300【更新操作】
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
JdbcTemplate template=ioc.getBean(JdbcTemplate.class);
        @Test
```
```python
public
```
```python
void
```
```python
test01
```
```python
(){
```
```python
//实验2：将sid=21020的记录的age字段更新为13
```
```python
String sql =
```
```python
"UPDATE student SET age = ? WHERE sid = ?"
```
```python
;
            template.update(sql,
```
```python
13
```
```python
,
```
```python
21020
```
```python
);
```
```python
//第一个是sql语句，后面的按着顺序传入参数即可，这个update方法是接收的可变参数！
```
```python
}
    }
```
从上述实验中就可以看到，该操作不用我们自己再去获取数据库连接信息了，而是直接传递sql语句及其参数！
实验3：批量插入
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
JdbcTemplate
```
```python
template
```
```python
=ioc.getBean(JdbcTemplate.
```
```python
class
```
```python
);
                @Test
```
```python
public
```
```python
void
```
```python
testBatch(){
                    String sql=
```
```python
"INSERT INTO employee(`emp_name`,`salary`) VALUES(?,?)"
```
```python
;
```
```python
//执行sql语句需要传递的参数
```
```python
//      Object[][] params = new Object[3][2];
```
```python
//      params[0] = new Object[]{"Tom2015",1000};
```
```python
//      params[1] = new Object[]{"Tom2016",2000};
```
```python
//      params[2] = new Object[]{"Tom2017",3000};
```
```python
//
```
```python
List<Object[]>
```
```python
list
```
```python
=
```
```python
new
```
```python
ArrayList<Object[]>();
```
```python
list
```
```python
.add(
```
```python
new
```
```python
Object[]{
```
```python
"Tom2015"
```
```python
,
```
```python
1000
```
```python
});
```
```python
list
```
```python
.add(
```
```python
new
```
```python
Object[]{
```
```python
"Tom2016"
```
```python
,
```
```python
2000
```
```python
});
```
```python
list
```
```python
.add(
```
```python
new
```
```python
Object[]{
```
```python
"Tom2017"
```
```python
,
```
```python
3000
```
```python
});
```
```python
template
```
```python
.batchUpdate(sql,
```
```python
list
```
```python
);
                }
        }
```
实验4：查询emp_id=5的数据库记录，封装为一个Java对象返回
分析：封装为一个对象返回的话，首先我们需要有一个与数据表对应的实体类！
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
JdbcTemplate template=ioc.getBean(JdbcTemplate.class);
            @Test
```
```python
public
```
```python
void
```
```python
test01
```
```python
(){
```
```python
//需要注意的是：sql语句中的别名要与对应实体类的属性名保持一致！
```
```python
String sql =
```
```python
"SELECT emp_id AS empId,emp_name AS empName,salary FROM employee WHERE emp_id=?"
```
```python
;
```
```python
//RowMapper是一个接口,这里我们使用其子类
```
```python
RowMapper<Employee> rowMapper =
```
```python
new
```
```python
BeanPropertyRowMapper<Employee>(Employee.class);
```
```python
//最后一个参数是可变参数，用于向sql语句中依次传递参数!
```
```python
Employee employee = template.queryForObject(sql, rowMapper,
```
```python
5
```
```python
);
                System.
```
```python
out
```
```python
.println(employee);
            }
        }
```
实验5：查询salary>4000的数据库记录，封装为List集合返回
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
JdbcTemplate template=ioc.getBean(JdbcTemplate.class);
            @Test
```
```python
public
```
```python
void
```
```python
test01
```
```python
(){
```
```python
//需要注意的是：sql语句中的别名要与对应实体类的属性名保持一致！
```
```python
String sql =
```
```python
"SELECT emp_id AS empId,emp_name AS empName,salary FROM employee WHERE salary > ?"
```
```python
;
```
```python
//RowMapper是一个接口,这里我们使用其子类
```
```python
RowMapper<Employee> rowMapper =
```
```python
new
```
```python
BeanPropertyRowMapper<Employee>(Employee.class);
```
```python
//该query方法查询出来的是一个list列表,query方法的最后一个参数是可变参数！
```
```python
List<Employee> list = template.query(sql, rowMapper,
```
```python
4000
```
```python
);
```
```python
for
```
```python
(Employee employee : list) {
                    System.
```
```python
out
```
```python
.println(employee);
                }
            }
        }
```
从上面可以看出，查询结果是一个实体还是一个list列表是靠template对象的不同方法实现的！
实验6：查询最大salary
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
JdbcTemplate template=ioc.getBean(JdbcTemplate.class);
        @Test
```
```python
public
```
```python
void
```
```python
test01
```
```python
(){
            String sql =
```
```python
"SELECT MAX(salary) FROM employee"
```
```python
;
```
```python
//需要指定返回值的类型,而且类型必须是包装类型
```
```python
Double maxSalary = template.queryForObject(sql, Double.class);
            System.
```
```python
out
```
```python
.println(maxSalary);
        }
    }
```
实验7：使用带有具名参数的SQL语句插入一条员工记录，并以Map形式传入参数值
具名参数:是指基于名称的，前面我们使用的都是用?作为占位符，然后是使用基于位置的！
如果要使用具名参数的sql语句就必须在spring配置文件中配置NamedParameterJdbcTemplat这个模板类，而不能使用
原来的JdbcTemplate，因为JdbcTemplate不能完成这样的任务！
```python
<!-- 加载properties文件中 信息 -->
```
```python
<
```
```python
context:property-placeholder
```
```python
location
```
```python
=
```
```python
"classpath:jdbc.properties"
```
```python
/>
```
```python
<!-- 配置数据源 -->
```
```python
<
```
```python
bean
```
```python
id
```
```python
=
```
```python
"comboPooledDataSource"
```
```python
class
```
```python
=
```
```python
"com.mchange.v2.c3p0.ComboPooledDataSource"
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"user"
```
```python
value
```
```python
=
```
```python
"${jdbc.user}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"password"
```
```python
value
```
```python
=
```
```python
"${jdbc.passowrd}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"jdbcUrl"
```
```python
value
```
```python
=
```
```python
"${jdbc.url}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"driverClass"
```
```python
value
```
```python
=
```
```python
"${jdbc.driver}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
</
```
```python
bean
```
```python
>
```
```python
<!-- 配置JdbcTemplate对应的bean， 并装配dataSource数据源属性-->
```
```python
<
```
```python
bean
```
```python
id
```
```python
=
```
```python
"jdbcTemplate"
```
```python
class
```
```python
=
```
```python
"org.springframework.jdbc.core.JdbcTemplate"
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"dataSource"
```
```python
ref
```
```python
=
```
```python
"comboPooledDataSource"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
</
```
```python
bean
```
```python
>
```
```python
<!-- 为了执行带有具名参数的SQL语句，需要配置NamedParameterJdbcTemplate -->
```
```python
<!-- 该NamedParameterJdbcTemplate类没有无参构造器，需要传入JdbcTemplate对象或者数据源对象[DataSource] -->
```
```python
<
```
```python
bean
```
```python
id
```
```python
=
```
```python
"namedParameterJdbcTemplate"
```
```python
class
```
```python
=
```
```python
"org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate"
```
```python
>
```
```python
<!-- 不能使用property标签配置哦 -->
```
```python
<
```
```python
constructor-arg
```
```python
ref
```
```python
=
```
```python
"jdbcTemplate"
```
```python
>
```
```python
</
```
```python
constructor-arg
```
```python
>
```
```python
</
```
```python
bean
```
```python
>
```
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
NamedParameterJdbcTemplate namedJdbcTemplate = ioc.getBean(NamedParameterJdbcTemplate.class);
            @Test
```
```python
public
```
```python
void
```
```python
test01
```
```python
(){
                String sql=
```
```python
"INSERT INTO employee(`emp_name`,`salary`) VALUES(:paramName,:paramSalary)"
```
```python
;
                Map<String,Object> paramMap =
```
```python
new
```
```python
HashMap<String,Object>();
                paramMap.put(
```
```python
"paramName"
```
```python
,
```
```python
"张学友"
```
```python
);
                paramMap.put(
```
```python
"paramSalary"
```
```python
,
```
```python
1000
```
```python
);
                namedJdbcTemplate.update(sql, paramMap);
            }
        }
```
实验8：重复实验7，以SqlParameterSource形式传入参数值
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
NamedParameterJdbcTemplate namedJdbcTemplate = ioc.getBean(NamedParameterJdbcTemplate.class);
            @Test
```
```python
public
```
```python
void
```
```python
test01
```
```python
(){
                String sql=
```
```python
"INSERT INTO employee(`emp_name`,`salary`) VALUES(:empName,:salary)"
```
```python
;
```
```python
//该BeanPropertySqlParameterSource类构造器需要一个对象参数，该对象参数是一个封装了sql语句参数的对象！
```
```python
//此时要求对象的属性名要和sql中的参数名保持一致！这里我们使用Employee对象来完成
```
```python
Employee employee=
```
```python
new
```
```python
Employee(
```
```python
null
```
```python
,
```
```python
"郭富城"
```
```python
,
```
```python
1500
```
```python
);
```
```python
//以实体对象的形式封装具名参数和值
```
```python
SqlParameterSource source =
```
```python
new
```
```python
BeanPropertySqlParameterSource(employee);
                namedJdbcTemplate.update(sql, source);
            }
        }
```
实验9：创建JdbcTemplateDao，自动装配JdbcTemplate对象
1.创建dao类：
```python
@Repository
```
```python
public
```
```python
class
```
```python
JdbcTemplateDao
```
```python
{
```
```python
@Autowired
```
```python
private
```
```python
JdbcTemplate jdbcTemplate;
```
```python
public
```
```python
void
```
```python
update
```
```python
(String sql,Object ...args){
            jdbcTemplate.update(sql, args);
        }
    }
```
2.配置spring的配置文件
```python
<!-- 配置扫描的包 -->
```
```python
<
```
```python
context:component-scan
```
```python
base-package
```
```python
=
```
```python
"com.neuedu.dao"
```
```python
>
```
```python
</
```
```python
context:component-scan
```
```python
>
```
```python
<!-- 加载properties文件中 信息 -->
```
```python
<
```
```python
context:property-placeholder
```
```python
location
```
```python
=
```
```python
"classpath:jdbc.properties"
```
```python
/>
```
```python
<!-- 配置数据源 -->
```
```python
<
```
```python
bean
```
```python
id
```
```python
=
```
```python
"comboPooledDataSource"
```
```python
class
```
```python
=
```
```python
"com.mchange.v2.c3p0.ComboPooledDataSource"
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"user"
```
```python
value
```
```python
=
```
```python
"${jdbc.user}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"password"
```
```python
value
```
```python
=
```
```python
"${jdbc.passowrd}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"jdbcUrl"
```
```python
value
```
```python
=
```
```python
"${jdbc.url}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"driverClass"
```
```python
value
```
```python
=
```
```python
"${jdbc.driver}"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
</
```
```python
bean
```
```python
>
```
```python
<!-- 配置JdbcTemplate对应的bean， 并装配dataSource数据源属性-->
```
```python
<
```
```python
bean
```
```python
id
```
```python
=
```
```python
"jdbcTemplate"
```
```python
class
```
```python
=
```
```python
"org.springframework.jdbc.core.JdbcTemplate"
```
```python
>
```
```python
<
```
```python
property
```
```python
name
```
```python
=
```
```python
"dataSource"
```
```python
ref
```
```python
=
```
```python
"comboPooledDataSource"
```
```python
>
```
```python
</
```
```python
property
```
```python
>
```
```python
</
```
```python
bean
```
```python
>
```
3.测试该dao
```python
public
```
```python
class
```
```python
TestDataSource {
```
```python
private
```
```python
ApplicationContext ioc =
```
```python
new
```
```python
ClassPathXmlApplicationContext(
```
```python
"applicationContext.xml"
```
```python
);
```
```python
private
```
```python
NamedParameterJdbcTemplate namedJdbcTemplate = ioc.getBean(NamedParameterJdbcTemplate.class);
    @Test
```
```python
public
```
```python
void
```
```python
test01
```
```python
(){
        JdbcTemplateDao dao = ioc.getBean(JdbcTemplateDao.class);
        String sql =
```
```python
"INSERT INTO employee(`emp_name`,`salary`) VALUES(?,?)"
```
```python
;
        dao.update(sql,
```
```python
"比尔盖茨"
```
```python
,
```
```python
10000000
```
```python
);
    }
}
```

