
# The Ethereum Virtual Machine（EVM）简介 - Wesley's Blog - CSDN博客


2018年05月18日 10:51:09[WesleyWang97](https://me.csdn.net/yinanmo5569)阅读数：804


# 概述
EVM是以太坊智能合约的运行时环境．它不仅仅是个沙盒，而是完全隔离的．这意味着代码在EVM中运行时没有办法连接网络，文件系统或者其他进程，甚至一个智能合约没有办法访问另一个智能合约．
官方文档地址：[https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html](https://solidity.readthedocs.io/en/v0.4.24/introduction-to-smart-contracts.html)
# 账号
以太坊有两种不同类型的账号共享着相同的地址空间：
外部账号(External accounts)，受公钥私钥(public-private key)，也就是人，控制
合约账号(contract accounts)，受存储在账号中的代码控制
外部账号的地址是由公钥决定的．而一个合约账号的地址是在合约创建时决定的（这个地址通过合约创建者的地址和从该地址发出过的交易数量计算得到的，也就是所谓的“nonce”）
无论帐户是否存储代码，这两类账户对 EVM 来说是一样的。
每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为**存储（storage）**。
此外，每个账户有一个以太币余额（ balance ）（单位是“Wei”），余额会因为发送包含以太币的交易而改变。
# 交易
交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。
如果目标账户含有代码，此代码会被执行，并以合约负载（payload）作为入参。
**如果目标账户是零账户（账户地址为 0 )，此交易将创建一个新合约**。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。这个用来创建合约的交易的 payload　会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要向合约发送真正的合约代码，而是发送能够产生真正代码的代码。
# Gas
一经创建，每笔交易都收取一定数量的 gas ，目的是限制执行交易所需要的工作量和为交易支付手续费。EVM 执行交易时，gas 将按特定规则逐渐耗尽。
**gas price**是交易发送者设置的一个值，发送者账户需要**预付的手续费 = gas_price * gas**。如果交易执行后还有剩余， gas 会原路返还。
无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前**调用帧（call frame）**所做的所有状态修改都将被回滚。
译者注：调用帧（call frame），指的是下文讲到的EVM的运行栈（stack）中当前操作所需要的若干元素。
# 存储，内存和栈
每个账户有一块持久化内存区称为**存储**。 存储是将256位字映射到256位字的键值存储区。 在合约中枚举存储是不可能的，且读存储的相对开销很高，修改存储的开销甚至更高。合约只能读写存储区内属于自己的部分。
第二个内存区称为**内存**，合约会试图为每一次消息调用获取一块被重新擦拭干净的内存实例。 内存是线性的，可按字节级寻址，但读的长度被限制为256位，而写的长度可以是8位或256位。当访问（无论是读还是写）之前从未访问过的内存字（word）时（无论是偏移到该字内的任何位置），内存将按字进行扩展（每个字是256位）。扩容也将消耗一定的gas。 随着内存使用量的增长，其费用也会增高（以平方级别）。
EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为**栈（stack）**的区域执行。栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。
# 指令集
EVM的指令集量应尽量少，以最大限度地避免可能导致共识问题的错误实现。所有的指令都是针对”256位的字（word）”这个基本的数据类型来进行操作。具备常用的算术、位、逻辑和比较操作。也可以做到有条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。
# 消息调用
合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源、目标、数据、以太币、gas和返回数据。事实上每个交易都由一个顶层消息调用组成，这个消息调用又可创建更多的消息调用。
合约可以决定在其内部的消息调用中，对于剩余的 gas ，应发送和保留多少。如果在内部消息调用时发生了out-of-gas异常（或其他任何异常），这将由一个被压入栈顶的错误值所指明。此时，只有与该内部消息调用一起发送的gas会被消耗掉。并且，Solidity中，发起调用的合约默认会触发一个手工的异常，以便异常可以从调用栈里“冒泡出来”。 如前文所述，被调用的合约（可以和调用者是同一个合约）会获得一块刚刚清空过的内存，并可以访问调用的payload——由被称为 calldata 的独立区域所提供的数据。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。 调用深度被**限制**为 1024 ，因此对于更加复杂的操作，我们应**使用循环而不是递归**。
# 委托调用/代码调用和库
有一种特殊类型的消息调用，被称为**委托调用(delegatecall)**。它和一般的消息调用的区别在于，目标地址的代码将在发起调用的合约的上下文中执行，并且**msg.sender**和**msg.value**不变。 这意味着一个合约可以在运行时从另外一个地址动态加载代码。存储、当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得 Solidity 可以实现”库“能力：可复用的代码库可以放在一个合约的存储上，如用来实现复杂的数据结构的库。
# 日志
有一种特殊的可索引的数据结构，其存储的数据可以一路映射直到区块层级。这个特性被称为**日志(logs)**，Solidity用它来实现**事件(events)**。合约创建之后就无法访问日志数据，但是这些数据可以从区块链外高效的访问。因为部分日志数据被存储在**布隆过滤器（Bloom filter)**中，我们可以高效并且加密安全地搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。
# 创建
合约甚至可以通过一个特殊的指令来创建其他合约（不是简单的调用零地址）。创建合约的调用**create calls**和普通消息调用的唯一区别在于，负载会被执行，执行的结果被存储为合约代码，调用者/创建者在栈上得到新合约的地址。
# 自毁
合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作**selfdestruct**。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。
尽管一个合约的代码中没有显式地调用**selfdestruct**，它仍然有可能通过**delegatecall**或**callcode**执行自毁操作。
目前，**外部账户**不能从状态中移除。

