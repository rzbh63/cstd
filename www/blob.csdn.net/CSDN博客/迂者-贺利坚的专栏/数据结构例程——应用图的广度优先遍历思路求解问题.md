
# 数据结构例程——应用图的广度优先遍历思路求解问题 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月03日 21:52:23[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2793


本文是[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]中第9课时[[BFS的应用](http://edu.csdn.net/course/detail/1595/24599?auto_start=1)]的例程。
（程序中graph.h是图存储结构的“算法库”中的头文件，详情请[单击链接…](http://blog.csdn.net/sxhelijian/article/details/49591419)）
1、最短路径
问题：求不带权连通图G中从顶点u到顶点v的一条最短路径。
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
data;
```
```python
//顶点编号
```
```python
int
```
```python
parent;
```
```python
//前一个顶点的位置
```
```python
} QUERE;
```
```python
//非环形队列类型
```
```python
void
```
```python
ShortPath(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v)
{
```
```python
//输出从顶点u到顶点v的最短逆路径
```
```python
ArcNode *p;
```
```python
int
```
```python
w,i;
    QUERE qu[MAXV];
```
```python
//非环形队列
```
```python
int
```
```python
front=-
```
```python
1
```
```python
,rear=-
```
```python
1
```
```python
;
```
```python
//队列的头、尾指针
```
```python
int
```
```python
visited[MAXV];
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
```
```python
//访问标记置初值0
```
```python
visited[i]=
```
```python
0
```
```python
;
    rear++;
```
```python
//顶点u进队
```
```python
qu[rear].data=u;
    qu[rear].parent=-
```
```python
1
```
```python
;
    visited[u]=
```
```python
1
```
```python
;
```
```python
while
```
```python
(front!=rear)
```
```python
//队不空循环
```
```python
{
        front++;
```
```python
//出队顶点w
```
```python
w=qu[front].data;
```
```python
if
```
```python
(w==v)
```
```python
//找到v时输出路径之逆并退出
```
```python
{
            i=front;
```
```python
//通过队列输出逆路径
```
```python
while
```
```python
(qu[i].parent!=-
```
```python
1
```
```python
)
            {
```
```python
printf
```
```python
(
```
```python
"%2d "
```
```python
,qu[i].data);
                i=qu[i].parent;
            }
```
```python
printf
```
```python
(
```
```python
"%2d\n"
```
```python
,qu[i].data);
```
```python
break
```
```python
;
        }
        p=G->adjlist[w].firstarc;
```
```python
//找w的第一个邻接点
```
```python
while
```
```python
(p!=NULL)
        {
```
```python
if
```
```python
(visited[p->adjvex]==
```
```python
0
```
```python
)
            {
                visited[p->adjvex]=
```
```python
1
```
```python
;
                rear++;
```
```python
//将w的未访问过的邻接点进队
```
```python
qu[rear].data=p->adjvex;
                qu[rear].parent=front;
            }
            p=p->nextarc;
```
```python
//找w的下一个邻接点
```
```python
}
    }
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
A[
```
```python
9
```
```python
][
```
```python
9
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
}
    };
```
```python
//请画出对应的有向图
```
```python
ArrayToList(A[
```
```python
0
```
```python
],
```
```python
9
```
```python
, G);
    ShortPath(G,
```
```python
0
```
```python
,
```
```python
7
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试用图结构
![这里写图片描述](https://img-blog.csdn.net/20151103214956718)
2、最远顶点
问题：求不带权连通图G中，距离顶点v最远的顶点k
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
int
```
```python
Maxdist(ALGraph *G,
```
```python
int
```
```python
v)
{
    ArcNode *p;
```
```python
int
```
```python
i,j,k;
```
```python
int
```
```python
Qu[MAXV];
```
```python
//环形队列
```
```python
int
```
```python
visited[MAXV];
```
```python
//访问标记数组
```
```python
int
```
```python
front=
```
```python
0
```
```python
,rear=
```
```python
0
```
```python
;
```
```python
//队列的头、尾指针
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
```
```python
//初始化访问标志数组
```
```python
visited[i]=
```
```python
0
```
```python
;
    rear++;
    Qu[rear]=v;
```
```python
//顶点v进队
```
```python
visited[v]=
```
```python
1
```
```python
;
```
```python
//标记v已访问
```
```python
while
```
```python
(rear!=front)
    {
        front=(front+
```
```python
1
```
```python
)%MAXV;
        k=Qu[front];
```
```python
//顶点k出队
```
```python
p=G->adjlist[k].firstarc;
```
```python
//找第一个邻接点
```
```python
while
```
```python
(p!=NULL)
```
```python
//所有未访问过的相邻点进队
```
```python
{
            j=p->adjvex;
```
```python
//邻接点为顶点j
```
```python
if
```
```python
(visited[j]==
```
```python
0
```
```python
)
```
```python
//若j未访问过
```
```python
{
                visited[j]=
```
```python
1
```
```python
;
                rear=(rear+
```
```python
1
```
```python
)%MAXV;
                Qu[rear]=j;
```
```python
//进队
```
```python
}
            p=p->nextarc;
```
```python
//找下一个邻接点
```
```python
}
    }
```
```python
return
```
```python
k;
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
A[
```
```python
9
```
```python
][
```
```python
9
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
}
    };
```
```python
//请画出对应的有向图
```
```python
ArrayToList(A[
```
```python
0
```
```python
],
```
```python
9
```
```python
, G);
```
```python
printf
```
```python
(
```
```python
"离顶点0最远的顶点:%d"
```
```python
,Maxdist(G,
```
```python
0
```
```python
));
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试用图结构
![这里写图片描述](https://img-blog.csdn.net/20151103215144072)

