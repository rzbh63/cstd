
# Tensorflow源码解析2 -- 前后端连接的桥梁 - Session - 谢杨易的博客 - CSDN博客

2018年11月15日 21:08:58[谢杨易](https://me.csdn.net/u013510838)阅读数：1630


Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)
# 1 Session概述
Session是TensorFlow前后端连接的桥梁。用户利用session使得client能够与master的执行引擎建立连接，并通过session.run()来触发一次计算。它建立了一套上下文环境，封装了operation计算以及tensor求值的环境。
session创建时，系统会分配一些资源，比如graph引用、要连接的计算引擎的名称等。故计算完毕后，需要使用session.close()关闭session，避免引起内存泄漏，特别是graph无法释放的问题。可以显式调用session.close(),或利用with上下文管理器，或者直接使用InteractiveSession。
session之间采用共享graph的方式来提高运行效率。一个session只能运行一个graph实例，但一个graph可以运行在多个session中。一般情况下，创建session时如果不指定Graph实例，则会使用系统默认Graph。常见情况下，我们都是使用一个graph，即默认graph。当session创建时，不会重新创建graph实例，而是默认graph引用计数加1。当session close时，引用计数减1。只有引用计数为0时，graph才会被回收。这种graph共享的方式，大大减少了graph创建和回收的资源消耗，优化了TensorFlow运行效率。

# 2 默认session
op运算和tensor求值时，如果没有指定运行在哪个session中，则会运行在默认session中。通过session.as_default()可以将自己设置为默认session。但个人建议最好还是通过session.run(operator)和session.run(tensor)来进行op运算和tensor求值。
### operation.run()
operation.run()等价于tf.get_default_session().run(operation)
```python
@tf_export
```
```python
(
```
```python
"Operation"
```
```python
)
```
```python
class
```
```python
Operation
```
```python
(
```
```python
object
```
```python
)
```
```python
:
```
```python
# 通过operation.run()调用，进行operation计算
```
```python
def
```
```python
run
```
```python
(
```
```python
self
```
```python
,
```
```python
feed_dict
```
```python
=
```
```python
None
```
```python
,
```
```python
session
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
_run_using_default_session
```
```python
(
```
```python
self
```
```python
,
```
```python
feed_dict
```
```python
,
```
```python
self
```
```python
.
```
```python
graph
```
```python
,
```
```python
session
```
```python
)
```
```python
def
```
```python
_run_using_default_session
```
```python
(
```
```python
operation
```
```python
,
```
```python
feed_dict
```
```python
,
```
```python
graph
```
```python
,
```
```python
session
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
# 没有指定session，则获取默认session
```
```python
if
```
```python
session
```
```python
is
```
```python
None
```
```python
:
```
```python
session
```
```python
=
```
```python
get_default_session
```
```python
(
```
```python
)
```
```python
# 最终还是通过session.run()进行运行的。tf中任何运算，都是通过session来run的。
```
```python
# 通过session来建立client和master的连接，并将graph发送给master，master再进行执行
```
```python
session
```
```python
.
```
```python
run
```
```python
(
```
```python
operation
```
```python
,
```
```python
feed_dict
```
```python
)
```
### tensor.eval()
tensor.eval()等价于tf.get_default_session().run(tensor), 如下
```python
@tf_export
```
```python
(
```
```python
"Tensor"
```
```python
)
```
```python
class
```
```python
Tensor
```
```python
(
```
```python
_TensorLike
```
```python
)
```
```python
:
```
```python
# 通过tensor.eval()调用，进行tensor运算
```
```python
def
```
```python
eval
```
```python
(
```
```python
self
```
```python
,
```
```python
feed_dict
```
```python
=
```
```python
None
```
```python
,
```
```python
session
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
return
```
```python
_eval_using_default_session
```
```python
(
```
```python
self
```
```python
,
```
```python
feed_dict
```
```python
,
```
```python
self
```
```python
.
```
```python
graph
```
```python
,
```
```python
session
```
```python
)
```
```python
def
```
```python
_eval_using_default_session
```
```python
(
```
```python
tensors
```
```python
,
```
```python
feed_dict
```
```python
,
```
```python
graph
```
```python
,
```
```python
session
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
# 如果没有指定session，则获取默认session
```
```python
if
```
```python
session
```
```python
is
```
```python
None
```
```python
:
```
```python
session
```
```python
=
```
```python
get_default_session
```
```python
(
```
```python
)
```
```python
return
```
```python
session
```
```python
.
```
```python
run
```
```python
(
```
```python
tensors
```
```python
,
```
```python
feed_dict
```
```python
)
```
### 默认session的管理
tf通过运行时维护的session本地线程栈，来管理默认session。故不同的线程会有不同的默认session，默认session是线程作用域的。
```python
# session栈
```
```python
_default_session_stack
```
```python
=
```
```python
_DefaultStack
```
```python
(
```
```python
)
```
```python
# 获取默认session的接口
```
```python
@tf_export
```
```python
(
```
```python
"get_default_session"
```
```python
)
```
```python
def
```
```python
get_default_session
```
```python
(
```
```python
)
```
```python
:
```
```python
return
```
```python
_default_session_stack
```
```python
.
```
```python
get_default
```
```python
(
```
```python
)
```
```python
# _DefaultStack默认session栈是线程相关的
```
```python
class
```
```python
_DefaultStack
```
```python
(
```
```python
threading
```
```python
.
```
```python
local
```
```python
)
```
```python
:
```
```python
# 默认session栈的创建，其实就是一个list
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
super
```
```python
(
```
```python
_DefaultStack
```
```python
,
```
```python
self
```
```python
)
```
```python
.
```
```python
__init__
```
```python
(
```
```python
)
```
```python
self
```
```python
.
```
```python
_enforce_nesting
```
```python
=
```
```python
True
```
```python
self
```
```python
.
```
```python
stack
```
```python
=
```
```python
[
```
```python
]
```
```python
# 获取默认session
```
```python
def
```
```python
get_default
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
return
```
```python
self
```
```python
.
```
```python
stack
```
```python
[
```
```python
-
```
```python
1
```
```python
]
```
```python
if
```
```python
len
```
```python
(
```
```python
self
```
```python
.
```
```python
stack
```
```python
)
```
```python
>=
```
```python
1
```
```python
else
```
```python
None
```

# 3 前端Session类型
### session类图
会话Session的UML类图如下
![](https://img.alicdn.com/tfs/TB1gbOcpMTqK1RjSZPhXXXfOFXa-1210-452.png)
分为两种类型，普通Session和交互式InteractiveSession。InteractiveSession和Session基本相同，区别在于
InteractiveSession创建后，会将自己替换为默认session。使得之后operation.run()和tensor.eval()的执行通过这个默认session来进行。特别适合Python交互式环境。
InteractiveSession自带with上下文管理器。它在创建时和关闭时会调用上下文管理器的enter和exit方法，从而进行资源的申请和释放，避免内存泄漏问题。这同样很适合Python交互式环境。
Session和InteractiveSession的代码逻辑不多，主要逻辑均在其父类BaseSession中。主要代码如下
```python
@tf_export
```
```python
(
```
```python
'Session'
```
```python
)
```
```python
class
```
```python
Session
```
```python
(
```
```python
BaseSession
```
```python
)
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
,
```
```python
target
```
```python
=
```
```python
''
```
```python
,
```
```python
graph
```
```python
=
```
```python
None
```
```python
,
```
```python
config
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
# session创建的主要逻辑都在其父类BaseSession中
```
```python
super
```
```python
(
```
```python
Session
```
```python
,
```
```python
self
```
```python
)
```
```python
.
```
```python
__init__
```
```python
(
```
```python
target
```
```python
,
```
```python
graph
```
```python
,
```
```python
config
```
```python
=
```
```python
config
```
```python
)
```
```python
self
```
```python
.
```
```python
_default_graph_context_manager
```
```python
=
```
```python
None
```
```python
self
```
```python
.
```
```python
_default_session_context_manager
```
```python
=
```
```python
None
```
```python
@tf_export
```
```python
(
```
```python
'InteractiveSession'
```
```python
)
```
```python
class
```
```python
InteractiveSession
```
```python
(
```
```python
BaseSession
```
```python
)
```
```python
:
```
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
,
```
```python
target
```
```python
=
```
```python
''
```
```python
,
```
```python
graph
```
```python
=
```
```python
None
```
```python
,
```
```python
config
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
self
```
```python
.
```
```python
_explicitly_closed
```
```python
=
```
```python
False
```
```python
# 将自己设置为default session
```
```python
self
```
```python
.
```
```python
_default_session
```
```python
=
```
```python
self
```
```python
.
```
```python
as_default
```
```python
(
```
```python
)
```
```python
self
```
```python
.
```
```python
_default_session
```
```python
.
```
```python
enforce_nesting
```
```python
=
```
```python
False
```
```python
# 自动调用上下文管理器的__enter__()方法
```
```python
self
```
```python
.
```
```python
_default_session
```
```python
.
```
```python
__enter__
```
```python
(
```
```python
)
```
```python
self
```
```python
.
```
```python
_explicit_graph
```
```python
=
```
```python
graph
```
```python
def
```
```python
close
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
super
```
```python
(
```
```python
InteractiveSession
```
```python
,
```
```python
self
```
```python
)
```
```python
.
```
```python
close
```
```python
(
```
```python
)
```
```python
## 省略无关代码
```
```python
## 自动调用上下文管理器的__exit__()方法，避免内存泄漏
```
```python
self
```
```python
.
```
```python
_default_session
```
```python
.
```
```python
__exit__
```
```python
(
```
```python
None
```
```python
,
```
```python
None
```
```python
,
```
```python
None
```
```python
)
```
```python
self
```
```python
.
```
```python
_default_session
```
```python
=
```
```python
None
```
### BaseSession
BaseSession基本包含了所有的会话实现逻辑。包括会话的整个生命周期，也就是创建 执行 关闭和销毁四个阶段。生命周期后面详细分析。BaseSession包含的主要成员变量有graph引用，序列化的graph_def,  要连接的tf引擎target，session配置信息config等。

# 4 后端Session类型
在后端master中，根据前端client调用tf.Session(target=’’, graph=None, config=None)时指定的target，来创建不同的Session。target为要连接的tf后端执行引擎，默认为空字符串。Session创建采用了抽象工厂模式，如果为空字符串，则创建本地DirectSession，如果以grpc://开头，则创建分布式GrpcSession。类图如下
![](https://img.alicdn.com/tfs/TB1wzqEpOrpK1RjSZFhXXXSdXXa-1262-538.png)
DirectSession只能利用本地设备，将任务创建到本地的CPU GPU上。而GrpcSession则可以利用远端分布式设备，将任务创建到其他机器的CPU GPU上，然后通过grpc协议进行通信。grpc协议是谷歌发明并开源的远程通信协议。

# 5 Session生命周期
Session作为前后端连接的桥梁，以及上下文运行环境，其生命周期尤其关键。大致分为4个阶段
创建：通过tf.Session()创建session实例，进行系统资源分配，特别是graph引用计数加1
运行：通过session.run()触发计算的执行，client会将整图graph传递给master，由master进行执行
关闭：通过session.close()来关闭，会进行系统资源的回收，特别是graph引用计数减1.
销毁：Python垃圾回收器进行GC时，调用session.__del__()进行回收。
生命周期方法入口基本都在前端Python的BaseSession中，它会通过swig自动生成的函数符号映射关系，调用C层的实现。
### 5.1 创建
先从BaseSession类的init方法看起，只保留了主要代码。
```python
def
```
```python
__init__
```
```python
(
```
```python
self
```
```python
,
```
```python
target
```
```python
=
```
```python
''
```
```python
,
```
```python
graph
```
```python
=
```
```python
None
```
```python
,
```
```python
config
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
# graph表示构建的图。TensorFlow的一个session会对应一个图。这个图包含了所有涉及到的算子
```
```python
# graph如果没有设置（通常都不会设置），则使用默认graph
```
```python
if
```
```python
graph
```
```python
is
```
```python
None
```
```python
:
```
```python
self
```
```python
.
```
```python
_graph
```
```python
=
```
```python
ops
```
```python
.
```
```python
get_default_graph
```
```python
(
```
```python
)
```
```python
else
```
```python
:
```
```python
self
```
```python
.
```
```python
_graph
```
```python
=
```
```python
graph
    self
```
```python
.
```
```python
_opened
```
```python
=
```
```python
False
```
```python
self
```
```python
.
```
```python
_closed
```
```python
=
```
```python
False
```
```python
self
```
```python
.
```
```python
_current_version
```
```python
=
```
```python
0
```
```python
self
```
```python
.
```
```python
_extend_lock
```
```python
=
```
```python
threading
```
```python
.
```
```python
Lock
```
```python
(
```
```python
)
```
```python
# target为要连接的tf执行引擎
```
```python
if
```
```python
target
```
```python
is
```
```python
not
```
```python
None
```
```python
:
```
```python
self
```
```python
.
```
```python
_target
```
```python
=
```
```python
compat
```
```python
.
```
```python
as_bytes
```
```python
(
```
```python
target
```
```python
)
```
```python
else
```
```python
:
```
```python
self
```
```python
.
```
```python
_target
```
```python
=
```
```python
None
```
```python
self
```
```python
.
```
```python
_delete_lock
```
```python
=
```
```python
threading
```
```python
.
```
```python
Lock
```
```python
(
```
```python
)
```
```python
self
```
```python
.
```
```python
_dead_handles
```
```python
=
```
```python
[
```
```python
]
```
```python
# config为session的配置信息
```
```python
if
```
```python
config
```
```python
is
```
```python
not
```
```python
None
```
```python
:
```
```python
self
```
```python
.
```
```python
_config
```
```python
=
```
```python
config
      self
```
```python
.
```
```python
_add_shapes
```
```python
=
```
```python
config
```
```python
.
```
```python
graph_options
```
```python
.
```
```python
infer_shapes
```
```python
else
```
```python
:
```
```python
self
```
```python
.
```
```python
_config
```
```python
=
```
```python
None
```
```python
self
```
```python
.
```
```python
_add_shapes
```
```python
=
```
```python
False
```
```python
self
```
```python
.
```
```python
_created_with_new_api
```
```python
=
```
```python
ops
```
```python
.
```
```python
_USE_C_API
```
```python
# 调用C层来创建session
```
```python
self
```
```python
.
```
```python
_session
```
```python
=
```
```python
None
```
```python
opts
```
```python
=
```
```python
tf_session
```
```python
.
```
```python
TF_NewSessionOptions
```
```python
(
```
```python
target
```
```python
=
```
```python
self
```
```python
.
```
```python
_target
```
```python
,
```
```python
config
```
```python
=
```
```python
config
```
```python
)
```
```python
self
```
```python
.
```
```python
_session
```
```python
=
```
```python
tf_session
```
```python
.
```
```python
TF_NewSession
```
```python
(
```
```python
self
```
```python
.
```
```python
_graph
```
```python
.
```
```python
_c_graph
```
```python
,
```
```python
opts
```
```python
,
```
```python
status
```
```python
)
```
BaseSession先进行成员变量的赋值，然后调用TF_NewSession来创建session。TF_NewSession()方法由swig自动生成，在bazel-bin/tensorflow/python/pywrap_tensorflow_internal.py中
```python
def
```
```python
TF_NewSession
```
```python
(
```
```python
graph
```
```python
,
```
```python
opts
```
```python
,
```
```python
status
```
```python
)
```
```python
:
```
```python
return
```
```python
_pywrap_tensorflow_internal
```
```python
.
```
```python
TF_NewSession
```
```python
(
```
```python
graph
```
```python
,
```
```python
opts
```
```python
,
```
```python
status
```
```python
)
```
_pywrap_tensorflow_internal包含了C层函数的符号表。在swig模块import时，会加载pywrap_tensorflow_internal.so动态链接库，从而得到符号表。在pywrap_tensorflow_internal.cc中，注册了供Python调用的函数的符号表，从而实现Python到C的函数映射和调用。
```python
// c++函数调用的符号表，Python通过它可以调用到C层代码。符号表和动态链接库由swig自动生成
```
```python
static
```
```python
PyMethodDef SwigMethods
```
```python
[
```
```python
]
```
```python
=
```
```python
{
```
```python
// .. 省略其他函数定义
```
```python
// TF_NewSession的符号表，通过这个映射，Python中就可以调用到C层代码了。
```
```python
{
```
```python
(
```
```python
char
```
```python
*
```
```python
)
```
```python
"TF_NewSession"
```
```python
,
```
```python
_wrap_TF_NewSession
```
```python
,
```
```python
METH_VARARGS
```
```python
,
```
```python
NULL
```
```python
}
```
```python
,
```
```python
// ... 省略其他函数定义
```
```python
}
```
最终调用到c_api.c中的TF_NewSession()
```python
// TF_NewSession创建session的新实现，在C层后端代码中
```
```python
TF_Session
```
```python
*
```
```python
TF_NewSession
```
```python
(
```
```python
TF_Graph
```
```python
*
```
```python
graph
```
```python
,
```
```python
const
```
```python
TF_SessionOptions
```
```python
*
```
```python
opt
```
```python
,
```
```python
TF_Status
```
```python
*
```
```python
status
```
```python
)
```
```python
{
```
```python
Session
```
```python
*
```
```python
session
```
```python
;
```
```python
// 创建session
```
```python
status
```
```python
->
```
```python
status
```
```python
=
```
```python
NewSession
```
```python
(
```
```python
opt
```
```python
->
```
```python
options
```
```python
,
```
```python
&
```
```python
session
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
status
```
```python
->
```
```python
status
```
```python
.
```
```python
ok
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
TF_Session
```
```python
*
```
```python
new_session
```
```python
=
```
```python
new
```
```python
TF_Session
```
```python
(
```
```python
session
```
```python
,
```
```python
graph
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
graph
```
```python
!=
```
```python
nullptr
```
```python
)
```
```python
{
```
```python
// 采用了引用计数方式，多个session共享一个图实例，效率更高。
```
```python
// session创建时，引用计数加1。session close时引用计数减1。引用计数为0时，graph才会被回收。
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
graph
```
```python
->
```
```python
mu
```
```python
)
```
```python
;
```
```python
graph
```
```python
->
```
```python
sessions
```
```python
[
```
```python
new_session
```
```python
]
```
```python
=
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
new_session
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
DCHECK_EQ
```
```python
(
```
```python
nullptr
```
```python
,
```
```python
session
```
```python
)
```
```python
;
```
```python
return
```
```python
nullptr
```
```python
;
```
```python
}
```
```python
}
```
session创建时，并创建graph，而是采用共享方式，只是引用计数加1了。这种方式减少了session创建和关闭时的资源消耗，提高了运行效率。NewSession()根据前端传递的target，使用sessionFactory创建对应的TensorFlow::Session实例。
```python
Status
```
```python
NewSession
```
```python
(
```
```python
const
```
```python
SessionOptions
```
```python
&
```
```python
options
```
```python
,
```
```python
Session
```
```python
*
```
```python
*
```
```python
out_session
```
```python
)
```
```python
{
```
```python
SessionFactory
```
```python
*
```
```python
factory
```
```python
;
```
```python
const
```
```python
Status s
```
```python
=
```
```python
SessionFactory
```
```python
:
```
```python
:
```
```python
GetFactory
```
```python
(
```
```python
options
```
```python
,
```
```python
&
```
```python
factory
```
```python
)
```
```python
;
```
```python
// 通过sessionFactory创建多态的Session。本地session为DirectSession，分布式为GRPCSession
```
```python
*
```
```python
out_session
```
```python
=
```
```python
factory
```
```python
->
```
```python
NewSession
```
```python
(
```
```python
options
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
*
```
```python
out_session
```
```python
)
```
```python
{
```
```python
return
```
```python
errors
```
```python
:
```
```python
:
```
```python
Internal
```
```python
(
```
```python
"Failed to create session."
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
创建session采用了抽象工厂模式。根据client传递的target，来创建不同的session。如果target为空字符串，则创建本地DirectSession。如果以grpc://开头，则创建分布式GrpcSession。TensorFlow包含本地运行时和分布式运行时两种运行模式。
下面来看DirectSessionFactory的NewSession()方法
```python
class DirectSessionFactory
```
```python
:
```
```python
public SessionFactory
```
```python
{
```
```python
public
```
```python
:
```
```python
Session
```
```python
*
```
```python
NewSession
```
```python
(
```
```python
const
```
```python
SessionOptions
```
```python
&
```
```python
options
```
```python
)
```
```python
override
```
```python
{
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Device
```
```python
*
```
```python
>
```
```python
devices
```
```python
;
```
```python
// job在本地执行
```
```python
const
```
```python
Status s
```
```python
=
```
```python
DeviceFactory
```
```python
:
```
```python
:
```
```python
AddDevices
```
```python
(
```
```python
options
```
```python
,
```
```python
"/job:localhost/replica:0/task:0"
```
```python
,
```
```python
&
```
```python
devices
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
s
```
```python
.
```
```python
ok
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
LOG
```
```python
(
```
```python
ERROR
```
```python
)
```
```python
<<
```
```python
s
```
```python
;
```
```python
return
```
```python
nullptr
```
```python
;
```
```python
}
```
```python
DirectSession
```
```python
*
```
```python
session
```
```python
=
```
```python
new
```
```python
DirectSession
```
```python
(
```
```python
options
```
```python
,
```
```python
new
```
```python
DeviceMgr
```
```python
(
```
```python
devices
```
```python
)
```
```python
,
```
```python
this
```
```python
)
```
```python
;
```
```python
{
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
sessions_lock_
```
```python
)
```
```python
;
```
```python
sessions_
```
```python
.
```
```python
push_back
```
```python
(
```
```python
session
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
session
```
```python
;
```
```python
}
```
GrpcSessionFactory的NewSession()方法就不详细分析了，它会将job任务创建在分布式设备上，各job通过grpc协议通信。
### 5.2 运行
通过session.run()可以启动graph的执行。入口在BaseSession的run()方法中, 同样只列出关键代码
```python
class
```
```python
BaseSession
```
```python
(
```
```python
SessionInterface
```
```python
)
```
```python
:
```
```python
def
```
```python
run
```
```python
(
```
```python
self
```
```python
,
```
```python
fetches
```
```python
,
```
```python
feed_dict
```
```python
=
```
```python
None
```
```python
,
```
```python
options
```
```python
=
```
```python
None
```
```python
,
```
```python
run_metadata
```
```python
=
```
```python
None
```
```python
)
```
```python
:
```
```python
# fetches可以为单个变量，或者数组，或者元组。它是图的一部分，可以是操作operation，也可以是数据tensor，或者他们的名字String
```
```python
# feed_dict为对应placeholder的实际训练数据，它的类型为字典
```
```python
result
```
```python
=
```
```python
self
```
```python
.
```
```python
_run
```
```python
(
```
```python
None
```
```python
,
```
```python
fetches
```
```python
,
```
```python
feed_dict
```
```python
,
```
```python
options_ptr
```
```python
,
```
```python
run_metadata_ptr
```
```python
)
```
```python
return
```
```python
result
```
```python
def
```
```python
_run
```
```python
(
```
```python
self
```
```python
,
```
```python
handle
```
```python
,
```
```python
fetches
```
```python
,
```
```python
feed_dict
```
```python
,
```
```python
options
```
```python
,
```
```python
run_metadata
```
```python
)
```
```python
:
```
```python
# 创建fetch处理器fetch_handler
```
```python
fetch_handler
```
```python
=
```
```python
_FetchHandler
```
```python
(
```
```python
self
```
```python
.
```
```python
_graph
```
```python
,
```
```python
fetches
```
```python
,
```
```python
feed_dict_tensor
```
```python
,
```
```python
feed_handles
```
```python
=
```
```python
feed_handles
```
```python
)
```
```python
# 经过不同类型的fetch_handler处理，得到最终的fetches和targets
```
```python
# targets为要执行的operation，fetches为要执行的tensor
```
```python
_
```
```python
=
```
```python
self
```
```python
.
```
```python
_update_with_movers
```
```python
(
```
```python
feed_dict_tensor
```
```python
,
```
```python
feed_map
```
```python
)
```
```python
final_fetches
```
```python
=
```
```python
fetch_handler
```
```python
.
```
```python
fetches
```
```python
(
```
```python
)
```
```python
final_targets
```
```python
=
```
```python
fetch_handler
```
```python
.
```
```python
targets
```
```python
(
```
```python
)
```
```python
# 开始运行
```
```python
if
```
```python
final_fetches
```
```python
or
```
```python
final_targets
```
```python
or
```
```python
(
```
```python
handle
```
```python
and
```
```python
feed_dict_tensor
```
```python
)
```
```python
:
```
```python
results
```
```python
=
```
```python
self
```
```python
.
```
```python
_do_run
```
```python
(
```
```python
handle
```
```python
,
```
```python
final_targets
```
```python
,
```
```python
final_fetches
```
```python
,
```
```python
feed_dict_tensor
```
```python
,
```
```python
options
```
```python
,
```
```python
run_metadata
```
```python
)
```
```python
else
```
```python
:
```
```python
results
```
```python
=
```
```python
[
```
```python
]
```
```python
# 输出结果到results中
```
```python
return
```
```python
fetch_handler
```
```python
.
```
```python
build_results
```
```python
(
```
```python
self
```
```python
,
```
```python
results
```
```python
)
```
```python
def
```
```python
_do_run
```
```python
(
```
```python
self
```
```python
,
```
```python
handle
```
```python
,
```
```python
target_list
```
```python
,
```
```python
fetch_list
```
```python
,
```
```python
feed_dict
```
```python
,
```
```python
options
```
```python
,
```
```python
run_metadata
```
```python
)
```
```python
:
```
```python
# 将要运行的operation添加到graph中
```
```python
self
```
```python
.
```
```python
_extend_graph
```
```python
(
```
```python
)
```
```python
# 执行一次运行run，会调用底层C来实现
```
```python
return
```
```python
tf_session
```
```python
.
```
```python
TF_SessionPRunSetup_wrapper
```
```python
(
```
```python
session
```
```python
,
```
```python
feed_list
```
```python
,
```
```python
fetch_list
```
```python
,
```
```python
target_list
```
```python
,
```
```python
status
```
```python
)
```
```python
# 将要运行的operation添加到graph中
```
```python
def
```
```python
_extend_graph
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
with
```
```python
self
```
```python
.
```
```python
_extend_lock
```
```python
:
```
```python
if
```
```python
self
```
```python
.
```
```python
_graph
```
```python
.
```
```python
version
```
```python
>
```
```python
self
```
```python
.
```
```python
_current_version
```
```python
:
```
```python
# 生成graph_def对象，它是graph的序列化表示
```
```python
graph_def
```
```python
,
```
```python
self
```
```python
.
```
```python
_current_version
```
```python
=
```
```python
self
```
```python
.
```
```python
_graph
```
```python
.
```
```python
_as_graph_def
```
```python
(
```
```python
from_version
```
```python
=
```
```python
self
```
```python
.
```
```python
_current_version
```
```python
,
```
```python
add_shapes
```
```python
=
```
```python
self
```
```python
.
```
```python
_add_shapes
```
```python
)
```
```python
# 通过TF_ExtendGraph将序列化后的graph，也就是graph_def传递给后端
```
```python
with
```
```python
errors
```
```python
.
```
```python
raise_exception_on_not_ok_status
```
```python
(
```
```python
)
```
```python
as
```
```python
status
```
```python
:
```
```python
tf_session
```
```python
.
```
```python
TF_ExtendGraph
```
```python
(
```
```python
self
```
```python
.
```
```python
_session
```
```python
,
```
```python
graph_def
```
```python
.
```
```python
SerializeToString
```
```python
(
```
```python
)
```
```python
,
```
```python
status
```
```python
)
```
```python
self
```
```python
.
```
```python
_opened
```
```python
=
```
```python
True
```
逻辑还是十分复杂的，主要有一下几步
入参处理，创建fetch处理器fetch_handler，得到最终要执行的operation和tensor
对graph进行序列化，生成graph_def对象
将序列化后的grap_def对象传递给后端master。
通过后端master来run。
我们分别来看extend和run。
#### 5.2.1 extend添加节点到graph中
TF_ExtendGraph()会调用到c_api中，这个逻辑同样通过swig工具自动生成。下面看c_api.cc中的TF_ExtendGraph()方法
```python
// 增加节点到graph中，proto为序列化后的graph
```
```python
void
```
```python
TF_ExtendGraph
```
```python
(
```
```python
TF_DeprecatedSession
```
```python
*
```
```python
s
```
```python
,
```
```python
const
```
```python
void
```
```python
*
```
```python
proto
```
```python
,
```
```python
size_t proto_len
```
```python
,
```
```python
TF_Status
```
```python
*
```
```python
status
```
```python
)
```
```python
{
```
```python
GraphDef g
```
```python
;
```
```python
// 先将proto反序列化，得到client传递的graph，放入g中
```
```python
if
```
```python
(
```
```python
!
```
```python
tensorflow
```
```python
:
```
```python
:
```
```python
ParseProtoUnlimited
```
```python
(
```
```python
&
```
```python
g
```
```python
,
```
```python
proto
```
```python
,
```
```python
proto_len
```
```python
)
```
```python
)
```
```python
{
```
```python
status
```
```python
->
```
```python
status
```
```python
=
```
```python
InvalidArgument
```
```python
(
```
```python
"Invalid GraphDef"
```
```python
)
```
```python
;
```
```python
return
```
```python
;
```
```python
}
```
```python
// 再调用session的extend方法。根据创建的不同session类型，多态调用不同方法。
```
```python
status
```
```python
->
```
```python
status
```
```python
=
```
```python
s
```
```python
->
```
```python
session
```
```python
->
```
```python
Extend
```
```python
(
```
```python
g
```
```python
)
```
```python
;
```
```python
}
```
后端系统根据生成的Session类型，多态的调用Extend方法。如果是本地session，则调用DirectSession的Extend()方法。如果是分布式session，则调用GrpcSession的相关方法。下面来看GrpcSession的Extend方法。
```python
Status GrpcSession
```
```python
:
```
```python
:
```
```python
Extend
```
```python
(
```
```python
const
```
```python
GraphDef
```
```python
&
```
```python
graph
```
```python
)
```
```python
{
```
```python
CallOptions call_options
```
```python
;
```
```python
call_options
```
```python
.
```
```python
SetTimeout
```
```python
(
```
```python
options_
```
```python
.
```
```python
config
```
```python
.
```
```python
operation_timeout_in_ms
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
return
```
```python
ExtendImpl
```
```python
(
```
```python
&
```
```python
call_options
```
```python
,
```
```python
graph
```
```python
)
```
```python
;
```
```python
}
```
```python
Status GrpcSession
```
```python
:
```
```python
:
```
```python
ExtendImpl
```
```python
(
```
```python
CallOptions
```
```python
*
```
```python
call_options
```
```python
,
```
```python
const
```
```python
GraphDef
```
```python
&
```
```python
graph
```
```python
)
```
```python
{
```
```python
bool handle_is_empty
```
```python
;
```
```python
{
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
mu_
```
```python
)
```
```python
;
```
```python
handle_is_empty
```
```python
=
```
```python
handle_
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
if
```
```python
(
```
```python
handle_is_empty
```
```python
)
```
```python
{
```
```python
// 如果graph句柄为空，则表明graph还没有创建好，此时extend就等同于create
```
```python
return
```
```python
Create
```
```python
(
```
```python
graph
```
```python
)
```
```python
;
```
```python
}
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
mu_
```
```python
)
```
```python
;
```
```python
ExtendSessionRequest req
```
```python
;
```
```python
req
```
```python
.
```
```python
set_session_handle
```
```python
(
```
```python
handle_
```
```python
)
```
```python
;
```
```python
*
```
```python
req
```
```python
.
```
```python
mutable_graph_def
```
```python
(
```
```python
)
```
```python
=
```
```python
graph
```
```python
;
```
```python
req
```
```python
.
```
```python
set_current_graph_version
```
```python
(
```
```python
current_graph_version_
```
```python
)
```
```python
;
```
```python
ExtendSessionResponse resp
```
```python
;
```
```python
// 调用底层实现，来添加节点到graph中
```
```python
Status s
```
```python
=
```
```python
master_
```
```python
->
```
```python
ExtendSession
```
```python
(
```
```python
call_options
```
```python
,
```
```python
&
```
```python
req
```
```python
,
```
```python
&
```
```python
resp
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
s
```
```python
.
```
```python
ok
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
current_graph_version_
```
```python
=
```
```python
resp
```
```python
.
```
```python
new_graph_version
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
s
```
```python
;
```
```python
}
```
Extend()方法中要注意的一点是，如果是首次执行Extend(), 则要先调用Create()方法进行graph的注册。否则才是执行添加节点到graph中。
#### 5.2.2 run执行图的计算
同样，Python通过swig自动生成的代码，来实现对C API的调用。C层实现在c_api.cc的TF_Run()中。
```python
// session.run()的C层实现
```
```python
void
```
```python
TF_Run
```
```python
(
```
```python
TF_DeprecatedSession
```
```python
*
```
```python
s
```
```python
,
```
```python
const
```
```python
TF_Buffer
```
```python
*
```
```python
run_options
```
```python
,
```
```python
// Input tensors，输入的数据tensor
```
```python
const
```
```python
char
```
```python
*
```
```python
*
```
```python
c_input_names
```
```python
,
```
```python
TF_Tensor
```
```python
*
```
```python
*
```
```python
c_inputs
```
```python
,
```
```python
int
```
```python
ninputs
```
```python
,
```
```python
// Output tensors，运行计算后输出的数据tensor
```
```python
const
```
```python
char
```
```python
*
```
```python
*
```
```python
c_output_names
```
```python
,
```
```python
TF_Tensor
```
```python
*
```
```python
*
```
```python
c_outputs
```
```python
,
```
```python
int
```
```python
noutputs
```
```python
,
```
```python
// Target nodes，要运行的节点
```
```python
const
```
```python
char
```
```python
*
```
```python
*
```
```python
c_target_oper_names
```
```python
,
```
```python
int
```
```python
ntargets
```
```python
,
```
```python
TF_Buffer
```
```python
*
```
```python
run_metadata
```
```python
,
```
```python
TF_Status
```
```python
*
```
```python
status
```
```python
)
```
```python
{
```
```python
// 省略一段代码
```
```python
TF_Run_Helper
```
```python
(
```
```python
s
```
```python
->
```
```python
session
```
```python
,
```
```python
nullptr
```
```python
,
```
```python
run_options
```
```python
,
```
```python
input_pairs
```
```python
,
```
```python
output_names
```
```python
,
```
```python
c_outputs
```
```python
,
```
```python
target_oper_names
```
```python
,
```
```python
run_metadata
```
```python
,
```
```python
status
```
```python
)
```
```python
;
```
```python
}
```
```python
// 真正的实现了session.run()
```
```python
static
```
```python
void
```
```python
TF_Run_Helper
```
```python
(
```
```python
)
```
```python
{
```
```python
RunMetadata run_metadata_proto
```
```python
;
```
```python
// 调用不同的session实现类的run方法，来执行
```
```python
result
```
```python
=
```
```python
session
```
```python
->
```
```python
Run
```
```python
(
```
```python
run_options_proto
```
```python
,
```
```python
input_pairs
```
```python
,
```
```python
output_tensor_names
```
```python
,
```
```python
target_oper_names
```
```python
,
```
```python
&
```
```python
outputs
```
```python
,
```
```python
&
```
```python
run_metadata_proto
```
```python
)
```
```python
;
```
```python
// 省略代码
```
```python
}
```
最终会调用创建的session来执行run方法。DirectSession和GrpcSession的Run()方法会有所不同。后面很复杂，就不接着分析了。
### 5.3 关闭session
通过session.close()来关闭session，释放相关资源，防止内存泄漏。
```python
class
```
```python
BaseSession
```
```python
(
```
```python
SessionInterface
```
```python
)
```
```python
:
```
```python
def
```
```python
close
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
tf_session
```
```python
.
```
```python
TF_CloseSession
```
```python
(
```
```python
self
```
```python
.
```
```python
_session
```
```python
,
```
```python
status
```
```python
)
```
会调用到C API的TF_CloseSession()方法。
```python
void
```
```python
TF_CloseSession
```
```python
(
```
```python
TF_Session
```
```python
*
```
```python
s
```
```python
,
```
```python
TF_Status
```
```python
*
```
```python
status
```
```python
)
```
```python
{
```
```python
status
```
```python
->
```
```python
status
```
```python
=
```
```python
s
```
```python
->
```
```python
session
```
```python
->
```
```python
Close
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
最终根据创建的session，多态的调用其Close()方法。同样分为DirectSession和GrpcSession两种。
```python
:
```
```python
:
```
```python
tensorflow
```
```python
:
```
```python
:
```
```python
Status DirectSession
```
```python
:
```
```python
:
```
```python
Close
```
```python
(
```
```python
)
```
```python
{
```
```python
cancellation_manager_
```
```python
->
```
```python
StartCancel
```
```python
(
```
```python
)
```
```python
;
```
```python
{
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
closed_lock_
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
closed_
```
```python
)
```
```python
return
```
```python
:
```
```python
:
```
```python
tensorflow
```
```python
:
```
```python
:
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
closed_
```
```python
=
```
```python
true
```
```python
;
```
```python
}
```
```python
// 注销session
```
```python
if
```
```python
(
```
```python
factory_
```
```python
!=
```
```python
nullptr
```
```python
)
```
```python
factory_
```
```python
->
```
```python
Deregister
```
```python
(
```
```python
this
```
```python
)
```
```python
;
```
```python
return
```
```python
:
```
```python
:
```
```python
tensorflow
```
```python
:
```
```python
:
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
DirectSessionFactory中的Deregister()方法如下
```python
void
```
```python
Deregister
```
```python
(
```
```python
const
```
```python
DirectSession
```
```python
*
```
```python
session
```
```python
)
```
```python
{
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
sessions_lock_
```
```python
)
```
```python
;
```
```python
// 释放相关资源
```
```python
sessions_
```
```python
.
```
```python
erase
```
```python
(
```
```python
std
```
```python
:
```
```python
:
```
```python
remove
```
```python
(
```
```python
sessions_
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
,
```
```python
sessions_
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
,
```
```python
session
```
```python
)
```
```python
,
```
```python
sessions_
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
### 5.4 销毁session
session的销毁是由Python的GC自动执行的。python通过引用计数方法来判断是否回收对象。当对象的引用计数为0，且虚拟机触发了GC时，会调用对象的`__del__()`方法来销毁对象。引用计数法有个很致命的问题，就是无法解决循环引用问题，故会存在内存泄漏。Java虚拟机采用了调用链分析的方式来决定哪些对象会被回收。
```python
class
```
```python
BaseSession
```
```python
(
```
```python
SessionInterface
```
```python
)
```
```python
:
```
```python
def
```
```python
__del__
```
```python
(
```
```python
self
```
```python
)
```
```python
:
```
```python
# 先close，防止用户没有调用close()
```
```python
try
```
```python
:
```
```python
self
```
```python
.
```
```python
close
```
```python
(
```
```python
)
```
```python
# 再调用c api的TF_DeleteSession来销毁session
```
```python
if
```
```python
self
```
```python
.
```
```python
_session
```
```python
is
```
```python
not
```
```python
None
```
```python
:
```
```python
try
```
```python
:
```
```python
status
```
```python
=
```
```python
c_api_util
```
```python
.
```
```python
ScopedTFStatus
```
```python
(
```
```python
)
```
```python
if
```
```python
self
```
```python
.
```
```python
_created_with_new_api
```
```python
:
```
```python
tf_session
```
```python
.
```
```python
TF_DeleteSession
```
```python
(
```
```python
self
```
```python
.
```
```python
_session
```
```python
,
```
```python
status
```
```python
)
```
c_api.cc中的相关逻辑如下
```python
void
```
```python
TF_DeleteSession
```
```python
(
```
```python
TF_Session
```
```python
*
```
```python
s
```
```python
,
```
```python
TF_Status
```
```python
*
```
```python
status
```
```python
)
```
```python
{
```
```python
status
```
```python
->
```
```python
status
```
```python
=
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
TF_Graph
```
```python
*
```
```python
const
```
```python
graph
```
```python
=
```
```python
s
```
```python
->
```
```python
graph
```
```python
;
```
```python
if
```
```python
(
```
```python
graph
```
```python
!=
```
```python
nullptr
```
```python
)
```
```python
{
```
```python
graph
```
```python
->
```
```python
mu
```
```python
.
```
```python
lock
```
```python
(
```
```python
)
```
```python
;
```
```python
graph
```
```python
->
```
```python
sessions
```
```python
.
```
```python
erase
```
```python
(
```
```python
s
```
```python
)
```
```python
;
```
```python
// 如果graph的引用计数为0，也就是graph没有被任何session持有，则考虑销毁graph对象
```
```python
const
```
```python
bool del
```
```python
=
```
```python
graph
```
```python
->
```
```python
delete_requested
```
```python
&&
```
```python
graph
```
```python
->
```
```python
sessions
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
;
```
```python
graph
```
```python
->
```
```python
mu
```
```python
.
```
```python
unlock
```
```python
(
```
```python
)
```
```python
;
```
```python
// 销毁graph对象
```
```python
if
```
```python
(
```
```python
del
```
```python
)
```
```python
delete graph
```
```python
;
```
```python
}
```
```python
// 销毁session和TF_Session
```
```python
delete s
```
```python
->
```
```python
session
```
```python
;
```
```python
delete s
```
```python
;
```
```python
}
```
TF_DeleteSession()会判断graph的引用计数是否为0，如果为0，则会销毁graph。然后销毁session和TF_Session对象。通过Session实现类的析构函数，来销毁session，释放线程池Executor，资源管理器ResourceManager等资源。
```python
DirectSession
```
```python
:
```
```python
:
```
```python
~
```
```python
DirectSession
```
```python
(
```
```python
)
```
```python
{
```
```python
for
```
```python
(
```
```python
auto
```
```python
&
```
```python
it
```
```python
:
```
```python
partial_runs_
```
```python
)
```
```python
{
```
```python
it
```
```python
.
```
```python
second
```
```python
.
```
```python
reset
```
```python
(
```
```python
nullptr
```
```python
)
```
```python
;
```
```python
}
```
```python
// 释放线程池Executor
```
```python
for
```
```python
(
```
```python
auto
```
```python
&
```
```python
it
```
```python
:
```
```python
executors_
```
```python
)
```
```python
{
```
```python
it
```
```python
.
```
```python
second
```
```python
.
```
```python
reset
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
for
```
```python
(
```
```python
auto
```
```python
d
```
```python
:
```
```python
device_mgr_
```
```python
->
```
```python
ListDevices
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
d
```
```python
->
```
```python
op_segment
```
```python
(
```
```python
)
```
```python
->
```
```python
RemoveHold
```
```python
(
```
```python
session_handle_
```
```python
)
```
```python
;
```
```python
}
```
```python
// 释放ResourceManager
```
```python
for
```
```python
(
```
```python
auto
```
```python
d
```
```python
:
```
```python
device_mgr_
```
```python
->
```
```python
ListDevices
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
d
```
```python
->
```
```python
ClearResourceMgr
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
// 释放CancellationManager实例
```
```python
functions_
```
```python
.
```
```python
clear
```
```python
(
```
```python
)
```
```python
;
```
```python
delete cancellation_manager_
```
```python
;
```
```python
// 释放ThreadPool
```
```python
for
```
```python
(
```
```python
const
```
```python
auto
```
```python
&
```
```python
p_and_owned
```
```python
:
```
```python
thread_pools_
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
p_and_owned
```
```python
.
```
```python
second
```
```python
)
```
```python
delete p_and_owned
```
```python
.
```
```python
first
```
```python
;
```
```python
}
```
```python
execution_state_
```
```python
.
```
```python
reset
```
```python
(
```
```python
nullptr
```
```python
)
```
```python
;
```
```python
flib_def_
```
```python
.
```
```python
reset
```
```python
(
```
```python
nullptr
```
```python
)
```
```python
;
```
```python
}
```

# 6 总结
Session是TensorFlow的client和master连接的桥梁，client任何运算也是通过session来run。它是client端最重要的对象。在Python层和C++层，均有不同的session实现。session生命周期会经历四个阶段，create run close和del。四个阶段均由Python前端开始，最终调用到C层后端实现。由此也可以看到，TensorFlow框架的前后端分离和模块化设计是多么的精巧。
Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)

