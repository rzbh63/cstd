# 多态与虚函数



标签： [多态](http://so.csdn.net/so/search/s.do?q=%E5%A4%9A%E6%80%81&t=blog)[虚函数](http://so.csdn.net/so/search/s.do?q=%E8%99%9A%E5%87%BD%E6%95%B0&t=blog) 更多

个人分类： [C/C++](https://blog.csdn.net/godloveyuxu/article/category/6961315)



 版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/godloveyuxu/article/details/80030428

多态的作用：继承是子类使用父类的方法，而多态则是父类使用子类的方法。

在C++中，多态有两种，一种是函数重载，一种是虚函数。函数重载发生在编译的时候，它的函数参数是不一样的。而虚函数是发生在运行的时候，它的函数原型是一样的，依靠的是指针的指向。

有一篇非常好的文章介绍多态与虚函数。发一个链接在这里。

[http://blog.csdn.net/augusdi/article/details/38271009](https://blog.csdn.net/augusdi/article/details/38271009)

这么一大堆名词，实际上就围绕一件事展开，就是多态，其他三个名词都是为实现C++的多态机制而提出的一些规则，下面分两部分介绍，第一部分介绍【多态】，第二部分介绍【虚函数，纯虚函数，抽象类】

**一 、【多态】**

**多态的概念** ：关于多态，好几种说法，好的坏的都有，分别说一下：

1、指同一个函数的多种形态。

​       个人认为这是一种高手中的高手喜欢的说法，对于一般开发人员是一种差的不能再差的概念，简直是对人的误导，然人很容易就靠到函数重载上了。

​        以下是个人认为解释的比较好的两种说法，意思大体相同：

2、多态是具有表现多种形态的能力的特征，在OO中是指，语言具有根据对象的类型以不同方式处理之，特别是重载方法和继承类这种形式的能力。

​       这种说法有点绕，仔细想想，这才是C++要告诉我们的。

 3、多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。多态性在Object Pascal和C++中都是通过虚函数（Virtual Function）实现的。

​       这种说法看来是又易懂，又全面的一种，尤其是最后一句，直接点出了虚函数与多态性的关系，如果你还是不太懂，没关系，再把3读两遍，有个印象，往后看吧。

 **二、****【虚函数，纯虚函数，抽象类】**

​       多态才说了个概念，有什么用还没说就进入第二部分了？看看概念3的最后一句，虚函数就是为多态而生的，多态的作用的介绍和虚函数简直关系太大了，就放一起说吧。

**多态的作用：**继承是子类使用父类的方法，而多态则是父类使用子类的方法。这是一句大白话，多态从用法上就是要用父类(确切的说是父类的对象名)去调用子类的方法，例如：

【例一】

[cpp]

view plain

copy









1. **class** A {  
2.   
3. **public**:  
4.   
5. A() {}  
6.   
7. 　　（**virtual**） **void** print() {  
8.   
9. cout << "This is A." << endl;  
10.   
11. }  
12.   
13. };  
14.   
15. **class** B : **public** A {  
16.   
17. **public**:  
18.   
19. B() {}  
20.   
21. **void** print() {  
22.   
23. cout << "This is B." << endl;  
24.   
25. }  
26.   
27. };  
28.   
29. **int** main(**int** argc, **char*** argv[]) {  
30.   
31. ​    B b;  
32.   
33. A a;  a = b;a.print;---------------------------------------- make1  
34.   
35. // A &a = b; a->print();----------------------------------make2  
36.   
37.  //A *a = new B();a->print();--------------------------------make3  
38.   
39. **return** 0;  
40.   
41. }  



这将显示：

This is B.

　　如果把virtual去掉，将显示：

This is A.

(make1,2,3分别是对应兼容规则(后面介绍)的三种方式，调用结果是一样的)

加上virtual 多态了，B中的print被调用了，也就是可以实现父类使用子类的方法。

对多态的作用有一个初步的认识了之后，再提出更官方，也是更准确的对多态作用的描述：

多态性使得能够利用同一类(基类)类型的指针来引用不同类的对象,以及根据所引用对象的不同,以不同的方式执行相同的操作。把不同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作(也就是可以调用子对象中对父对象的相关函数的改进方法)。

​         那么上面例子中为什么去掉virtual就调用的不是B中的方法了呢，明明把B的对象赋给指针a了啊，是因为C++定义了一组对象赋值的兼容规则，就是指在公有派生的情况下，对于某些场合，一个派生类的对象可以作为基类对象来使用，具体来说，就是下面三种情形：

 Class A ;

class B:public A

**1.    派生的对象可以赋给基类的对象**

A a;

B b;

a = b;

**2.    派生的对象可以初始化基类的引用**

B b;

A &a = b;

**3.     派生的对象的地址可以赋给指向基类的指针**

B b;

A *a = &b;

或

A *a = new B();

​       由上述对象赋值兼容规则可知，一个基类的对象可兼容派生类的对象，一个基类的指针可指向派生类的对象，一个基类的引用可引用派生类的对象，于是对于通过基类的对象指针(或引用)对成员函数的调用，编译时无法确定对象的类，而只是在运行时才能确定并由此确定调用哪个类中的成员函数。

​       看看刚才的例子，根据兼容规则，B的对象根本就被当成了A的对象来使用，难怪B的方法不能被调用。

【例二】

[cpp]

view plain

copy









1. \#include <iostream>  
2.   
3. **using** **namespace** std;  
4.   
5. **class** A  
6.   
7. {  
8.   
9. ​    **public**:  
10.   
11. ​        **void** (**virtual**) print(){cout << "A print"<<endl;}  
12.   
13. ​          
14.   
15. ​    **private**:  
16.   
17. };  
18.   
19. **class** B : **public** A  
20.   
21. {  
22.   
23. ​    **public**:  
24.   
25. ​        **void** print(){cout << "B print"<<endl;}  
26.   
27. ​    **private**:  
28.   
29. };  
30.   
31. **void** test(A &tmpClass)  
32.   
33. {  
34.   
35. ​    tmpClass.print();  
36.   
37. }  
38.   
39. **int** main(**void**)  
40.   
41. {  
42.   
43. ​    B b;  
44.   
45. ​    test(b);  
46.   
47. ​    getchar();  
48.   
49. ​    **return** 0;  
50. }  



这将显示：

B print

如果把virtual去掉，将显示：

A print

​      那么，为什么加了一个virtual以后就达到调用的目的了呢，多态了嘛~那么为什么加上virtual就多态了呢，我们还要介绍一个概念：联编

​      函数的联编：在编译或运行将函数调用与相应的函数体连接在一起的过程。

1 、先期联编或静态联编：在编译时就能进行函数联编称为先期联编或静态联编。

2 、迟后联编或动态联编：在运行时才能进行的联编称为迟后联编或动态联编。

​     那么联编与虚函数有什么关系呢，当然，造成上面例子中的矛盾的原因就是代码的联编过程采用了先期联编，使得编译时系统无法确定究竟应该调用基类中的函数还是应该调用派生类中的函数，要是能够采用上面说的迟后联编就好了，可以在运行时再判断到底是哪个对象，所以，virtual关键字的作用就是提示编译器进行迟后联编，告诉连接过程：“我是个虚的，先不要连接我，等运行时再说吧”。

​     那么为什么连接的时候就知道到底是哪个对象了呢，这就引出虚函数的原理了：当编译器遇到virtual后，会为所在的类构造一个表和一个指针，那个表叫做vtbl，每个类都有自己的vtbl，vtbl的作用就是保存自己类中虚函数的地址，我们可以把vtbl形象地看成一个数组，这个数组的每个元素存放的就是虚函数的地址.指针叫做vptr，指向那个表。而这个指针保存在相应的对象当中，也就是说只有创建了对象以后才能找到相应虚函数的地址。

**【注意】**

1、为确保运行时的多态定义的基类与派生类的虚函数不仅函数名要相同，其返回值及参数都必须相同，否则即使加上了virtual，系统也不进行迟后联编。

2 、虚函数关系通过继承关系自动传递给基类中同名的函数，也就是上例中如果A中print有virtual,那么 B中的print即使不加virtual,也被自动认为是虚函数。

*3 、没有继承关系，多态机制没有意义，继承必须是公有继承。

*4、现实中，远不只我举的这两个例子，但是大的原则都是我前面说到的“如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的”。这句话也可以反过来说：“如果你发现基类提供了虚函数，那么你最好override它”。

 

**纯虚函数：**

​     虚函数的作用是为了实现对基类与派生类中的虚函数成员的迟后联编，而纯虚函数是表明不具体实现的虚函数成员，即纯虚函数无实现代码。其作用仅仅是为其派生类提过一个统一的构架，具体实现在派生类中给出。

​     一个函数声明为纯虚后，纯虚函数的意思是：我是一个抽象类！不要把我实例化！纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。

**抽象类：**

​     含有一个或多个纯虚函数的类称为抽象类。

【例三】

[cpp]

view plain

copy









1. \#include <iostream>  
2.   
3.    
4. **using** **namespace** std;  
5.   
6. **class** A  
7. {  
8. ​    **public**:  
9.   
10. ​         **virtual** **float** print() = 0;  
11.   
12. ​    **protected**:  
13.   
14. ​        **float** h,w;      
15.   
16. ​    **private**:  
17. };  
18.   
19. **class** B : **public** A  
20.   
21. {  
22.   
23. ​    **public**:  
24.   
25. ​        B(**float** h0,**float** w0){h = h0;w = w0;}  
26.   
27. ​        **float** print(){**return** h*w;}  
28.   
29. ​    **private**:  
30.   
31. };  
32.   
33. **class** C : **public** A  
34.   
35. {  
36.   
37. ​    **public**:  
38.   
39. ​        C(**float** h0,**float** w0){h = h0;w = w0;}  
40.   
41. ​        **float** print(){**return** h*w/2;}  
42.   
43. ​    **private**:  
44.   
45. };  
46.   
47.    
48.   
49. **int** main(**void**)  
50.   
51. {  
52.   
53. ​    A *a1,*a2;  
54.   
55. ​    B b(1,2);  
56.   
57. ​    C c(1,2);  
58.   
59. ​    a1 = &b;  
60.   
61. ​    a2 = &c;  
62.   
63. ​    cout << a1->print()<<","<<a2->print()<<endl;  
64.   
65. ​    getchar();  
66.   
67. ​    **return** 0;  
68. }  



结果为：

2，1

​        在这个例子中，A就是一个抽象类，基类A中print没有确定具体的操作，但不能从基类中去掉，否则不能使用基类的指针a1，a2调用派生类中的方法(a1->print;a2->print就不能用了)，给多态性造成不便，这里要强调的是，我们是希望用基类的指针调用派生类的方法，希望用到多态机制，如果读者并不想用基类指针，认为用b，c指针直接调用更好，那纯虚函数就没有意义了，多态也就没有意义了，了解一下多态的好处，再决定是否用纯虚函数吧。

**【注意】**

1 、抽象类并不能直接定义对象，只可以如上例那样声明指针，用来指向基类派生的子类的对象，上例中的A *a1,*a2;该为 A a1,a2;是错误的。

2、 从一个抽象类派生的类必须提供纯虚函数的代码实现或依旧指明其为派生类，否则是错误的。

3 、当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。

【例三】

[cpp]

view plain

copy









1. **class** A  
2. {  
3. **public**:  
4. ​    A() { ptra_ = **new** **char**[10];}  
5. ​    ~A() { **delete**[] ptra_;}        // 非虚析构函数  
6. **private**:  
7. ​    **char** * ptra_;  
8. };  
9.   
10. **class** B: **public** A  
11. {  
12. **public**:  
13. ​    B() { ptrb_ = **new** **char**[20];}  
14. ​    ~B() { **delete**[] ptrb_;}  
15. **private**:  
16. ​    **char** * ptrb_;  
17. };  
18.   
19. **void** foo()  
20. {  
21. ​    A * a = **new** B;  
22. ​    **delete** a;  
23. }  



​      在这个例子中，程序也许不会象你想象的那样运行，在执行delete a的时候，实际上只有A::~A()被调用了，而B类的析构函数并没有被调用！这是否有点儿可怕？ 如果将上面A::~A()改为virtual，就可以保证B::~B()也在delete a的时候被调用了。因此基类的析构函数都必须是virtual的。纯虚的析构函数并没有什么作用，是虚的就够了。通常只有在希望将一个类变成抽象类（不能实例化的类），而这个类又没有合适的函数可以被纯虚化的时候，可以使用纯虚的析构函数来达到目的。

 

   最后通过一个例子说明一下抽象类，纯虚函数以及多态的妙用吧：

   我们希望通过一个方法得到不同图形面积的和的方式：



[cpp]

view plain

copy









1. \#include <iostream>  
2.   
3. **using** **namespace** std;  
4.   
5. **class** A //定义一个抽象类，用来求图形面积  
6.   
7. {  
8.   
9. ​    **public**:  
10.   
11. ​         **virtual** **float** area() = 0;//定义一个计算面积的纯虚函数，图形没确定，当  
12.   
13. //不能确定具体实现  
14.   
15. ​    **protected**:  
16.   
17. ​        **float** h,w;    //这里假设所有图形的面积都可以用h和w两个元素计算得出  
18.   
19. ​                      //就假设为高和长吧  
20.   
21. ​    **private**:  
22.   
23. };  
24.   
25. **class** B : **public** A //定义一个求长方形面积的类  
26.   
27. {  
28.   
29. ​    **public**:  
30.   
31. ​        B(**float** h0,**float** w0){h = h0;w = w0;}  
32.   
33. ​        **float** area (){**return** h*w;}//基类纯虚函数的具体实现  
34.   
35. ​    **private**:  
36.   
37. };  
38.   
39. **class** C : **public** A //定义一个求三角形面积的类  
40.   
41. {  
42.   
43. ​    **public**:  
44.   
45. ​        C(**float** h0,**float** w0){h = h0;w = w0;}  
46.   
47. ​        **float** area (){**return** h*w/2;}//基类纯虚函数的具体实现  
48.   
49. ​    **private**:  
50.   
51. };  
52.   
53.    
54.   
55. **float** getTotal(A *s[],**int** n)//通过一个数组传递所有的图形对象  
56.   
57. ​                            //多态的好处出来了吧，不是多态，不能用基类A调用  
58.   
59. ​                            //参数类型怎么写，要是有100个不同的图形，怎么传递  
60.   
61. {  
62.   
63. ​       **float** sum = 0;  
64.   
65. ​       **for**(**int** i = 0;i < n; i++)  
66.   
67. ​      sum = sum + s[i]->area();  
68.   
69. **return** sum;  
70.   
71. }  
72.   
73. **int** main(**void**)  
74.   
75. {  
76.   
77. ​        **float** totalArea;  
78.   
79. A *a[2];  
80.   
81. a[0] = **new** B(1,2); //一个长方形对象  
82.   
83. a[1] = **new** C(1,2);//一个三角形对象  
84.   
85. totalArea = getTotal(a , 2);//求出两个对象的面积和  
86.   
87. ​    getchar();  
88.   
89. ​    **return** 0;  
90.   
91. }  