
# 20160208.CCPP体系详解(0018天) - 尹成的技术博客 - CSDN博客

置顶2016年02月21日 00:36:53[尹成](https://me.csdn.net/yincheng01)阅读数：2061个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)



程序片段(01):main.c
内容概要:**PointWithOutInit**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.野指针详解:
```
```python
//  1.野指针:没有进行初始化操作的指针-->由于该指针变量内部所存储的地址是个随机值,因此是野地址(类型含义:指针)
```
```python
//    注:指针类型的变量必须在其被创建的时候就需要进行初始化操作,否则就成了野指针,所谓野指针就是乱指向的指针,形成的就是一个随机垃圾地址
```
```python
//  2.胡乱使用野指针所造成的现象:
```
```python
//    (1).指向驱动程序所属内存,将会出现蓝屏现象
```
```python
//       (2).指向普通的应用程序,会将本身的这个应用程序结束掉
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
* p;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *p);
```
```python
//
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):01.地址.c+02.内容.c+03.指针实战.c+04.指针副本机制.c
内容概要:**指针地址与取值运算符**
```python
///01.地址.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
get
```
```python
()
{
```
```python
return
```
```python
10
```
```python
;
}
```
```python
//01.严格进行变量区分:
```
```python
//  1.普通变量和指针变量
```
```python
//  2.严格的变量类型:
```
```python
//      常规类型+特殊类型
```
```python
//02.对变量取地址的操作发起于寄存器当中
```
```python
//  因此地址也生成于寄存器变量当中,C语言无法直接访问
```
```python
//03.关于取地址符不能操作的两种情况:
```
```python
//      &&intNum;-->C语言无法直接操作寄存器变量
```
```python
//      &get();-->返回值存储与寄存器的(cache)区,或者程序的(备份内存),这两块儿内存都不可直接访问
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intNum;
    &intNum;
```
```python
//这里获取一个声明但没有初始化的普通变量的所属地址可以,但是如果是指针类型的变量就不行了
```
```python
//&&intNum;//&intNum这个表达式所代表操作执行于寄存器当中,在寄存器当中使用寄存器变量进行存储,因此C语言无法进行寄存器变量的操作
```
```python
//  而且&intNum所获得的数据来自于CPU-->寄存器-->代码区-->符号表中,因此不能通过取地址运算符进行操作(C语言相对于汇编语言的缺点)
```
```python
//&get();//get();的返回值,也就是函数的返回值可能存储于两个常见位置:寄存器的缓冲区(cache),应用程序的备份内存,因此返回值不可取地址
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.内容.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.取值运算符("*")与取地址运算符("&"):
```
```python
//  1.星号("*")表示取值运算符,也就是根据指针访问内存块儿
```
```python
//  2.与号("&")表示取地址运算符,也就是根据变量的内存实体获取变量的地址
```
```python
//02.对指针变量使用取值运算符(星号:"*")的使用规律:
```
```python
//  用原始指针类型的指针级别减去取地址运算符的个数;
```
```python
//  就是当前所访问的具体变量(普通变量和指针变量)
```
```python
//      结果为0-->普通变量
```
```python
//      结果为1-->一级指针变量
```
```python
//      结果为2-->二级指针变量
```
```python
//      结果为n-->N级指针变量
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//*(001) = 1;//由于常量读取于代码区符号表,产生于CPU寄存器,因此C语言不能够直接进行访问
```
```python
int
```
```python
intVar =
```
```python
10
```
```python
;
    *(&intVar) =
```
```python
3
```
```python
;
```
```python
//星号(*)表示取值运算符,也就是根据指针访问内存区块儿
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, intVar);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.取值运算符(星号:"*")的操作对象实质必须是指针
```
```python
//  注:*&intVar-->严格区分执行流程
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intVar =
```
```python
10
```
```python
;
    *&intVar =
```
```python
3
```
```python
;
```
```python
//*&这两个符号可以同时进行出现,操作流程为:取地址运算符(与号:"&")先进行取地址操作,再根据取值运算符(星号:"*")根据指针获取该指针所指向的内存实体|数据实体
```
```python
//**&intVar;//编译报错-->由于*&intVar之后的结果为普通变量类型(int)-->取值运算符的操作对象必须是指针类型,也就是含有(星号:"*")的类型
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, intVar);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.凡是涉及到的操作和运算的步骤都是由CPU在寄存器当中进行执行的,这里的强制类型转换属于"读取"并"转换"的操作
```
```python
//  因此属于寄存器操作,要进行间接修改数据,必须得先获取到相应的指针,而且指针类型必须是可以修改的,这样就有可能涉及到
```
```python
//  指针变量的类型转换操作
```
```python
//05.*(int *)&num这段儿代码的详细解释:
```
```python
//  0.这些符号都是用于对变量名进行操作的
```
```python
//      注:对变量进行的操作实质其实是对内存实体(数据实体)直接进行操作
```
```python
//  1.取地址运算符(与号:"&")最接近于变量名称,所以优先执行
```
```python
//  2.强制类型转换操作(int *)次接近于变量名称,所以其次执行
```
```python
//  3.取值运算符(星号:"*")再次接近于变量名称,所以再其次执行
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
const
```
```python
int
```
```python
num =
```
```python
3
```
```python
;
```
```python
//在C语言中,Const关键字在处理普通变量的时候,只能够避免对变量的直接修改,但是避免不了间接修改(普通变量适用,指针变量稍有差别)
```
```python
//num = 1;//直接修改,编译报错
```
```python
(
```
```python
int
```
```python
)num;
```
```python
//对任何变量的强制类型转换操作,强制转换之后的数值产生于CPU的寄存器
```
```python
*(
```
```python
int
```
```python
*)&num =
```
```python
10
```
```python
;
```
```python
//int *类型转换,这里要特别注意,const int需要被看做为整体的一个类型进行处理
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//06.关于空类型的指针与空指针的区分:
```
```python
//  空类型的指针:
```
```python
//      严格说是空类型的指针变量-->该指针变量没有具体类型,只是用于存储地址(没有类型含义)而已
```
```python
//      因此不能直接对空类型的指针变量进行数据实体的访问操作,没有明确解析步长和解析方式
```
```python
//  空指针:
```
```python
//      就是用于标识指针变量没有存储任何有实际意义的地址-->空置的指针变量而已
```
```python
//      实质形式:NULL-->(void *)0
```
```python
//  区分:空类型的指针是左值,空指针属于右值
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intVar =
```
```python
10
```
```python
;
    intVar =
```
```python
3
```
```python
;
```
```python
void
```
```python
* pIntVar = &intVar;
```
```python
//空类型的指针多用于多线程的数据传送处理
```
```python
//printf("%d \n", *p);//不可以直接操作空类型的指针
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
change01(
```
```python
int
```
```python
* pNum)
```
```python
//副本机制,数组除外
```
```python
{
    *pNum =
```
```python
10
```
```python
;
}
```
```python
int
```
```python
main06(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
20
```
```python
;
    change01(&num);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///03.指针实战.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.如何快速确定一个变量的所属类型?
```
```python
//  变量名称对称法(直接看声明变量的代码块儿,进行直观对称得出)
```
```python
int
```
```python
main07(
```
```python
void
```
```python
)
{
```
```python
double
```
```python
db =
```
```python
10.8
```
```python
;
```
```python
double
```
```python
dbl =
```
```python
10.9
```
```python
;
```
```python
double
```
```python
* p = &db;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(p));
```
```python
//指针变量-->类型(double *)-->占用4个内存字节
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(*p));
```
```python
//数据实体-->类型(double)-->占用8个内存字节
```
```python
*p =
```
```python
10.6
```
```python
;
```
```python
printf
```
```python
(
```
```python
"db = %lf, dbl = %lf, *p = %lf \n"
```
```python
, db, dbl, *p);
```
```python
//10.6 10.9 10.6
```
```python
p = &dbl;
```
```python
printf
```
```python
(
```
```python
"db = %lf, dbl = %lf, *p = %lf \n"
```
```python
, db, dbl, *p);
```
```python
//10.6 10.9 10.9
```
```python
*p =
```
```python
9.2
```
```python
;
```
```python
printf
```
```python
(
```
```python
"db = %lf, dbl = %lf, *p = %lf \n"
```
```python
, db, dbl, *p);
```
```python
//10.6 9.2 9.2
```
```python
dbl =
```
```python
2.1
```
```python
;
```
```python
printf
```
```python
(
```
```python
"db = %lf, dbl = %lf, *p = %lf \n"
```
```python
, db, dbl, *p);
```
```python
//10.6 2.1 2.1
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
///04.指针副本机制.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.函数形式参数的副本机制:
```
```python
//  1.在C语言当中,函数形式参数传参的副本机制只有数组例外,因为提升效率,节约内存拷贝
```
```python
//  2.跨函数改变变量(普通变量|指针变量)的传参要素
```
```python
//      被掉函数修改主调函数当中的普通变量,需要普通变量的地址
```
```python
//      被掉函数修改主调函数当中的指针变量,需要指针变量的地址
```
```python
//  注:总之在被掉函数当中修改主调函数的变量,无论是普通变量还是指针变量,必须传递变量的地址
```
```python
//      否则绝对不行!!!
```
```python
//void change02(int a, int b);//副本机制,被掉函数需要修改主调函数当中的变量,需要由主调函数向被掉函数传递该待修改变量的所属地址
```
```python
void
```
```python
change02(
```
```python
int
```
```python
* pa,
```
```python
int
```
```python
* pb)
{
```
```python
printf
```
```python
(
```
```python
"change02:&pa = %p, &pb = %p \n"
```
```python
, &pa, &pb);
```
```python
//int * pTemp;//某些编译器会编译不通过!
```
```python
int
```
```python
* pTemp = pa;
    pa = pb;
    pb = pTemp;
}
```
```python
//02.区分指针变量和指针:
```
```python
//  指针变量:含内存块儿
```
```python
//      用于存储指针的变量
```
```python
//  指针:不含有内存块儿
```
```python
//      是一个具有类型含义的地址
```
```python
//      是一个具有类型含义的数值
```
```python
//  注:使用指针变量的实质就是使用指针!
```
```python
int
```
```python
main08(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a;
```
```python
int
```
```python
b;
```
```python
int
```
```python
* pa = &a, *pb = &b;
```
```python
//scanf("%d%d", &a, &b);//scanf();函数后面所需的是"指针"
```
```python
scanf
```
```python
(
```
```python
"%d%d"
```
```python
, pa, pb);
```
```python
printf
```
```python
(
```
```python
"main: &pa = %p, &pb = %p \n"
```
```python
, &pa, &pb);
```
```python
if
```
```python
(*pa > *pb)
    {
        change02(pa, pb);
```
```python
//间接修改无法成功
```
```python
int
```
```python
temp = a;
```
```python
//直接修改
```
```python
a = b;
        b = temp;
    }
```
```python
printf
```
```python
(
```
```python
"a = %d, b = %d \n"
```
```python
, a, b);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main09(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a;
```
```python
int
```
```python
b;
```
```python
int
```
```python
* pa = &a, *pb = &b;
```
```python
scanf
```
```python
(
```
```python
"%d%d"
```
```python
, pa, pb);
```
```python
if
```
```python
(*pa > *pb)
```
```python
//对应指向的数据实体
```
```python
{
```
```python
int
```
```python
* pTemp = pa;
```
```python
//交换指针
```
```python
pa = pb; 
        pb = pTemp;
    }
```
```python
printf
```
```python
(
```
```python
"a = %d, b = %d \n"
```
```python
, a, b);
```
```python
printf
```
```python
(
```
```python
"pa= %d, pb = %d \n"
```
```python
, *pa, *pb);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
change03(
```
```python
int
```
```python
* p1,
```
```python
int
```
```python
* p2)
{
```
```python
printf
```
```python
(
```
```python
"change03: &p1 = %p, &p2 = %p \n"
```
```python
, &p1, &p2);
```
```python
int
```
```python
pTemp = *p1;
    *p1 = *p2;
    *p2 = pTemp;
}
```
```python
void
```
```python
change04(
```
```python
int
```
```python
* p1,
```
```python
int
```
```python
* p2)
{
```
```python
printf
```
```python
(
```
```python
"change04: &p1 = %p, &p2 = %p \n"
```
```python
, &p1, &p2);
```
```python
//int * pTemp;//野指针:没有经过初始化的指针-->某些编译器直接编译报错
```
```python
int
```
```python
* pTemp = NULL;
```
```python
//使用空指针来标识指针变量没有指向任何位置
```
```python
*pTemp = *p1;
```
```python
//错误:访问了不该访问的地址0
```
```python
*p1 = *p2;
    *p2 = *pTemp;
}
```
```python
int
```
```python
main10(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a;
```
```python
int
```
```python
b;
```
```python
int
```
```python
* pa = &a, * pb = &b;
```
```python
scanf
```
```python
(
```
```python
"%d %d"
```
```python
, pa, pb);
```
```python
if
```
```python
(*pa > *pb)
```
```python
//对比指向的数据实体
```
```python
{
```
```python
//change03(pa, pb);
```
```python
change02(*pa, *pb);
```
```python
//函数传递数据,传递的都只是副本而已
```
```python
}
```
```python
printf
```
```python
(
```
```python
"a = %d, b = %d \n"
```
```python
, a, b);
```
```python
printf
```
```python
(
```
```python
"*pa = %d, *pb= %d \n"
```
```python
, *pa, *pb);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
change05(
```
```python
int
```
```python
* p1,
```
```python
int
```
```python
* p2)
{
```
```python
printf
```
```python
(
```
```python
"change05: &p1 = %p, &p2 = %p \n"
```
```python
, &p1, &p2);
```
```python
int
```
```python
* pTemp = p1;
    p1 = p2;
    p2 = pTemp;
}
```
```python
//03.无论是指针变量的操作还是对指针的操作:
```
```python
//  都必须明确其类型
```
```python
int
```
```python
main11(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a;
```
```python
int
```
```python
b;
```
```python
int
```
```python
* pa = &a, *pb = &b;
```
```python
scanf
```
```python
(
```
```python
"%d%d"
```
```python
, pa, pb);
```
```python
printf
```
```python
(
```
```python
"main: &pa =%p, &pb = %p \n"
```
```python
, &pa, &pb);
```
```python
printf
```
```python
(
```
```python
"main pa = %p, pb= %p"
```
```python
, pa, pb);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(03):01.线程.c
内容概要:**多线程参数传递**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
//01.空类型的指针-->空类型的指针变量:
```
```python
//  只是标识该类型的变量具备存储地址的能力,严格区分地址与指针的不同
```
```python
void
```
```python
run(
```
```python
void
```
```python
* p)
```
```python
//采用空类型的一级指针变量可以存储任何类型的地址:只是具备存储地址的能力
```
```python
{
```
```python
int
```
```python
* pTemp = p;
```
```python
//为该地址赋予实际的意义(地址-->指针)-->具备(解析步长+解析方式)的能力
```
```python
char
```
```python
str[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
    sprintf(str,
```
```python
"锄禾日当午%d \n"
```
```python
, *pTemp);
    MessageBoxA(
```
```python
0
```
```python
, str,
```
```python
"天朝很苦!"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
//02.关于单线程和多线程的实现问题:
```
```python
//  1.要看CPU到底有多少个逻辑内核?
```
```python
//      逻辑内核只有一个无法实现多线程的
```
```python
//  2.要看使用的的线程技术?
```
```python
//      使用单线程技术无法实现多线程访问
```
```python
//      使用多线程技术既可以实现单线程访问也可以实现多线程访问
```
```python
//03.明确多线程情况下的一个应用程序的堆栈使用情况:
```
```python
//  1.单进程情况之下的堆栈使用情况
```
```python
//  2.各条线程共享单进程的堆内存
```
```python
//  3.各条线程独享各自的栈内存
```
```python
//  注:当主线程开启辅助辅助线程的时候!
```
```python
//      主线程所占用的栈内存相对于其他辅助线程就是共享的堆内存!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
//多线程同一时刻访问同一个变量的冲突问题(详解:多条线程全部开启,大家都读取到了变量i的地址,然后同一时刻访问了变量i的数据,因此相同)
```
```python
//  此时的主线程数据相对于其它辅助线程的数据就如同堆内存当中的数据,各条线程共享该数据-->因此多线程访问冲突
```
```python
HANDLE
```
```python
hd = _beginthread(run ,
```
```python
0
```
```python
, &i);
        WaitForSingleObject(hd, INFINITE);
```
```python
//无限等待,意思就是知道直到上一条工作线程执行完毕之后,再继续执行此行代码之后的代码
```
```python
//_beginthread(run, 0, &intArr[i]);//多线程传递参数的方式-->此时每条线程当问的不是同一个数据,因此不会出现多线程访问冲突问题
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(04):01.指针运算.c+02.数组.cpp+03.数组实战.c
内容概要:**指针与数组**
```python
///01.指针运算.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.指针变量的运算符特点:
```
```python
//  1.指针变量的运算只有在所属数组的情况下才具备实际意义
```
```python
//  2.指针变量的运算与其所指向的数据实体的类型密切相关
```
```python
//  3.没有明确类型的指针变量完全无法进行访问(读取|修改)
```
```python
//      只是具备这存储地址这么一个唯一的功能
```
```python
//02.指针变量的运算规律总结:
```
```python
//  1.p+1<==>p+sizeof(*p)*1;
```
```python
//  2.空类型的指针变量必须明确数据类型之后才能进行具体操作
```
```python
//      否则只是具备容器的特点
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intNum =
```
```python
10
```
```python
;
```
```python
int
```
```python
* pIntNum = &intNum;
```
```python
//pIntNum+1;<>pIntNum+sizeof(*pIntNum)*1;
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, pIntNum, pIntNum +
```
```python
1
```
```python
);
```
```python
char
```
```python
ch =
```
```python
"X"
```
```python
;
```
```python
char
```
```python
*pCh = &ch;
```
```python
printf
```
```python
(
```
```python
"%p, %p, %p \n"
```
```python
, pCh, pCh +
```
```python
1
```
```python
, pCh -
```
```python
1
```
```python
);
```
```python
//指针变量的运算与类型密切相关
```
```python
void
```
```python
* ppCh = &ch;
```
```python
//pv+1;//没有明确指针类型的指针变量,不能进行指针变量的算术运算
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intNum =
```
```python
10
```
```python
;
```
```python
int
```
```python
* pIntNum = &intNum;
```
```python
printf
```
```python
(
```
```python
"%p, %p, %p \n"
```
```python
, pIntNum -
```
```python
1
```
```python
, pIntNum, pIntNum +
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"%d, %d, %d \n"
```
```python
, *(pIntNum -
```
```python
1
```
```python
), *pIntNum, *(pIntNum +
```
```python
1
```
```python
));
```
```python
//如果指针变量所存储的指针所描述的地址不在数组当中,那么指针变量的加减运算法则没有任何意义
```
```python
//  因为运算结果可以和数组索引相互挂钩
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.关于指针变量的运算特点:
```
```python
//  1.参与运算的指针变量所存储的指针必须指向同一个数组内存情况下
```
```python
//  2.指针变量的运算范围:
```
```python
//      (1).指针变量既可以加上一个整数或者也可以减去一个整数(指针结果不要越过数组)
```
```python
//      (2).指着变量值可以减去一个指针变量,但不可以加上一个指针变量
```
```python
//      (3).指针变量既不可以执行乘法运算也不可执行除法运算,因为运算结果毫无实际意义!
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
int
```
```python
* p1 = &intArr[
```
```python
0
```
```python
];
```
```python
int
```
```python
* p2 = &intArr[
```
```python
6
```
```python
];
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, p2 - p1);
```
```python
//在同一个数组当中的两个指针变量(指针变量p1-指针变量p2<=>(指针1-指针2)/sizeof(*p1)<=>相差的元素个数)
```
```python
//printf("%d \n", *(p1 -2));
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.数组.cpp
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <iostream>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
//01.关于数组名和&数组名的内容详解:
```
```python
//  1.数组名的本质:将所有数组看作为一维数组,那么数组名就是该一维数组当中首个数组元素的地址
```
```python
//      常量指针!-->含有内存实体,是个伪常量,可以避免直接修改,但是无法避免间接修改
```
```python
//  2.&数组名的本质:获取指向整个数组整体的指针类型
```
```python
//      指针常量!-->没有内存实体,是个真常量,既不可以直接修改,也不可以间接修改
```
```python
//  因此:无论是常量指针还是指针常量所对应的值都是指针(是具备类型含义的地址)
```
```python
//      数组名+1<=>常量指针+1<=>常量指针的值+sizeof(*常量指针)
```
```python
//      &数组名+1<=>指针常量+1<=>指针常量的值+sizeof(*指针常量)
```
```python
//  诀窍:对任何类型的变量(无论是真变量还是伪变量)进行取地址操作,都属于指针类型
```
```python
//      也就统统占用4个字节的内存空间
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
printf
```
```python
(
```
```python
"intArr = %p, &intArr = %p \n"
```
```python
, intArr, &intArr);
```
```python
printf
```
```python
(
```
```python
"%d, %d \n"
```
```python
, intArr, intArr +
```
```python
1
```
```python
);
```
```python
//数组的第一个元素的地址,长度为int类型的字节数
```
```python
printf
```
```python
(
```
```python
"%d ,%d \n"
```
```python
, &intArr, &intArr +
```
```python
1
```
```python
);
```
```python
//整个数组的类型,长度为整个数组的长度(4*10),这里说明取地址运算符在进行运算的时候同时获取了指针的地址和类型
```
```python
printf
```
```python
(
```
```python
"sizeof(intArr) = %lu, sizeof(&intArr) = %lu \n"
```
```python
,
```
```python
sizeof
```
```python
(intArr),
```
```python
sizeof
```
```python
(&intArr));
```
```python
printf
```
```python
(
```
```python
"%s ,%s"
```
```python
,
```
```python
typeid
```
```python
(intArr).name(),
```
```python
typeid
```
```python
(&intArr).name());
    system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
1
```
```python
;
}
```
```python
///03.数组实战.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.函数的形式参数如果是数组名称,就取消了副本机制!
```
```python
//  取消副本机制的原理-->将数组名称当做了指针变量的名称进行处理
```
```python
//  该指针变量具备着实际参数数组的所有信息(包括类型信息)
```
```python
//  注:这里的指针变量的类型是将所有数组类型看做为一维数组,那么
```
```python
//      该一维数组当中的所有元素的类型就是该指针变量所指向的内存
```
```python
//      实体的类型
```
```python
void
```
```python
testFun(
```
```python
int
```
```python
* p)
```
```python
//借助指针变量访问外界数组
```
```python
{
```
```python
printf
```
```python
(
```
```python
"testFun sizeof(p) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(p));
```
```python
for
```
```python
(
```
```python
int
```
```python
* px = p; px < p +
```
```python
10
```
```python
; px++)
    {
        *px =
```
```python
12
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d ,%p \n"
```
```python
, *px, px);
    }
}
```
```python
//02.sizeof(对象)运算诀窍:
```
```python
//  sizeof(*&对象);<==>绝对正确的一个结果
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
printf
```
```python
(
```
```python
"main: sizof(intArr) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(intArr));
```
```python
//sizeof(数组名)<=>sizeof(*&数组名);
```
```python
testFun(intArr);
```
```python
printf
```
```python
(
```
```python
"原生数组: \n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
* p = intArr; p < intArr +
```
```python
10
```
```python
; ++p)
    {
```
```python
printf
```
```python
(
```
```python
"%d ,%p \n"
```
```python
, *p, p);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.对于数组的变量需要借助指针变量进行:
```
```python
//  指针变量作为循环变量进行运算
```
```python
int
```
```python
main06(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
//int * pIntArr = &intArr;//类型不匹配:&intArr-->指向数组的指针
```
```python
//intArr++;//数组名称intArr作为一个常量指针,是不能够直接进行自增自减运算的
```
```python
for
```
```python
(
```
```python
int
```
```python
* p = intArr +
```
```python
2
```
```python
; p < intArr +
```
```python
10
```
```python
; ++p)
    {
```
```python
printf
```
```python
(
```
```python
"%d, %p \n"
```
```python
, *p, p);
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
* p = intArr +
```
```python
10
```
```python
; p > intArr -
```
```python
1
```
```python
; --p)
    {
```
```python
printf
```
```python
(
```
```python
"%d, %p \n"
```
```python
, *p, p);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.sizeof();诀窍:
```
```python
//  sizeof(ob);<=>sizeof(*&obj);
```
```python
int
```
```python
main07(
```
```python
void
```
```python
)
{
```
```python
double
```
```python
* pDb;
```
```python
//在C语言当中,指针变量必须进行初始化,否则就会成为野指针,使用的时候容易出现问题,某些编译器不会通过的
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(*pDb));
```
```python
//对称法则:double  | * pDb-->8个字节
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
printf
```
```python
(
```
```python
"intArr = %p, &intArr = %p \n"
```
```python
, intArr, &intArr);
```
```python
//printf("sizeof(intArr) = %lu, sizeof(&intArr) = %lu \n", sizeof(intArr), sizeof(&intArr));
```
```python
//printf("sizeof(*intArr) = %lu, sizeof(*&intArr) = %lu", sizeof(*intArr), sizeof(*&intArr));
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(intArr));
```
```python
//sizoef();使用诀窍
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):thread.c
内容概要:**多线程切割**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <time.h>
```
```python
#include <process.h>
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
* pStart;
```
```python
//待检索首地址
```
```python
int
```
```python
sLength;
```
```python
//待检索长度
```
```python
int
```
```python
dFindValue;
```
```python
//待检索值
```
```python
int
```
```python
tID;
```
```python
//当前检索线程ID
```
```python
} thTask;
```
```python
int
```
```python
isFind =
```
```python
0
```
```python
;
```
```python
//线程检索成功标识,用于多线程之间的通信
```
```python
//01.多线程检索原理:
```
```python
//  1.将多个线程任务放置到线程队列当中去
```
```python
//  2.然后调度多条线程执行线程队列当中的任务代码
```
```python
//  3.线程随机调度:
```
```python
//      那条线程最闲置,那么该线程最容易优先执行到
```
```python
#define M 100
```
```python
//待检索的数据量
```
```python
#define N 4
```
```python
//总共所使用的检索线程数目(最好是CPU逻辑内核的倍数,负载均衡原理)
```
```python
//02.多线程检索数据最容易遇到的问题:
```
```python
//  数据量并不是单条线程所处理数据量的整数倍?-->需要解决这个负载均衡问题
```
```python
//      让N-1线程所处理的数据量一致,让最后一条线程处理量不一致
```
```python
//  举例说明:
```
```python
//      1.当线程处理数据量刚好平分的情况:
```
```python
//          100%4=0
```
```python
//      2.当线程处理数据量不好平分的情况:
```
```python
//          100%7!=0
```
```python
//          100/(7-1)=16...4-->前6条线程,每条的数据处理量是16条数据
```
```python
//          100%(7-1)=4----->第7条线程的数据处理量为4条
```
```python
void
```
```python
thSearchTask(
```
```python
void
```
```python
* pThTask)
{
    thTask * thTaskBlock = pThTask;
```
```python
//地址->指针
```
```python
printf
```
```python
(
```
```python
"线程%d开始查找! \n"
```
```python
, thTaskBlock->tID);
```
```python
for
```
```python
(
```
```python
int
```
```python
* pf = (*thTaskBlock).pStart; pf < (*thTaskBlock).pStart + (*thTaskBlock).sLength; ++pf)
    {
```
```python
if
```
```python
(
```
```python
1
```
```python
== isFind)
        {
```
```python
printf
```
```python
(
```
```python
"线程%d结束查找,其他线程已经找到! \n"
```
```python
, (*thTaskBlock).tID);
```
```python
return
```
```python
;
        }
```
```python
if
```
```python
((*thTaskBlock).dFindValue == *pf)
        {
```
```python
printf
```
```python
(
```
```python
"结束查找状态!线程%d已经找到数据%d,地址为%p"
```
```python
,(*thTaskBlock).tID, (*thTaskBlock).dFindValue, pf);
            isFind =
```
```python
1
```
```python
;
```
```python
return
```
```python
;
        }
        Sleep(
```
```python
500
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"线程%d结束查找,没有找到! \n"
```
```python
, (*thTaskBlock).tID);
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[M] = {
```
```python
0
```
```python
};
    srand((
```
```python
unsigned
```
```python
int
```
```python
)time(NULL));
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
    {
        intArr[i] = rand() %
```
```python
100
```
```python
+
```
```python
1
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%4d"
```
```python
, intArr[i]);
```
```python
if
```
```python
(
```
```python
0
```
```python
== (i +
```
```python
1
```
```python
) %
```
```python
100
```
```python
)
        {
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
        }
    }
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &num);
```
```python
//待查找的数据
```
```python
thTask thTaskArgS[N];
```
```python
//线程任务参数集
```
```python
if
```
```python
(
```
```python
0
```
```python
== M%N)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
        {
            thTaskArgS[i].pStart = intArr + M / N *i;
            thTaskArgS[i].sLength = M / N;
            thTaskArgS[i].tID = i;
            thTaskArgS[i].dFindValue = num;
            HANDLE hd = _beginthread(thSearchTask,
```
```python
0
```
```python
, &thTaskArgS[i]);
```
```python
//开启线程
```
```python
//WaitForSingleObject(hd, INFINITE);
```
```python
}
    }
```
```python
else
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N -
```
```python
1
```
```python
; ++i)
        {
            thTaskArgS[i].pStart = intArr + M / (N -
```
```python
1
```
```python
)*i;
            thTaskArgS[i].sLength = M / (N -
```
```python
1
```
```python
);
            thTaskArgS[i].tID = i;
            thTaskArgS[i].dFindValue = num;
            HANDLE hd = _beginthread(thSearchTask,
```
```python
0
```
```python
, &thTaskArgS[i]);
```
```python
//WaitForSingleObject(hd, INFINITE);
```
```python
}
```
```python
int
```
```python
i = N -
```
```python
1
```
```python
;
        thTaskArgS[i].pStart = intArr + M / (N -
```
```python
1
```
```python
)*i;
        thTaskArgS[i].sLength = M % (N -
```
```python
1
```
```python
);
        thTaskArgS[i].tID = i;
        thTaskArgS[i].dFindValue = num;
        HANDLE hd = _beginthread(thSearchTask,
```
```python
0
```
```python
, &thTaskArgS[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):多线程检索.c
内容概要:**多线程检索**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <time.h>
```
```python
#include <process.h>
```
```python
typedef struct
{
```
```python
int
```
```python
tID;
```
```python
int
```
```python
* pStart;
```
```python
int
```
```python
sLength;
```
```python
int
```
```python
sValue;
} thTaskInfo;
```
```python
int
```
```python
isFind =
```
```python
0
```
```python
;
void searchTaskFun(void * pTemp)
{
    thTaskInfo * thTaskArg = pTemp;
```
```python
printf
```
```python
(
```
```python
"ID为
```
```python
%d
```
```python
的线程开始进行检索任务! \n"
```
```python
, (
```
```python
*thTaskArg
```
```python
).tID);
```
```python
for
```
```python
(
```
```python
int
```
```python
* pf = (
```
```python
*thTaskArg
```
```python
).pStart; pf < (
```
```python
*thTaskArg
```
```python
).pStart + (
```
```python
*thTaskArg
```
```python
).sLength; ++pf)
    {
```
```python
if
```
```python
(
```
```python
1
```
```python
== isFind)
        {
```
```python
printf
```
```python
(
```
```python
"ID为
```
```python
%d
```
```python
的线程结束检索状态,其他线程已经检索到
```
```python
%d
```
```python
! \n"
```
```python
, (
```
```python
*thTaskArg
```
```python
).tID, (
```
```python
*thTaskArg
```
```python
).sValue);
```
```python
return
```
```python
;
        }
```
```python
if
```
```python
((
```
```python
*thTaskArg
```
```python
).sValue ==
```
```python
*pf
```
```python
)
        {
            isFind =
```
```python
1
```
```python
;
```
```python
printf
```
```python
(
```
```python
"ID为
```
```python
%d
```
```python
的线程已检索到数据
```
```python
%d
```
```python
,该值所在地址为
```
```python
%p
```
```python
\n"
```
```python
, (
```
```python
*thTaskArg
```
```python
).tID, (
```
```python
*thTaskArg
```
```python
).sValue, pf);
```
```python
return
```
```python
;
        }
        Sleep(
```
```python
500
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"ID为
```
```python
%d
```
```python
的线程未能检索到数据
```
```python
%d
```
```python
,结束检索状态! \n"
```
```python
, (
```
```python
*thTaskArg
```
```python
).tID, (
```
```python
*thTaskArg
```
```python
).sValue);
}
```
```python
int
```
```python
main01(void)
{
```
```python
int
```
```python
intArr[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
srand
```
```python
((unsigned
```
```python
int
```
```python
)
```
```python
time
```
```python
(NULL));
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"
```
```python
%4d
```
```python
"
```
```python
, intArr[i] =
```
```python
rand
```
```python
() %
```
```python
100
```
```python
+
```
```python
1
```
```python
);
```
```python
if
```
```python
(
```
```python
0
```
```python
== (i +
```
```python
1
```
```python
) %
```
```python
10
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
int
```
```python
value =
```
```python
0
```
```python
;
    scanf(
```
```python
"
```
```python
%d
```
```python
"
```
```python
, &value);
    thTaskInfo thTaskArgS[
```
```python
10
```
```python
];
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        thTaskArgS[i].tID = i;
        thTaskArgS[i].pStart = intArr +
```
```python
10
```
```python
* i;
        thTaskArgS[i].sLength =
```
```python
10
```
```python
;
        thTaskArgS[i].sValue = value;
        HANDLE hd = _beginthread(searchTaskFun,
```
```python
0
```
```python
, &thTaskArgS[i]);
    }
```
```python
system
```
```python
(
```
```python
"pause"
```
```python
);
}
```
程序片段(07):二级指针.c
内容概要:**二级指针**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.指针变量规律:
```
```python
//  1.指针变量必须注意指针的类型
```
```python
//  2.指针变量必须注意指针所指向实体的类型
```
```python
//  3.针对于指针变量的(加减一个整数)规律:
```
```python
//      实质:必须根据指针变量所存储的指针所指向的实体类型来定断
```
```python
//      形式:p+1<=>p+sizeof(*p);-->必需带上内存实体才能准确!
```
```python
//  4.指着变量的级数规律:
```
```python
//      (1).如何表明当前指针变量存储的是什么类型的变量的地址?
```
```python
//          double **pp-->二级指针变量PP存储的是(double * p)这个一级指针变量的地址
```
```python
//          规律:指针变量的声明级数减去一级就是该指针变量所存储的变量的地址
```
```python
//      (2).如何确定取值运算符(星号:"*")当前所访问的内存实体是什么?
```
```python
//          double **pp-->**pp-->(指针变量声明级数-当前取值运算符操作的级数)
```
```python
//              就是该取值运算符所访问的变量的数据
```
```python
//          例如:**-**=0-->变量的数据
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
double
```
```python
db =
```
```python
10.8
```
```python
;
```
```python
double
```
```python
* p = &db;
```
```python
//double * pT = &p;//指针类型不匹配
```
```python
double
```
```python
** pp = &p;
```
```python
//printf("%p, %p \n", pT, pT + 1);//PT结果不正确
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, pp, pp +
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"%lf \n"
```
```python
, **pp);
```
```python
//普通变量
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
a =
```
```python
10
```
```python
;
```
```python
int
```
```python
b =
```
```python
20
```
```python
;
```
```python
//02.函数形参的副本机制要点:
```
```python
//  只是针对于数组类型没有副本机制,其他所有类型的形参都有副本机制
```
```python
//  原理:就是将数组类型进行退化为指针("指向数组元素的指针"),以避免副本机制产生
```
```python
//  注:指向数组元素的指针,明确该数组当中所存储的到底是什么类型的数据!
```
```python
void
```
```python
changeP(
```
```python
int
```
```python
* p)
```
```python
//指针变量也有副本机制
```
```python
{
```
```python
printf
```
```python
(
```
```python
"change: &p = %p \n"
```
```python
, &p);
    p = &b;
}
```
```python
void
```
```python
changePP(
```
```python
int
```
```python
** pp)
{
    *pp = &b;
}
```
```python
//03.要想让被掉函数修改主调函数当中的变量数据:
```
```python
//  诀窍:至少必须传递主调函数当中的变量地址(至少得是直接地址)
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
* p = &a;
```
```python
printf
```
```python
(
```
```python
"main: &p = %p \n"
```
```python
, &p);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *p);
```
```python
//10
```
```python
//p = &b;
```
```python
//changeP(p);
```
```python
changePP(&p);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *p);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.集团体系架构关系:
```
```python
//  职称体系可以通过指针级数进行描述
```
```python
//  例如:司令采用的是10级指针描述,里面存储的军长的地址
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a =
```
```python
10
```
```python
;
```
```python
int
```
```python
* p = &a;
```
```python
int
```
```python
** pp = &p;
```
```python
int
```
```python
*** ppp = &pp;
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, &ppp);
```
```python
//集团体系架构关系可以通过指针级数进行描述
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//05.字符类型的指针如果指向的是代码区符号表实体:
```
```python
//  那是不允许通过字符指针间接修改代码区符号表内容的!
```
```python
//  注:代码区符号表的内容只能够进行读取操作,不能进行写入操作
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
* p =
```
```python
"123"
```
```python
;
```
```python
//"123"存储于代码区符号表
```
```python
*p =
```
```python
'A'
```
```python
;
```
```python
//*p所访问的内存实体位于代码区符号表,因此不能直接进行修改
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, p);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
run(
```
```python
char
```
```python
* arr[
```
```python
5
```
```python
])
{
```
```python
printf
```
```python
(
```
```python
"run: sizeof(arr) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(arr));
```
```python
//sizeof(char **)
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
        system(arr[i]);
    }
}
```
```python
//06.数组作为形参究竟退化为什么类型的指针?
```
```python
//  实质:退化为指向该数组当中所有元素的指针!
```
```python
//int arr[5]-->arr作形参,退化为-->int * arr
```
```python
//char * arr[5]-->arr作形参,退化为-->char ** arr
```
```python
void
```
```python
runT(
```
```python
char
```
```python
**arr)
```
```python
//指针数组作为形参,将会退化成为二级指针
```
```python
{
```
```python
printf
```
```python
(
```
```python
"runT: sizeof(arr) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(arr));
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
        system(arr[i]);
```
```python
//arr[i]的实质其实是一级指针
```
```python
}
}
```
```python
//07.数组作为形参的时候,会具体转化为指向该数组当中每个元素的指针类型:
```
```python
//  在访问的时候,采取该指针类型变量名加上中括号("[]")等同于数组访问方式!
```
```python
//  实质:arr[i]<=>*(arr+i)-->效果等价
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
//int arr[10];
```
```python
char
```
```python
* arr[
```
```python
5
```
```python
] = {
```
```python
"calc"
```
```python
,
```
```python
"notepad"
```
```python
,
```
```python
"mspaint"
```
```python
,
```
```python
"tasklist"
```
```python
,
```
```python
"pause"
```
```python
};
```
```python
printf
```
```python
(
```
```python
"main: sizeof(arr) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(arr));
```
```python
//诀窍:sizeof(varName)<=>sizeof(*&varName)
```
```python
run(arr);
```
```python
//runT(arr);
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(08):数组.c
内容概要:**指针结合数组**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.几组概念区分:
```
```python
//  1.普通变量和指针变量:
```
```python
//      是否具有地址意义
```
```python
//  2.变量指针和常量指针
```
```python
//      指针变量和数组名的区分
```
```python
//  3.常量指针和指针常量
```
```python
//      数组名和地址意义上的数值
```
```python
//  注:通常意义上的指针实质上是指着变量
```
```python
//02.函数形参使用数组声明形式以及指针声明形式
```
```python
//  其访问实参的方式都是相同的(数组形式<=>指针形式)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
};
```
```python
int
```
```python
* p = arr;
```
```python
//变量指针接收常量指针的值
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d, %d, %d, %d \n"
```
```python
, arr[i], *(arr + i), p[i], *(p + i));
    }
```
```python
//接收同样一个数组实参
```
```python
//  采用数组声明形式和采用指针声明形式的访问方式完全一样
```
```python
//  例如:arr[i]<=>p[i];*(p+i)<=>*(arr+i)
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.数组作为形参的函数标准声明形式!
```
```python
//  指向数组元素的指针+数组元素个数
```
```python
void
```
```python
revArr(
```
```python
int
```
```python
* p,
```
```python
int
```
```python
n)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < n /
```
```python
2
```
```python
; ++i)
```
```python
//节省效率的反转方式
```
```python
{
        p[i] = p[i] ^ p[n -
```
```python
1
```
```python
- i];
        p[n -
```
```python
1
```
```python
- i] = p[i] ^ p[n -
```
```python
1
```
```python
- i];
        p[i] = p[i] ^ p[n -
```
```python
1
```
```python
- i];
    }
}
```
```python
//04.通过指针方式来对数组进行遍历!
```
```python
void
```
```python
revArrT(
```
```python
int
```
```python
* p,
```
```python
int
```
```python
n)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
* pHead = p, *pTail = p + n -
```
```python
1
```
```python
; pHead < pTail; ++pHead, --pTail)
    {
```
```python
//奇数:重合退出+偶数:交叉退出
```
```python
*pHead = *pHead ^ *pTail;
        *pTail = *pHead ^ *pTail;
        *pHead = *pHead ^ *pTail;
    }
}
```
```python
//05.传递实质是什么就可以以何种形式进行数据访问!
```
```python
//  这里传递的实质是数组,因此可以采用数组方式访问
```
```python
void
```
```python
showArr(
```
```python
int
```
```python
* p,
```
```python
int
```
```python
n)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < n; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%2d"
```
```python
, p[i]);
    }
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arrA[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
};
```
```python
//10/2=5..0--><=5-->0~4(前0~4与后0~4)对称
```
```python
int
```
```python
arrB[
```
```python
9
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
};
```
```python
//9/2=4..1--><=4-->0~3(前0~3与后0~4)对称
```
```python
revArr(arrA,
```
```python
sizeof
```
```python
(arrA) /
```
```python
sizeof
```
```python
(arrA[
```
```python
0
```
```python
]));
    showArr(arrA,
```
```python
sizeof
```
```python
(arrA) /
```
```python
sizeof
```
```python
(arrA[
```
```python
0
```
```python
]));
```
```python
putchar
```
```python
(
```
```python
'\n'
```
```python
);
    revArrT(arrB,
```
```python
sizeof
```
```python
(arrB) /
```
```python
sizeof
```
```python
(arrB[
```
```python
0
```
```python
]));
    showArr(arrB,
```
```python
sizeof
```
```python
(arrB) /
```
```python
sizeof
```
```python
(arrB[
```
```python
0
```
```python
]));
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//06.特殊常量指针访问数组方式:
```
```python
//  原理:arr[i]<=>*(arr+i)
```
```python
//  因此:i[arr]<=>*(i+arr)
```
```python
//  注:所有数组的解析方式都是按照arr[i]-->*(arr+i)-->
```
```python
//      所有荒唐用法i[arr]也可以进行替换为-->*(i+arr)
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
};
```
```python
printf
```
```python
(
```
```python
"% \n"
```
```python
,
```
```python
8
```
```python
[arr]);
```
```python
//arr[1]<==>*(arr+1)
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(09):queue.h&queue.c+01.多线程.c+02.多线程排队.c
内容概要:**多线程并行计算**
```python
///
```
```python
queue.h
```
```python
#
```
```python
define
```
```python
EN 100
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
data[EN];
```
```python
int
```
```python
head;
```
```python
int
```
```python
tail;
} Queue;
```
```python
void
```
```python
initQueue(Queue * pQueue);
```
```python
int
```
```python
isEmpty(Queue * pQueue);
```
```python
int
```
```python
isFull(Queue * pQueue);
```
```python
void
```
```python
enQueue(Queue * pQueue,
```
```python
int
```
```python
value
```
```python
);
```
```python
void
```
```python
deQueue(Queue * pQueue);
```
```python
int
```
```python
getLast(Queue * pQueue);
```
```python
void
```
```python
showQueue(Queue * pQueue);
```
```python
//#undef N//结束宏名为N的作用域
```
```python
///queue.c
```
```python
#include "queue.h"
```
```python
#include <memory.h>
```
```python
#include <stdio.h>
```
```python
void
```
```python
initQueue(Queue * pQueue)
{
```
```python
memset
```
```python
((*pQueue).data,
```
```python
0
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
)*EN);
```
```python
//数据清零,模拟回收
```
```python
(*pQueue).head = (*pQueue).tail = -
```
```python
1
```
```python
;
}
```
```python
int
```
```python
isEmpty(Queue * pQueue)
{
```
```python
if
```
```python
((*pQueue).head == (*pQueue).tail)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
isFull(Queue * pQueue)
{
```
```python
if
```
```python
(EN -
```
```python
1
```
```python
== (*pQueue).tail)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
enQueue(Queue * pQueue,
```
```python
int
```
```python
value)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== isFull(pQueue))
```
```python
return
```
```python
;
```
```python
if
```
```python
(
```
```python
1
```
```python
== isEmpty(pQueue))
    {
        (*pQueue).data[
```
```python
0
```
```python
] = value;
        (*pQueue).tail =
```
```python
0
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i = (*pQueue).tail; i >
```
```python
0
```
```python
; --i)
        {
            (*pQueue).data[i] = (*pQueue).data[i -
```
```python
1
```
```python
];
        }
        (*pQueue).data[
```
```python
0
```
```python
] = value;
        ++((*pQueue).tail);
    }
}
```
```python
void
```
```python
deQueue(Queue * pQueue)
{
```
```python
if
```
```python
(isEmpty(pQueue))
```
```python
return
```
```python
;
    --((*pQueue).tail);
}
```
```python
int
```
```python
getLast(Queue * pQueue)
{
```
```python
return
```
```python
(*pQueue).data[((*pQueue).tail)--];
}
```
```python
void
```
```python
showQueue(Queue * pQueue)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <= (*pQueue).tail; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%2d"
```
```python
, (*pQueue).data[i]);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
///01.多线程.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <time.h>
```
```python
#include <process.h>
```
```python
#define N 1024
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    srand((
```
```python
unsigned
```
```python
int
```
```python
)time(NULL));
```
```python
int
```
```python
data[N] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        data[i] = rand() %
```
```python
1000
```
```python
+
```
```python
1
```
```python
;
    }
```
```python
int
```
```python
sum =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        sum += data[i];
    }
```
```python
printf
```
```python
(
```
```python
"单线程串行结果为%d! \n"
```
```python
, sum);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
tID;
```
```python
int
```
```python
* pStart;
```
```python
int
```
```python
sLength;
```
```python
int
```
```python
cSum;
} thTaskInfo;
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    thTaskInfo thTask;
    thTaskInfo * pThTask = &thTask;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (*pThTask).sLength =
```
```python
100
```
```python
);
```
```python
//结构体访问的等价关系!
```
```python
//  (*thTask).sLength <=>thTask->sLength
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (*pThTask).sLength);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
thTaskFun(
```
```python
void
```
```python
* p)
{
    thTaskInfo * thTask = p;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < (*thTask).sLength; ++i)
    {
        (*thTask).cSum += (*thTask).pStart[i];
    }
```
```python
printf
```
```python
(
```
```python
"ID为%d的线程计算结果为%d! \n"
```
```python
, (*thTask).tID, (*thTask).cSum);
}
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
    srand((
```
```python
unsigned
```
```python
int
```
```python
)time(NULL));
```
```python
int
```
```python
data[N] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        data[i] = rand() %
```
```python
1000
```
```python
+
```
```python
1
```
```python
;
    }
```
```python
int
```
```python
sum =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        sum += data[i];
    }
```
```python
printf
```
```python
(
```
```python
"单线程串行计算结果为%d \n"
```
```python
, sum);
    thTaskInfo thTaskArgs[
```
```python
4
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
4
```
```python
; ++i)
    {
        thTaskArgs[i].tID = i;
        thTaskArgs[i].pStart = data + (N /
```
```python
4
```
```python
) * i;
        thTaskArgs[i].sLength = N /
```
```python
4
```
```python
;
        thTaskArgs[i].cSum =
```
```python
0
```
```python
;
        _beginthread(thTaskFun,
```
```python
0
```
```python
, &thTaskArgs[i]);
    }
    system(
```
```python
"pause"
```
```python
);
```
```python
//等待所有并行计算线程完成计算操作
```
```python
int
```
```python
lastNum =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
4
```
```python
; ++i)
    {
        lastNum += thTaskArgs[i].cSum;
    }
```
```python
printf
```
```python
(
```
```python
"多线程并行计算结果为%d! \n"
```
```python
, lastNum);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.多线程排队.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <time.h>
```
```python
#include "queue.h"
```
```python
#include <process.h>
```
```python
#define N 1024
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
tID;
```
```python
int
```
```python
* pStart;
```
```python
int
```
```python
sLength;
```
```python
int
```
```python
cSum;
} thTaskInfo;
Queue thQueue;
```
```python
//管理线程的队列,全局变量,所有线程共享
```
```python
//01.C语言当中的static关键字使用:
```
```python
//  static关键字用于限定函数或者变量只能作用域当前文件!
```
```python
static
```
```python
void
```
```python
thTaskFun(
```
```python
void
```
```python
* p)
{
    thTaskInfo * thTask = p;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < (*thTask).sLength; ++i)
    {
        (*thTask).cSum += (*thTask).pStart[i];
    }
    enQueue(&thQueue, (*thTask).tID);
```
```python
//线程ID进队,便于顺序打印结果
```
```python
printf
```
```python
(
```
```python
"ID为%d的线程计算结果为%d! \n"
```
```python
, (*thTask).tID, (*thTask).cSum);
}
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
    srand((
```
```python
unsigned
```
```python
int
```
```python
)time(NULL));
```
```python
int
```
```python
data[N] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        data[i] = rand() %
```
```python
1000
```
```python
+
```
```python
1
```
```python
;
    }
```
```python
int
```
```python
sum =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        sum += data[i];
    }
```
```python
printf
```
```python
(
```
```python
"单线程串行计算的结果为%d! \n"
```
```python
, sum);
    initQueue(&thQueue);
    thTaskInfo thTaskArgs[
```
```python
4
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
4
```
```python
; ++i)
    {
        thTaskArgs[i].tID = i;
        thTaskArgs[i].pStart = data + (N /
```
```python
4
```
```python
) *i;
        thTaskArgs[i].sLength = N /
```
```python
4
```
```python
;
        thTaskArgs[i].cSum =
```
```python
0
```
```python
;
        _beginthread(thTaskFun,
```
```python
0
```
```python
, &thTaskArgs[i]);
    }
    system(
```
```python
"pause"
```
```python
);
```
```python
//让主线程等待所有辅助线程完成并行计算
```
```python
showQueue(&thQueue);
```
```python
int
```
```python
lastNum =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
4
```
```python
; ++i)
    {
        lastNum += thTaskArgs[i].cSum;
    }
```
```python
printf
```
```python
(
```
```python
"多线程并行运算的结果为%d! \n"
```
```python
, lastNum);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(10):main.c
内容概要:**TestC**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.格式字符串规律:
```
```python
//  格式字符串当中的两个%等同于一个非输入格式控制符
```
```python
//  注:严格区分格式控制符与非格式控制符以及转义字符
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a =
```
```python
2
```
```python
, b =
```
```python
5
```
```python
;
```
```python
printf
```
```python
(
```
```python
"a = %%d, b = %%d \n"
```
```python
, a, b);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(11):test.c
内容概要:**Test**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.自变运算符的特殊性:
```
```python
//  相同的自变运算符如果在表达式当中同时出现;
```
```python
//  那就需要进行同时整体取值运算操作!
```
```python
//  例如:
```
```python
//      出现几个(i++),就同一时间提出几个(i++)的值
```
```python
//          但是提取的是第一个(i++)的值
```
```python
//      出现几个(++I),就同一时间提出几个(++i)的值
```
```python
//          但是提取的是最后一个(++i)的值
```
```python
//02.溢出规律特点:
```
```python
//  原来99块钱,两位数
```
```python
//       99
```
```python
//  加上1块钱,三位数
```
```python
//      100
```
```python
//  但是,只能有两位数
```
```python
//      所以剩下两位是00
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
float
```
```python
x =
```
```python
1
```
```python
, y;
    y = ++x*++x;
```
```python
printf
```
```python
(
```
```python
"%f \n"
```
```python
, y);
```
```python
float
```
```python
i =
```
```python
1
```
```python
, j;
    j = i+++i++;
```
```python
printf
```
```python
(
```
```python
"%f \n"
```
```python
,j);
```
```python
unsigned
```
```python
short
```
```python
num =
```
```python
65535
```
```python
+
```
```python
1
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, num);
```
```python
int
```
```python
a, b;
```
```python
float
```
```python
c;
```
```python
//c = a = b;
```
```python
system(
```
```python
"pause"
```
```python
);
}
```

