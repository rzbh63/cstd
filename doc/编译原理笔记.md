# 编译原理笔记





# 正规文法与有限自动机

教材：[《编译原理》](https://www.baidu.com/s?wd=%E3%80%8A%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E3%80%8B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd) 陈火旺



## 文法

### 前导概念

> 注：我用 单引号（‘ ’）表示 单个字符 双引号（“ ”）表示符号串 
> 这样更容易区分，不过书里面是没有单引号和双引号的！

#### 符号表

单个符号构成的有穷集合，一般表示为 “Σ” 
例如：Σ={‘a’,’b’,’c’,’1’,’2’,’3’,’%’,’+’,’-‘} ​
Σ* 表示 Σ上所有符号串的全体

#### 2.符号串

很好理解 符号串就是由符号表中的符号构成的有穷序列。 
设有符号串X=‘a’+’b’=”ab” ,Y=‘c’+’d’=”cd” 
符号串有一个属性叫长度，很好理解：“ab”的长度为2,”abc”的长度为3 
对符号串的运算：**乘积**（连接）. 
很好理解： XY=“abcd” 
直观理解：这编程语言中很常见的两个字符串变量相加

#### 3.符号串集合

很好理解：把一些符号串组成一个集合就得到了符号串集合

##### 集合相乘：

设两个符号串集合 
A={“a”,”b”,”ab”,”12”} 
B={“c”,”bc”} 
设x代表A集合的元素 
设y代表B集合的元素 
则A与B相乘的结果定义为这样的一个 符号串集合： 
A*B={xy|x∈A,y∈B} 
其中xy表示两个符号串的连接而成的符号串

> 另外我觉得有必要补充的是离散数学中笛卡儿积的概念，笛卡儿积也是两个集合相乘运算的一种定义 
> AxB={(x,y)|x∈A，y∈B}，但是经过这样运算以后生成的是有序偶的集合与编译原理中的集合相乘运算定义并不一样

定义了乘法那么 集合的幂运算 其实就是自己跟自己相乘。

##### 集合的闭包

设现有符号串集合A，令A={“a”,”ab”,”c”}（无论是符号串集合还是符号表） 
则A的闭包（A*）为是指这样的一个符号串集合： 
A*所有元素都是由A中的符号串经过有限次连接而成 
即 
A*=A0∪A1∪A2∪····∞ 
其中 规定了 A0={ ε } 即 空串集合（不等于空集！） 
直观看来其A*之中已经包括所有组合连接的可能情况， 
显然这个集合是无穷集合。 
更加形象来说：假设用26个英文字母作为集合A 那么A*就是用这26个字母可能构成的所有单词的集合（不考虑组成的单词是否有意义） 
A的正（则）闭包 A+其实就是去除了集合A0 也就是{ε}之后的集合

#### 语言

符号序列的集合称为形式语言

> 每个形式语言都是某个字母表上按某种规则构成的所有符号串的集合。反之，任何一个字母表上符号串的集合均可定义为一个形式语言。

通俗点说语言是句子的集合。

每个具体语言,都有语法和语义两个方面 
形式语言是指不考虑语言的具体意义，即不考虑语义。

现在的问题是如何描述这门语言 
如果组成语言的**句子是有限个**的话，那么只要**枚举**出来所有的句子就等于是描述清楚了这门语言。

但情况往往是：我们可以构造**无穷**多个不同的句子，因此无法通过枚举语言中包含的所有句子来描述这门语言。

在这种情况下，我们使用**文法**来描述这门语言。

例如，设字母表∑={ 0, 1 }, 则

∑+=∑1∪∑2∪∑3∪…
={ 0, 1, 00, 10, 11, 01, 000, 100, …}


显然形式语言 Σ+是**无穷集合**

下面用A表示∑+，用式子A→0表示符号串0∈A或A生成符号串0,

符号“→”读作“**定义为**” 
则集合A可表示成：

```
{
   A→0
   A→1
   A→A0
   A→A1
 }
```

以上诸如“A→0”的式子 称为 **规则** 也称 **产生式**

### 定义

设有文法**G** 
**G**包括四个组成部分：一组终结符号(Terminal)，一组非终结符号(Nonterminal)，一个开始符号，以及一组产生式。 
通常表示成四元组 $G=\{V_N, V_T,P,S\}$

$V_N$​ 是规则中非终结符号的集合。

$V_T$ 是规则中终结符号的集合。

$P$ 是文法规则的集合。※ 
例

```
P={
   A→0
   A→1
   A→A0
   A→A1
 }
```

$S​$ 是一个非终结符号，称为文法的开始符号或文法的识别符号，它至少要在一条规则中作为左部出现。由它开始，识别出我们所定义的语言。

由文法定义可知，文法是对语言结构的定义和描述，文法四大要素中关键是规则的集合。

以上就是文法的定义。

#### 文法分类

乔姆斯基把文法分成了4类；即，对以上定义中的产生式的格式进行限制，比如0型文法（不加限制），1型文法，2型文法，3型文法

##### 0型文法

就是不加限制的文法。当然在判断文法时，肯定是先从3型开始，如果不是再看是不是2型，如果还不是再看是不是1型，如果1,2,3型都不是哪就是0型文法！

##### 1型文法：

又称为上下文有关文法

（1）：式子左边可以有多个字符，但必须有一个终结符
（2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符

##### 2型文法：

又称为上下文无关文法，它的识别系统是非确定下推自动机，产生式形如： $A→b $
其中：$A∈V_N ；b∈(V_T∪V_N)^*$

（1）：式子左边只能有一个字符，而且必须是非终结符
（2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，8但必须是有限个字符

##### 3型文法：

又称为**正规文法**（包括**左线性文法**和**右线性文法**），产生式形如：$ A→aB 或 A→a $
其中： $a∈V_T^*；A，B∈V_N$

（1）：式子左边只能有一个字符，而且必须是非终结符
（2）：式子右边最多有二个字符，而且如果有二个字符必须是一个终结符和一个非终结符
如果只有一个字符，那么必须是终结符
（3）：式子右边的格式一定要一致，也就是说如果有一个是（终结符+非终结符）那么所有的式子都必须是（终结符+非终结符）
  如果有一个是（非终结符+终结符），那么所有的式子都必须是（非终结符+终结符）

###### 正规文法——左线性文法：

（1）：必须是三型文法
（2）：式子右边的产生是（非终结符+终结符）的格式

###### 正规文法——右线型文法：

（1）：必须是三型文法
（2）：式子右边的产生式是（终结符+非终结符）的格式



#### 四种文法描述能力比较

![这里写图片描述](https://img-blog.csdn.net/20180406210817369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
由图可知 正规文法是描述能力最弱的 0型文法最强

------

## 正规式与正规集

正规文法和 正规式正规集

### 定义

递归定义

> - ε是一个正规式，它表示集合L(ε)={ε}。
> - 若a是∑上的字符，则a是一个正规式，它所表示的正规集L(a)={a}。
> - 若正规式r和s分别表示正规集L(r)、L(s)，则 
>   （a）r|s是正规式，表示集合L(r)∪L(s)； 
>   （b）r·s是正规式，表示集合L(r)L(s)； 
>   （c）r*是正规式，表示集合(L(r))*； 
>   （d）(r)是正规式，表示集合L(r)。

仅由有限次地使用上述三个步骤定义的表达式才是∑上的正规式。 
运算符“|”、“·”、“\*”分别称为“或”、“连接”和“闭包”。在正规式的书写中，连接运算符“·”可省略。运算符的优先级从高到低顺序排列为：“\*”、“·”、“|”。 
运算符“|”表示“或”、并集。“*”表示*之前括号里的内容出现0次或多次。 
若两个正规式表示的正规集相同，则认为二者等价。两个等价的正规集U和V

**关于正规式和正规集的理解**：简单说来，字母表里面的元素是正规式，这些元素经过一些运算（| 或，· 连接，* 闭包）之后依然是正规式 由此可知正规式其实是描述了一个集合，这个集合称作正规集。

正规式本身是由字符表元素和运算符组成。可以没有运算符，比如，L(a)={a} 
也可以有运算符的比如正规式 U=(a|b) ,L(U)={a,b} 
如果正规式里面没有闭包操作，那么就是有限个字符串，反之则是无穷个字符串。 
（a|b）*=(a\*b*)*

## 确定有限自动机（DFA）

### 定义

一个确定有限自动机（DFA）**M** 是一个五元式

> M =（S，Σ，δ，s0 ，F ) 
> (1) S 是一个非空有限集，它的每个元素称为一个状态 
> (2) Σ是一个有穷字母表，它的每个元素称为一个输入符号，所以也称为输入符号字母表 
> (3)δ是状态转换函数，是在S×Σ→S上的单值映射。δ（s,a）=s’ 意味着输入a以后会从s状态转换到s’状态 
> (4) s0， s0 ∈S，是**唯一**的一个初态 
> (5) F， F∈S，可空,是一个终态集,终态也称可接受状态或结束状态

### 特点：

1. 初态唯一
2. 输入字符不包括ε
3. 有向边上只有一个字符
4. 一个状态对于某个字符，最多只有一条出边

如图：

![这里写图片描述](https://img-blog.csdn.net/20180406210849521?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**对定义进行一些说明：**

**SxΣ** 是指 S与Σ的笛卡儿积，生成的是有序偶集合

> 笛卡儿积：设A,B为集合，用A中元素为第一元素，B中元素为第二元素构成有序对，所有这样的有序对组成的集合叫做A与B的笛卡尔积， 
> 记作AxB.A×B={(x,y)|x∈A∧y∈B} 
> 例如：设 有状态S={1，2} Σ={a,b}，则SxΣ={(1,a),(1,b),(2,a),(2,b)}

**单值映射**

> 两个非空集合A与B间**存在着对应关系f**，而且对于A中的**每一个**元素x，B中**总有唯一的**一个元素y与它对应，就这种对应为从A到B的映射，记作f：A→B。其中，b称为元素a在映射f下的**象**，记作：b=f(a)。a称为b关于映射f的**原象**。集合A中所有元素的象的集合称为映射f的值域，记作f(A)。

## 非确定有限自动机(NFA)

### 定义

一个非确定有限自动机(NFA) **M**是一个五元式 $M=(S,Σ,δ,S_0,F) $
 (1)$S$ 有穷非空状态集合 
 (2)$Σ$ 有穷的输入字母表集合 
 (3)$δ$ 从$S×∑^*$到S的子集的映射 
 (4)$S_0∈S$, 是S的**非空子集**,称为**初始状态集合** 
 (5)$F ∈ S$ ,是$S$的子集(可空),称为终止状态集合

### 特点：

1. 初态不唯一
2. 输入字符包括 $ε$
3. 有向边上可以为字符串
4. 一个状态对于某个字符，可能有多条输出边，即状态的后继不唯一

## 正规文法，正规式，DFA以及NFA的关系

对于每一个NFA M 都存在一个DFA M” 使 L(M)=L(M”)（NFA可以转换成DFA） 
正规文法与有限自动机等价（可以相互转换） 
正规式与有限自动机等价（可以相互转换） 
正规文法与正规式等价（可以相互转换）

### 正规文法→正规式

#### 方法

1. 将正规文法中的每个非终结符表示成关于它的一个正规式方程，获得一个联立方程组
2. 依照求解规则：

```
   若 x = αx | β (或 x = αx + β ) 
   则解为 x = α*β （右线性）
   若 x = xα | β (或 x = xα + β ) 
   则解为 x = βα* （左线性）1234
```

以及正规式的分配律、交换律和结合律求关于文法开始符号的正规式方程组的解。

> 另注： 
> 2型文法是(上下文无关文法)是用来语法分析的，词法分析暂时不需要考虑它啦，3型文法是主场

### 正规式→正规文法

#### 方法

1. 令 $V_T=Σ$ 。
2. 对任何正规式R选择一个非终结符Z生成规则$Z→R$并令$S＝Z​$。
3. 若a和b都是正规式，对形如 $A→ab$ 的规则转换成 $A→aB$和 $B→b$两规则，其中B是新增的非终结符。
4. 对已转换的文法中, 形如$A→ a^*b$ 的规则，进一步转换 成 $A → aA | b$ 。
5. 不断利用规则(3)和(4)进行变换，直到 每条规则最多含有一个终结符为止。

### 正规式→NFA

由正规式构造NFA 
设有正规式**R**

**输入：**字母表Σ上的正规式R

> 注：因为正规式代表了一类符号集合，转换成NFA的过程中正规式充当的对象是输入字符的作用。也就是说，构造出可以识别此正规式的NFA

**输出：**识别(接受)语言L(R)的NFAN

#### 方法

##### 1.引进初始结点X和终止结点Y，把R表示成拓广转换图

![拓广转换图](https://img-blog.csdn.net/20180406211051838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

##### 2.分析R的语法结构，用如下规则对R中的每个基本符号构造NFA。

**(1)R=Φ, 构造NFA如图所示。** 
![这里写图片描述](https://img-blog.csdn.net/20180406210940681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**2)R= ε , 构造NFA如图所示。** 
![这里写图片描述](https://img-blog.csdn.net/20180406211016115?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**(3)R= a (a∈Σ), 构造NFA如图所示。** 
![这里写图片描述](https://img-blog.csdn.net/20180406211037363?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
**(4) 若R是复合正规式，则按下图的转换规则** 
对R进行分裂和加进新结, 直至每个边上只留下一个符号或 ε 为止。 
![这里写图片描述](https://img-blog.csdn.net/20180406211103613?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 3.整个分裂过程中, 所有新结均采用不同的名字，保留X，Y为全图唯一初态结和终态结。

### NFA→正规式

从NFA构造正规式 
设有NFA **M** 以及正规式**r**

#### 方法 ：

**（1）在M中引进新的初态结点X和终态结点Y，形成M’，使得：**

![这里写图片描述](https://img-blog.csdn.net/20180406211134346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
![这里写图片描述](https://img-blog.csdn.net/20180406211207313?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**（2）M’消结，只剩下X，Y 反复使用下面的替换规则消去M’中的所有结点，逐步用正规式来标记弧：** 
![这里写图片描述](https://img-blog.csdn.net/20180406211152723?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 
**（3）结点X和Y之间弧上的标记，即为所求正规式r** 
![这里写图片描述](https://img-blog.csdn.net/20180406211122854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDE1NzdGMDU0Ng==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





## 文法→自动机

正规文法转有穷自动机方法
正规文法G和有穷自动机M表示如下： 


G与M的对应关系

1) 状态集合 Q = VN ∪ Z
2) 字母表 ∑ = VT
3) 初态 q0 = S
4) P与f的转换规则
a)  A → aB  ==>  f(A,a) = B
b)  A → a  ==>  f(A,a) = Z

5) 画状态转换图 

例题
已知G[S]:

```
S  →  aA
S  →  bB
S  →  ε
A  →  aB
A  →  bA
B  →  aS
B  →  bA
B  →  ε
```

解: 
1) Q = {S,A,B,Z} 
2) ∑ = {a,b} 
3) q0 = S 
4) P与f的转换关系

f(S,a) = A
f(S,b) = B
f(S,ε) = Z
f(A,a) = B
f(A,b) = A
f(B,a) = S
f(B,b) = A
f(B,ε) = Z

5) 画状态转换图 


说明

转换得到的是NFA，有必要的时候需要转换成DFA，DFA最简化



## 自动机→文法



- 这是[“文法→自动机”](https://www.jianshu.com/p/8157484382ef)的逆过程，把过程反过来就行。可以点击以查看相关内容。
- 注意的一点就是：对终态增加规则 Z → ε。下面直接上例子

### 例子

![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-69d600d96b985155.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-315dada385fba882.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1) $V_N = \{A,B,C,D\} $
2) $V_T = \{a,b\}$ 
3) $S = A$ 
4) f与P的对应

```
A  →  aB
A  →  bD
B  →  bC
C  →  aA
C  →  bD
D  →  bD
D  →  aB
C  →  ε
D  →  ε
```

- 所以 G = ({A,B,C,D}, {a,b}, P, A),其中P为：

```
A  →  aB                  A  →  bD
B  →  bC                  C  →  aA
C  →  bD                  D  →  bD
D  →  aB                  C  →  ε
D  →  ε
```






# LL(1)文法

**说明**：所有大写字母代表非终结符，小写字母代表终结符，省略号代表未知数目(可能为0)的不确定类型的文法符号。

### FIRST集合

FIRST集合顾名思义就是求一个文法符号串所可能推导出的符号串的第一个终结符的集合。

FIRST(X)就是求X所有推导出的符号串的第一个符号的集合。

求FIRST集合可分如下几种情况:

单个符号的FIRST集合：

单个终结符的FIRST集合就是它自己。

单个非终结符的FIRST集合：

A-->a  产生式右部以终结符开头

根据定义，这种情况下显然可以看出a属于FIRST(A)。

 

A-->B  产生式右部以非终结符开头

根据定义，既然可以把A替换成B  ，也可以看出 FIRST(B) 属于FIRST(A)。

这是一个递归的推导。

 

多个符号形成的符号串的FIRST结合：

符号串ABC ，并且A不能推导出空串ε

当A不能推导出空串ε，显然根据定义FIRST(ABC )=FIRST(A)

 

符号串ABC ，并且A可能推导出空串ε

当A不是空串的时候，显然FIRST(A)属于FIRST(ABC )，但当A是空串的时候，

ABC 就成了BC ，此时根据B是否能推出空串来决定是否将FIRST(B)加入FIRST(ABC )。这是一个递归的推导，综上所述，符号串中的第一个不能推出空串的符 号前面所有符号的FIRST集合减去空串ε都属于FIRST(ABC )，第一个不能推出空串的 符号的FIRST集合也属于FIRST(ABC )。也就是假设A、B都可以推出空串，C不能推 出空串，FIRST(ABC )=FIRST(A)-ε∪FIRST(B)-ε∪FIRST(C)。

 

符号串ABC ，并且所有的符号ABC 都可能推导出空串ε

此时FIRST(ABC )就是所有符号的FIRST集合的并集

 

 

注意：FIRST集合中的符号一定是终结符，终结符也包括空串ε。

### FOLLOW集合

FOLLOW集合也是顾名思义的，就是文法符号后面可能跟随的终结符的集合(不包括空 串ε)。

FOLLOW(X)就是求X后面可能跟随的符号集合。

求FOLLOW集合可分如下几种情况:

 

终结符的FOLLOW集合没有定义，只有非终结符才会有FOLLOW集合。

 

A--> Ua  要求的FOLLOW集合的非终结符后跟终结符

根据定义，显然a属于FOLLOW(U)。这种情况下，FOLLOW(U)和A没有任何关系，产 生式左边是什么无所谓。

 

A--> UP  要求的FOLLOW集合的非终结符后跟非终结符

根据定义，显然P的第一个符号属于FOLLOW(U)，也就是FIRST(P)属于FOLLOW(U)。

 

A--> UP并且ε属于FIRST(P) 要求的FOLLOW集合的非终结符后跟非结尾的终结符， 并且结尾非终结符的FIRST集合包含空串。

这是上一种情况的一种特例，除了要按上一种情况处理，FIRST(P)属于FOLLOW(U) 以外还要进行分析；因为当P推导为空串时，空串不能出现在FOLLOW集合中，所以U后面跟随的应该是P后面的东西，可P已经是结束的符号，此时U后面显然就是A后 面跟随的东西了。所以在这种情况下FOLLOW(A)也属于FOLLOW(U)。

 

A--> U  要求的FOLLOW集合的非终结符在产生式结尾

这时候又要递归推导，U是A的结尾，所以U后面跟随的东西也就是A后面跟随的东 西。所以FOLLOW(A)属于FOLLOW(U)。

注意：FOLLOW集合中的符号一定是终结符，并且不能包括空串ε，而且定义开始符号 的FOLLOW集合初始为{#(句子括号)}。

 

### SELECT集合

SELECT集合就是产生式左部的可能的推导结果的起始符号。

SELECT(A-->B)就是求这个产生式中A可能推导出起始符号集合(不包含空串ε)。

求SELECT集合可分如下几种情况:

 

A-->X (X为任意文法符号串，不限于非终结符或单个符号)，并且X不能推导出空串ε

根据定义，显然A推出的符号串起始就是X的起始，也就是FIRST(X).

SELECT(A-->X)= FIRST(X)

 

A-->X (X为任意文法符号串，不限于非终结符或单个符号)，并且X能推导出空串ε

根据定义，显然FIRST(X)属于SELECT(A-->X)，此外，当X推导为空串时，显然A也推导为空串，那么此时推导出的符号串就会是A后面的符号的推导结果。也就是FOLLOW(A),所以，此时FOLLOW(A)也属于SELECT(A-->X)。

 

**注意**：SELECT集合中不包括空串ε，但有可能会包含#(句子括号)。











## 消除左递归



### 前言

- 在进行语法分析的时候，如果采用自上而下的分析方法（从开始符开始，推句子），那么要求文法不是左递归的，进而如果是左递归的，则要求消除左递归

- 左递归的定义：文法经过一次或多次推导之后，出现如下形式: $P → Pa$

- 左递归的分类 

  - 直接左递归：$P → Pa​$
  - 简介左递归：$P → Aa， A → …… → Pb​$

------

### 直接左递归的消除

- 对于 $P → Pa | b$ 形式(b可为空)，可以知道，推导结束的时候一定有一个b在最开始位置（如ba），后面是无数多个a，所以可以归纳得出如下的消除方法

```
P  →  bP'
P' →  aP' | ε
```

- 更一般化的形如$P → PX|Y$（其中X和Y看作一个整体，比如：$P → Pabc|ab|b$，X就是abc，Y就是ab|b），可以归纳成如下形式：

```
P  →  YP';        比如：P  →  abP' | b P'
P'  →  XP' | ε;   比如：P' →  abcP' | ε12
```

### 间接左递归的消除

- 对于P → Aa | x1， A → …… → Pb | x2的形式
- 消除规则
  - 1） 若消除过程中出现了直接左递归，就按照直接左递归的方法，来消除
  - 2） 若产生式右部最左的符号是非终结符，且这个非终结符序号大于等于左部非终结符，则暂不处理（后面会处理到）
  - 3） 若序号小于左部的非终结符，则用之前求到的式子的右部来替换
- 步骤伪代码

```c
// 1.把文法G的所有非终结符按任意顺序排列，并编号
[P1,P2,……,Pn]

// 2.按上面的排列顺序，对这些非终结符进行遍历
for(int i = 1; i <= n; ++i) {

  for(int j = 1; i <= i - 1; ++j) {
    // 3.将当前处理的非终结符中的序号小于等于它的非终结符按规则3）进行替换（序号大于的按规则2）处理）
    2）、3）
  }
  // 4.消除i序号的非终结符的直接左递归（如果存在的话）
  1）
}

// 5.删除其中不可达的非终结符（从开始符开始，无法再推出的非终结符）
```

- 注意

  - 第一步对非终结符进行排序的序列不同，最后结果的产生式有可能不同，但它们是等价的
  - 开始符号不能改变
  - 该算法，能同时消除直接、间接左递归

------

### 例题

- 存在如下文法，消除左递归 
  1）S → Qc | c 
  2）Q → Rb | b 
  3）R → Sa | a

1）把文法G的所有非终结符按任意顺序排列，并编号

```
R、Q、S
```

2）按上面的排列顺序，对这些非终结符进行遍历 
3）将当前处理的非终结符中的序号小于等于它的非终结符按规则3）进行替换（序号大于的按规则2）处理）

```
R:
R的右部中的非终结符有S;
S的下标大于R，可以暂时不处理;
所以此时R改写为：R  →  Sa | a

----------------------------------------------
Q:
Q的右部中的非终结符有R;
R的下标小于Q，将R的右部替换进来;
所以此时Q改写为：Q  →  Sab | ab | b;
S的下标大于Q，可以暂时不处理;
所以此时Q改写为：Q  →  Sab | ab | b;

-----------------------------------------
S:
S的右部中的非终结符有Q;
Q的下标小于S，将Q的右部替换进来;
所以此时S改写为：S  →  Sabc |abc | bc | c
S的下标等于S，可以暂时不处理;
所以此时S改写为：S  →  Sabc |abc | bc | c
```

4）消除i序号的非终结符的直接左递归（如果存在的话）

```
S  →  Sabc |abc | bc | c
∴  X = abc，Y = abc | bc | c
∴ 直接消除左递归的结果是：
S  →  abcS' | bcS' | cS'
S'  → abcS' | ε
```

5）删除其中不可达的非终结符，这里就是Q、R了

∴ 最终消除左递归的结果是

```
S  →  abcS' | bcS' | cS'
S'  → abcS' | ε
```



## 求FIRST集合



### 前言

- 为什么需要求FIRST集合：因为一个产生式存在多个候选式，选择哪一个候选式是不确定的，所以这就产生了回溯。回溯需要消耗大量的计算、存储空间，所以我们需要消除回溯。而消除回溯的其中一种方法叫作“预测”，即根据栈顶非终结符去预测后面的候选式，那预测方法就是求第一个非终结符，来判断是否和读头匹配，以达到预测的效果 
  ![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-9ce41bc26adcbf10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### FIRST集合定义

- 文字定义：FIRST(α)集合是A的所有可能推导出的开头终结符或ε组成的集合，称FIRST(α)为α的开始符号集或首符号集

- 公式定义： 
  设G是上下文无关文法： $G=(V_N,V_T,P,S)$
  则： $FIRST(a) = \{a|A →aB , a\in V_T, A,B \in V_N\}$
  ![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-fea47ea81b817873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 注意

  - α多步能直接推出ε时，此时将ε加入FIRST集合

### 计算FIRST集合步骤

求解$FIRST(X)$:
- 1）若$X ∈ V_T$，则$FIRST(X) = \{X\}$。【终结符自己就是自己的FIRST集合】
- 2）若$X ∈ V_N$，且有产生式$X → a……， a ∈ V_T$，则$a ∈ FIRST(X)$ 【非终结符，选第一个终结符加入】
- 3）若$X ∈ V_N，X → ε​$，则 $ε ∈ FIRST(X)​$ 【能直接推出ε，ε加入FIRST】
- 4）若$X,Y_1,Y_2,……,Y_n ∈ V_N$，而有产生式$X → Y_1,Y_2,……,Y_n$。当$Y_1,Y_2,……,Y_{i-1}$ 直接推出ε时，则$FIRST(Y_1) - ε, FIRST(Y_2) - ε, …… , FIRST(Y_{i-1} - ε) $,$FIRST(Y_i)$ 都包含在FIRST(X)中【中间的ε是不会加入进去的】
- 5）当4）中所有$Y_i​$ 都推出 ε时，则最后的$FIRST(X) = FIRST(Y_1) ∪ FIRST(Y_2) ∪ …… ∪ FIRST(Y_n) ∪ {ε}​$

反复运用2）-5）步骤，直到每个符号的FIRST集合不再增大为止

### 例题

- 对如下文法G，求各个非终结符的终结首符集

```
1.E  →  TE'
2.E'  →  +TE'
3.E'  →  ε
4.T  →  FT'
5.T'  →  *FT'
6.T'  →  ε
7.F  →  i
8.F  →  (E)
```

解：

```c
----------------------FIRST(E)、FIRST(T)、FIRST(F)----------------------
FIRST(E) = FIRST(T);       // 1.
FIRST(T) = FIRST(F);       // 4.
FIRST(F) = {i,(};          // 7. 8.

∴ FIRST(E) = FIRST(T) = FIRST(F) = {i,(};


----------------------FIRST(E')----------------------
FIRST(E') = {+,ε};         // 2. 3.

----------------------FIRST(T')----------------------
FIRST(T') = {*,ε};         // 5. 6.
```

### 

## 提取最左因子



### 前言

- 为什么需要提取最左因子：当存在公共的最左因子时，FIRST集合之间会造成两两相交的情况，为了不使FIRST集合之间相交，所以需要提取最左因子

### 提取办法

- 很简单，比如 A → δβ1 | δβ2 | δβ3 | …… |δβn | δ，就提取成 
  A → δA’ 
  A’ → β1 | β2 | β3 | …… | βn | ε 
  重复这个操作，直到所有的FIRST集合两两不相交

### 注意

- 这样做是有一定代价的，会引入大量的非终结符和ε，增加了语法分析的难度

## 求FOLLOW集合



### 前言

- 为什么需要求FIRST集合：因为一个产生式存在多个候选式，选择哪一个候选式是不确定的，所以这就产生了回溯。回溯需要消耗大量的计算、存储空间，所以我们需要消除回溯。而消除回溯的其中一种方法叫作“预测”，即根据栈顶非终结符去预测后面的候选式，那预测方法就是求第一个非终结符，来判断是否和读头匹配，以达到预测的效果
- 为什么需要求FOLLOW集合：求FOLLOW集合的目的和FIRST集合的目的是一样的，但是应该对的情形不一样，当出现了下列情形时，求FIRST集合已经达不到要求了

![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-13a28fbb55858746.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

但是我们观察后发现，当F推出ε时，下面的E推出的a是能进行匹配的，在F这个位置求到a，就是在求FOLLOW集合

### FOLLOW集合定义

- 文字定义：FOLLOW(A)集合是所有紧跟A之后的终结符或#所组成的集合（#是句尾的标志），称FOLLOW(A)是A的随符集
- 公式定义： 
  设G是上下文无关文法，A ∈ VN，S是开始符 
  ![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-cc6c3fbeb1a17dfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 
  则： 
  ![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-5ad83d274994e39d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 注意
  - 当A是最右部的时候，# 加入 FOLLOE(A)

------

### 计算FOLLOW集合步骤

- 求解非终结符A的随符集FOLLOW(A)
- 1）对S，将 # 加入 FOLLOW(S)，然后再按后面的处理
- 2）若B → αAβ是G的产生式，则将FIRST(β) - ε 加入FOLLOW(A)
- 3）若B → αA是G的产生式，或B → αAβ是G的产生式（β 多次推导后得到ε ），则将FOLLOW(B) 加入到FOLLOW(A) 【因为把B用αA替换之后，B后面紧跟的字符就是A后面紧跟的字符】
- 4）反复使用2）-3），直到FOLLOW集合不再增大为止
- 注意
  - 这里的文法G必须是消除左递归且提取了左因子（点击查看提取左因子的办法）

------

### 例题

- 对如下文法G，E为开始符，求E、T、F的随符集

```
1.E  →  TE'
2.E'  →  +TE'
3.E'  →  ε
4.T  →  FT'
5.T'  →  *FT'
6.T'  →  ε
7.F  →  i
8.F  →  (E)12345678
```

解：

```
---------------FOLLOW(E)---------------
FOLLOW(E) = {)} ;   // 8. 规则2）
又 ∵  E是开始符，所以FOLLOW(E) = { #,) } ;     // 规则1）

---------------FOLLOW(T)---------------
FOLLOW(T) = FIRST(E') - ε; // 1.  规则2）
FIRST(E') = {+,ε};     // 2. 3.  
当E' = ε时，E  →  TE' 就是 E  →  T，所以FOLLOW(E)也要加入FOLLOW(T)，
∴ FOLLOW(T) = {+, #,)}
同理，FOLLOW(E')也需要加入到FOLLOW(T)中，
FOLLOW(E') = FOLLOW(E) = { #, )};   // 1. 规则3）
∴ FOLLOW(T) = {+, #,)}

---------------FOLLOW(F)---------------
与FOLLOW(F)相关的式子有：
T'  →  *FT'
T  →  FT'

先，T'  →  *FT'
∴ FOLLOW(F) = FIRST(T') - ε;
FIRST(T') = {*,ε}
当T'为ε时，也要把FOLLOW(T')加入FOLLOW(F)中，
FOLLOW(T') = {+, #,)}，∴ FOLLOW(F) =  {+,*, #,)}

再，T  →  FT'，
∴ FOLLOW(F) = FIRST(T') - ε;
当T'为ε时，也要把FOLLOW(T)加入FOLLOW(F)中，
∴ FOLLOW(F) =  {+,*, #,)}12345678910111213141516171819202122232425262728
```

- 注
  - 形如 T’ → *FT’，求FOLLOW(T’)时，针对本句，可以忽略3），因为是还是再求FOLLOW(T’)
  - 对于产生了ε的，一定要记得3）
  - FIRST求解的时候，关注点在左部，进行推导；FOLLOW求解的时候，关注点在右部，看跟随



## 求SELECT集合

### 前言

- 为什么要求SELECT集合：前面求解的FIRST集合和FOLLOW集合都是为了回溯的问题。求SELECT集合是一个比较简单的操作，主要是为了给后面求预测分析表提供数据

------

### 方法

- 首先，得会求解**FIRST集合**和**FOLLOW集合**
- 求解方法： 
  1.如果 α 不能推出 ε，则：SELECT(A → α) = FIRST(α) 
  2.如果 α 推出 ε，则：SELECT(A → α) = ( FIRST(α) – {ε} ) ∪ FOLLOW(A)

------

### 例子

- 由于比较简单，就不出例子了。在后面求解预测分析表的时候，会进行相关操作

### 

## 求文法G的预测分析表



### 前言

- 为什么求预测分析表：为了消除回溯，前面做了许多准备。其中关键是FIRST集合和FOLLOW集合，它们两个组合，达到了预测候选式的目的。为了使计算机比较好处理，把它们的预测结果统计成一张二维表，这就是求预测分析表的原因
- 定义：M[A] 是一个二维数组，其中行A表示的是栈顶符号，a表示的读头下的符号（A为非终结符，a为终结符），它们存放的是当前状态下所使用的候选式（或存放出错标志，指出A不该面临a的输入） ![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-1526dd4f70a793f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

------

### 预测分析程序的算法（栈顶为X，读入头下为a）

- 1）X = a = ‘#’：识别成功，推出分析程序（X为终结符）
- 2）X = a ≠ ‘#’：进行匹配，弹出X，读头后移（X为终结符）
- 3）X ≠ a：进行error处理（X是终结符）
- 4）若X是非终结符，则查询预测分析表M，若M[X,a]中有关于X的产生式，则弹出X，将产生式入栈；如果M[X,a]中是出错标志，则error处理

------

### 预测分析表求法

- 步骤
  - 1）求出所有非终结符的FIRST集合，FOLLOW集合
  - 2）求出所有产生式的SELECT集合
  - 3）按规则填预测分析表
- 填表规则
  - 根据FIRST集合，看该位置是填候选式还是出错标志（输入符号不存在于FIRST集合中，就是出错标志）
  - 若要填候选式，根据SELECT集合的元素对应填写候选式

### 例子

- 题目：表达式文法为，E是开始符

```
E  →  E+T | T
T  →  T*F | F
F  →  i | (E)123
```

------

解：

- 前期准备 
  1）消除P → P，ε 
  2）消除左递归，得到文法(点击查看如何[消除左递归](https://www.jianshu.com/p/7cd310e6c74e))

```
1.E  →  TE'
2.E'  →  +TE' | ε
3.T  →  FT'
4.T'  →  *FT' | ε
5.F  →  i | (E)12345
```

------

- 正式开始求预测分析表 
  1）求出所有非终结符的FIRST集合，FOLLOW集合

```
非终结符：E、T、F、T'、E'

---------------FIRST(E)、FIRST(T)、FIRST(F)---------------
FIRST(E) = FIRST(T) = FIRST(F) = {i,(};     //  1. 3. 5.

---------------FIRST(T')---------------
FIRST(T') = {*, ε} ;      // 4.

---------------FIRST(E')---------------
FIRST(E') = {+, ε} ;      // 2.12345678910
非终结符：E、T、F、T'、E'
---------------FOLLOW(E)---------------
FOLLOW(E) = {#, )};    // 5.

---------------FOLLOW(T)---------------
A = FIRST(E') - {ε} = {+};    // 1.
B = FOLLOW(E) = {#, )};    // 1.
C = FOLLOW(E') = {#, )};

∴ FOLLOW(T) = A ∪ B ∪ C = {#, ), +};

---------------FOLLOW(F)---------------
A = FIRST(T') - {ε} = {*}
B = FOLLOW(T') = {#, ), +};
C = FOLLOW(T) = {#, ), +};

∴ FOLLOW(F) = A ∪ B ∪ C = {#, ), +, *};

---------------FOLLOW(T')---------------
FOLLOW(T') = FOLLOW(T) =  {#, ), +};

---------------FOLLOW(E')---------------
FOLLOW(E') = FOLLOW(E) = {#, )};1234567891011121314151617181920212223
```

2）求出所有产生式的SELECT集合

```
SELECT(E  →  TE') = FIRST(T) = {i,(};
SELECT(E'  →  +TE') = { + };
SELECT(E'  →  ε) = FOLLOW(E') = {#, )};    // | 连接的，分开出来
SELECT(T  →  FT') = FIRST(F) = {i,(};
SELECT(T'  →  *FT') = {*}
SELECT(T'  →  ε) = FOLLOW(T') =  {#, ), +};
SELECT(F  →  i) = {i}
SELECT(F  →  (E) ) = {(} 12345678
```

3）按规则填预测分析表

| i    | +       | *         | (         | )       | #       |
| ---- | ------- | --------- | --------- | ------- | ------- |
| E    | E → TE’ |           |           | E → TE’ |         |
| T    | T → FT’ |           |           | T → FT’ |         |
| F    | F → i   |           |           |         | F → (E) |
| T’   |         | T’ → ε    | T’ → *FT’ |         | T’ → ε  |
| E’   |         | E’ → +TE’ |           |         | E’ → ε  |

------



## LL(1)文法



- 前面说的像消除左递归、提取最左公因子、求FIRST集合……，今天给它一个称呼，叫作LL(1)文法
- LL(1)文法：若文法G的预测分析表M中不含有多重定义项，则称G为LL(1)文法 
  ![微信公众号：JavaWeb架构师](https://upload-images.jianshu.io/upload_images/8244809-a1df0ef8410ed071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 判断一个文法是不是LL(1)文法
  - 当且仅当对于G的每个非终结符A的任何两个产生式A → α | β，有：

```
// 消除左递归，提取最左公因子的情况下
1）FIRST(α) ∩ FIRST(β) = ∅
2）若ε ∈ FIRST(β)，则FIRST(α) ∩ FOLLOW(A) = ∅123
```

- 注意

   

  - LL(1)文法没有二义性，有二义性的文法一定不是LL(1)文法
  - LL(1)文法是上下文无关文法的一个子集

------

### 

# 自底向上优先分析概述



### 前言

- 前面学了自顶向下的分析方法，它是使用推导的方式进行语法分析。这里学的自底向上优先分析是使用规约进行的语法分析
- 自底向上优先分析的原理：从输入串开始，朝着文法的开始符号进行规约，直到到达开始符号。这是一个最左规约的过程
- 自底向上优先分析的分类：简单优先分析法、算符优先分析法
- 自底向上分析所使用的自动机是PDA（下推自动机） 
  ![PDA](https://upload-images.jianshu.io/upload_images/8244809-6d7daf4b6908ef57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

------

### 工作方式“移进-规约”

- 从左至右让输入串进栈，在移动的过程中不断查看栈顶符号，一旦形成某个句型的句柄就进行替换，直到栈顶不再形成句柄为止。然后继续读入符号，重复上述过程。直到栈顶剩下S#，输入串只有#为止。

- 注意

   

  - 初态时，栈内只有#，读头指向最左边的单词
  - 程序的执行动作 
    1）移入：读最左边的单词 
    2）规约：对栈顶进行规约，并输出产生式的编号 
    3）识别成功：栈顶剩下S#，输入串只有#

### 例子

- 存在如下文法

```
1. S → aAcBe      2. A → b      3.A → Ab      4.B → d1
```

问：abbcde是不是该文法的合法句子

解： 
1）为了便于后续分析，我们先画出语法树 
![语法树](https://upload-images.jianshu.io/upload_images/8244809-af0687ab2dbc3bc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2）进行操作，在规约的时候，按句柄（树的最左的一步推导得到的叶子）规约

| 序号 | 栈    | 输入带  | 输出带  | 操作类型 |
| ---- | ----- | ------- | ------- | -------- |
| 1    | #     | abbcde# |         |          |
| 2    | a     | bbcde#  |         | 移进     |
| 3    | ab    | bcde#   |         | 移进     |
| 4    | aA    | bcde#   | 2       | 规约     |
| 5    | aAb   | cde#    | 2       | 移进     |
| 6    | aA    | cde#    | 2,3     | 规约     |
| 7    | aAc   | de#     | 2,3     | 移入     |
| 8    | aAcd  | e#      | 2,3     | 移入     |
| 9    | aAcB  | e#      | 2,3,4   | 规约     |
| 10   | aAcBe | #       | 2,3,4   | 移入     |
| 11   | S     | #       | 2,3,4,1 | 规约     |

3）进过上述操作后，最后得到栈内元素为 #S，输入串为#，表示识别成功。所以abbcde是该文法的合法句子

- 注意：这里有个前提，是我们已经把语法树给画出来了，所以可以从图中方便的找到句柄。计算机该如何找到句柄呢？这是后面学习的内容



# LL(1),LR(0),SLR(1),LALR(1),LR(1)对比



LL(1)定义：一个文法G是LL（1）的，当且仅当对于G的每一个非终结符A的任何两个不同产生式 A→α|β，下面的条件成立：SELECT( A→α)∩SELECT( A→β)= ∅,其中，

α|β不能同时ε。

解释：LL(1)的意思是，第一个L,指的是从左往右处理输入，第二个L,指的是它为输入生成一个最左推导。1指的是向前展望1个符号。LL(1)文法是上下文无关文法的一个子集。它用的方法是自顶向下的(递归式的处理)。它要求生成的预测分析表的每一个项目至多只能有一个生成式。上面的定义说的是，任何两个不同的产生式 A→α和 A→β,选择A→α或者 A→β是不能有冲突的，即SELECT( A→α)∩SELECT( A→β)= ∅，具体来说，就是，第一:First( A→α) ∩ First( A→β)=,首符集不能有交集，否则当交集中的元素出现时，选择哪个产生式进行推导是不确定的，（这其中也包含了α|β不能同时ε，否则交集就是{ε}不为空），第二：若任何一个产生式β，有ε属于First(β),应有First(A)∩Follow( A)为空（当ε属于First(β)，则A有可能被空串代替，那么就要看A的下一个字符，即Follow集，即要求Follow集和First集不能相交，否则可能发生冲突）。

LR文法：定义：如果某一文法能够构造一张分析表，使得表中每一个元素至多只有一种明确动作，则该文法称为LR文法。

拓展：由上面的定义可以看到，LL(1)和LR文法都是无二义性的：LL(1)要求生成的预测分析表的每一个项目至多只能有一个生成式，即对于读头下的每一个字符，都可以明确地选择哪个产生式来推导，LR文法要求每一步都有明确的动作，移进和归约都是可确定的，没有二义性。

比较两大类型（自顶向下　vs 自底向上）的文法的特点：

1.首先LL(1)分析法是自上而下的分析法。LR(0),LR(1),SLR(1),LALR(1)是自下而上的分析法。
   2.自上而下:从开始符号出发，根据产生式规则推导给定的句子。用的是推导
   3.自下而上:从给定的句子规约到文法的开始符号。用的是归约
   4.自上而下就是一种试探过程，怎么试探？需要你写出它的FIRST()集与FOLLOW()集。写出这两个集合后根据LL(1)分析表构造规则画出LL(1)分析表。现在基本完成了大半，当计算机输入句子时，分析程序便会根据输入去和分析表进行匹配，如果每步都能够匹配成功则说明符合该语法规则，分析成功。
   FIRST()集：其实是终结符的集合，看该非终结符A能不能产生以它里面的某个符号开头的句子。（这也是自上而下分析法的思想）
   5.自下而上就是把句子变成非终结符，在把非终结符变成非终结符，这样不断的进行如果能到根节点则成功。

 LL(1)就是向前只搜索1个符号，即与FIRST()匹配，如果FIRST为空则还要考虑Follow。
　 LR需要构造一张LR分析表，此表用于当面临输入字符时，将它移进，规约（即自下而上分析思想），接受还是出错。
   LR(0)找出句柄前缀，构造分析表，然后根据输入符号进行规约。不考虑先行，只要出现终结符就移进，只要出现归约状态，就无条件归约,这样子可能出现归约－移进，归约－归约冲突。
   SLR(1)使用LR(0)时若有归约－归约冲突，归约－移进冲突，所以需要看先行，则只把有问题的地方向前搜索一次。

SLR(1)定义：满足下面两个条件的文法是SLR(1)文法

a.对于在s中的任何项目 A→α.Xβ,当X是一个终结符，且X在Follow(B)中时，s中没有完整的项目B→r.

b.对于在s中的任何两个完整项目A→α.和 B→β.,Follow(A)∩Follow(B)为空。

解释：a.当X是一个终结符且X出现在读头上，对于项目 A→α.Xβ应该采用移进，若有完整的项目B→r.且Follow(B)中有X，当X出现在读头上时，此时应该归约，于是，就产生了移进和归约冲突

b.假设Follow(A)∩Follow(B)为{ X },对于A→α.，若Follow(A)[A后面的元素]出现时，应该归约，同理B也一样，于是，会产生归约－归约冲突，SLR(1)是为了消除LR(0)的两个冲突。
   LR(1)1.在每个项目中增加搜索符。2.举个列子如有A->α.Bβ，则还需将B的规则也加入。
   LALR(1)就是假如两个产生式集相同则将它们合并为一个，几合并同心集

总结：

见到First集就移进，见到Follow集就归约。

LR(0):见到First集就移进，见到终态就归约

SLR(1)见到First集就移进，见到终态先看Follow集，与Follow集对应的项目归约，其它报错。

SLR分析法包含的展望信息是体现在利用了Follow(A)信息，可以解决“归约－归约”冲突

SLR分析法没有包含足够的展望信息，不能完成解决“移进－归约”冲突，需要改进。

下面是LR(0),SLR(1),LALR(1),LR(1)文法处理能力的比较，圆圈越大说明能力越强。







![img](https://img-blog.csdn.net/20130703204706828)