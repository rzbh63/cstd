
# 事务日志回滚机制研究 - .NET博文收藏 - CSDN博客


2008年06月10日 12:45:00[hejishan](https://me.csdn.net/hejishan)阅读数：747标签：[sql server																](https://so.csdn.net/so/search/s.do?q=sql server&t=blog)[数据库																](https://so.csdn.net/so/search/s.do?q=数据库&t=blog)[dataset																](https://so.csdn.net/so/search/s.do?q=dataset&t=blog)[任务																](https://so.csdn.net/so/search/s.do?q=任务&t=blog)[存储																](https://so.csdn.net/so/search/s.do?q=存储&t=blog)[.net																](https://so.csdn.net/so/search/s.do?q=.net&t=blog)[
							](https://so.csdn.net/so/search/s.do?q=存储&t=blog)[
																															](https://so.csdn.net/so/search/s.do?q=任务&t=blog)
[
				](https://so.csdn.net/so/search/s.do?q=dataset&t=blog)
[
			](https://so.csdn.net/so/search/s.do?q=dataset&t=blog)
[
		](https://so.csdn.net/so/search/s.do?q=数据库&t=blog)
[
	](https://so.csdn.net/so/search/s.do?q=sql server&t=blog)
摘要：
**隔离级别的概念**
企业级的数据库每一秒钟都可能应付成千上万的并发访问，因而带来了并发控制的问题。由数据库理论可知，由于并发访问，在不可预料的时刻可能引发如下几个可以预料的问题：
**脏读**：包含未提交数据的读取。例如，事务1 更改了某行。事务2 在事务1 提交更改之前读取已更改的行。如果事务1 回滚更改，则事务2 便读取了逻辑上从未存在过的行。
**不可重复读取**：当某个事务不止一次读取同一行，并且一个单独的事务在两次（或多次）读取之间修改该行时，因为在同一个事务内的多次读取之间修改了该行，所以每次读取都生成不同值，从而引发不一致问题。
**幻象**：通过一个任务，在以前由另一个尚未提交其事务的任务读取的行的范围中插入新行或删除现有行。带有未提交事务的任务由于该范围中行数的更改而无法重复其原始读取。
如你所想，这些情况发生的根本原因都是因为在并发访问的时候，没有一个机制避免交叉存取所造成的。而隔离级别的设置，正是为了避免这些情况的发生。事务准备接受不一致数据的级别称为隔离级别。隔离级别是一个事务必须与其它事务进行隔离的程度。较低的隔离级别可以增加并发，但代价是降低数据的正确性。相反，较高的隔离级别可以确保数据的正确性，但可能对并发产生负面影响。
根据隔离级别的不同，DBMS为并行访问提供不同的互斥保证。在SQL Server数据库中，提供四种隔离级别：未提交读、提交读、可重复读、可串行读。这四种隔离级别可以不同程度地保证并发的数据完整性：

|隔离级别|脏 读|不可重复读取|幻 像|
|未提交读|是|是|是|
|提交读|否|是|是|
|可重复读|否|否|是|
|可串行读|否|否|否|
可以看出，“可串行读”提供了最高级别的隔离，这时并发事务的执行结果将与串行执行的完全一致。如前所述，最高级别的隔离也就意味着最低程度的并发，因此，在此隔离级别下，数据库的服务效率事实上是比较低的。尽管可串行性对于事务确保数据库中的数据在所有时间内的正确性相当重要，然而许多事务并不总是要求完全的隔离。例如，多个作者工作于同一本书的不同章节。新章节可以在任意时候提交到项目中。但是，对于已经编辑过的章节，没有编辑人员的批准，作者不能对此章节进行任何更改。这样，尽管有未编辑的新章节，但编辑人员仍可以确保在任意时间该书籍项目的正确性。编辑人员可以查看以前编辑的章节以及最近提交的章节。这样，其它的几种隔离级别也有其存在的意义。
在.net框架中，事务的隔离级别是由枚举System.Data.IsolationLevel所定义的：

|[Flags]
|[Serializable]
|public enum IsolationLevel|
其成员及相应的含义如下：

|成 员|含 义|
|Chaos|无法改写隔离级别更高的事务中的挂起的更改。|
|ReadCommitted|在正在读取数据时保持共享锁，以避免脏读，但是在事务结束之前可以更改数据，从而导致不可重复的读取或幻像数据。|
|ReadUncommitted|可以进行脏读，意思是说，不发布共享锁，也不接受独占锁。|
|RepeatableRead|在查询中使用的所有数据上放置锁，以防止其他用户更新这些数据。防止不可重复的读取，但是仍可以有幻像行。|
|Serializable|在DataSet上放置范围锁，以防止在事务完成之前由其他用户更新行或向数据集中插入行。|
|Unspecified|正在使用与指定隔离级别不同的隔离级别，但是无法确定该级别。
|
显而意见，数据库的四个隔离级别在这里都有映射。
默认的情况下，SQL Server使用ReadCommitted(提交读)隔离级别。
关于隔离级别的最后一点就是如果你在事务执行的过程中改变了隔离级别，那么后面的命名都在最新的隔离级别下执行——隔离级别的改变是立即生效的。有了这一点，你可以在你的事务中更灵活地使用隔离级别从而达到更高的效率和并发安全性。
**最后的忠告**
无疑，引入事务处理是应对可能出现的数据错误的好方法，但是也应该看到事务处理需要付出的巨大代价——用于存储点、回滚和并发控制所需要的CPU时间和存储空间。




