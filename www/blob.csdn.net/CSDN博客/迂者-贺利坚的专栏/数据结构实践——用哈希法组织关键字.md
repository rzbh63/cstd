
# 数据结构实践——用哈希法组织关键字 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月29日 15:52:17[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：1693


本文是针对[[数据结构基础系列(8)：查找](http://edu.csdn.net/course/detail/1669)]中第11课时[[哈希表——散列结构](http://edu.csdn.net/course/detail/1669/25735)]和第12课时[[哈希表的运算](http://edu.csdn.net/course/detail/1669/25735)]的实践项目。
【项目 - 用哈希法组织关键字】
已知一个关键字序列为if、while、for、case、do、break、else、struct、union、int、double、float、char、long、bool，共15个字符串，哈希函数H(key)为关键字的第一个字母在字母表中的序号，哈希表的表长为26。
（1）若处理冲突的方法采用线性探测法，请设计算法，输出每个关键字对应的H(key)，输出哈希表，并求成功情况下的平均查找长度。
[参考解答]
```python
#include <stdio.h>
```
```python
#include <string.h>
```
```python
#define N 15
```
```python
#define M 26
```
```python
int
```
```python
H(char
```
```python
*s
```
```python
)
{
```
```python
return
```
```python
((
```
```python
*s
```
```python
-
```
```python
'a'
```
```python
+
```
```python
1
```
```python
)
```
```python
%M
```
```python
);
}
```
```python
int
```
```python
main()
{
    char
```
```python
*s
```
```python
[N]= {
```
```python
"if"
```
```python
,
```
```python
"while"
```
```python
,
```
```python
"for"
```
```python
,
```
```python
"case"
```
```python
,
```
```python
"do"
```
```python
,
```
```python
"break"
```
```python
,
```
```python
"else"
```
```python
,
```
```python
"struct"
```
```python
,
```
```python
"union"
```
```python
,
```
```python
"int"
```
```python
,
```
```python
"double"
```
```python
,
```
```python
"float"
```
```python
,
```
```python
"char"
```
```python
,
```
```python
"long"
```
```python
,
```
```python
"bool"
```
```python
};
```
```python
int
```
```python
i, j, k;
    char HT[M][
```
```python
10
```
```python
];
```
```python
int
```
```python
Det[M];
```
```python
//
```
```python
存放探测次数
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M; i++)
    {
        HT[i][
```
```python
0
```
```python
]=
```
```python
'\0'
```
```python
;
        Det[i]=
```
```python
0
```
```python
;
    }
```
```python
printf
```
```python
(
```
```python
"字符串 key\tH(key)\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"------------------------\n"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<N; i++)
    {
        j=H(
```
```python
s
```
```python
[i]);
```
```python
//
```
```python
求哈希值
```
```python
printf
```
```python
(
```
```python
"
```
```python
%s
```
```python
\t\t
```
```python
%d
```
```python
\n"
```
```python
,
```
```python
s
```
```python
[i],j);
        k=
```
```python
0
```
```python
;
```
```python
//
```
```python
探测次数初值
```
```python
while
```
```python
(
```
```python
1
```
```python
)
        {
            k++;
```
```python
//
```
```python
累加探测次数
```
```python
if
```
```python
(HT[j][
```
```python
0
```
```python
]==
```
```python
'\0'
```
```python
)   //当不冲突时，直接放到该处
            {
                strcpy(HT[j],
```
```python
s
```
```python
[i]);
```
```python
break
```
```python
;
            }
```
```python
else
```
```python
//冲突时，采用线性探查法求下一个地址
            {
                j=(j+
```
```python
1
```
```python
)
```
```python
%M
```
```python
;
            }
        }
        Det[j]=k;
    }
```
```python
printf
```
```python
(
```
```python
"---------------------\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"哈希表\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"位置\t字符串\t探查次数\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"---------------------\n"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M; i++)
```
```python
printf
```
```python
(
```
```python
"
```
```python
%d
```
```python
\t
```
```python
%s
```
```python
\t
```
```python
%d
```
```python
\n"
```
```python
, i, HT[i], Det[i]);
```
```python
printf
```
```python
(
```
```python
"---------------------\n"
```
```python
);
    k=
```
```python
0
```
```python
;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M; i++)
        k+=Det[i];
```
```python
printf
```
```python
(
```
```python
"查找成功情况下的平均查找长度
```
```python
%f
```
```python
\n"
```
```python
,
```
```python
1.0
```
```python
*k
```
```python
/N);
```
```python
return
```
```python
0
```
```python
;
}
```
（2）若处理冲突的方法采用链地址法，请设计算法，输出哈希表，并计算成功情况和不成功情况下的平均查找长度。
[参考解答]
```python
#include <stdio.h>
```
```python
#include <string.h>
```
```python
#include <malloc.h>
```
```python
#define N 15
```
```python
#define M 26
```
```python
typedef
```
```python
struct
```
```python
node
```
```python
//定义哈希链表的节点类型
```
```python
{
```
```python
char
```
```python
*key;
```
```python
struct
```
```python
node *next;
} LNode;
```
```python
typedef
```
```python
struct
```
```python
{
    LNode *link;
} HTType;
```
```python
int
```
```python
H(
```
```python
char
```
```python
*s)
```
```python
//实现哈希函数
```
```python
{
```
```python
return
```
```python
((*s-
```
```python
'a'
```
```python
+
```
```python
1
```
```python
)%M);
}
```
```python
//构造哈希表
```
```python
void
```
```python
Hash(
```
```python
char
```
```python
*s[], HTType HT[])
{
```
```python
int
```
```python
i, j;
    LNode *q;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M; i++)
```
```python
//哈希表置初值
```
```python
HT[i].link=NULL;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<N; i++)
```
```python
//存储每一个关键字
```
```python
{
        q=(LNode*)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(LNode));
```
```python
//创建新节点
```
```python
q->key = (
```
```python
char
```
```python
*)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(
```
```python
strlen
```
```python
(s[i])+
```
```python
1
```
```python
));
```
```python
strcpy
```
```python
(q->key, s[i]);
        q->next=NULL;
        j=H(s[i]);
```
```python
//求哈希值
```
```python
if
```
```python
(HT[j].link==NULL)
```
```python
//不冲突，直接加入
```
```python
HT[j].link=q;
```
```python
else
```
```python
//冲突时，采用前插法插入
```
```python
{
            q->next = HT[j].link;
            HT[j].link=q;
        }
    }
}
```
```python
//输出哈希表
```
```python
void
```
```python
DispHT(HTType HT[])
{
```
```python
int
```
```python
i;
    LNode *p;
```
```python
printf
```
```python
(
```
```python
"哈希表\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"位置\t关键字序列\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"---------------------\n"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M; i++)
    {
```
```python
printf
```
```python
(
```
```python
" %d\t"
```
```python
, i);
        p=HT[i].link;
```
```python
while
```
```python
(p!=NULL)
        {
```
```python
printf
```
```python
(
```
```python
"%s "
```
```python
, p->key);
            p=p->next;
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"---------------------\n"
```
```python
);
}
```
```python
//求查找成功情况下的平均查找长度
```
```python
double
```
```python
SearchLength1(
```
```python
char
```
```python
*s[], HTType HT[])
{
```
```python
int
```
```python
i, k, count =
```
```python
0
```
```python
;
    LNode *p;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<N; i++)
    {
        k=
```
```python
0
```
```python
;
        p=HT[H(s[i])].link;
```
```python
while
```
```python
(p!=NULL)
        {
            k++;
```
```python
//p!=NULL，进入循环就要做一次查找
```
```python
if
```
```python
(
```
```python
strcmp
```
```python
(p->key, s[i])==
```
```python
0
```
```python
)
```
```python
//若找到，则退出
```
```python
break
```
```python
;
            p=p->next;
        }
        count+=k;
    }
```
```python
return
```
```python
1.0
```
```python
*count/N;
```
```python
//成功情况仅有N种
```
```python
}
```
```python
//求查找不成功情况下的平均查找长度
```
```python
double
```
```python
SearchLength2(HTType HT[])
{
```
```python
int
```
```python
i, k, count =
```
```python
0
```
```python
;
```
```python
//count为各种情况下不成功的总次数
```
```python
LNode *p;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<M; i++)
    {
        k=
```
```python
0
```
```python
;
        p=HT[i].link;
```
```python
while
```
```python
(p!=NULL)
        {
            k++;
            p=p->next;
        }
        count+=k;
    }
```
```python
return
```
```python
1.0
```
```python
*count/M;
```
```python
//不成功时，在表长为M的每个位置上均可能发生
```
```python
}
```
```python
int
```
```python
main()
{
    HTType HT[M];
```
```python
char
```
```python
*s[N]= {
```
```python
"if"
```
```python
,
```
```python
"while"
```
```python
,
```
```python
"for"
```
```python
,
```
```python
"case"
```
```python
,
```
```python
"do"
```
```python
,
```
```python
"break"
```
```python
,
```
```python
"else"
```
```python
,
```
```python
"struct"
```
```python
,
```
```python
"union"
```
```python
,
```
```python
"int"
```
```python
,
```
```python
"double"
```
```python
,
```
```python
"float"
```
```python
,
```
```python
"char"
```
```python
,
```
```python
"long"
```
```python
,
```
```python
"bool"
```
```python
};
    Hash(s, HT);
    DispHT(HT);
```
```python
printf
```
```python
(
```
```python
"查找成功情况下的平均查找长度 %f\n"
```
```python
, SearchLength1(s, HT));
```
```python
printf
```
```python
(
```
```python
"查找不成功情况下的平均查找长度 %f\n"
```
```python
, SearchLength2(HT));
```
```python
return
```
```python
0
```
```python
;
}
```

