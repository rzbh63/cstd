
# redis - wangzhiguo9261的博客 - CSDN博客


2018年05月29日 14:56:28[码里偷闲王果果](https://me.csdn.net/wangzhiguo9261)阅读数：51个人分类：[redis](https://blog.csdn.net/wangzhiguo9261/article/category/7698323)


基础知识：http://www.runoob.com/redis/redis-java.html
应用场合：
**问题的引入**
DB（Oracle、MySQL、Postgresql等）＋Memcached 这种架构模式在我们生产环境中十分常见，一般我们通过Memcached将热点数据加载到cache，应用层首先向Memcached请求数据，如果缓存中存在数据，那么直接返回应用层；但随着业务数据量的不断增加，和访问量的持续增长，我们也会遇到很多问题：
在DB和Memcached之间如何保证数据的一致性。

Memcached数据命中率低或down机，应用直接访问DB，形成雪崩效应，数据库压力瞬间暴增，直接导致数据库响应慢，或者crash掉。

跨机房cache同步问题。


**Redis**
在众多NoSQL中我们一般拿Redis替换Memecached使用，原因有下：
Redis 支持更多的数据类型（strings、map、 list、sets、 sorted sets等）

Redis 支持复制功能。

Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

Redis 支持Sharding技术， 很容易将数据分布到多个Redis实例中，方便快速扩展。

Redis 在内存分配时采用申请分配方式， 内存使用更高效。


**Redis最为常用的数据类型主要有以下：**
String
Hash
List
Set
Sorted set
pub/sub
Transactions

**数据类型应用**

**1.  String**
**常用命令：**get、set、incr、decr mget等。
**应用场景：**String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类.即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。

除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：
获取字符串长度
往字符串append内容
设置和获取字符串的某一段内容
设置及获取字符串的某一位（bit）
批量设置一系列字符串的内容

**2.  Hash**
**常用命令：**hget,hset,hgetall 等。
**应用场景：**在Memcached中，我们经常将一些结构化的信息打包成HashMap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。

比如我们要存储一个用户信息对象数据，包含以下信息：
用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式：

第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。
｛"ID":"xxxxxx","username,age,birthday"｝

第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。
{"xxxIDusername":"xxxxx","xxxIDage":"xxxx","xxxIDbirthday":"xxxxx"}

那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口：
{"ID":"xxxxxx":"userinfo":"\"username\":\"xxxxName\",\"age\":\"xxxx\",\"birthday\":\"xxxxxx\""｝，也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。

**3. List**
**常用命令：**lpush,rpush,lpop,rpop,lrange等。
**应用场景：**Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。

Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，

可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。

**4. Set**
**常用命令：**sadd,spop,smembers,sunion 等。
**应用场景：**Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。

Sets 集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。

**5. Sorted Set**
**常用命令：**zadd,zrange,zrem,zcard等。
**使用场景：**Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。

另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。

**6. Pub/Sub**
Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。

**实际应用场景**

**1、显示最新的项目列表**
下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。
`SELECT``*``FROM``foo``WHERE``...``ORDER``BY``time``DESC``LIMIT``10`
在Web应用中，“列出最新的回复”之类的查询非常普遍，这通常会带来可扩展性问题。这令人沮丧，因为项目本来就是按这个顺序被创建的，但要输出这个顺序却不得不进行排序操作。

**类似的问题就可以用Redis来解决。**比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。

我们假设数据库中的每条评论都有一个唯一的递增的ID字段。

我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表： LPUSH latest.comments <ID>

我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论：
`LTRIM``latest``.comments``0 5000`
每次我们需要获取最新评论的项目范围时，我们可以先从Redis 取得这个范围的 ID List， 然后拿这个ID list 到DB里边直接去取数据 ，这个ID一般就是我们RDBMS里边的 uniq key 或者primary key ， 这样以来我们省去了在 RDBMS 排序的时间，直接使用 consat 方式

我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。

**2、删除与过滤**
我们可以使用LREM来删除评论。如果删除操作非常少，另一个选择是直接跳过评论条目的入口，报告说该评论已经不存在。

有些时候你想要给不同的列表附加上不同的过滤器。如果过滤器的数量受到限制，你可以简单的为每个不同的过滤器使用不同的Redis列表。毕竟每个列表只有5000条项目，但Redis却能够使用非常少的内存来处理几百万条项目。

**3、排行榜相关**
另一个很普遍的需求是各种数据库的数据并非存储在内存中，因此在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。

典型的比如那些在线游戏的排行榜，比如一个Facebook的游戏，根据得分你通常想要：
- 列出前100名高分选手
- 列出某用户当前的全球排名

这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。

模式是这样的，每次获得新得分时，我们用这样的代码：
`ZADD leaderboard``<score>``<username>`
你可能用userID来取代username，这取决于你是怎么设计的。

得到前100名高分用户很简单：
`ZREVRANGE``leaderboard``0``99`
用户的全球排名也相似，只需要：
`ZRANK leaderboard``<username>`
**4、按照用户投票和时间排序**
排行榜的一种常见变体模式就像Reddit或Hacker News用的那样，新闻按照类似下面的公式根据得分来排序：
`score``= points / time^alpha`
因此用户的投票会相应的把新闻挖出来，但时间会按照一定的指数将新闻埋下去。下面是我们的模式，当然算法由你决定。

模式是这样的，开始时先观察那些可能是最新的项目，例如首页上的1000条新闻都是候选者，因此我们先忽视掉其他的，这实现起来很简单。

每次新的新闻贴上来后，我们将ID添加到列表中，使用LPUSH + LTRIM，确保只取出最新的1000条项目。

有一项后台任务获取这个列表，并且持续的计算这1000条新闻中每条新闻的最终得分。计算结果由ZADD命令按照新的顺序填充生成列表，老新闻则被清除。这里的关键思路是排序工作是由后台任务来完成的。

**5、处理过期项目**
另一种常用的项目排序是按照时间排序。我们使用unix时间作为得分即可。

模式如下：
- 每次有新项目添加到我们的非Redis数据库时，我们把它加入到排序集合中。这时我们用的是时间属性，current_time和time_to_live。
- 另一项后台任务使用ZRANGE…SCORES查询排序集合，取出最新的10个项目。如果发现unix时间已经过期，则在数据库中删除条目。

**6、计数**
Redis是一个很好的计数器，这要感谢INCRBY和其他相似命令。

我相信你曾许多次想要给数据库加上新的计数器，用来获取统计或显示新信息，但是最后却由于写入敏感而不得不放弃它们。

好了，现在使用Redis就不需要再担心了。有了原子递增（atomic increment），你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。

例如这样操作：
`INCR user:``<id>``EXPIRE`
你可以计算出最近用户在页面间停顿不超过60秒的页面浏览量，当计数达到比如20时，就可以显示出某些条幅提示，或是其它你想显示的东西。

**7、特定时间内的特定项目**
另一项对于其他数据库很难，但Redis做起来却轻而易举的事就是统计在某段特点时间里有多少特定用户访问了某个特定资源。比如我想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。

每次我获得一次新的页面浏览时我只需要这样做：
`SADD page:day1:``<page_id>``<user_id>`
当然你可能想用unix时间替换day1，比如time()-(time()%3600*24)等等。

想知道特定用户的数量吗？只需要使用：
`SCARD page:day1:``<page_id>`
需要测试某个特定用户是否访问了这个页面？
`SISMEMBER page:day1:``<page_id>`
**8、实时分析正在发生的情况，用于数据统计与防止垃圾邮件等**
我们只做了几个例子，但如果你研究Redis的命令集，并且组合一下，就能获得大量的实时分析方法，有效而且非常省力。使用Redis原语命令，更容易实施垃圾邮件过滤系统或其他实时跟踪系统。

**9、Pub/Sub**
Redis的Pub/Sub非常非常简单，运行稳定并且快速。支持模式匹配，能够实时订阅与取消频道。

**10、队列**
你应该已经注意到像list push和list pop这样的Redis命令能够很方便的执行队列操作了，但能做的可不止这些：比如Redis还有list pop的变体命令，能够在列表为空时阻塞队列。

现代的互联网应用大量地使用了消息队列（Messaging）。消息队列不仅被用于系统内部组件之间的通信，同时也被用于系统跟其它服务之间的交互。消息队列的使用可以增加系统的可扩展性、灵活性和用户体验。非基于消息队列的系统，其运行速度取决于系统中最慢的组件的速度（注：短板效应）。而基于消息队列可以将系统中各组件解除耦合，这样系统就不再受最慢组件的束缚，各组件可以异步运行从而得以更快的速度完成各自的工作。

此外，当服务器处在高并发操作的时候，比如频繁地写入日志文件。可以利用消息队列实现异步处理。从而实现高性能的并发操作。


