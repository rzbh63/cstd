
# 62. Unique Paths - OraYang的博客 - CSDN博客

2017年09月22日 08:56:09[OraYang](https://me.csdn.net/u010665216)阅读数：197个人分类：[Leetcode																](https://blog.csdn.net/u010665216/article/category/7026962)
所属专栏：[基础算法](https://blog.csdn.net/column/details/16604.html)



## 题目
A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).
How many possible unique paths are there?
![unique path](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)[ ](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
Above is a 3 x 7 grid. How many possible unique paths are there?
[
](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)Note: m and n will be at most 100.
[

](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
## 思路
[
](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)本题一开始会直接采用递归的方法，但是time limit了，如果对动规熟悉的话，会发现本题就是个典型的动态规划呀。我们维护一个二维数组A[m][n]，其中A[i][j]指robot到该位置有A[i][j]可能的路径；那么状态转移方程就是A[i][j] = A[i-1][j] + A[i][j-1]。代码如下：
[

](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
```python
class
```
```python
Solution {
```
```python
public
```
```python
:
```
```python
int
```
```python
uniquePaths(
```
```python
int
```
```python
m,
```
```python
int
```
```python
n) {
```
```python
//dp:res[i][j] = res[i-1][j] + res[i][j-1];
```
```python
vector
```
```python
<
```
```python
vector
```
```python
<
```
```python
int
```
```python
>
```
```python
>
```
```python
res(m,
```
```python
vector
```
```python
<
```
```python
int
```
```python
>
```
```python
(n,
```
```python
1
```
```python
));
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
1
```
```python
;i<m;i++)
```
```python
for
```
```python
(
```
```python
int
```
```python
j=
```
```python
1
```
```python
;j<n;j++)
            {
                res[i][j] = res[i-
```
```python
1
```
```python
][j] + res[i][j-
```
```python
1
```
```python
]; 
            }
```
```python
return
```
```python
res[m-
```
```python
1
```
```python
][n-
```
```python
1
```
```python
];
    }
};
```
[
](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)基于上述思路，我们可以进一步优化，只是又花了空间复杂度，就是用一个一维数组来维护A[j]:
状态转移方程为A[j] += A[j-1]。代码如下：
```python
class
```
```python
Solution {
```
```python
public
```
```python
:
```
```python
int
```
```python
uniquePaths(
```
```python
int
```
```python
m,
```
```python
int
```
```python
n) {
```
```python
//dp:res[j] +=res[j-1];
```
```python
vector
```
```python
<
```
```python
int
```
```python
>
```
```python
res(n,
```
```python
1
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
1
```
```python
;i<m;i++)
```
```python
for
```
```python
(
```
```python
int
```
```python
j=
```
```python
1
```
```python
;j<n;j++)
            {
                res[j] += res[j-
```
```python
1
```
```python
]; 
            }
```
```python
return
```
```python
res[n-
```
```python
1
```
```python
];
    }
};
```
### version3
```python
class
```
```python
Solution {
```
```python
public
```
```python
:
```
```python
int
```
```python
uniquePaths(
```
```python
int
```
```python
m,
```
```python
int
```
```python
n) {
```
```python
//dp:res[j] +=res[j-1];
```
```python
vector
```
```python
<
```
```python
int
```
```python
>
```
```python
res(n,
```
```python
0
```
```python
);
        res[
```
```python
0
```
```python
] =
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
;i<m;i++)
```
```python
for
```
```python
(
```
```python
int
```
```python
j=
```
```python
0
```
```python
;j<n;j++)
            {
```
```python
if
```
```python
(j>
```
```python
0
```
```python
)
                    res[j] += res[j-
```
```python
1
```
```python
]; 
            }
```
```python
return
```
```python
res[n-
```
```python
1
```
```python
];
    }
};
```
[
						](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
[
	](https://img-blog.csdn.net/20170922085003754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDY2NTIxNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
