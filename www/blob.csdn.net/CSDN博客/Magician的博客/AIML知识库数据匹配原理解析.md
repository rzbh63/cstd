
# AIML知识库数据匹配原理解析 - Magician的博客 - CSDN博客


2018年05月28日 11:11:31[春雨里de太阳](https://me.csdn.net/qq_16633405)阅读数：1226


[目录：](#目录)[前言：](#前言)
[1、AIML系统工作流程](#1aiml系统工作流程)
[2、AIML的核心推理机制](#2aiml的核心推理机制)
[3、推理举例](#3推理举例)
[4、匹配规则及实践中遇到的一些问题的解释](#4匹配规则及实践中遇到的一些问题的解释)
[总结：](#总结)


# 目录：
## 前言：
参考：《Alice机理分析与应用研究》
关于AIML库这里就不介绍了，详细的介绍及简单的使用请参考我的上一篇博客：[https://blog.csdn.net/qq_16633405/article/details/80228697](https://blog.csdn.net/qq_16633405/article/details/80228697)
这里主要介绍下AIML知识库内部数据匹配的机制，以便我们能更好的使用AIML库。废话少说，直接进入正题了。
## 1、AIML系统工作流程
AIML系统工作流程如图1所示。
**第一步：系统初始化**
AIML系统在启动时，首先根据配置文件进行系统的初始化操作，把需要替换的词串（如把 it’s替换为it is）、自身的相关信息（如名字、性别等）、人称转换信息以及此前的对话情景变量读入系统，并把AIML文件内容（即知识库）以树的结构形式加载到内存当中，形成内存知识树，这样当系统在响应用户输入的问句时，可直接在内存树中进行推理，提高了响应速度。加载完毕之后，等待用户输入问句。
**第二步：接收用户输入，进行问句规范化处理**
当AIML解析器接收到一行用户的输入后，首先把输入的文字分成单独的句子，进行问句规范化处理，分析当前句子中是否包含需要替换的字符串，如果有，则替换之。例如把问句中出现的“you’ve”替换为“you have”，“I’m”替换为“I am”等等。问句规范化处理完以后，以规范问句到内存知识树中查询推理答案。
**第三步：问句查询推理**
这一过程是AIML的核心部分，将规范化处理后的问句与内存知识树中的模式进行匹配，寻找最佳匹配结果，找到之后，读出该匹配模式对应的模板信息，进行下一步处理。
**第四步：模板处理**
也就是答案的后处理，模板中可能包含一些特殊标记需要处理，如读出机器人名字标记所代表的实际名称，还原星号部分所代表的内容，如果包含跳转标记，还需要在内存知识树中以跳转部分的内容做进一步的推理。 模板处理完后返回用户结果，等待用户输入新问句。
![这里写图片描述](https://img-blog.csdn.net/20180528101144327?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2NjMzNDA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
## 2、AIML的核心推理机制
AIML的核心推理部分称为 Graphmaster，它由一系列称为Nodemapper的节点集组成。每一个Nodemapper都有若干个从该节点出来的分支，这些分支可能是一个单词，也可能是一个通配符。
根据用户的输入查找对应模式的过程就是AIML的推理过程，假设用户输入的问句以单词X开头，那么首先拿X与Graphmaster中第一级节点的内容逐个比较，**整个推理过程可以分为三步：**
1、当前节点是否包含统配符“_”？如果有，则搜索以当前节点为根节点的子树，以X后面剩余部分组成的子句在该子树中继续该过程，如果没有相匹配的节点，则转 2）；
2、当前节点是否包含X？如果是，则搜索以当前节点为根节点的子树，以X后面剩余部分组成的子句在该子树中继续该过程，如果未发现相匹配节点，则转 3；
3、当前节点是否包含“!”？如果是，则搜索以当前节 点为根节点的子树，以X后面剩余部分组成的子句在该子树中继续该匹配过程。如果没有发现匹配节点，回溯到节点的父节点，把X重新加到子句子的首部，继续该匹配过程。
当进行匹配的句子到达句尾，并且匹配的最后一个节点包含模板内容时，则表明已经找到了相匹配的模式，此时，终止搜索匹配过程，返回该节点，取出模板内容，在必要信息处 理完毕后把结果返回用户。由该算法可以看出，如果内存知识树中第一级节点含有关键字“*”，并且该节点含有模板信息，则对任何输入的问句，都能得到一个结果。
## 3、推理举例
下面举一个简单的例子来说明AIML的实际推理过程。 假设知识库中有以下三个category：
![这里写图片描述](https://img-blog.csdn.net/20180528101345828?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2NjMzNDA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
针对这三个category，给出它的内存知识树如上图所示。为简明起见，图中节点只写出了它所包含的内容，滤掉了其它信息。假设用户输入的问句是“do you love your boy”
根据上图和前面所讲的匹配规则，匹配串为“do you love your boy”，首先将问句的第一个单词“do”与第一级节点（节点（1）和节点（5））进行匹配，首先应该匹配节点（1），它仅有一个子节点（2），与问句下一个单词“you;”匹配不成功，问句回退后“you;”与下划线匹配成功，则继续匹配“love”，成功，匹配“your”成功，当再匹配“boy”时，当前节点（4）既不是“_”，也不是“boy”和“*”，匹配不成功，这样对节点（1）而言，第一步匹配下划线失败。继而执行匹配过程的第二步，匹配相同单词“do”，成功，匹配“you”成功，匹配“love”，与节点（H）成功，再匹配下一个单词“your”时，根据优先级，匹配下划线不成功，匹配原单词“your”成功，再匹配最后一个单词“boy”时，三个步骤都不成功，此时回溯到节点（H）。再以原单词“your”与节点（8）中的星号匹配，成功，继续匹配最后一个单词“boy”与节点（I）中的星号匹配，成功，继续匹配最后一个单词“boy”，与节点（9）匹配成功，问句结束，整个匹配过程完毕，叶子节点（9）为最后搜索匹配结果，其中也含有模板信息，表明找到对应了模式，在进行模板信息处理后，即可把结果返回给用户。
## 4、匹配规则及实践中遇到的一些问题的解释
首先是拿知识库中的数据和提问的问句进行匹配的，先根据问句来确定知识库中匹配的首节点，之后从对应的匹配数据出发，看匹配的首节点的剩余部分是否和问句的剩余部分匹配，如果成功则直接返回匹配结果，如果失败则进行另一个分支的匹配工作（内部匹配的一个优先级即_>单词>*）
**例子：**
```python
M
```
```python
:*
```
```python
充值*金额*
```
```python
T
```
```python
：充值金额及次数限制？
```
```python
匹配的时候，先将
```
```python
T
```
```python
中的“充”字拿出来和M中的“*”号进行匹配，之后再将
```
```python
T
```
```python
中的“值”字与M中的“充”字进行匹配，
不匹配，则将
```
```python
T
```
```python
中的“值”字匹配到M中的“*”中，即此时的“*”代表”充值“二个字，然后再将
```
```python
T
```
```python
中的“金”字与M中“充”字进行匹配，
失败，再将
```
```python
T
```
```python
中的“金”字放到M中的“*”中
```
```python
...
```
```python
直到最后发现
```
```python
T
```
```python
中所有的汉字都无法匹配M中的“充”字，则说明当前这条路失败，
即进行第二条路，即M的初始“*”不代表任何字，则
```
```python
T
```
```python
中的“充”和M中的“充”匹配，值和值匹配，之后再参考前一条路的操作步骤，
先把*当做匹配的有对应的汉字，然后接着匹配
```
```python
T
```
```python
中的剩余的汉字，看是能与M完成匹配，若不能则返回“*”处，
即*是另一种情况即不代表任何汉字，接着进行匹配。。。
（对于汉语来说，内部是将一句话中的每个汉字都拆出来进行处理的）
```
**问题一：使用AIML库时遇到返回AIML库源码中一段字符串输出的原因的解释：**
例1：
问题：
提前还款违约金？
匹配项：
```python
A:
```
```python
*提前*
```
```python
还款
```
```python
*违约*
```
```python
B:
```
```python
*提前*
```
```python
还款*（匹配的是这个）
```
返回的语句是：对不起，无法回答您的问题。请您换种正式的方式提问（这个返回的字符串可以在源码中自定义更改）
出现这种情况的原因是：当你使用AIML库中srai标签时出现了多匹配问题，srai标签工作原理是当符合你定义的匹配规则时，他会再去搜索对应的问题，这时候出现了多匹配的问题即一个问题有多个匹配选择，程序不知道怎么选，所以就爆出上面源码中的一句话（srai详细的使用及原理请参考我的上篇文章：[https://blog.csdn.net/qq_16633405/article/details/80228697](https://blog.csdn.net/qq_16633405/article/details/80228697)）。
**PS：所以在使用的时候个人不建议为了省事，去使用Srai标签，因为使用这个标签后具相当于再次进行了一次检索匹配的过程，并且在这个过程中匹配的规则会发生一些变化，下面的例子会解释那些地方发生了变化。**
**对于星号的匹配有如下的规则：**
```python
在最后一个“
```
```python
*”处的规则是先假设B中的“*
```
```python
”有内容，若匹配失败才进入B中的“*”无内容的条件再次进行匹配。
```
**问题二：AIML库下中文的匹配规则**
在说明使用srai标签后的检索匹配与初始检索匹配机制的一些不同点之前有必要举个例子把AIML库下中文的匹配规则说明白。
例2：
匹配项：
```python
*贷款审批*
```
```python
时效*
```
```python
*审批*
```
```python
多久*
```
```python
*贷款*
```
```python
放款*
```
输入的问题：贷款审批后多久放款？
输入后，答案有冲突
这种情况下，我想让“贷款审批后多久放款？”这句话匹配`*贷款*放款*`的答案 ，就需要将`*贷款审批*时效*`转化为`*审批*时效*`，这样在输入的时候，会先匹配“贷款”两个字即先匹配`*贷款*放款*`这个模式，若匹配不成功才会去匹配另一个`*审批*多久*`（即单词的优先级高于星号，有单词先匹配单词）。
系统内部操作时也是将汉字一个个拆分，匹配的时候也是一个一个字的去匹配。内部运行效果如下如所示：
![这里写图片描述](https://img-blog.csdn.net/20180528110033823?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE2NjMzNDA1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
**问题三：使用srai标签后的检索匹配与初始检索匹配机制的一些不同点**
例3：
如下所示：
当我输入“贷款有哪些品种？”时，就会发生匹配多项的问题输出系统自定义的输出语句即：对不起，无法回答您的问题。请您换种正式的方式提问（我自定义的）。
```python
<
```
```python
category
```
```python
>
```
```python
<
```
```python
pattern
```
```python
>
```
```python
*贷款*种*
```
```python
</
```
```python
pattern
```
```python
>
```
```python
<
```
```python
template
```
```python
>
```
```python
贷款有哪些品种？
            房供贷、红本贷、流水贷（公积金、代发工资）、公务员贷、保单贷。
```
```python
</
```
```python
template
```
```python
>
```
```python
</
```
```python
category
```
```python
>
```
```python
<
```
```python
category
```
```python
>
```
```python
<
```
```python
pattern
```
```python
>
```
```python
*贷款*有*
```
```python
</
```
```python
pattern
```
```python
>
```
```python
<
```
```python
template
```
```python
>
```
```python
<
```
```python
srai
```
```python
>
```
```python
贷款有哪些品种？
```
```python
</
```
```python
srai
```
```python
>
```
```python
</
```
```python
template
```
```python
>
```
```python
</
```
```python
category
```
```python
>
```
但是当上面的匹配项改为这样时，系统就不会发生匹配多项的问题，也就不会返回相应的输出语句。
```python
<
```
```python
category
```
```python
>
```
```python
<
```
```python
pattern
```
```python
>
```
```python
*贷款*种*
```
```python
</
```
```python
pattern
```
```python
>
```
```python
<
```
```python
template
```
```python
>
```
```python
贷款有哪些品种？
            房供贷、红本贷、流水贷（公积金、代发工资）、公务员贷、保单贷。
```
```python
</
```
```python
template
```
```python
>
```
```python
</
```
```python
category
```
```python
>
```
```python
<
```
```python
category
```
```python
>
```
```python
<
```
```python
pattern
```
```python
>
```
```python
*贷款*有*
```
```python
</
```
```python
pattern
```
```python
>
```
```python
<
```
```python
template
```
```python
>
```
```python
贷款有哪些品种？
            房供贷、红本贷、流水贷（公积金、代发工资）、公务员贷、保单贷。
```
```python
</
```
```python
template
```
```python
>
```
```python
</
```
```python
category
```
```python
>
```
原因：使用srai标签的搜索匹配机制和初始的搜索匹配机制不一样的地方。使用sari标签的时候也许也许内部源码的运行机制也许是在初始搜素匹配机制的基础之上又添加了一些额外的限制，所以才导致有这样的问题（但是个人感觉这个问题完全可以解决，大体的步骤就是在执行srai标签时将初始匹配的那套流程代码再执行一遍不就OK了，也许中间还牵涉到一些其他的难点吧。。这里就不考虑这些了）
## 总结：
一直想找关于AIML内部数据加载机制的知识，但是可参考的资料真的少之又少，无奈只能把之前找到的资料和自己的实践相结合总结出来这样一篇文章，希望能对大家有所帮助。

