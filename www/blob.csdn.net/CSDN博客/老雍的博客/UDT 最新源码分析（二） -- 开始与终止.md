
# UDT 最新源码分析（二） -- 开始与终止 - 老雍的博客 - CSDN博客


2019年01月28日 22:55:34[老雍](https://me.csdn.net/yongkai0214)阅读数：177



### UDT 最新源码分析 -- 开始与终止
[UDT 开始与终止](#UDT__1)
[开始流程](#_2)
[终止流程](#_270)

# UDT 开始与终止
## 开始流程
> UDT:: startup ->  CUDT::startup ->  CUDTUnited::startup
初始化UDT库，多次调用时，调用计数增加，但实际上仅仅初始化一次。对于windows下，还需要初始化网络库WSAStartup。建立 garbageCollect 线程，用于清理失效socket，并删除分发器。
```python
int
```
```python
CUDTUnited
```
```python
:
```
```python
:
```
```python
startup
```
```python
(
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
gcinit
```
```python
(
```
```python
m_InitLock
```
```python
)
```
```python
;
```
```python
//获取初始锁
```
```python
if
```
```python
(
```
```python
m_iInstanceCount
```
```python
++
```
```python
>
```
```python
0
```
```python
)
```
```python
//实例被初始化的计数器，仅初始化一次
```
```python
return
```
```python
0
```
```python
;
```
```python
if
```
```python
(
```
```python
m_bGCStatus
```
```python
)
```
```python
//garbageCollect状态，保证线程不会被建立多个
```
```python
return
```
```python
true
```
```python
;
```
```python
m_bClosing
```
```python
=
```
```python
false
```
```python
;
```
```python
//CUDTUnited状态, 此状态下 garbageCollect内 while循环不退出
```
```python
pthread_mutex_init
```
```python
(
```
```python
&
```
```python
m_GCStopLock
```
```python
,
```
```python
NULL
```
```python
)
```
```python
;
```
```python
pthread_cond_init
```
```python
(
```
```python
&
```
```python
m_GCStopCond
```
```python
,
```
```python
NULL
```
```python
)
```
```python
;
```
```python
pthread_create
```
```python
(
```
```python
&
```
```python
m_GCThread
```
```python
,
```
```python
NULL
```
```python
,
```
```python
garbageCollect
```
```python
,
```
```python
this
```
```python
)
```
```python
;
```
```python
//garbageCollect 线程创建
```
```python
m_bGCStatus
```
```python
=
```
```python
true
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
}
```
再来看 garbageCollect：
```python
void
```
```python
*
```
```python
CUDTUnited
```
```python
:
```
```python
:
```
```python
garbageCollect
```
```python
(
```
```python
void
```
```python
*
```
```python
p
```
```python
)
```
```python
{
```
```python
CUDTUnited
```
```python
*
```
```python
self
```
```python
=
```
```python
(
```
```python
CUDTUnited
```
```python
*
```
```python
)
```
```python
p
```
```python
;
```
```python
//获取CUDTUnited实例，类型转化
```
```python
CGuard
```
```python
gcguard
```
```python
(
```
```python
self
```
```python
->
```
```python
m_GCStopLock
```
```python
)
```
```python
;
```
```python
//资源清理的锁
```
```python
while
```
```python
(
```
```python
!
```
```python
self
```
```python
->
```
```python
m_bClosing
```
```python
)
```
```python
//初始 m_bClosing = false，无限循环
```
```python
{
```
```python
//当UDT协议判断某一个UDT SOCKET的状态不正确时，会将其状态设置为BROKEN，并在这个函数中进行处理
```
```python
self
```
```python
->
```
```python
checkBrokenSockets
```
```python
(
```
```python
)
```
```python
;
```
```python
//睡眠等待，等待下一次可以清理出现BROKEN状态的UDT SOCKET。睡眠时间 timeout: 1s
```
```python
pthread_cond_timedwait
```
```python
(
```
```python
&
```
```python
self
```
```python
->
```
```python
m_GCStopCond
```
```python
,
```
```python
&
```
```python
self
```
```python
->
```
```python
m_GCStopLock
```
```python
,
```
```python
&
```
```python
timeout
```
```python
)
```
```python
;
```
```python
}
```
```python
//remove all sockets and multiplexers. m_bClosing = true, 清理目前依旧残余的资源
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
enterCS
```
```python
(
```
```python
self
```
```python
->
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
//遍历 m_Sockets 中的 UDT socket，设置为关闭，存入 m_ClosedSockets map，下一步处理连接记录。
```
```python
//查找 Listener, 将 该socket 在Listener中的 m_pQueuedSockets 与 m_pAcceptSockets中记录删除
```
```python
for
```
```python
(
```
```python
map
```
```python
<
```
```python
UDTSOCKET
```
```python
,
```
```python
CUDTSocket
```
```python
*
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator i
```
```python
=
```
```python
self
```
```python
->
```
```python
m_Sockets
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
i
```
```python
!=
```
```python
self
```
```python
->
```
```python
m_Sockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
i
```
```python
)
```
```python
{
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_bBroken
```
```python
=
```
```python
true
```
```python
;
```
```python
//将CUDT* 的状态设置为 BROKEN，后续进行处理
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
//关闭
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_Status
```
```python
=
```
```python
CLOSED
```
```python
;
```
```python
//设置状态为关闭
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_TimeStamp
```
```python
=
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
//调整最后一次操作 UDT socket 的时间
```
```python
self
```
```python
->
```
```python
m_ClosedSockets
```
```python
[
```
```python
i
```
```python
->
```
```python
first
```
```python
]
```
```python
=
```
```python
i
```
```python
->
```
```python
second
```
```python
;
```
```python
//将当前描述连接的CUDT*保存至 m_ClosedSockets
```
```python
// remove from listener's queue
```
```python
map
```
```python
<
```
```python
UDTSOCKET
```
```python
,
```
```python
CUDTSocket
```
```python
*
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator ls
```
```python
=
```
```python
self
```
```python
->
```
```python
m_Sockets
```
```python
.
```
```python
find
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_ListenSocket
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ls
```
```python
==
```
```python
self
```
```python
->
```
```python
m_Sockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
//如果没有找到Listener, m_ClosedSockets中继续查找
```
```python
{
```
```python
ls
```
```python
=
```
```python
self
```
```python
->
```
```python
m_ClosedSockets
```
```python
.
```
```python
find
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_ListenSocket
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ls
```
```python
==
```
```python
self
```
```python
->
```
```python
m_ClosedSockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
//如果没有找到，就不再处理
```
```python
continue
```
```python
;
```
```python
}
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
enterCS
```
```python
(
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
//获取Listener中的锁
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pQueuedSockets
```
```python
->
```
```python
erase
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
//清理接收连接但还未接受的排队 UDT socket
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pAcceptSockets
```
```python
->
```
```python
erase
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
//清理已完成连接的队列中UDT socket
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
leaveCS
```
```python
(
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
}
```
```python
self
```
```python
->
```
```python
m_Sockets
```
```python
.
```
```python
clear
```
```python
(
```
```python
)
```
```python
;
```
```python
//最后删除m_Sockets中的所有sockets
```
```python
//最后再次遍历待关闭的socket队列
```
```python
for
```
```python
(
```
```python
map
```
```python
<
```
```python
UDTSOCKET
```
```python
,
```
```python
CUDTSocket
```
```python
*
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator j
```
```python
=
```
```python
self
```
```python
->
```
```python
m_ClosedSockets
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
j
```
```python
!=
```
```python
self
```
```python
->
```
```python
m_ClosedSockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
j
```
```python
)
```
```python
{
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_TimeStamp
```
```python
=
```
```python
0
```
```python
;
```
```python
//设置状态为 0
```
```python
}
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
leaveCS
```
```python
(
```
```python
self
```
```python
->
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
while
```
```python
(
```
```python
true
```
```python
)
```
```python
{
```
```python
//之前只是将即将清理的UDT socket 状态设置为BROKEN，此时对BROKEN状态的socket进行清理
```
```python
self
```
```python
->
```
```python
checkBrokenSockets
```
```python
(
```
```python
)
```
```python
;
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
enterCS
```
```python
(
```
```python
self
```
```python
->
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
bool empty
```
```python
=
```
```python
self
```
```python
->
```
```python
m_ClosedSockets
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
;
```
```python
//判断待关闭socket是否已经全部清理
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
leaveCS
```
```python
(
```
```python
self
```
```python
->
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
empty
```
```python
)
```
```python
//如果为empty，就可以直接退出
```
```python
break
```
```python
;
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
sleep
```
```python
(
```
```python
)
```
```python
;
```
```python
//不行的话，再歇一会，再次进行处理
```
```python
}
```
```python
return
```
```python
NULL
```
```python
;
```
```python
}
```
上面代码中出现了两次 checkBrokenSockets，该方法用于清理处于BROKEN状态的 UDT socket。
检查所有的 UDT socket如果不是处于broken状态，查找下一个，如果处于broken状态：如果 socket 处于 LISTENING 状态，须再等待3s，以防止有客户端正在连接
如果 recvbuffer 存在数据，且 brokencount 计数器仍大于0，继续等待更长的时间
否则：设置socket为CLOSED状态，更新 m_TimeStamp 为当前时间, 开启移除定时器。
将当前socket加入待关闭 tbc vector, socket加入临时存储closed socket的 m_ClosedSockets map.
查找 Listener, 从m_pQueuedSockets 和 m_pAcceptSockets 移除接收到的socket 连接 socket。

对于移入临时存储待关闭的 m_ClosedSockets map，检查每个socket，如果 m_ullLingerExpiration > 0，表示在发送缓冲中存在数据时，GC设置了延迟关闭的时间如果发送缓冲不存在，或为空，或设置关闭时间已经超时：将m_ullLingerExpiration设置为0；设置UDT socket为关闭状态，在下一次GC中将被回收。更新关闭时间为当前时间。

否则：如果标记关闭时间已经超过1s，且socket对应接收队列信息节点已经被删除，或者节点不存在list中
将UDT socket加入tbr 移除队列

遍历tbc，从 m_Sockets中删除。遍历tbr, 将这些超时的 socket 移除。
```python
void
```
```python
CUDTUnited
```
```python
:
```
```python
:
```
```python
checkBrokenSockets
```
```python
(
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
cg
```
```python
(
```
```python
m_ControlLock
```
```python
)
```
```python
;
```
```python
//获取GC锁
```
```python
// set of sockets To Be Closed and To Be Removed
```
```python
vector
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
tbc
```
```python
;
```
```python
//收集处于Closed状态的 UDT SOCKET
```
```python
vector
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
tbr
```
```python
;
```
```python
//收集处于Removed状态的 UDT SOCKET
```
```python
for
```
```python
(
```
```python
map
```
```python
<
```
```python
UDTSOCKET
```
```python
,
```
```python
CUDTSocket
```
```python
*
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator i
```
```python
=
```
```python
m_Sockets
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
i
```
```python
!=
```
```python
m_Sockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
i
```
```python
)
```
```python
{
```
```python
// check broken connection
```
```python
if
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_bBroken
```
```python
)
```
```python
//如果处于BROKEN状态
```
```python
{
```
```python
if
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_Status
```
```python
==
```
```python
LISTENING
```
```python
)
```
```python
//如果是LISTENING UDT SOCKET
```
```python
{
```
```python
// for a listening socket, it should wait an extra 3 seconds in case a client is connecting
```
```python
if
```
```python
(
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
getTime
```
```python
(
```
```python
)
```
```python
-
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_TimeStamp
```
```python
<
```
```python
3000000
```
```python
)
```
```python
continue
```
```python
;
```
```python
}
```
```python
else
```
```python
if
```
```python
(
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_pRcvBuffer
```
```python
!=
```
```python
NULL
```
```python
)
```
```python
&&
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_pRcvBuffer
```
```python
->
```
```python
getRcvDataSize
```
```python
(
```
```python
)
```
```python
>
```
```python
0
```
```python
)
```
```python
&&
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_iBrokenCounter
```
```python
--
```
```python
>
```
```python
0
```
```python
)
```
```python
)
```
```python
{
```
```python
// if there is still data in the receiver buffer, wait longer
```
```python
continue
```
```python
;
```
```python
//如果缓冲区中依旧有数据，应该等待更长的时间
```
```python
}
```
```python
//close broken connections and start removal timer
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_Status
```
```python
=
```
```python
CLOSED
```
```python
;
```
```python
//将状态设置为CLOSED
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_TimeStamp
```
```python
=
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
//设置UDT SOCKET的关闭时间
```
```python
tbc
```
```python
.
```
```python
push_back
```
```python
(
```
```python
i
```
```python
->
```
```python
first
```
```python
)
```
```python
;
```
```python
//将这个UDT SOCKET添加进Closed Array，稍后处理
```
```python
m_ClosedSockets
```
```python
[
```
```python
i
```
```python
->
```
```python
first
```
```python
]
```
```python
=
```
```python
i
```
```python
->
```
```python
second
```
```python
;
```
```python
//将这个UDT SOCKET添加进CLOSED UDT SOCKET MAP
```
```python
// remove from listener's queue
```
```python
map
```
```python
<
```
```python
UDTSOCKET
```
```python
,
```
```python
CUDTSocket
```
```python
*
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator ls
```
```python
=
```
```python
m_Sockets
```
```python
.
```
```python
find
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_ListenSocket
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ls
```
```python
==
```
```python
m_Sockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
ls
```
```python
=
```
```python
m_ClosedSockets
```
```python
.
```
```python
find
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_ListenSocket
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ls
```
```python
==
```
```python
m_ClosedSockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
continue
```
```python
;
```
```python
}
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
enterCS
```
```python
(
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pQueuedSockets
```
```python
->
```
```python
erase
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pAcceptSockets
```
```python
->
```
```python
erase
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_SocketID
```
```python
)
```
```python
;
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
leaveCS
```
```python
(
```
```python
ls
```
```python
->
```
```python
second
```
```python
->
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
for
```
```python
(
```
```python
map
```
```python
<
```
```python
UDTSOCKET
```
```python
,
```
```python
CUDTSocket
```
```python
*
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator j
```
```python
=
```
```python
m_ClosedSockets
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
j
```
```python
!=
```
```python
m_ClosedSockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
j
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_ullLingerExpiration
```
```python
>
```
```python
0
```
```python
)
```
```python
//如果还没有到等待关闭时间
```
```python
{
```
```python
// asynchronous close:
```
```python
if
```
```python
(
```
```python
(
```
```python
NULL
```
```python
==
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_pSndBuffer
```
```python
)
```
```python
||
```
```python
(
```
```python
0
```
```python
==
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_pSndBuffer
```
```python
->
```
```python
getCurrBufSize
```
```python
(
```
```python
)
```
```python
)
```
```python
||
```
```python
(
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_ullLingerExpiration
```
```python
<=
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
getTime
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
{
```
```python
//如果发送缓冲区为空，接收缓冲区为空或者等待关闭时间小于0，调整状态为CLOSED直接关闭
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_ullLingerExpiration
```
```python
=
```
```python
0
```
```python
;
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_bClosing
```
```python
=
```
```python
true
```
```python
;
```
```python
//更新Closed状态，由下一次启动的GC线程回收
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_TimeStamp
```
```python
=
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
//更新关闭的时间
```
```python
}
```
```python
}
```
```python
// timeout 1 second to destroy a socket AND it has been removed from RcvUList
```
```python
if
```
```python
(
```
```python
(
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
getTime
```
```python
(
```
```python
)
```
```python
-
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_TimeStamp
```
```python
>
```
```python
1000000
```
```python
)
```
```python
&&
```
```python
(
```
```python
(
```
```python
NULL
```
```python
==
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_pRNode
```
```python
)
```
```python
||
```
```python
!
```
```python
j
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_pRNode
```
```python
->
```
```python
m_bOnList
```
```python
)
```
```python
)
```
```python
{
```
```python
tbr
```
```python
.
```
```python
push_back
```
```python
(
```
```python
j
```
```python
->
```
```python
first
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
// move closed sockets to the ClosedSockets structure
```
```python
for
```
```python
(
```
```python
vector
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator k
```
```python
=
```
```python
tbc
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
k
```
```python
!=
```
```python
tbc
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
k
```
```python
)
```
```python
m_Sockets
```
```python
.
```
```python
erase
```
```python
(
```
```python
*
```
```python
k
```
```python
)
```
```python
;
```
```python
// remove those timeout sockets
```
```python
for
```
```python
(
```
```python
vector
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator l
```
```python
=
```
```python
tbr
```
```python
.
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
l
```
```python
!=
```
```python
tbr
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
l
```
```python
)
```
```python
removeSocket
```
```python
(
```
```python
*
```
```python
l
```
```python
)
```
```python
;
```
```python
}
```
如果 m_ClosedSockets 中UDT socket 已经超过超过1s, 就会放入 tbr。遍历 tbr, 移除所有socket，更新相关资源。这里用到了removeSocket 方法。
如果UDT socket 是一个 Listener，将所有收到的但未接受的socket 关闭，设置为 BROKEN 状态，等待移除。
删除 m_PeerRec 中记录的连接。
删除 UDT socket， 检查对应的复用器，计数器减一，如果已经为0， 则关闭channel，清理复用器内的资源。
```python
void
```
```python
CUDTUnited
```
```python
:
```
```python
:
```
```python
removeSocket
```
```python
(
```
```python
const
```
```python
UDTSOCKET u
```
```python
)
```
```python
{
```
```python
map
```
```python
<
```
```python
UDTSOCKET
```
```python
,
```
```python
CUDTSocket
```
```python
*
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator i
```
```python
=
```
```python
m_ClosedSockets
```
```python
.
```
```python
find
```
```python
(
```
```python
u
```
```python
)
```
```python
;
```
```python
// invalid socket ID
```
```python
if
```
```python
(
```
```python
i
```
```python
==
```
```python
m_ClosedSockets
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
return
```
```python
;
```
```python
// 由于是多个UDT实例共享一个资源复用器，销毁时要减少引用计数
```
```python
// decrease multiplexer reference count, and remove it if necessary
```
```python
const
```
```python
int
```
```python
mid
```
```python
=
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_iMuxID
```
```python
;
```
```python
if
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pQueuedSockets
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
enterCS
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
// if it is a listener, close all un-accepted sockets in its queue and remove them later
```
```python
for
```
```python
(
```
```python
set
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator q
```
```python
=
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pQueuedSockets
```
```python
->
```
```python
begin
```
```python
(
```
```python
)
```
```python
;
```
```python
q
```
```python
!=
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pQueuedSockets
```
```python
->
```
```python
end
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
q
```
```python
)
```
```python
{
```
```python
m_Sockets
```
```python
[
```
```python
*
```
```python
q
```
```python
]
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
m_bBroken
```
```python
=
```
```python
true
```
```python
;
```
```python
//1. 将CUDT*的状态设置为BROKEN
```
```python
m_Sockets
```
```python
[
```
```python
*
```
```python
q
```
```python
]
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
//2. 调用CUDT中的close()
```
```python
m_Sockets
```
```python
[
```
```python
*
```
```python
q
```
```python
]
```
```python
->
```
```python
m_TimeStamp
```
```python
=
```
```python
CTimer
```
```python
:
```
```python
:
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
//3. 更新UDT SOCKET的关闭时间
```
```python
m_Sockets
```
```python
[
```
```python
*
```
```python
q
```
```python
]
```
```python
->
```
```python
m_Status
```
```python
=
```
```python
CLOSED
```
```python
;
```
```python
//4. 将UDT SOCKET设置为Closed
```
```python
m_ClosedSockets
```
```python
[
```
```python
*
```
```python
q
```
```python
]
```
```python
=
```
```python
m_Sockets
```
```python
[
```
```python
*
```
```python
q
```
```python
]
```
```python
;
```
```python
//5. 在Closed Array中添加当前UDT SOCKET，在GC线程中进行处理
```
```python
m_Sockets
```
```python
.
```
```python
erase
```
```python
(
```
```python
*
```
```python
q
```
```python
)
```
```python
;
```
```python
//6. 从全局的MAP中删除
```
```python
}
```
```python
CGuard
```
```python
:
```
```python
:
```
```python
leaveCS
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_AcceptLock
```
```python
)
```
```python
;
```
```python
}
```
```python
// remove from peer rec
```
```python
map
```
```python
<
```
```python
int64_t
```
```python
,
```
```python
set
```
```python
<
```
```python
UDTSOCKET
```
```python
>
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator j
```
```python
=
```
```python
m_PeerRec
```
```python
.
```
```python
find
```
```python
(
```
```python
(
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_PeerID
```
```python
<<
```
```python
30
```
```python
)
```
```python
+
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_iISN
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
j
```
```python
!=
```
```python
m_PeerRec
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
j
```
```python
->
```
```python
second
```
```python
.
```
```python
erase
```
```python
(
```
```python
u
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
j
```
```python
->
```
```python
second
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
)
```
```python
m_PeerRec
```
```python
.
```
```python
erase
```
```python
(
```
```python
j
```
```python
)
```
```python
;
```
```python
}
```
```python
// delete this one
```
```python
i
```
```python
->
```
```python
second
```
```python
->
```
```python
m_pUDT
```
```python
->
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
delete i
```
```python
->
```
```python
second
```
```python
;
```
```python
m_ClosedSockets
```
```python
.
```
```python
erase
```
```python
(
```
```python
i
```
```python
)
```
```python
;
```
```python
map
```
```python
<
```
```python
int
```
```python
,
```
```python
CMultiplexer
```
```python
>
```
```python
:
```
```python
:
```
```python
iterator m
```
```python
;
```
```python
m
```
```python
=
```
```python
m_mMultiplexer
```
```python
.
```
```python
find
```
```python
(
```
```python
mid
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m
```
```python
==
```
```python
m_mMultiplexer
```
```python
.
```
```python
end
```
```python
(
```
```python
)
```
```python
)
```
```python
//如果这个资源复用器不存在，直接返回
```
```python
{
```
```python
//something is wrong!!!
```
```python
return
```
```python
;
```
```python
}
```
```python
m
```
```python
->
```
```python
second
```
```python
.
```
```python
m_iRefCount
```
```python
--
```
```python
;
```
```python
//否则的话，减少这个资源复用器的引用计数
```
```python
if
```
```python
(
```
```python
0
```
```python
==
```
```python
m
```
```python
->
```
```python
second
```
```python
.
```
```python
m_iRefCount
```
```python
)
```
```python
{
```
```python
m
```
```python
->
```
```python
second
```
```python
.
```
```python
m_pChannel
```
```python
->
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
//与UDP SOCKET关联的Channel直接关闭
```
```python
delete m
```
```python
->
```
```python
second
```
```python
.
```
```python
m_pSndQueue
```
```python
;
```
```python
//清理资源复用器的资源
```
```python
delete m
```
```python
->
```
```python
second
```
```python
.
```
```python
m_pRcvQueue
```
```python
;
```
```python
delete m
```
```python
->
```
```python
second
```
```python
.
```
```python
m_pTimer
```
```python
;
```
```python
delete m
```
```python
->
```
```python
second
```
```python
.
```
```python
m_pChannel
```
```python
;
```
```python
m_mMultiplexer
```
```python
.
```
```python
erase
```
```python
(
```
```python
m
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
## 终止流程
UDT::cleanup -> CUDT::cleanup -> CUDTUnited::cleanup
终止流程与开始流程相反，在计数器清零以后才会真正退出，每次调用，计数减一。修改 m_bClosing 与 m_bGCStatus 状态，终止垃圾回收线程。
```python
int
```
```python
CUDTUnited
```
```python
:
```
```python
:
```
```python
cleanup
```
```python
(
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
gcinit
```
```python
(
```
```python
m_InitLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
--
```
```python
m_iInstanceCount
```
```python
>
```
```python
0
```
```python
)
```
```python
//计数器减一
```
```python
return
```
```python
0
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
m_bGCStatus
```
```python
)
```
```python
return
```
```python
0
```
```python
;
```
```python
m_bClosing
```
```python
=
```
```python
true
```
```python
;
```
```python
pthread_cond_signal
```
```python
(
```
```python
&
```
```python
m_GCStopCond
```
```python
)
```
```python
;
```
```python
pthread_join
```
```python
(
```
```python
m_GCThread
```
```python
,
```
```python
NULL
```
```python
)
```
```python
;
```
```python
pthread_mutex_destroy
```
```python
(
```
```python
&
```
```python
m_GCStopLock
```
```python
)
```
```python
;
```
```python
pthread_cond_destroy
```
```python
(
```
```python
&
```
```python
m_GCStopCond
```
```python
)
```
```python
;
```
```python
m_bGCStatus
```
```python
=
```
```python
false
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
}
```
对UDT库的初始化与终止流程分析结束，在例程中，基本上都是显示调用这两个接口，但是在 appclient.cpp 中，通过构造函数与析构函数隐式完成。两种方式均可，可根据需要自选。
```python
struct
```
```python
UDTUpDown
```
```python
{
```
```python
UDTUpDown
```
```python
(
```
```python
)
```
```python
{
```
```python
// use this function to initialize the UDT library
```
```python
UDT
```
```python
:
```
```python
:
```
```python
startup
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
~
```
```python
UDTUpDown
```
```python
(
```
```python
)
```
```python
{
```
```python
// use this function to release the UDT library
```
```python
UDT
```
```python
:
```
```python
:
```
```python
cleanup
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
;
```

