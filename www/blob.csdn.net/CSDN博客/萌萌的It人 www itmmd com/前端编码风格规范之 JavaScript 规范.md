
# 前端编码风格规范之 JavaScript 规范 - 萌萌的It人 www.itmmd.com - CSDN博客


2015年01月16日 13:19:46[Jlins](https://me.csdn.net/dyllove98)阅读数：1219


## JavaScript 规范
---

### 全局命名空间污染与 IIFE
总是将代码包裹成一个 IIFE(Immediately-Invoked Function Expression)，用以创建独立隔绝的定义域。这一举措可防止全局命名空间被污染。
IIFE 还可确保你的代码不会轻易被其它全局命名空间里的代码所修改（i.e. 第三方库，window 引用，被覆盖的未定义的关键字等等）。
不推荐
```python
var
```
```python
x
```
```python
=
```
```python
10
```
```python
,
```
```python
y
```
```python
=
```
```python
100
```
```python
;
```
```python
// Declaring variables in the global scope is resulting in global scope pollution. All variables declared like this
```
```python
// will be stored in the window object. This is very unclean and needs to be avoided.
```
```python
console
```
```python
.
```
```python
log
```
```python
(
```
```python
window
```
```python
.
```
```python
x
```
```python
+
```
```python
' '
```
```python
+
```
```python
window
```
```python
.
```
```python
y
```
```python
);
```
推荐
```python
// We declare a IIFE and pass parameters into the function that we will use from the global space
```
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
,
```
```python
w
```
```python
,
```
```python
undefined
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
x
```
```python
=
```
```python
10
```
```python
,
```
```python
y
```
```python
=
```
```python
100
```
```python
;
```
```python
// Will output 'true true'
```
```python
log
```
```python
((
```
```python
w
```
```python
.
```
```python
x
```
```python
===
```
```python
undefined
```
```python
)
```
```python
+
```
```python
' '
```
```python
+
```
```python
(
```
```python
w
```
```python
.
```
```python
y
```
```python
===
```
```python
undefined
```
```python
));
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
,
```
```python
window
```
```python
));
```

---

### IIFE（立即执行的函数表达式）
无论何时，想要创建一个新的封闭的定义域，那就用 IIFE。它不仅避免了干扰，也使得内存在执行完后立即释放。
所有脚本文件建议都从 IIFE 开始。
立即执行的函数表达式的执行括号应该写在外包括号内。虽然写在内还是写在外都是有效的，但写在内使得整个表达式看起来更像一个整体，因此推荐这么做。
不推荐
```python
(
```
```python
function
```
```python
(){})();
```
推荐
```python
(
```
```python
function
```
```python
(){}());
```
so，用下列写法来格式化你的 IIFE 代码：
```python
(
```
```python
function
```
```python
(){
```
```python
'use strict'
```
```python
;
```
```python
// Code goes here
```
```python
}());
```
如果你想引用全局变量或者是外层 IIFE 的变量，可以通过下列方式传参：
```python
(
```
```python
function
```
```python
(
```
```python
$
```
```python
,
```
```python
w
```
```python
,
```
```python
d
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
$
```
```python
(
```
```python
function
```
```python
()
```
```python
{
```
```python
w
```
```python
.
```
```python
alert
```
```python
(
```
```python
d
```
```python
.
```
```python
querySelectorAll
```
```python
(
```
```python
'div'
```
```python
).
```
```python
length
```
```python
);
```
```python
});
```
```python
}(
```
```python
jQuery
```
```python
,
```
```python
window
```
```python
,
```
```python
document
```
```python
));
```

---

### 严格模式
ECMAScript 5 严格模式可在整个脚本或独个方法内被激活。它对应不同的 javascript 语境会做更加严格的错误检查。严格模式也确保了 javascript 代码更加的健壮，运行的也更加快速。
严格模式会阻止使用在未来很可能被引入的预留关键字。
你应该在你的脚本中启用严格模式，最好是在独立的 IIFE 中应用它。避免在你的脚本第一行使用它而导致你的所有脚本都启动了严格模式，这有可能会引发一些第三方类库的问题。
不推荐
```python
// Script starts here
```
```python
'use strict'
```
```python
;
```
```python
(
```
```python
function
```
```python
(){
```
```python
// Your code starts here
```
```python
}());
```
推荐
```python
(
```
```python
function
```
```python
(){
```
```python
'use strict'
```
```python
;
```
```python
// Your code starts here
```
```python
}());
```

---

### 变量声明
总是使用`var`来声明变量。如不指定 var，变量将被隐式地声明为全局变量，这将对变量难以控制。如果没有声明，变量处于什么定义域就变得不清（可以是在 Document 或 Window 中，也可以很容易地进入本地定义域）。所以，请总是使用 var 来声明变量。
采用严格模式带来的好处是，当你手误输入错误的变量名时，它可以通过报错信息来帮助你定位错误出处。
不推
```python
x
```
```python
=
```
```python
10
```
```python
;
```
```python
y
```
```python
=
```
```python
100
```
```python
;
```
推荐
```python
var
```
```python
x
```
```python
=
```
```python
10
```
```python
,
```
```python
y
```
```python
=
```
```python
100
```
```python
;
```

---

### 理解 JavaScript 的定义域和定义域提升
在 JavaScript 中变量和方法定义会自动提升到执行之前。JavaScript 只有 function 级的定义域，而无其他很多编程语言中的块定义域，所以使得你在某一 function 内的某语句和循环体中定义了一个变量，此变量可作用于整个 function 内，而不仅仅是在此语句或循环体中，因为它们的声明被 JavaScript 自动提升了。
我们通过例子来看清楚这到底是怎么一回事：
原 function
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
a
```
```python
=
```
```python
10
```
```python
;
```
```python
for
```
```python
(
```
```python
var
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
a
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
var
```
```python
b
```
```python
=
```
```python
i
```
```python
*
```
```python
i
```
```python
;
```
```python
log
```
```python
(
```
```python
b
```
```python
);
```
```python
}
```
```python
if
```
```python
(
```
```python
a
```
```python
===
```
```python
10
```
```python
)
```
```python
{
```
```python
var
```
```python
f
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
log
```
```python
(
```
```python
a
```
```python
);
```
```python
};
```
```python
f
```
```python
();
```
```python
}
```
```python
function
```
```python
x
```
```python
()
```
```python
{
```
```python
log
```
```python
(
```
```python
'Mr. X!'
```
```python
);
```
```python
}
```
```python
x
```
```python
();
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
被 JS 提升过后
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
// All variables used in the closure will be hoisted to the top of the function
```
```python
var
```
```python
a
```
```python
,
```
```python
i
```
```python
,
```
```python
b
```
```python
,
```
```python
f
```
```python
;
```
```python
// All functions in the closure will be hoisted to the top
```
```python
function
```
```python
x
```
```python
()
```
```python
{
```
```python
log
```
```python
(
```
```python
'Mr. X!'
```
```python
);
```
```python
}
```
```python
a
```
```python
=
```
```python
10
```
```python
;
```
```python
for
```
```python
(
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
a
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
b
```
```python
=
```
```python
i
```
```python
*
```
```python
i
```
```python
;
```
```python
log
```
```python
(
```
```python
b
```
```python
);
```
```python
}
```
```python
if
```
```python
(
```
```python
a
```
```python
===
```
```python
10
```
```python
)
```
```python
{
```
```python
// Function assignments will only result in hoisted variables but the function body will not be hoisted
```
```python
// Only by using a real function declaration the whole function will be hoisted with its body
```
```python
f
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
log
```
```python
(
```
```python
a
```
```python
);
```
```python
};
```
```python
f
```
```python
();
```
```python
}
```
```python
x
```
```python
();
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
根据以上提升过程，你是否可理解以下代码？
有效代码
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
a
```
```python
=
```
```python
10
```
```python
;
```
```python
i
```
```python
=
```
```python
5
```
```python
;
```
```python
x
```
```python
();
```
```python
for
```
```python
(
```
```python
var
```
```python
i
```
```python
;
```
```python
i
```
```python
<
```
```python
a
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
log
```
```python
(
```
```python
b
```
```python
);
```
```python
var
```
```python
b
```
```python
=
```
```python
i
```
```python
*
```
```python
i
```
```python
;
```
```python
}
```
```python
if
```
```python
(
```
```python
a
```
```python
===
```
```python
10
```
```python
)
```
```python
{
```
```python
f
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
log
```
```python
(
```
```python
a
```
```python
);
```
```python
};
```
```python
f
```
```python
();
```
```python
var
```
```python
f
```
```python
;
```
```python
}
```
```python
function
```
```python
x
```
```python
()
```
```python
{
```
```python
log
```
```python
(
```
```python
'Mr. X!'
```
```python
);
```
```python
}
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
正如你所看到的这段令人充满困惑与误解的代码导致了出人意料的结果。只有良好的声明习惯，也就是下一章节我们要提到的声明规则，才能尽可能的避免这类错误风险。
---
提升声明
为避免上一章节所述的变量和方法定义被自动提升造成误解，把风险降到最低，我们应该手动地显示地去声明变量与方法。也就是说，所有的变量以及方法，应当定义在 function 内的首行。
只用一个`var`关键字声明，多个变量用逗号隔开。
不推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
a
```
```python
=
```
```python
10
```
```python
;
```
```python
var
```
```python
b
```
```python
=
```
```python
10
```
```python
;
```
```python
for
```
```python
(
```
```python
var
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
10
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
var
```
```python
c
```
```python
=
```
```python
a
```
```python
*
```
```python
b
```
```python
*
```
```python
i
```
```python
;
```
```python
}
```
```python
function
```
```python
f
```
```python
()
```
```python
{
```
```python
}
```
```python
var
```
```python
d
```
```python
=
```
```python
100
```
```python
;
```
```python
var
```
```python
x
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
return
```
```python
d
```
```python
*
```
```python
d
```
```python
;
```
```python
};
```
```python
log
```
```python
(
```
```python
x
```
```python
());
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
a
```
```python
=
```
```python
10
```
```python
,
```
```python
b
```
```python
=
```
```python
10
```
```python
,
```
```python
i
```
```python
,
```
```python
c
```
```python
,
```
```python
d
```
```python
,
```
```python
x
```
```python
;
```
```python
function
```
```python
f
```
```python
()
```
```python
{
```
```python
}
```
```python
for
```
```python
(
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
10
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
c
```
```python
=
```
```python
a
```
```python
*
```
```python
b
```
```python
*
```
```python
i
```
```python
;
```
```python
}
```
```python
d
```
```python
=
```
```python
100
```
```python
;
```
```python
x
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
return
```
```python
d
```
```python
*
```
```python
d
```
```python
;
```
```python
};
```
```python
log
```
```python
(
```
```python
x
```
```python
());
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
把赋值尽量写在变量申明中。
不推荐
```python
var
```
```python
a
```
```python
,
```
```python
b
```
```python
,
```
```python
c
```
```python
;
```
```python
a
```
```python
=
```
```python
10
```
```python
;
```
```python
b
```
```python
=
```
```python
10
```
```python
;
```
```python
c
```
```python
=
```
```python
100
```
```python
;
```
推荐
```python
var
```
```python
a
```
```python
=
```
```python
10
```
```python
,
```
```python
b
```
```python
=
```
```python
10
```
```python
,
```
```python
c
```
```python
=
```
```python
100
```
```python
;
```

### 总是使用带类型判断的比较判断
总是使用`===`精确的比较操作符，避免在判断的过程中，由 JavaScript 的强制类型转换所造成的困扰。
如果你使用`===`操作符，那比较的双方必须是同一类型为前提的条件下才会有效。
如果你想了解更多关于强制类型转换的信息，你可以读一读[
Dmitry Soshnikov 的这篇文章](http://dmitrysoshnikov.com/notes/note-2-ecmascript-equality-operators/)。
在只使用`==`的情况下，JavaScript 所带来的强制类型转换使得判断结果跟踪变得复杂，下面的例子可以看出这样的结果有多怪了：
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
log
```
```python
(
```
```python
'0'
```
```python
==
```
```python
0
```
```python
);
```
```python
// true
```
```python
log
```
```python
(
```
```python
''
```
```python
==
```
```python
false
```
```python
);
```
```python
// true
```
```python
log
```
```python
(
```
```python
'1'
```
```python
==
```
```python
true
```
```python
);
```
```python
// true
```
```python
log
```
```python
(
```
```python
null
```
```python
==
```
```python
undefined
```
```python
);
```
```python
// true
```
```python
var
```
```python
x
```
```python
=
```
```python
{
```
```python
valueOf
```
```python
:
```
```python
function
```
```python
()
```
```python
{
```
```python
return
```
```python
'X'
```
```python
;
```
```python
}
```
```python
};
```
```python
log
```
```python
(
```
```python
x
```
```python
==
```
```python
'X'
```
```python
);
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```

---

### 明智地使用真假判断
当我们在一个 if 条件语句中使用变量或表达式时，会做真假判断。`if(a == true)`是不同于`if(a)`的。后者的判断比较特殊，我们称其为真假判断。这种判断会通过特殊的操作将其转换为 true 或 false，下列表达式统统返回 false：`false`,`0`,`undefined`,`null`,`NaN`,`''`（空字符串）.
这种真假判断在我们只求结果而不关心过程的情况下，非常的有帮助。
以下示例展示了真假判断是如何工作的：
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
function
```
```python
logTruthyFalsy
```
```python
(
```
```python
expr
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
expr
```
```python
)
```
```python
{
```
```python
log
```
```python
(
```
```python
'truthy'
```
```python
);
```
```python
}
```
```python
else
```
```python
{
```
```python
log
```
```python
(
```
```python
'falsy'
```
```python
);
```
```python
}
```
```python
}
```
```python
logTruthyFalsy
```
```python
(
```
```python
true
```
```python
);
```
```python
// truthy
```
```python
logTruthyFalsy
```
```python
(
```
```python
1
```
```python
);
```
```python
// truthy
```
```python
logTruthyFalsy
```
```python
({});
```
```python
// truthy
```
```python
logTruthyFalsy
```
```python
([]);
```
```python
// truthy
```
```python
logTruthyFalsy
```
```python
(
```
```python
'0'
```
```python
);
```
```python
// truthy
```
```python
logTruthyFalsy
```
```python
(
```
```python
false
```
```python
);
```
```python
// falsy
```
```python
logTruthyFalsy
```
```python
(
```
```python
0
```
```python
);
```
```python
// falsy
```
```python
logTruthyFalsy
```
```python
(
```
```python
undefined
```
```python
);
```
```python
// falsy
```
```python
logTruthyFalsy
```
```python
(
```
```python
null
```
```python
);
```
```python
// falsy
```
```python
logTruthyFalsy
```
```python
(
```
```python
NaN
```
```python
);
```
```python
// falsy
```
```python
logTruthyFalsy
```
```python
(
```
```python
''
```
```python
);
```
```python
// falsy
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```

---

### 变量赋值时的逻辑操作
逻辑操作符`||`和`&&`也可被用来返回布尔值。如果操作对象为非布尔对象，那每个表达式将会被自左向右地做真假判断。基于此操作，最终总有一个表达式被返回回来。这在变量赋值时，是可以用来简化你的代码的。
不推荐
```python
if
```
```python
(
```
```python
!
```
```python
x
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
!
```
```python
y
```
```python
)
```
```python
{
```
```python
x
```
```python
=
```
```python
1
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
x
```
```python
=
```
```python
y
```
```python
;
```
```python
}
```
```python
}
```
推荐
```python
x
```
```python
=
```
```python
x
```
```python
||
```
```python
y
```
```python
||
```
```python
1
```
```python
;
```
这一小技巧经常用来给方法设定默认的参数。
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
function
```
```python
multiply
```
```python
(
```
```python
a
```
```python
,
```
```python
b
```
```python
)
```
```python
{
```
```python
a
```
```python
=
```
```python
a
```
```python
||
```
```python
1
```
```python
;
```
```python
b
```
```python
=
```
```python
b
```
```python
||
```
```python
1
```
```python
;
```
```python
log
```
```python
(
```
```python
'Result '
```
```python
+
```
```python
a
```
```python
*
```
```python
b
```
```python
);
```
```python
}
```
```python
multiply
```
```python
();
```
```python
// Result 1
```
```python
multiply
```
```python
(
```
```python
10
```
```python
);
```
```python
// Result 10
```
```python
multiply
```
```python
(
```
```python
3
```
```python
,
```
```python
NaN
```
```python
);
```
```python
// Result 3
```
```python
multiply
```
```python
(
```
```python
9
```
```python
,
```
```python
5
```
```python
);
```
```python
// Result 45
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```

---

### 分号
总是使用分号，因为隐式的代码嵌套会引发难以察觉的问题。当然我们更要从根本上来杜绝这些问题[1] 。以下几个示例展示了缺少分号的危害：
```python
// 1.
```
```python
MyClass
```
```python
.
```
```python
prototype
```
```python
.
```
```python
myMethod
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
return
```
```python
42
```
```python
;
```
```python
}
```
```python
// No semicolon here.
```
```python
(
```
```python
function
```
```python
()
```
```python
{
```
```python
// Some initialization code wrapped in a function to create a scope for locals.
```
```python
})();
```
```python
var
```
```python
x
```
```python
=
```
```python
{
```
```python
'i'
```
```python
:
```
```python
1
```
```python
,
```
```python
'j'
```
```python
:
```
```python
2
```
```python
}
```
```python
// No semicolon here.
```
```python
// 2.  Trying to do one thing on Internet Explorer and another on Firefox.
```
```python
// I know you'd never write code like this, but throw me a bone.
```
```python
[
```
```python
ffVersion
```
```python
,
```
```python
ieVersion
```
```python
][
```
```python
isIE
```
```python
]();
```
```python
var
```
```python
THINGS_TO_EAT
```
```python
=
```
```python
[
```
```python
apples
```
```python
,
```
```python
oysters
```
```python
,
```
```python
sprayOnCheese
```
```python
]
```
```python
// No semicolon here.
```
```python
// 3. conditional execution a la bash
```
```python
-
```
```python
1
```
```python
==
```
```python
resultOfOperation
```
```python
()
```
```python
||
```
```python
die
```
```python
();
```
So what happens?
JavaScript 错误 —— 首先返回 42 的那个 function 被第二个 function 当中参数传入调用，接着数字 42 也被“调用”而导致出错。
八成你会得到 ‘no such property in undefined’ 的错误提示，因为在真实环境中的调用是这个样子：x[ffVersion, ieVersion][isIE]().
die总是被调用。因为数组减 1 的结果是NaN，它不等于任何东西（无论resultOfOperation是否返回NaN）。所以最终的结果是die()执行完所获得值将赋给THINGS_TO_EAT.
Why?
JavaScript 中语句要以分号结束，否则它将会继续执行下去，不管换不换行。以上的每一个示例中，函数声明或对象或数组，都变成了在一句语句体内。要知道闭合圆括号并不代表语句结束，JavaScript 不会终结语句，除非它的下一个 token 是一个中缀符[2] 或者是圆括号操作符。
这真是让人大吃一惊，所以乖乖地给语句末加上分号吧。
澄清：分号与函数
分号需要用在表达式的结尾，而并非函数声明的结尾。区分它们最好的例子是：
```python
var
```
```python
foo
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
return
```
```python
true
```
```python
;
```
```python
};
```
```python
// semicolon here.
```
```python
function
```
```python
foo
```
```python
()
```
```python
{
```
```python
return
```
```python
true
```
```python
;
```
```python
}
```
```python
// no semicolon here.
```

---

### 嵌套函数
嵌套函数是非常有用的，比如用在持续创建和隐藏辅助函数的任务中。你可以非常自由随意地使用它们。
---

### 语句块内的函数声明
切勿在语句块内声明函数，在 ECMAScript 5 的严格模式下，这是不合法的。函数声明应该在定义域的顶层。但在语句块内可将函数申明转化为函数表达式赋值给变量。
不推荐
```python
if
```
```python
(
```
```python
x
```
```python
)
```
```python
{
```
```python
function
```
```python
foo
```
```python
()
```
```python
{}
```
```python
}
```
推荐
```python
if
```
```python
(
```
```python
x
```
```python
)
```
```python
{
```
```python
var
```
```python
foo
```
```python
=
```
```python
function
```
```python
()
```
```python
{};
```
```python
}
```

---

### 异常
基本上你无法避免出现异常，特别是在做大型开发时（使用应用开发框架等等）。
在没有自定义异常的情况下，从有返回值的函数中返回错误信息一定非常的棘手，更别提多不优雅了。不好的解决方案包括了传第一个引用类型来接纳错误信息，或总是返回一个对象列表，其中包含着可能的错误对象。以上方式基本上是比较简陋的异常处理方式。适时可做自定义异常处理。
在复杂的环境中，你可以考虑抛出对象而不仅仅是字符串（默认的抛出值）。
```python
if
```
```python
(
```
```python
name
```
```python
===
```
```python
undefined
```
```python
)
```
```python
{
```
```python
throw
```
```python
{
```
```python
name
```
```python
:
```
```python
'System Error'
```
```python
,
```
```python
message
```
```python
:
```
```python
'A name should always be specified!'
```
```python
}
```
```python
}
```

---

### 标准特性
总是优先考虑使用标准特性。为了最大限度地保证扩展性与兼容性，总是首选标准的特性，而不是非标准的特性（例如：首选`string.charAt(3)`而不是`string[3]`；首选 DOM 的操作方法来获得元素引用，而不是某一应用特定的快捷方法）。
---

### 简易的原型继承
如果你想在 JavaScript 中继承你的对象，请遵循一个简易的模式来创建此继承。如果你预计你会遇上复杂对象的继承，那可以考虑采用一个继承库，比如[
Proto.js by Axel Rauschmayer](https://github.com/rauschma/proto-js).
简易继承请用以下方式：
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
// Constructor function
```
```python
function
```
```python
Apple
```
```python
(
```
```python
name
```
```python
)
```
```python
{
```
```python
this
```
```python
.
```
```python
name
```
```python
=
```
```python
name
```
```python
;
```
```python
}
```
```python
// Defining a method of apple
```
```python
Apple
```
```python
.
```
```python
prototype
```
```python
.
```
```python
eat
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
log
```
```python
(
```
```python
'Eating '
```
```python
+
```
```python
this
```
```python
.
```
```python
name
```
```python
);
```
```python
};
```
```python
// Constructor function
```
```python
function
```
```python
GrannySmithApple
```
```python
()
```
```python
{
```
```python
// Invoking parent constructor
```
```python
Apple
```
```python
.
```
```python
prototype
```
```python
.
```
```python
constructor
```
```python
.
```
```python
call
```
```python
(
```
```python
this
```
```python
,
```
```python
'Granny Smith'
```
```python
);
```
```python
}
```
```python
// Set parent prototype while creating a copy with Object.create
```
```python
GrannySmithApple
```
```python
.
```
```python
prototype
```
```python
=
```
```python
Object
```
```python
.
```
```python
create
```
```python
(
```
```python
Apple
```
```python
.
```
```python
prototype
```
```python
);
```
```python
// Set constructor to the sub type, otherwise points to Apple
```
```python
GrannySmithApple
```
```python
.
```
```python
prototype
```
```python
.
```
```python
constructor
```
```python
=
```
```python
GrannySmithApple
```
```python
;
```
```python
// Calling a super method
```
```python
GrannySmithApple
```
```python
.
```
```python
prototype
```
```python
.
```
```python
eat
```
```python
=
```
```python
function
```
```python
()
```
```python
{
```
```python
// Be sure to apply it onto our current object with call(this)
```
```python
Apple
```
```python
.
```
```python
prototype
```
```python
.
```
```python
eat
```
```python
.
```
```python
call
```
```python
(
```
```python
this
```
```python
);
```
```python
log
```
```python
(
```
```python
'Poor Grany Smith'
```
```python
);
```
```python
};
```
```python
// Instantiation
```
```python
var
```
```python
apple
```
```python
=
```
```python
new
```
```python
Apple
```
```python
(
```
```python
'Test Apple'
```
```python
);
```
```python
var
```
```python
grannyApple
```
```python
=
```
```python
new
```
```python
GrannySmithApple
```
```python
();
```
```python
log
```
```python
(
```
```python
apple
```
```python
.
```
```python
name
```
```python
);
```
```python
// Test Apple
```
```python
log
```
```python
(
```
```python
grannyApple
```
```python
.
```
```python
name
```
```python
);
```
```python
// Granny Smith
```
```python
// Instance checks
```
```python
log
```
```python
(
```
```python
apple
```
```python
instanceof
```
```python
Apple
```
```python
);
```
```python
// true
```
```python
log
```
```python
(
```
```python
apple
```
```python
instanceof
```
```python
GrannySmithApple
```
```python
);
```
```python
// false
```
```python
log
```
```python
(
```
```python
grannyApple
```
```python
instanceof
```
```python
Apple
```
```python
);
```
```python
// true
```
```python
log
```
```python
(
```
```python
grannyApple
```
```python
instanceof
```
```python
GrannySmithApple
```
```python
);
```
```python
// true
```
```python
// Calling method that calls super method
```
```python
grannyApple
```
```python
.
```
```python
eat
```
```python
();
```
```python
// Eating Granny Smith\nPoor Grany Smith
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```

---

### 使用闭包
闭包的创建也许是 JS 最有用也是最易被忽略的能力了。[关于闭包如何工作的合理解释](http://jibbering.com/faq/faq_notes/closures.html)。
---

### 切勿在循环中创建函数
在简单的循环语句中加入函数是非常容易形成闭包而带来隐患的。下面的例子就是一个典型的陷阱：
不推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
,
```
```python
w
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
// numbers and i is defined in the current function closure
```
```python
var
```
```python
numbers
```
```python
=
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
],
```
```python
i
```
```python
;
```
```python
for
```
```python
(
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
numbers
```
```python
.
```
```python
length
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
w
```
```python
.
```
```python
setTimeout
```
```python
(
```
```python
function
```
```python
()
```
```python
{
```
```python
// At the moment when this gets executed the i variable, coming from the outer function scope
```
```python
// is set to 3 and the current program is alerting the message 3 times
```
```python
// 'Index 3 with number undefined
```
```python
// If you understand closures in javascript you know how to deal with those cases
```
```python
// It's best to just avoid functions / new closures in loops as this prevents those issues
```
```python
w
```
```python
.
```
```python
alert
```
```python
(
```
```python
'Index '
```
```python
+
```
```python
i
```
```python
+
```
```python
' with number '
```
```python
+
```
```python
numbers
```
```python
[
```
```python
i
```
```python
]);
```
```python
},
```
```python
0
```
```python
);
```
```python
}
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
,
```
```python
window
```
```python
));
```
接下来的改进虽然已经解决了上述例子中的问题或 bug，但还是违反了不在循环中创建函数或闭包的原则。
不推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
,
```
```python
w
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
// numbers and i is defined in the current function closure
```
```python
var
```
```python
numbers
```
```python
=
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
],
```
```python
i
```
```python
;
```
```python
for
```
```python
(
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
numbers
```
```python
.
```
```python
length
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
// Creating a new closure scope with an IIFE solves the problem
```
```python
// The delayed function will use index and number which are
```
```python
// in their own closure scope (one closure per loop iteration).
```
```python
// ---
```
```python
// Still this is not recommended as we violate our rule to not
```
```python
// create functions within loops and we are creating two!
```
```python
(
```
```python
function
```
```python
(
```
```python
index
```
```python
,
```
```python
number
```
```python
){
```
```python
w
```
```python
.
```
```python
setTimeout
```
```python
(
```
```python
function
```
```python
()
```
```python
{
```
```python
// Will output as expected 0 > 1, 1 > 2, 2 > 3
```
```python
w
```
```python
.
```
```python
alert
```
```python
(
```
```python
'Index '
```
```python
+
```
```python
index
```
```python
+
```
```python
' with number '
```
```python
+
```
```python
number
```
```python
);
```
```python
},
```
```python
0
```
```python
);
```
```python
}(
```
```python
i
```
```python
,
```
```python
numbers
```
```python
[
```
```python
i
```
```python
]));
```
```python
}
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
,
```
```python
window
```
```python
));
```
接下来的改进已解决问题，而且也遵循了规范。可是，你会发现看上去似乎过于复杂繁冗了，应该会有更好的解决方案吧。
不完全推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
,
```
```python
w
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
// numbers and i is defined in the current function closure
```
```python
var
```
```python
numbers
```
```python
=
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
],
```
```python
i
```
```python
;
```
```python
// Create a function outside of the loop that will accept arguments to create a
```
```python
// function closure scope. This function will return a function that executes in this
```
```python
// closure parent scope.
```
```python
function
```
```python
alertIndexWithNumber
```
```python
(
```
```python
index
```
```python
,
```
```python
number
```
```python
)
```
```python
{
```
```python
return
```
```python
function
```
```python
()
```
```python
{
```
```python
w
```
```python
.
```
```python
alert
```
```python
(
```
```python
'Index '
```
```python
+
```
```python
index
```
```python
+
```
```python
' with number '
```
```python
+
```
```python
number
```
```python
);
```
```python
};
```
```python
}
```
```python
// First parameter is a function call that returns a function.
```
```python
// ---
```
```python
// This solves our problem and we don't create a function inside our loop
```
```python
for
```
```python
(
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
numbers
```
```python
.
```
```python
length
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
w
```
```python
.
```
```python
setTimeout
```
```python
(
```
```python
alertIndexWithNumber
```
```python
(
```
```python
i
```
```python
,
```
```python
numbers
```
```python
[
```
```python
i
```
```python
]),
```
```python
0
```
```python
);
```
```python
}
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
,
```
```python
window
```
```python
));
```
将循环语句转换为函数执行的方式问题能得到立马解决，每一次循环都会对应地创建一次闭包。函数式的风格更加值得推荐，而且看上去也更加地自然和可预料。
推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
,
```
```python
w
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
// numbers and i is defined in the current function closure
```
```python
var
```
```python
numbers
```
```python
=
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
],
```
```python
i
```
```python
;
```
```python
numbers
```
```python
.
```
```python
forEach
```
```python
(
```
```python
function
```
```python
(
```
```python
number
```
```python
,
```
```python
index
```
```python
)
```
```python
{
```
```python
w
```
```python
.
```
```python
setTimeout
```
```python
(
```
```python
function
```
```python
()
```
```python
{
```
```python
w
```
```python
.
```
```python
alert
```
```python
(
```
```python
'Index '
```
```python
+
```
```python
index
```
```python
+
```
```python
' with number '
```
```python
+
```
```python
number
```
```python
);
```
```python
},
```
```python
0
```
```python
);
```
```python
});
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
,
```
```python
window
```
```python
));
```

---

### eval 函数（魔鬼）
`eval()`不但混淆语境还很危险，总会有比这更好、更清晰、更安全的另一种方案来写你的代码，因此尽量不要使用 evil 函数。
---

### this 关键字
只在对象构造器、方法和在设定的闭包中使用`this`关键字。this 的语义在此有些误导。它时而指向全局对象（大多数时），时而指向调用者的定义域（在 eval 中），时而指向 DOM 树中的某一节点（当用事件处理绑定到 HTML 属性上时），时而指向一个新创建的对象（在构造器中），还时而指向其它的一些对象（如果函数被`call()`和`apply()`执行和调用时）。
正因为它是如此容易地被搞错，请限制它的使用场景：
在构造函数中
在对象的方法中（包括由此创建出的闭包内）
---

### 首选函数式风格
函数式编程让你可以简化代码并缩减维护成本，因为它容易复用，又适当地解耦和更少的依赖。
接下来的例子中，在一组数字求和的同一问题上，比较了两种解决方案。第一个例子是经典的程序处理，而第二个例子则是采用了函数式编程和 ECMA Script 5.1 的数组方法。
例外：往往在重代码性能轻代码维护的情况之下，要选择最优性能的解决方案而非维护性高的方案（比如用简单的循环语句代替 forEach）。
不推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
arr
```
```python
=
```
```python
[
```
```python
10
```
```python
,
```
```python
3
```
```python
,
```
```python
7
```
```python
,
```
```python
9
```
```python
,
```
```python
100
```
```python
,
```
```python
20
```
```python
],
```
```python
sum
```
```python
=
```
```python
0
```
```python
,
```
```python
i
```
```python
;
```
```python
for
```
```python
(
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
arr
```
```python
.
```
```python
length
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
sum
```
```python
+=
```
```python
arr
```
```python
[
```
```python
i
```
```python
];
```
```python
}
```
```python
log
```
```python
(
```
```python
'The sum of array '
```
```python
+
```
```python
arr
```
```python
+
```
```python
' is: '
```
```python
+
```
```python
sum
```
```python
)
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
arr
```
```python
=
```
```python
[
```
```python
10
```
```python
,
```
```python
3
```
```python
,
```
```python
7
```
```python
,
```
```python
9
```
```python
,
```
```python
100
```
```python
,
```
```python
20
```
```python
];
```
```python
var
```
```python
sum
```
```python
=
```
```python
arr
```
```python
.
```
```python
reduce
```
```python
(
```
```python
function
```
```python
(
```
```python
prevValue
```
```python
,
```
```python
currentValue
```
```python
)
```
```python
{
```
```python
return
```
```python
prevValue
```
```python
+
```
```python
currentValue
```
```python
;
```
```python
},
```
```python
0
```
```python
);
```
```python
log
```
```python
(
```
```python
'The sum of array '
```
```python
+
```
```python
arr
```
```python
+
```
```python
' is: '
```
```python
+
```
```python
sum
```
```python
);
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
另一个例子通过某一规则对一个数组进行过滤匹配来创建一个新的数组。
不推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
numbers
```
```python
=
```
```python
[
```
```python
11
```
```python
,
```
```python
3
```
```python
,
```
```python
7
```
```python
,
```
```python
9
```
```python
,
```
```python
100
```
```python
,
```
```python
20
```
```python
,
```
```python
14
```
```python
,
```
```python
10
```
```python
],
```
```python
numbersGreaterTen
```
```python
=
```
```python
[],
```
```python
i
```
```python
;
```
```python
for
```
```python
(
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
numbers
```
```python
.
```
```python
length
```
```python
;
```
```python
i
```
```python
++
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
numbers
```
```python
[
```
```python
i
```
```python
]
```
```python
>
```
```python
10
```
```python
)
```
```python
{
```
```python
numbersGreaterTen
```
```python
.
```
```python
push
```
```python
(
```
```python
numbers
```
```python
[
```
```python
i
```
```python
]);
```
```python
}
```
```python
}
```
```python
log
```
```python
(
```
```python
'From the list of numbers '
```
```python
+
```
```python
numbers
```
```python
+
```
```python
' only '
```
```python
+
```
```python
numbersGreaterTen
```
```python
+
```
```python
' are greater than ten'
```
```python
);
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```
推荐
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
var
```
```python
numbers
```
```python
=
```
```python
[
```
```python
11
```
```python
,
```
```python
3
```
```python
,
```
```python
7
```
```python
,
```
```python
9
```
```python
,
```
```python
100
```
```python
,
```
```python
20
```
```python
,
```
```python
14
```
```python
,
```
```python
10
```
```python
];
```
```python
var
```
```python
numbersGreaterTen
```
```python
=
```
```python
numbers
```
```python
.
```
```python
filter
```
```python
(
```
```python
function
```
```python
(
```
```python
element
```
```python
)
```
```python
{
```
```python
return
```
```python
element
```
```python
>
```
```python
10
```
```python
;
```
```python
});
```
```python
log
```
```python
(
```
```python
'From the list of numbers '
```
```python
+
```
```python
numbers
```
```python
+
```
```python
' only '
```
```python
+
```
```python
numbersGreaterTen
```
```python
+
```
```python
' are greater than ten'
```
```python
);
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```

---

### 使用 ECMA Script 5
建议使用 ECMA Script 5 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。
---

### 数组和对象的属性迭代
用 ECMA5 的迭代方法来迭代数组。使用`Array.forEach`或者如果你要在特殊场合下中断迭代，那就用`Array.every`。
```python
(
```
```python
function
```
```python
(
```
```python
log
```
```python
){
```
```python
'use strict'
```
```python
;
```
```python
// Iterate over an array and break at a certain condition
```
```python
[
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
].
```
```python
every
```
```python
(
```
```python
function
```
```python
(
```
```python
element
```
```python
,
```
```python
index
```
```python
,
```
```python
arr
```
```python
)
```
```python
{
```
```python
log
```
```python
(
```
```python
element
```
```python
+
```
```python
' at index '
```
```python
+
```
```python
index
```
```python
+
```
```python
' in array '
```
```python
+
```
```python
arr
```
```python
);
```
```python
if
```
```python
(
```
```python
index
```
```python
!==
```
```python
5
```
```python
)
```
```python
{
```
```python
return
```
```python
true
```
```python
;
```
```python
}
```
```python
});
```
```python
// Defining a simple javascript object
```
```python
var
```
```python
obj
```
```python
=
```
```python
{
```
```python
a
```
```python
:
```
```python
'A'
```
```python
,
```
```python
b
```
```python
:
```
```python
'B'
```
```python
,
```
```python
'c-d-e'
```
```python
:
```
```python
'CDE'
```
```python
};
```
```python
// Iterating over the object keys
```
```python
Object
```
```python
.
```
```python
keys
```
```python
(
```
```python
obj
```
```python
).
```
```python
forEach
```
```python
(
```
```python
function
```
```python
(
```
```python
element
```
```python
,
```
```python
index
```
```python
,
```
```python
arr
```
```python
)
```
```python
{
```
```python
log
```
```python
(
```
```python
'Key '
```
```python
+
```
```python
element
```
```python
+
```
```python
' has value '
```
```python
+
```
```python
obj
```
```python
[
```
```python
element
```
```python
]);
```
```python
});
```
```python
}(
```
```python
window
```
```python
.
```
```python
console
```
```python
.
```
```python
log
```
```python
));
```

---

### 不要使用 switch
switch 在所有的编程语言中都是个非常错误的难以控制的语句，建议用 if else 来替换它。
这个我表示不同意
---

### 数组和对象字面量
用数组和对象字面量来代替数组和对象构造器。数组构造器很容易让人在它的参数上犯错。
不推荐
```python
// Length is 3.
```
```python
var
```
```python
a1
```
```python
=
```
```python
new
```
```python
Array
```
```python
(
```
```python
x1
```
```python
,
```
```python
x2
```
```python
,
```
```python
x3
```
```python
);
```
```python
// Length is 2.
```
```python
var
```
```python
a2
```
```python
=
```
```python
new
```
```python
Array
```
```python
(
```
```python
x1
```
```python
,
```
```python
x2
```
```python
);
```
```python
// If x1 is a number and it is a natural number the length will be x1.
```
```python
// If x1 is a number but not a natural number this will throw an exception.
```
```python
// Otherwise the array will have one element with x1 as its value.
```
```python
var
```
```python
a3
```
```python
=
```
```python
new
```
```python
Array
```
```python
(
```
```python
x1
```
```python
);
```
```python
// Length is 0.
```
```python
var
```
```python
a4
```
```python
=
```
```python
new
```
```python
Array
```
```python
();
```
正因如此，如果将代码传参从两个变为一个，那数组很有可能发生意料不到的长度变化。为避免此类怪异状况，请总是采用更多可读的数组字面量。
推荐
```python
var
```
```python
a
```
```python
=
```
```python
[
```
```python
x1
```
```python
,
```
```python
x2
```
```python
,
```
```python
x3
```
```python
];
```
```python
var
```
```python
a2
```
```python
=
```
```python
[
```
```python
x1
```
```python
,
```
```python
x2
```
```python
];
```
```python
var
```
```python
a3
```
```python
=
```
```python
[
```
```python
x1
```
```python
];
```
```python
var
```
```python
a4
```
```python
=
```
```python
[];
```
对象构造器不会有类似的问题，但是为了可读性和统一性，我们应该使用对象字面量。
不推荐
```python
var
```
```python
o
```
```python
=
```
```python
new
```
```python
Object
```
```python
();
```
```python
var
```
```python
o2
```
```python
=
```
```python
new
```
```python
Object
```
```python
();
```
```python
o2
```
```python
.
```
```python
a
```
```python
=
```
```python
0
```
```python
;
```
```python
o2
```
```python
.
```
```python
b
```
```python
=
```
```python
1
```
```python
;
```
```python
o2
```
```python
.
```
```python
c
```
```python
=
```
```python
2
```
```python
;
```
```python
o2
```
```python
[
```
```python
'strange key'
```
```python
]
```
```python
=
```
```python
3
```
```python
;
```
应该写成这样：
推荐
```python
var
```
```python
o
```
```python
=
```
```python
{};
```
```python
var
```
```python
o2
```
```python
=
```
```python
{
```
```python
a
```
```python
:
```
```python
0
```
```python
,
```
```python
b
```
```python
:
```
```python
1
```
```python
,
```
```python
c
```
```python
:
```
```python
2
```
```python
,
```
```python
'strange key'
```
```python
:
```
```python
3
```
```python
};
```

---

### 修改内建对象的原型链
修改内建的诸如`Object.prototype`和`Array.prototype`是被严厉禁止的。修改其它的内建对象比如`Function.prototype`，虽危害没那么大，但始终还是会导致在开发过程中难以 debug 的问题，应当也要避免。
---

### 自定义 toString() 方法
你可以通过自定义`toString()`来控制对象字符串化。这很好，但你必须保证你的方法总是成功并不会有其它副作用。如果你的方法达不到这样的标准，那将会引发严重的问题。如果`toString()`调用了一个方法，这个方法做了一个断言[3] ，当断言失败，它可能会输出它所在对象的名称，当然对象也需要调用`toString()`。
---

### 圆括号
一般在语法和语义上真正需要时才谨慎地使用圆括号。不要用在一元操作符上，例如`delete`,`typeof`和`void`，或在关键字之后，例如`return`,`throw`,`case`,`new`等。
---

### 字符串
统一使用单引号(’)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：
```python
var
```
```python
msg
```
```python
=
```
```python
'This is some HTML <div class="makes-sense"></div>'
```
```python
;
```

---

### 三元条件判断（if 的快捷方法）
用三元操作符分配或返回语句。在比较简单的情况下使用，避免在复杂的情况下使用。没人愿意用 10 行三元操作符把自己的脑子绕晕。
不推荐
```python
if
```
```python
(
```
```python
x
```
```python
===
```
```python
10
```
```python
)
```
```python
{
```
```python
return
```
```python
'valid'
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
return
```
```python
'invalid'
```
```python
;
```
```python
}
```
推荐
```python
return
```
```python
x
```
```python
===
```
```python
10
```
```python
?
```
```python
'valid'
```
```python
:
```
```python
'invalid'
```
```python
;
```

---
[1]：作者指的是采用严格规范的语句写法，从根本上杜绝由分号缺失而引起的代码歧义。
[2]：中缀符，指的是像`x + y`中的`+`。
[3]：断言一般指程序员在测试测序时的假设，一般是一些布尔表达式，当返回是 true 时，断言为真，代码运行会继续进行；如果条件判断为 false，代码运行停止，你的应用被终止。
**其他精彩文章**
## [jQuery教程(19)-jquery ajax操作之序列化表单](http://www.itmmd.com/201501/497.html)
## [jQuery教程(18)-ajax操作之执行POST请求](http://www.itmmd.com/201501/496.html)
## [jQuery教程(20)-jquery ajax + php 操作之为Ajax请求提供不同...](http://www.itmmd.com/201501/499.html)
## [jQuery教程(21)-jquery ajax 回调函数](http://www.itmmd.com/201501/500.html)
## [jQuery教程(22)-ajax操作之错误处理](http://www.itmmd.com/201501/503.html)

## [jQuery教程(24)-ajax操作之Ajax和事件](http://www.itmmd.com/201501/504.html)

更多关于[android开发](http://www.itmmd.com/mobile.html)文章


