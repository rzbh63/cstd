# 递归式求解的三种方法

2016年02月01日 09:34:59 [l-jobs](https://me.csdn.net/qq_26010491) 阅读数：9356



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/qq_26010491/article/details/50616845

算法设计经常用到递归，而递归式是比较好写的，也是容易反应算法的设计思路的，我们分析含递归算法的时间复杂度就要求解递归式。

下面介绍求解递归式的三种方法，以下方法参考《算法导论》，图片来自网络。

## 1.主方法求解递归式

​    一种求解大部分递归式的公式。简洁实用，有兴趣的同学可以自己去看算法导论上的证明，这里只列举结论。

​    给出递归式: T(n) = a * T(n/b) + f(n) ，其中a>=1，b>1，f(n)是给定的函数，T(n)是定义在非负整数上的递归式。
​    这种方法要记忆三种情况，![img](https://img-blog.csdn.net/20160201085628397)

将余项f(n)与函数![img](https://img-blog.csdn.net/20160201090137586)进行比较， 直觉上来说两个函数的较大者决定了递归式的解，如果两个函数相当，则乘上一个对数因子logn。

这里要注意主方法不能求解的地方，所有的大于和小于都是多项式意义上的大于和小于，对于有些递归式夹在三种情况的间隙中，是无法用主方法来求解的。下面解释一下什么是多项式意义上的小于和大于：   

  f(x)多项式大于g(x):存在实数e>0,使得f(x)>g(x)*n^e
  f(x)多项式小于g(x):存在实数e>0,使得f(x)<g(x)*n^e

举个例子，有递归式T(n) = 2T(n/2)+nlgn, ![img](https://img-blog.csdn.net/20160201090137586)= n,nlgn/n = lgn,此时不存在e>0，使得n*lgn>n*n^e，所以就不能用主方法求解。

## 2.递归树求解

​    用主方法求解不了的递归式，我们可以用递归树来猜测解的上界，然后用代入法来证明解的正确性。递归树的求解精确度取决于你画递归树的精确度。

​     举例，![img](https://img-blog.csdn.net/20160201091404071) 

​     画出它的递归树，

​                                              ![img](https://img-blog.csdn.net/20160201091411294)

![img](https://img-blog.csdn.net/20160201091528638)

![img](https://img-blog.csdn.net/20160201091655389)

​       这里我们把递归树扩展到T(1)的层，然后以T(1)为单位把每层的代价求和，最后就是总的代价，需要注意的是，这里需要一定的数学知识。

## 3.代入法

   比如我们求解，递归式T(n) = 2T(n/2)+n，我们猜测解是O(nlgn),我们要寻找到一个常数c,使得T(n)<=cnlgn

   即T(n) <= 2c(n/2)lg(n/2)+n <= cnlgn-cnlg2+n = cnlgn-cn+n

   只要c>=1,T(n)<=cnlgn,所以我们的猜测是正确的。

   要注意的是，代入法全凭经验，通常用递归树来确定上界，然后用代入法再证明。