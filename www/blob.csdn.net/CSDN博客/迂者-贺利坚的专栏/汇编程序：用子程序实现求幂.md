
# 汇编程序：用子程序实现求幂 - 迂者-贺利坚的专栏 - CSDN博客

2017年04月22日 23:07:57[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：1396


【任务】
编制一个子程序，求$y=x^4$，自变量$x$为字节，应变量$y$可以在一个字内存放而不溢出
（1）版本1：子程序的参数由寄存器dl提供，返回结果在ax中；
（2）版本2：子程序不变，主程序中提供如下数据区，在主程序中，循环调用子程序，完成$y=x^4$的求解，并将结果存入在相应的数据区：
```python
data
```
```python
segment
```
```python
x db
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
y dw
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
data
```
```python
ends
```
（3）版本3：数据区不变，子程序完成全部8个数据的求解任务，主程序只调用一次子程序即可。数据x的起始偏移地址由si提供，存放结果的y的偏移地址，由di提供，在调用前，由主程序为子程序提供si、di值。
（4）版本4：将上面的程序按多文件的方式存放。
【参考解答】
（1）版本1：子程序的参数由寄存器dl提供，返回结果在ax中；
```python
assume cs:codesg, ss:stacksg
stacksg segment
    db
```
```python
32
```
```python
dup (
```
```python
0
```
```python
)
stacksg ends
codesg segment
main proc
```
```python
start:
```
```python
mov
```
```python
ax,stacksg
```
```python
mov
```
```python
ss,ax
```
```python
mov
```
```python
sp,
```
```python
16
```
```python
mov
```
```python
bl,
```
```python
8
```
```python
;为调用子程序准备参数
```
```python
call
```
```python
subp
```
```python
;子程序调用返回后要做的处理
```
```python
mov
```
```python
ax,
```
```python
4
```
```python
c00h
       int
```
```python
21
```
```python
h
main endp
```
```python
;子程序功能：求y=x^4
```
```python
;入口参数：x的值由bl提供
```
```python
;返回值：y值由ax返回，且y值
```
```python
subp proc
```
```python
push
```
```python
cx
```
```python
push
```
```python
dx
```
```python
;虽然说最后的结果不会超出1个字，但并不意味着求解过程中中间结果不会超出1个字节，故这儿还要用字的乘法
```
```python
push
```
```python
bx
```
```python
;重点是保护bh
```
```python
;尽管子程序中用到了ax，但规定结果由ax返回
```
```python
mov
```
```python
bh,
```
```python
0
```
```python
;使bx的值，与作为参数的bl相等
```
```python
mov
```
```python
ax,
```
```python
1
```
```python
mov
```
```python
cx,
```
```python
4
```
```python
s:
```
```python
mul
```
```python
bx
```
```python
;用连乘4次实现4次方
```
```python
loop s
```
```python
pop
```
```python
bx
```
```python
pop
```
```python
dx
```
```python
;因为不超1个字，最后结果由ax返回就行了，dx恢复
```
```python
pop
```
```python
cx
```
```python
ret
```
```python
subp endp
codesg ends
end start
```
（2）版本2：子程序不变，主程序中提供如下数据区，在主程序中，循环调用子程序，完成$y=x^4$的求解，并将结果存入在相应的数据区：
```python
assume cs:codesg, ss:stacksg, ds:datasg
stacksg segment
    db
```
```python
32
```
```python
dup (
```
```python
0
```
```python
)
stacksg ends
datasg segment
```
```python
x
```
```python
db
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
y
```
```python
dw
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
datasg ends
codesg segment
main proc
```
```python
start:
```
```python
mov
```
```python
ax, datasg
```
```python
mov
```
```python
ds, ax
```
```python
mov
```
```python
ax,stacksg
```
```python
mov
```
```python
ss,ax
```
```python
mov
```
```python
sp,
```
```python
16
```
```python
mov
```
```python
cx,
```
```python
8
```
```python
mov
```
```python
si, offset
```
```python
x
```
```python
mov
```
```python
di, offset
```
```python
y
```
```python
c:
```
```python
mov
```
```python
bl,[si]
```
```python
;为调用子程序准备参数
```
```python
call
```
```python
subp
```
```python
mov
```
```python
[di], ax
```
```python
;子程序调用返回后要做的处理
```
```python
inc
```
```python
si
```
```python
inc
```
```python
di
```
```python
inc
```
```python
di
       loop c
```
```python
mov
```
```python
ax,
```
```python
4
```
```python
c00h
       int
```
```python
21
```
```python
h
main endp
```
```python
;子程序功能：求y=x^4
```
```python
;入口参数：x的值由bl提供
```
```python
;返回值：y值由ax返回，且y值
```
```python
subp proc
```
```python
push
```
```python
cx
```
```python
push
```
```python
dx
```
```python
;虽然说最后的结果不会超出1个字，但并不意味着求解过程中中间结果不会超出1个字节，故这儿还要用字的乘法
```
```python
push
```
```python
bx
```
```python
;重点是保护bh
```
```python
;尽管子程序中用到了ax，但规定结果由ax返回
```
```python
mov
```
```python
bh,
```
```python
0
```
```python
;使bx的值，与作为参数的bl相等
```
```python
mov
```
```python
ax,
```
```python
1
```
```python
mov
```
```python
cx,
```
```python
4
```
```python
s:
```
```python
mul
```
```python
bx
```
```python
;用连乘4次实现4次方
```
```python
loop s
```
```python
pop
```
```python
bx
```
```python
pop
```
```python
dx
```
```python
;因为不超1个字，最后结果由ax返回就行了，dx恢复
```
```python
pop
```
```python
cx
```
```python
ret
```
```python
subp endp
codesg ends
end start
```
（3）版本3：数据区不变，子程序完成全部8个数据的求解任务，主程序只调用一次子程序即可。数据x的起始偏移地址由si提供，存放结果的y的偏移地址，由di提供，在调用前，由主程序为子程序提供si、di值。
```python
assume cs:codesg, ss:stacksg, ds:datasg
stacksg segment
    db
```
```python
32
```
```python
dup (
```
```python
0
```
```python
)
stacksg ends
datasg segment
```
```python
x
```
```python
db
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
y
```
```python
dw
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
datasg ends
codesg segment
main proc
```
```python
start:
```
```python
mov
```
```python
ax, datasg
```
```python
mov
```
```python
ds, ax
```
```python
mov
```
```python
ax,stacksg
```
```python
mov
```
```python
ss,ax
```
```python
mov
```
```python
sp,
```
```python
16
```
```python
mov
```
```python
si, offset
```
```python
x
```
```python
mov
```
```python
di, offset
```
```python
y
```
```python
call
```
```python
subp
```
```python
mov
```
```python
ax,
```
```python
4
```
```python
c00h
       int
```
```python
21
```
```python
h
main endp
```
```python
;子程序功能：求y[i]=x[i]^4，即为8个连续存储的字节求幂
```
```python
;入口参数：参数x[i]作为源参数，起始地址在si
```
```python
;        存放求值结果y[i]的内存单元，起始地起码在di中
```
```python
;返回值：无
```
```python
subp proc
```
```python
push
```
```python
cx
```
```python
push
```
```python
dx
```
```python
;虽然说最后的结果不会超出1个字，但并不意味着求解过程中中间结果不会超出1个字节，故这儿还要用字的乘法
```
```python
push
```
```python
bx
```
```python
;重点是保护bh
```
```python
mov
```
```python
bh,
```
```python
0
```
```python
;使下面要用到bx时，bx的值就是其低8位bl
```
```python
mov
```
```python
cx,
```
```python
8
```
```python
;循环8次，处理8个数据
```
```python
c:
```
```python
mov
```
```python
bl,[si]
```
```python
;为调用子程序准备参数
```
```python
mov
```
```python
ax,
```
```python
1
```
```python
push
```
```python
cx
```
```python
;保护外层循环次数
```
```python
mov
```
```python
cx,
```
```python
4
```
```python
s:
```
```python
mul
```
```python
bx
```
```python
;用连乘4次实现4次方
```
```python
loop s
```
```python
mov
```
```python
[di], ax
```
```python
;子程序调用返回后要做的处理
```
```python
inc
```
```python
si
```
```python
inc
```
```python
di
```
```python
inc
```
```python
di
```
```python
pop
```
```python
cx
```
```python
;恢复外层循环次数
```
```python
loop c
```
```python
pop
```
```python
bx
```
```python
pop
```
```python
dx
```
```python
;因为不超1个字，最后结果由ax返回就行了，dx恢复
```
```python
pop
```
```python
cx
```
```python
ret
```
```python
subp endp
codesg ends
end start
```
（4）版本4：将上面的程序按多文件的方式存放。
主程序所在文件：
```python
extrn subp:far
assume cs:codesg, ss:stacksg, ds:datasg
stacksg segment
    db
```
```python
32
```
```python
dup (
```
```python
0
```
```python
)
stacksg ends
datasg segment
```
```python
x
```
```python
db
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
y
```
```python
dw
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
datasg ends
codesg segment
main proc
```
```python
start:
```
```python
mov
```
```python
ax, datasg
```
```python
mov
```
```python
ds, ax
```
```python
mov
```
```python
ax,stacksg
```
```python
mov
```
```python
ss,ax
```
```python
mov
```
```python
sp,
```
```python
16
```
```python
mov
```
```python
si, offset
```
```python
x
```
```python
mov
```
```python
di, offset
```
```python
y
```
```python
call
```
```python
subp
```
```python
mov
```
```python
ax,
```
```python
4
```
```python
c00h
       int
```
```python
21
```
```python
h
main endp
codesg ends
end start
```
子程序所在文件
```python
public subp
assume cs:codesg
codesg segment
```
```python
;子程序功能：求y[i]=x[i]^4，即为8个连续存储的字节求幂
```
```python
;入口参数：参数x[i]作为源参数，起始地址在si
```
```python
;          存放求值结果y[i]的内存单元，起始地起码在di中
```
```python
;返回值：无
```
```python
subp proc far
```
```python
push
```
```python
cx
```
```python
push
```
```python
dx
```
```python
;虽然说最后的结果不会超出1个字，但并不意味着求解过程中中间结果不会超出1个字节，故这儿还要用字的乘法
```
```python
push
```
```python
bx
```
```python
;重点是保护bh
```
```python
mov
```
```python
bh,
```
```python
0
```
```python
;使下面要用到bx时，bx的值就是其低8位bl
```
```python
mov
```
```python
cx,
```
```python
8
```
```python
;循环8次，处理8个数据
```
```python
c:
```
```python
mov
```
```python
bl,[si]
```
```python
;为调用子程序准备参数
```
```python
mov
```
```python
ax,
```
```python
1
```
```python
push
```
```python
cx
```
```python
;保护外层循环次数
```
```python
mov
```
```python
cx,
```
```python
4
```
```python
s:
```
```python
mul
```
```python
bx
```
```python
;用连乘4次实现4次方
```
```python
loop s
```
```python
mov
```
```python
[di], ax
```
```python
;子程序调用返回后要做的处理
```
```python
inc
```
```python
si
```
```python
inc
```
```python
di
```
```python
inc
```
```python
di
```
```python
pop
```
```python
cx
```
```python
;恢复外层循环次数
```
```python
loop c
```
```python
pop
```
```python
bx
```
```python
pop
```
```python
dx
```
```python
;因为不超1个字，最后结果由ax返回就行了，dx恢复
```
```python
pop
```
```python
cx
```
```python
ret
```
```python
subp endp
codesg ends
end
```

