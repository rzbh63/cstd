
# 深度学习基础（四）：各种优化方法总结 - lyc_yongcai的博客 - CSDN博客


2017年06月14日 10:38:55[刷街兜风](https://me.csdn.net/lyc_yongcai)阅读数：210



---最近在看Google的Deep Learning一书，看到优化方法那一部分，正巧之前用tensorflow也是对那些优化方法一知半解的，所以看完后就整理了下放上来，

---主要是一阶的梯度法，包括SGD, Momentum, Nesterov Momentum, AdaGrad, RMSProp, Adam。

---其中SGD,Momentum,Nesterov Momentum是手动指定学习速率的,而后面的AdaGrad, RMSProp, Adam,就能够自动调节学习速率。


---BGD

---即batch gradient descent. 在训练中,每一步迭代都使用训练集的所有内容. 也就是说,利用现有参数对训练集中的

---每一个输入

---生成一个估计输出

---,然后跟实际输出

---比较,统计所有误差,求平均以后得到平均误差,以此来作为更新参数的依据.

---具体实现:

---需要:

---学习速率

---,
 初始参数

---每步迭代过程:

---1. 提取训练集中的所有内容

---,以及相关的输出

---2. 计算梯度和误差并更新参数:



---优点:

---由于每一步都利用了训练集中的所有数据,因此当损失函数达到最小值以后,能够保证此时计算出的梯度为0,换句话说,就是能够收敛.因此,使用BGD时不需要逐渐减小学习速率

---缺点:

---由于每一步都要使用所有数据,因此随着数据集的增大,运行速度会越来越慢.

---SGD

---SGD全名 stochastic gradient descent， 即随机梯度下降。不过这里的SGD其实跟MBGD(minibatch gradient descent)是一个意思,即随机抽取一批样本,以此为根据来更新参数.

---具体实现:

---需要:

---学习速率

---,
 初始参数

---每步迭代过程:

---1. 从训练集中的随机抽取一批容量为m的样本

---,以及相关的输出

---2. 计算梯度和误差并更新参数:



---优点:

---训练速度快,对于很大的数据集,也能够以较快的速度收敛.

---缺点:

---由于是抽取,因此不可避免的,得到的梯度肯定有误差.因此学习速率需要逐渐减小.否则模型无法收敛

---因为误差,所以每一次迭代的梯度受抽样的影响比较大,也就是说梯度含有比较大的噪声,不能很好的反映真实梯度.

---学习速率该如何调整:

---那么这样一来,

---如何衰减就成了问题.如果要保证SGD收敛,应该满足如下两个要求:



---而在实际操作中,一般是进行线性衰减:


---其中

---是初始学习率,

---是最后一次迭代的学习率.

---自然代表迭代次数.一般来说,

---设为

---的1%比较合适.而

---一般设为让训练集中的每个数据都输入模型上百次比较合适.那么初始学习率

---怎么设置呢?书上说,你

---先用固定的学习速率迭代100次,找出效果最好的学习速率,然后

---设为比它大一点就可以了.

---Momentum

---上面的SGD有个问题,就是每次迭代计算的梯度含有比较大的噪音. 而Momentum方法可以比较好的缓解这个问题,尤其是

---在面对小而连续的梯度但是含有很多噪声的时候,可以很好的加速学习

---.Momentum借用了物理中的动量概念,即前几次的梯度也会参与运算.为了表示动量,引入了一个新的变量v(velocity).v是之前的梯度的累加,但是每回合都有一定的衰减.

---具体实现:

---需要:

---学习速率

---,
 初始参数

---,
 初始速率v, 动量衰减参数

---每步迭代过程:

---1. 从训练集中的随机抽取一批容量为m的样本

---,以及相关的输出

---2. 计算梯度和误差,并更新速度v和参数

---:



---其中参数

---表示每回合速率v的衰减程度.同时也可以推断得到,如果每次迭代得到的梯度都是g,那么最后得到的v的稳定值为



---也就是说,Momentum最好情况下能够将学习速率加速

---倍.一般

---的取值有0.5,0.9,0.99这几种.当然,也可以让

---的值随着时间而变化,一开始小点,后来再加大.不过这样一来,又会引进新的参数.

---特点:

---前后梯度方向一致时,能够加速学习

---前后梯度方向不一致时,能够抑制震荡

---Nesterov Momentum

---这是对之前的Momentum的一种改进,大概思路就是,先对参数进行估计,然后使用估计后的参数来计算误差

---具体实现:

---需要:

---学习速率

---,
 初始参数

---,
 初始速率v, 动量衰减参数

---每步迭代过程:

---1. 从训练集中的随机抽取一批容量为m的样本

---,以及相关的输出

---2. 计算梯度和误差,并更新速度v和参数

---:



---注意在估算

---的时候,参数变成了

---而不是之前的

---AdaGrad

---AdaGrad可以自动变更学习速率,只是需要设定一个全局的学习速率

---,但是这并非是实际学习速率,实际的速率是与以往参数的模之和的开方成反比的.也许说起来有点绕口,不过用公式来表示就直白的多:



---其中

---是一个很小的常亮,大概在

---,防止出现除以0的情况.

---具体实现:

---需要:

---全局学习速率

---,
 初始参数

---,
 数值稳定量

---中间变量: 梯度累计量r(初始化为0)

---每步迭代过程:

---1. 从训练集中的随机抽取一批容量为m的样本

---,以及相关的输出

---2. 计算梯度和误差,更新r,再根据r和梯度计算参数更新量



---优点:

---能够实现学习率的自动更改。如果这次梯度大,那么学习速率衰减的就快一些;如果这次梯度小,那么学习速率衰减的就满一些。

---缺点:

---任然要设置一个变量

---经验表明，在普通

---[算法](http://lib.csdn.net/base/datastructure)

---中也许效果不错，但在

---[深度学习](http://lib.csdn.net/base/deeplearning)

---中，深度过深时会造成训练提前结束。

---RMSProp

---RMSProp通过引入一个衰减系数，让r每回合都衰减一定比例，类似于Momentum中的做法。

---具体实现:

---需要:

---全局学习速率

---,
 初始参数

---,
 数值稳定量

---，衰减速率

---中间变量: 梯度累计量r(初始化为0)

---每步迭代过程:

---1. 从训练集中的随机抽取一批容量为m的样本

---,以及相关的输出

---2. 计算梯度和误差,更新r,再根据r和梯度计算参数更新量



---优点：

---相比于AdaGrad,这种方法很好的解决了深度学习中过早结束的问题

---适合处理非平稳目标，对于RNN效果很好

---缺点：

---又引入了新的超参，衰减系数

---依然依赖于全局学习速率

---RMSProp with Nesterov Momentum

---当然，也有将RMSProp和Nesterov Momentum结合起来的

---具体实现:

---需要:

---全局学习速率

---,
 初始参数

---,
 初始速率v，动量衰减系数

---,
 梯度累计量衰减速率

---中间变量: 梯度累计量r(初始化为0)

---每步迭代过程:

---1. 从训练集中的随机抽取一批容量为m的样本

---,以及相关的输出

---2. 计算梯度和误差,更新r,再根据r和梯度计算参数更新量



---Adam

---Adam(Adaptive Moment Estimation)本质上是带有动量项的RMSprop，它利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。Adam的优点主要在于经过偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳。

---具体实现:

---需要:

---步进值

---,
 初始参数

---,
 数值稳定量

---，一阶动量衰减系数

---,
 二阶动量衰减系数

---其中几个取值一般为：

---中间变量：一阶动量s，二阶动量r,都初始化为0

---每步迭代过程:

---1. 从训练集中的随机抽取一批容量为m的样本

---,以及相关的输出

---2. 计算梯度和误差,更新r和s,再根据r和s以及梯度计算参数更新量





