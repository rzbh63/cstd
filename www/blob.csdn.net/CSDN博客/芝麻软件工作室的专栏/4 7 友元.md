
# 4.7 友元 -  芝麻软件工作室的专栏 - CSDN博客


2016年06月13日 08:51:05[seven-soft](https://me.csdn.net/softn)阅读数：138


在面向对象的程序设计中，类的封装性使得我们使用类（对象）的成员数据时经常要通过类（对象）的成员函数。这对于类是一种保护。但在某些情况下，频繁的成员函数调用使得效率严重受损。
例如，定义矩阵类，并有两个矩阵对象相乘，为了获得矩阵中的元素值（私有成员），要频繁调用取值函数（公有成员）。
怎样可以提高效率？——使用友元函数。在C++中友元（friend）函数允许在类外访问该类中的任何成员，就象类的成员函数一样。
友元函数用关键字friend说明。下面用友元函数重载运算符“+”，以实现c=d+c。（即实数与复数的加法。）
◆ 1、定义友元函数的一般格式：
首先，在类声明里声明：
class Complex
{
……
friend Complex operator + (double,Complex);
};/*opration+为类Complex类的友元函数， friend只用于类说明中 ……*/
第二步，在类外定义：
Complex operator + (double d , Complex c)
{
return Complex(d+c.Real , c.Image) ;
}
//注意友元不是成员函数，在类声明以外的地方也不加friend
第三步，使用，友元函数可以在任何地方直接访问类的私有成员
void main(void)
{
…… c=d+c1;
}
这里d+c1被C++编译器解释为operator+(d，c1)，即调用友元函数operator+(d，c1)。
◆ 2、再进一步，如果使用友元函数
friend
 complex operator +(complex c1 , complexc2) ;
无论是复数与复数相加，还是实数与复数相加（不论实数在前还是在后）都可以用。为什么呢？
因为有此例所定义的缺省的构造函数，实数会被强制转换为虚部为零的复数。d+c1被解释为：
operator+(complex(d)
 , c1)
◆ 3、
friend Complex operator+(const Complex & c1,const Complex & c2)
{
……
}
这里采用Complex对象的引用而不是对象本身，调用时不再重新分配内存建立一个复制的对象，函数效率会更高。加const，实参只读，可防止实参被修改。
◆ 4、单目运算符前置“++”的友元函数重载方式如下：
Complex Complex::operator++(Complex & c )
{
return (++c.Real , ++c.Image) ;
}
采用友元函数方式定义与使用都很方便。但采用友元方式必须使用引用，因为被施加“++”运算的是一个参数。
◆ 5、友元函数重载后置“++”如下：
friend Complex operator++(Complex & c , int)
{
Complex temp=c;
c.Real++ , c.Image++ ;
return temp;
}
采用引用类型，实参c做了++，而temp是++前的值。
◆ 6、友元函数注意点：友元函数不是类的成员函数，在友元函数体中访问对象的成员，必须用对象名加运算符“.”加对象成员名。这一点和一般函数一样。但友元函数可以访问类中的所有成员（公有的、私有的、保护的），一般函数只能访问类中的公有成员；
友元函数不受类中的访问权限关键字限制，可以把它放在类的公有、私有、保护部分，但结果一样；
某类的友元函数的作用域并非该类域。如果该友元函数是另一类的成员函数，则其作用域为另一类的类域，否则与一般函数相同。
友元函数破坏了面向对象程序设计类的封装性，所以友元函数如不是必须使用，则尽可能少用。或者用其他手段保证封装性。
友元还有友元类概念，整个类可以是另一个类的友元。友元类的每个成员函数都是另一个类的友元函数，都可访问另一个类中的保护或私有数据成员。定义方法如下：
class A
{
……
friend class B; //B为A的友元类
……
};

