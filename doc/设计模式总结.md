# 设计模式总结

 									

## 1.面向对象的三大特性

1）**封装**（Encapsulation）

隐藏对象的具体实现细节，通过共有方法暴露对象的功能。内部结构可以自由修改，同时可对成员进行更加精确的控制 (比如在setter方法中加值合法判断)

2）**继承**（Inheritance）

> 使用已经存在的类作为基础类（父类），在此基础上建立新类（子类）， 子类既可复用父类的功能，也能进行扩展，从而实现代码复用。 另外，Java不能像C++那样同时继承多个父类，只能**树形的继承**， 比如：Man -> Human -> Animal，或通过**接口和内部类**实现多继承。

另外，关于继承还需注意以下几点：

> - 1.子类拥有父类非private的属性与方法
> - 2.构造方法只能调用，不能实现，子类默认调用父类的无参构造方法， 
>    	如果父类没有无参的构造方法，需要使用super显式调用！
> - 3.慎用继承，要考虑是否需要从子类向父类进行向上转型！

3）**多态**（Polymorphism）

**定义**：一个类实例的相同方法在不同的情形下有不同的表现形式

分为以下两种：

- **编译时多态**（OverLoading）—— **方法重载**
- **运行时多态**（OverRidding）—— **继承** + **方法重写** + **向上转型**(父类引用指向子类对象)

**运行时多态**(动态绑定，new后面什么类型，动态类型就是什么类型)

示例如下：

C++代码

1. class Animal() { fun show() { println("动物") }}  
2. class People：Animal() { fun show() { println("人类") }}  
3. //下述代码打印结果：人类  
4. Animal animal = new People()  
5. animal.show()

------

## 2.类与类间的关系

**口诀**：**鸡湿衣冠剧组**(继承，实现，依赖，关联，聚合，组合)

继承和实现就不说了，后面四个只是 **语意层次** 的区别 
 两个类的相关程度，**依赖** < **关联** < **聚合** < **组合**

依次的UML类图标记：

- **继承/泛化**（Generalization）： 子类 ![img](http://static.zybuluo.com/coder-pig/b1cwnp03wm6oq31lqnihblwa/image_1b9fp46sq17acq711gfjati19un9.png) 父类
- **实现**（Realization）：实现类 ![img](http://static.zybuluo.com/coder-pig/9cdlyy2xbsyo9mi24fqqc36d/image_1b9fp63jk1dpotjl5ldsqquanm.png) 接口
- **依赖**（Dependency）：**不持有引用**，具体表现：局部变量，函数参数， 
   	返回值使用 ![img](http://static.zybuluo.com/coder-pig/8so6t0c0u25hb0mab9k7dhow/image_1bbnvj0orp8i1e2t21ip1l13o79.png) 依赖类，比如大佬依赖于递茶小弟；
- **关联**（Association）：**持有引用**，具体表现：成员变量， 箭头指向被关联类，可双向，一对多或多对多： 
  ![img](http://static.zybuluo.com/coder-pig/x04586fgviggkjxd5eq91cjg/image_1bdgqmab3um61v31nv2h4b140qg.png)
- **聚合**（Aggregation）：成员变量，**关联**是处于**同一层次**的，而**聚合**则 是**整体和局部**层次的，比如：**社团** 和 **小弟**，另外即使没有了社团， 小弟们依旧可以到别的地方搞事情。 
  ![img](http://static.zybuluo.com/coder-pig/jr0o9jyblfi128sehfo6aiu5/image_1bdgqo6bp1209dgj14sm1gu1kfmt.png)
- **组合**（Composition）：与聚合类似，程度更加强烈，共生死，**组合类** 负责**被组合类**的生命周期，比如： **社团** 和 **大佬**，如果没了社团， 大佬也就就不能存在了。 
  ![img](http://static.zybuluo.com/coder-pig/pnx0e6t24v5pg3kd4304oc1o/image_1bdgqpa8h13i2vqu1mvk192f1dn21a.png)

------

## 3.面向对象七大原则

- **单一职责原则**（Single Responsibility Principle） 
  **每一个类应该专注于做一件事情**。 即：高内聚，低耦合。
- **开闭原则**（Open Close Principle） 
   	一个对象**对扩展开放**，**对修改关闭**。即：对类的改动是通过增加代码进行的，而不是修改现有代码。
- **里氏替换原则**（Liskov Substitution Principle） 
   	在任何父类出现的地方都可以用它的子类来替代。
- **依赖倒置原则**（Dependence Inversion Principle） 
  **要依赖于抽象**，**不要依赖于具体实现**。
- **接口隔离原则**（Interface Segregation Principle） 
   	应当为客户端提供**尽可能小的单独的接口**，而不是提供大的总的接口。
- **迪米特原则**（Law Of Demeter） 
   	一个对象应当尽量少地与其他对象之间发生相互作用，使得系统功能模块相对独立。
- **组合**/**聚合复用原则**（Composite/Aggregate Reuse Principle） 
   	尽量使用**组合/聚合**的方式，而**不是使用继承**。

------

## 23种设计模式

- **创建型**（5种）：主要用于处理对象的创建，实例化对象： 
  **单例**，**建造者**，**原型**，**工厂方法**，**抽象工厂**
- **结构型**（7种）：处理类或对象间的组合 
  **适配器**，**装饰者**，**结合**，**桥接**，**外观**，**享元**，**代理**
- **行为型**（11种）：描述类或对象怎样进行交互和职责分配 
  **策略**，**观察者**，**迭代器**，**命令**，**备忘录**，**中介者**，**解释器**，**访问者**，**责任链**，**状态**，**模板方法**

------

## 一. 单例模式（Singleton Pattern）

**作用**：保证 **类在内存中** 的 **对象唯一性**。

**适用场景**：

- 1.避免创建多个实例浪费资源
- 2.避免多个实例因多次调用而出现错误
- 3.一般写工具类，线程池，缓存，数据库会用到。

**套路**(三个要点)：

- 1.不允许在类外new对象 —— **构造方法私有化**
- 2.在类中创建对象 —— **通过new在本类中创建一个实例**
- 3.对外提供获取该实例的方法 —— **定义公有方法返回创建的实例**

**饿汉与懒汉的区别**

前者在**类装载时**就实例化，后者只有在**第一次被使用**时才实例化。 (饿汉的优点是避免线程同步问题，缺点是即使没用到这个实例还是会加载) (懒汉的优点是实现了懒加载，但需要解决线程安全问题！)

**7种单例套路**：

1）**饿汉式**，没有实现懒加载~

Java代码

```java
public class Singleton() {  
    private static Singleton instance = new Singleton();  
    private Singleton(){ }  
    public static Singleton getInstance() {   
        return instance;    
    }  
}
//获取单例对象  
Singleton mSingleton = Singleton.getInstance();
```

2）**懒汉式**

虽然达到了懒加载，但是却存在线程安全问题，比如有两个线程都刚好执行完if(instance == null)，接着准备执行instance = new Singleton() 语句，这样的结果会导致我们**实例化了两个Singleton对象**，为了解决线程不安全问题，可以对getInstance()方法加锁。

Java代码

```java
public class Singleton {  
    private static Singleton instance = null;  
    private Singleton() { }  
    private static Singleton getInstance() {  
        if(instance == null) {   
            instance = new Singleton();   
        }  
        return instance;  
    }  
}
```

3）**懒汉式加锁版**

为getInstance方法加锁虽然保证了线程安全，但是每次执行getInstance() 都需要同步，而实例化对象只需要执行一次就够了，后面获取该示例， 应该直接return就好了，方法同步效率太低，一种改进后的写法是： **synchronized (Singleton.class) { instance = new Singleton(); }** 但是，这样写依然是线程不安全的，如果你还是想用懒汉式的话，推荐**双重检查锁定**（DCL，Double Check Lock）。

Java代码

```java
public class Singleton {  
    private static Singleton instance = null;  
    private Singleton() { }  
    private static synchronized Singleton getInstance() {  
        if(instance == null) {   
            instance = new Singleton();   
        }  
        return instance;  
    }  
}
```

4）**懒汉式双重校验锁**（DCL）

代码中进行了两次if检查，这样就可以保证线程安全，初始化一次后，后面再次访问时，if检查，直接return 实例化对象。volatile是1.5后引入的，volatile关键字会屏蔽Java虚拟机所做的一些代码优化，会导 
 致系统运行效率降低，而更好的写法是使用静态内部类来实现单例！

Java代码

```java
public class Singleton{  
    private static volatile Singleton instance = null;  
    private Singleton() { }  
    public static Singleton getInstance() {  
        if(instance == null) {  
            synchronized(Singleton.class) {  
                if(instance == null) instance = new Singleton();  
            }
        }
        return instance;
    }
 }
```

5）**静态内部类实现单例**（推荐）

和饿汉式类似，都是通过类加载机制来保证初始化实例的时候只有一个线程，从而避免线程安全问题，饿汉式的Singleton类被加载时，就会实例化，而静态内部类这种，当Singleton类被加载时，不会立即实例化，调用getInstance()  方法才会装载SingletonHolder类，从而完成Singleton的实例化。

Java代码

```java
public class Singleton {  
    private Singleton() { }  
    private static final Singleton getInstance() {  
        return SingletonHolder.INSTANCE;  
    }  
    private static class SingletonHolder {  
        private static final Singleton INSTANCE = new Singleton()  
    }  
}
```

6）**枚举实现单例**

INSTANCE即为SingletonEnum类型的引用，得到它就可以调用 
 枚举中的方法。既避免了线程安全问题，还能防止反序列化 
 重新创建新的对象，但是失去了类的一些特性，而且没有延时加载。

Java代码

```java
public enum SingletonEnum {  
    INSTANCE;  
    private Singleton instance;  
    SingletonEnum() {   
        instance = new Singleton();  
    }  
    public Singleton getInstance() {   
        return instance;   
    }  
}  
//调用方式  
SingletonEnum.INSTANCE.method(); 
```

7）**容器实现单例**

将多种单例类型注入到一个统一的管理类中，在使用时根据key获取对象 
 对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使 
 用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用 
 户隐藏了具体实现，降低了耦合度。

Java代码

```java
public class SingletonManager {  
    private static Map<String,Object> objMap = new HashMap<String,Object>();  
    private Singleton(){ }  
    public static void registerService(String key,Object instance) {  
        if(!objMap.containsKey(key)) {  
            objMap.put(key,instance);  
        }  
    }  
    public static Object getService(String key) {  
        return objMap.get(key);  
    }  
}
```



------

## 二. 建造者模式（Builder Pattern）

将 **复杂对象的构建与表示分离** 开来，使得**同样的构建过程**可以**创建不同的表示**，缺点是可能产生**多余的创建者与构建过程对象**，消耗内存，**不适用于内部建造顺序不稳定，变化复杂的对象**，可能导致需要**创建很多**具体的建造者来实现这些变化。

例子：玩游戏创建角色时的自定义，不同的搭配生成不同的角色。

**四个角色与UML类图**

![img](http://static.zybuluo.com/coder-pig/of2vpynvirgpbfavb656nucb/1.png)

![img](http://static.zybuluo.com/coder-pig/t26cnx7u11ti63xbc7pfpvk1/2.png)

**示例代码**：

Java代码

```java
//产品类  
class Character {  
    private String sex;  
    private String face;  
    private String clothes;  
    void setSex(String sex) { this.sex = sex;}  
    void setFace(String face) { this.face = face; }  
    void setClothes(String clothes) { this.clothes = clothes;}  
    String showMsg() { return "你创建了一个穿着 " + clothes + " 一副 " + face + " 的" + sex + "ヾ(≧▽≦*)o 戳菊狂笑~"; }  
}  
//抽象Builder接口  
interface Builder {  
    void setSex(String sex);  
    void setFace(String face);  
    void setClothes(String clothes);  
    Character build();  
}  
//Builder接口实现类  
class ConcreteBuilder implements Builder {  
    private Character mCharacter = new Character();  
    @Override public void setSex(String sex) { mCharacter.setSex(sex); }  
    @Override public void setFace(String face) { mCharacter.setFace(face); }  
    @Override public void setClothes(String clothes) { mCharacter.setClothes(clothes); }  
    @Override public Character build() {return mCharacter;}  
}  
//装配过程类  
class Director {  
    private Builder mBuilder = null;  
    Director(Builder builder) { this.mBuilder = builder; }  
    Character createCharacter(String sex, String face, String clothes) {  
        this.mBuilder.setSex(sex);  
        this.mBuilder.setFace(face);  
        this.mBuilder.setClothes(clothes);  
        return mBuilder.build();  
    }  
}  
//客户端调用类  
public class Game {  
    public static void main(String[] args) {  
        Builder builder = new ConcreteBuilder();  
        Director director = new Director(builder);  
        Character character =  director.createCharacter("基佬","硬汉脸","死库水");  
        System.out.println(character.showMsg());  
    }  
}
```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/rb886dqnm3j63ni5jh9pvw0y/image_1b6j4ao9d1o2u15ee1s1tlup17e43n.png)

------

## 三. 原型模式（Prototype Pattern）

下面两种场景可以考虑使用原型模式：

- 1.当初始化类对象需要消耗非常多资源，或者说要进行繁琐 
   	的数据准备或者权限，如果想**简化创建**，可以使用原型模式。
- 2.一个对象提供给其他对象访问，而各个调用者可能都需要 
   	修改对象的值，可以考虑使用原型模式克隆多个对象供调用者 
   	使用（**保护性拷贝**）

**三个角色与UML类图**

![img](http://static.zybuluo.com/coder-pig/wzsltwv4k1oe9jxosarexdjw/image_1b9i3b3g2qnaleav54vgheg69.png)

![img](http://static.zybuluo.com/coder-pig/d4mhu2im7dg0ydtzwa1dm09l/image_1b9i3bidnucak1m18oi4ud1f7jm.png)

**Java中 == 与equals的区别**

- **==**，**基本数据类型**(int,long等)，比较**存储的值**是否相等 
   	对比的是**引用类型**，比较的是**所指对象地址**是否相等
- **equals**，不能用于比较基本数据类型，如果**没对equals()方法进行重写**，比较的是**指向的对象地址**，如果想要比较对象内容，**需要自行重写**方法，做相应的判断！！！！String调equals是可以判断内容是否一样，是因为对equals()方法进行了重写，具体可参见源码！

**克隆需要满足的三个条件**

- 1.**x.clone()!=x** ，即 **不是同一对象**
- 2.**x.clone().getClass == x.getClass()**，即 **对象类型一致**
- 3.如果对象obj的equals()方法定义恰当的话，那么 
  **obj.clone().equals(obj) == true**应当是成立的。(推荐，不强制)

**Java中如何使用**

Prototype原型类(想被克隆的类)**实现Cloneable接口**，**重写clone()**方法。

Java代码

1. ConcretePrototype cp1 = new ConcretePrototype();   
2. ConcretePrototype cp2 = (ConcretePrototype)cp1.clone(); 

**需注意**：

- 1.执行克隆方法，**不会调用构造方法**
- 2.克隆会生成的新的**对象成员，但指向的却是同一个内存地址**！
- 3.克隆前后**数据类型一致**！
- 4.克隆的时候，类中**基本数据类型**的属性会**新建**，但是**引用类型**的 
  **只会生成个新的引用变量**，引用变量的地址依旧指向同一个内存地址！

**实现深拷贝的两种套路**：

这种**只新建基本类型数据，不新建引用类型数据**，称为**浅拷贝**，如果连引用类型数据也新建的话，则称为**深拷贝**。

两个套路：

1.**引用类型也实现Cloneable接口**，如果属性的类型也是对象，那么需要一直递归的克隆下去 
 2.**序列化**，属性的类型是引用类型的话，需要实现**Serializable接口**，然后自己写个方法来在里面**完成对象转二进制流与二进制流转对象**的方法，然后返回克隆后的对象！

具体代码见：[3.Prototype Pattern](https://github.com/coder-pig/DesignPatternsExample/tree/master/3.Prototype%20Pattern)

------

## 四.工厂方法模式（Factory Method Pattern）

关于三种工厂模式，其实理解起来非常简单，只是把对象的创建放到一个特定的类中，相比起我们直接new对象，这种套路会写多几个类，但是却拥有更好的扩展性，而且当创建的对象发生改变，可以减少一定的修改量。(想想你在项目中有一个类在多处都new了，现在需要对这个类的构造方法，或者相关参数做些修改，你需要找到每个new这个类的地方进行修改，而如果你把工作都丢给一个工厂类，你可能只需要修改这个类)  另外，简介下这几种工厂模式的区别：

- **简单工厂模式**：最简单的直接把new对象丢到一个工厂类中；
- **工厂方法模式**：对工厂类进行抽象，实现具体工厂类以创建不同对象；
- **抽象工厂模式**：当工厂需要创建多种相互关联或依赖的对象，有两个名 
  **产品等级结构**与**产品族**，具体是什么的自己看~

------

**简单工厂模式的三个角色**：

![img](http://static.zybuluo.com/coder-pig/iriq61yeb6k9bv774iaq16f0/image_1b9i6ev7hjf01o3t1vsfrd21bfb1g.png)

**代码示例**：

Java代码

```
abstract class Tea {  
    public abstract void 加奶茶();  
    public abstract void 加料();  
}  
class YeGuoTea extends Tea{  
    @Override public void 加奶茶() { System.out.println("加了一把奶茶");}  
    @Override public void 加料() {System.out.println("加了一把椰果");}  
}  
class ZhenZhuTea  extends Tea{  
    @Override public void 加奶茶() { System.out.println("加了一把奶茶");}  
    @Override public void 加料() {System.out.println("加了一把珍珠");}  
}  
public class Me {  
    public static Tea makeTea(int type) {  
        System.out.println("==============");  
        Tea tea = type == 0 ? new ZhenZhuTea() : new YeGuoTea();  
        tea.加奶茶();  
        tea.加料();  
        return tea;  
    }  
}  
public class Store {  
    public static void main(String[] args) {  
        for (int i = 0;i < 3;i++) {  
            Tea tea = Me.makeTea(buyTea()); //小猪制作奶茶  
        }  
    }  
    /* 模拟用户下单，0代表要珍珠奶茶，1代表要椰果奶茶 */  
    private static int buyTea() {  
        return new Random().nextInt(2);  
    }  
} 
```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/nx62r78plntzeq6bc4vdakwi/image_1beroc2sau8pqer1heotis10339.png)

------

**工厂方法模式(静态工厂)**：

其实就是在简单工厂模式基础上，把工厂创建不同产品的**内部逻辑**抽取出来，生成一个**抽象工厂**，再创建具体工厂类，生产不同的产品。

**UML类图**

![img](http://static.zybuluo.com/coder-pig/c90sqj8qlh5v1rwf57rghhdn/image_1b9i7lg7f1rrr2kt1fqp14991ii12a.png)

**代码示例**：

Java代码

```
//工厂接口/抽象类  
abstract class MakeTea {  
    abstract Tea 小猪带特效的奶茶制作工艺();  
}  
//工厂实现类1  
class ZhenZhuMakeTea extends MakeTea {  
    @Override  
    Tea 小猪带特效的奶茶制作工艺() {  
        System.out.println("====== 珍珠小弟炮制港式珍珠奶茶 ======");  
        Tea tea = new ZhenZhuTea();  
        tea.加奶();  
        tea.加茶();  
        tea.加料();  
        tea.打包();  
        return tea;  
    }  
}  
//工厂实现类2  
class YeGuoMakeTea extends MakeTea {  
    @Override  
    Tea 小猪带特效的奶茶制作工艺() {  
        System.out.println("====== 椰果小弟炮制日式椰果奶茶 ======");  
        Tea tea = new YeGuoTea();  
        tea.加奶();  
        tea.加茶();  
        tea.加料();  
        tea.打包();  
        return tea;  
    }  
}  
//客户端调用  
public class StoreS {  
    public static void main(String[] args) {  
        //初始化两个小弟  
        ZhenZhuMakeTea zhenzhu = new ZhenZhuMakeTea();  
        YeGuoMakeTea yeguo = new YeGuoMakeTea();  
        for (int i = 0;i < 3;i++) {  
            Tea tea = buyTea() == 0 ? zhenzhu.小猪带特效的奶茶制作工艺()   
                : yeguo.小猪带特效的奶茶制作工艺();  
        }  
    }  
    /* 模拟用户下单，0代表要珍珠奶茶，1代表要椰果奶茶 */  
    private static int buyTea() {  
        return new Random().nextInt(2);  
    }  
}
```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/r0udk32w4d38nwq431h6da0s/image_1b9ia4o3j1f718kbl0v1a6ikud2n.png)

另外还可以通过**反射**简洁生产过程，直接传入产品的**类类型**，生成对应的产品，示例如下：

Java代码

```
abstract class SMakeTea {  
    public abstract <T extends Tea> T 小猪带特效的奶茶制作工艺(Class<T> clz);  
}  
class SMe extends SMakeTea {  
    @Override  
    public <T extends Tea> T 小猪带特效的奶茶制作工艺(Class<T> clz) {  
        System.out.println("==============");  
        Tea tea = null;  
        try {  
            tea = (Tea) Class.forName(clz.getName()).newInstance();  
            tea.加奶();  
            tea.加茶();  
            tea.加料();  
            tea.打包();  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        return (T) tea;  
    }  
}  
public class SStore {  
    public static void main(String[] args) {  
        SMe me = new SMe();  
        me.小猪带特效的奶茶制作工艺(ZhenZhuTea.class);  
        me.小猪带特效的奶茶制作工艺(YeGuoTea.class);  
    }  
}
```



------

## 六. 抽象工厂模式（Abstract Factory Pattern）

**代码示例**

Java代码

```
//抽象产品类1  
abstract class Drink {  
    public abstract void drink();  
}  
//抽象产品类2  
abstract class Snack {  
    public abstract void snack();  
}  
//具体产品类们  
class MilkTea extends Drink {  
    @Override public void drink() { System.out.println("一杯奶茶"); }  
}  
class Juice extends Drink {  
    @Override public void drink() { System.out.println("一杯果汁"); }  
}  
class HandGrab extends Snack {  
    @Override public void snack() { System.out.println("一个手抓饼"); }  
}  
class FishBall extends Snack {  
    @Override public void snack() { System.out.println("一碗鱼蛋"); }  
}  
//抽象工厂类  
abstract class MakeFood {  
    abstract Drink createMakeDrink();  
    abstract Snack createMakeSnack();  
}  
//具体工厂类1  
class FirstXiaoDi extends MakeFood {  
    @Override public Drink createMakeDrink() { return new MilkTea(); }  
    @Override public Snack createMakeSnack() { return new HandGrab(); }  
}  
//具体工厂类2  
class SecondXiaoDi extends MakeFood {  
    @Override public Drink createMakeDrink() { return new Juice(); }  
    @Override public Snack createMakeSnack() { return new FishBall(); }  
}  
//客户端调用  
public class Store {  
    public static void main(String[] args) {  
        //初始化两个小弟  
        MakeFood xiaodi1 = new FirstXiaoDi();  
        MakeFood xiaodi2 = new SecondXiaoDi();  
        for(int i = 0;i < 4 ;i++) {  
            System.out.println("====== 根据订单配餐： ======");  
            Drink drink = buyDrink() == 0 ?  
                xiaodi1.createMakeDrink() : xiaodi2.createMakeDrink();  
            Snack snack = buySnack() == 0 ?   
                xiaodi1.createMakeSnack() : xiaodi2.createMakeSnack();  
            drink.drink();  
            snack.snack();  
        }  
    }  
    /* 模拟用户点饮料，0代表要奶茶，1代表要果汁 */  
    private static int buyDrink() { return new Random().nextInt(2); }  
    /* 模拟用户点小吃，0代表要手抓饼，1代表要鱼蛋 */  
    private static int buySnack() { return new Random().nextInt(2); }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/mso0k3qry85hpmd6791y42w4/image_1b9iavfoj1vfc1qpebgd162a1e3m34.png)

**两个名词**(**产品等级结构**与**产品族**)

- **产品等级结构（继承）**： 
   	比如这里的抽象类是Drink(饮料)，子类有奶茶，果汁，然后抽象饮料与具体饮料构成了一个产品等级结构，抽象饮料是父类，具体饮料是其子类。
- **产品族** 
   	同一工厂生产的，位于**不同产品等级结构的一组产品**，比如这里的奶茶和果汁属于饮料结构的一组产品，而手抓饼和鱼蛋则属于小吃结构的一组产品。

**四个角色与UML类图**

![img](http://static.zybuluo.com/coder-pig/yraos0jqnyve83nub2kac0b0/image_1b9ib3cvm16q1vklqe91c37me93h.png)

![img](http://static.zybuluo.com/coder-pig/bgkqe2awh7zqgqp61aeb15kj/image_1b9ib48j61nimnuk1a5g1v3a1pj13u.png)

抽象工厂模式适用于创建的对象有**多个相互关联或依赖的产品族；**抽象工厂模式隔离具体类的生成，接口与实现分离，增加新的产品族很方便；但是扩展新的产品等级结构麻烦，需要修改抽象工厂，具体工厂类也要更改。

------

## 七. 适配器模式（Adapter Pattern）

两个彼此间没太大关联的类，想进行交互完成某些事情，不想直接去修改各自的接口，可以添加一个**中间类**，让他来协调两个类间的关系，完成相关业务，这种模式就叫适配器模式。

然后分为：**类适配器** 和 **对象适配器** 两种，前者和适配者是**继承**关系，后者与适配者则是**引用**关系。

**对象适配器**支持**传入**一个**被适配器对象**，因此可以做到对多种被适配接口进行适配。而**类适配器直接继承**，**无法动态修改**，所以一般情况下对象适配器使用得更多！（Java不支持多重继承！！！）

![img](http://static.zybuluo.com/coder-pig/1uwlplrvcr48mnl3hsw29wnh/image_1bbo0s0tdqu9jlc1sse1lol1cjk9.png)

![img](http://static.zybuluo.com/coder-pig/d3vkqdz3fo7ox6t1ljmxkige/image_1bbo0suuj1p8krlpq447pe5k4m.png)

对象适配器例子(用得较多)

Java代码

```
/* 目标接口 */  
interface Chinese {  
    void speakChinese(String string);  
}  
/* 需要适配的类 */  
class English {  
    void speakEnglish(String string) { System.out.println("【英语】" + string); }  
}  
/* 适配器 */  
class Translator implements Chinese{  
    private English english = new English();  
    Translator(English english) { this.english = english; }  
    @Override public void speakChinese(String string) { english.speakEnglish(string); }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        Chinese chinese = new Translator(new English());  
        chinese.speakChinese("那你很棒棒哦！");  
    }  
} 

```

**输出结果**：![img](http://static.zybuluo.com/coder-pig/qgjjijggp7ppv1ltx1zd7uwb/image_1bbo15a9b1tk7dte1h4m1khiufu13.png)

类适配器例子

Java代码

```
/* 类适配器 */  
class ClassTranslator extends English implements Chinese {  
    @Override public void speakChinese(String string) { speakEnglish(string); }  
}  
/* 客户端调用 */  
public class ClientC {  
    public static void main(String[] args) {  
        ClassTranslator translator = new ClassTranslator();  
        translator.speakChinese("你也很好啊！");  
    }  
} 
```

**输出结果**：![img](http://static.zybuluo.com/coder-pig/fy4r3fo1opcz5zupxvi2cjb6/image_1bbo17et6100p9p01cntpv6401g.png)

除此之外还有个**缺省适配器模式**的名词，简单点说就是不需要实现接口中提供的所有方法时，先写一个抽象类实现这个接口，然后为每个方法提供一个默认实现（空方法），然后选择性覆盖某些方法实现需求，又称**单接口适配器**模式。

------

## 八.装饰者模式（Decorator Pattern）

动态的给对象添加一些额外的职责，就增加功能来说，装饰者模式比起生成子类更加灵活！就是想替代**多重层继承**的模式。其实就是**一层套一层**。

![img](http://static.zybuluo.com/coder-pig/cc9uh6mugnh06alw3f0pn6x9/image_1bbo234rp18ek1scjsgse7c76c1t.png)

![img](http://static.zybuluo.com/coder-pig/0k3n7nr9tnkxrg563eycjmxj/image_1bbo23jvo1b4011pg1b425rr1q2f2a.png)

**代码示例**

Java代码

```
/* 抽象组件 */  
abstract class Tea {  
    private String name = "茶";  
    public String getName() { return name; }  
    void setName(String name) { this.name = name; }  
    public abstract int price();  
}  
/* 具体组件 */  
class MilkTea extends Tea {  
    MilkTea() { setName("奶茶"); }  
    @Override public int price() { return 5; }  
}  
class LemonTea extends Tea{  
    LemonTea() { setName("柠檬茶"); }  
    @Override public int price() { return 3; }  
}  
/* 抽象装饰类 */  
abstract class Decorator extends Tea{  
    public abstract String getName();  
}  
/* 具体装饰类 */  
class ZhenZhu extends Decorator {  
    Tea tea;  
    ZhenZhu(Tea tea) { this.tea = tea; }  
    @Override public String getName() { return "珍珠" + tea.getName(); }  
    @Override public int price() { return 2 + tea.price(); }  
}  
class YeGuo extends Decorator{  
    //...  
}  
class JinJu extends Decorator{  
    //...  
}  
class HongDou extends Decorator{  
    //...  
}  
/* 客户端调用 */  
public class Store {  
    public static void main(String[] args) {  
        Tea tea1 = new MilkTea();  
        System.out.println("你点的是：" + tea1.getName() + " 价格为：" + tea1.price());  
        Tea tea2 = new LemonTea();  
        tea2 = new JinJu(tea2);  
        System.out.println("你点的是：" + tea2.getName() + " 价格为：" + tea2.price());  
        Tea tea3 = new MilkTea();  
        tea3 = new ZhenZhu(tea3);  
        tea3 = new YeGuo(tea3);  
        tea3 = new HongDou(tea3);  
        tea3 = new JinJu(tea3);  
        System.out.println("你点的是：" + tea3.getName() + " 价格为：" + tea3.price());  
    }  
}

```

**输出结果**： ![img](http://static.zybuluo.com/coder-pig/8puozpv9a7q4wz7gifw7v1iz/image_1b6vt45l5112v1oojbo21vak9bk66.png)

------

## 九.组合模式（Composite Pattern）

**部分-整体**模式，把具有 **相似的一组对象** 当做一个对象处理，用一种 **树状的结构** 来**组合对象**，再提供统一的方法去访问相似的对象，以此忽略掉对象与对象容器间的差别。

![img](http://static.zybuluo.com/coder-pig/x4rsk3royx4k8bhgyumkrxtr/image_1bbo38tjj1qsg66vc8fda9bqb3e.png)

**根节点**，**枝结点**，**叶子结点** 三个名词需要理解，类比上图，根节点是菜单，枝结点是饮料菜单和小吃菜单，叶子结点是奶茶，果汁，手抓饼和鱼蛋！

![img](http://static.zybuluo.com/coder-pig/4c36y482qkoxcr2xk0nnjk3v/image_1bbo3elnu9ca9e80oml2136u3r.png)

**代码示例**

Java代码

```
/* 抽象组件 */  
abstract class AbstractMenu {  
    public abstract void add(AbstractMenu menu);  
    public abstract AbstractMenu get(int index);  
    public abstract String getString();  
}  
/* 容器组件 */  
class Menu extends AbstractMenu {  
    private String name;  
    private String desc;  
    private List<AbstractMenu> menus = new ArrayList<>();  
    Menu(String name, String desc) {  
        this.name = name;  
        this.desc = desc;  
    }  
    @Override public void add(AbstractMenu menu) { menus.add(menu); }  
    @Override public AbstractMenu get(int index) { return menus.get(index); }  
    @Override public String getString() {  
        StringBuilder sb = new StringBuilder("\n【菜单】：" + name + " 信息：" + desc + "\n");  
        for (AbstractMenu menu: menus) { sb.append(menu.getString()).append("\n"); }  
        return sb.toString();  
    }  
}  
/* 叶子组件 */  
class MilkTea extends AbstractMenu {  
    private String name;  
    private String desc;  
    private int price;  
    MilkTea(String name, String desc, int price) {  
        this.name = name;  
        this.desc = desc;  
        this.price = price;  
    }  
    @Override public void add(AbstractMenu menu) { /未使用/ }  
    @Override public AbstractMenu get(int index) { return null; }  
    @Override public String getString() {  
        return " - 【奶茶】* " + name + " 标注：" + desc + " 价格：" + price;  
    }  
}  
class MilkTea extends AbstractMenu {  
    //...  
}  
class HandCake  extends AbstractMenu {  
    //...  
}  
class FishBall  extends AbstractMenu {  
    //...  
}  
/* 客户端调用 */  
public class Store {  
    public static void main(String[] args) {  
        AbstractMenu mainMenu = new Menu("大菜单", "包含所有子菜单");  
        AbstractMenu drinkMenu = new Menu("饮品菜单", "都是喝的");  
        AbstractMenu eatMenu = new Menu("小吃菜单", "都是吃的");  
        AbstractMenu milkTea = new MilkTea("珍珠奶茶", "奶茶+珍珠", 5);  
        AbstractMenu juice = new Juice("鲜榨猕猴桃枝", "无添加即榨", 8);  
        AbstractMenu ball = new FishBall("咖喱鱼蛋", "微辣", 6);  
        AbstractMenu cake = new HandCake("培根手抓饼", "正宗台湾风味", 8);  
        drinkMenu.add(milkTea);  
        drinkMenu.add(juice);  
        eatMenu.add(ball);  
        eatMenu.add(cake);  
        mainMenu.add(drinkMenu);  
        mainMenu.add(eatMenu);  
        System.out.println(mainMenu.getString());  
    }  
}

```

**输出结果**： ![img](http://static.zybuluo.com/coder-pig/bo8kaw5uf2a5kmsbhkppfq4q/image_1bbo6elocjmpmucjqp11rv23648.png)

------

## 十.桥接模式（Bridge Pattern）

基于**单一职责原则**，如果系统中的类存在**多个变化的维度**，通过该模式可以将这几个**维度分离**出来， 然后进行独立扩展。这些分离开来的维度，通过在**抽象层**持有其他维度的引用来进行关联，就好像在两个维度间搭了桥一样，所以叫桥接模式。

![img](http://static.zybuluo.com/coder-pig/qssmttgymba1argjked3e3zi/image_1bbt7qo1t1fpqjlnltc1icg4vu9.png)

**代码示例**(变化的三个维度：配餐，扒类)

Java代码

```
/* 抽象部分 */  
abstract class Rations {  
    abstract String rations();  
}  
/* 扩展抽象部分 */  
class Rice extends Rations {  
    @Override public String rations() { return "饭"; }  
}  
class Spaghetti extends Rations {  
    @Override public String rations() { return "意粉"; }  
}  
/* 实现部分 */  
abstract class Steak {  
    Rations rations;  
    Steak(Rations rations) { this.rations = rations; }  
    abstract String sale();  
}  
/* 具体实现部分 */  
class BeefSteak extends Steak{  
    BeefSteak(Rations rations) { super(rations); }  
    @Override public String sale() { return "牛扒"+ (rations == null ? "" : rations.rations()); }  
}  
class PorkSteak extends Steak {  
    PorkSteak(Rations rations) { super(rations); }  
    @Override public String sale() { return "猪扒"+ (rations == null ? "" : rations.rations()); }  
}  
/* 客户端调用 */  
public class Restaurant {  
    public static void main(String[] args) {  
        System.out.println("\n" + new Date(System.currentTimeMillis()));  
        System.out.println("==================");  
        Steak steak1 = new BeefSteak(new Rice());  
        System.out.println("卖出了一份：" + steak1.sale());  
        Steak steak2 = new PorkSteak(new Spaghetti());  
        System.out.println("卖出了一份：" + steak2.sale());  
        Steak steak3 = new PorkSteak(null);  
        System.out.println("卖出了一份：" + steak3.sale());  
         System.out.println("==================");  
} 

```

**输出结果**： ![img](http://static.zybuluo.com/coder-pig/xdgvafrt2hdqtdu2kpwqou9y/image_1bbtb5u7inc51o5j1nohsdkflm.png)

------

## 十一.外观模式（Facade Pattern）

要求一个子系统的外部与内部的通信必须通过一个统一的对象进行，外观模式提供一个高层次的接口，使得子系统更易于使用。(其实就是**封装**，用于**解决类与类间的依赖关系**，比如本来是：玩家依赖于：Q，A，E，R等键位对象，现在变成只依赖与脚本对象从而降低了类间的耦合度。)

![img](http://static.zybuluo.com/coder-pig/r58s0ihsrgsyf9jwci90w5b2/image_1bbtbe2ef1obm18p7i9n1b4414q99.png)

**代码示例**

Java代码

```
/* 子系统 */  
class A {  
    String a() { return "A"; }  
}  
class Q { /* ... */ }  
class Space { /* ... */ }  
class LeftClick { /* ... */ }  
/* 外观类 */  
class JiaoBen {  
    A a;  
    Q q;  
    LeftClick leftClick;  
    Space space;  
    JiaoBen() {  
        a = new A();  
        leftClick = new LeftClick();  
        q = new Q();  
        space = new Space();  
    }  
    String 锐雯() {  
        StringBuilder sb = new StringBuilder();  
        sb.append(q.q()).append(" + ");  
        sb.append(space.space()).append(" + ");  
        sb.append(a.a()).append(" + ");  
        sb.append(leftClick.leftClick()).append(" + ");  
        sb.append(q.q()).append(" + ");  
        sb.append(space.space()).append(" + ");  
        sb.append(a.a()).append(" + ");  
        sb.append(leftClick.leftClick()).append(" + ");  
        sb.append(q.q()).append(" + ");  
        sb.append(space.space()).append(" + ");  
        sb.append(a.a()).append(" + ");  
        sb.append(leftClick.leftClick()).append("\n");  
        return sb.toString();  
    }  
}  
/* 客户端调用 */  
public class XLoLer {  
    public static void main(String[] args) {  
        JiaoBen jiaoBen = new JiaoBen();  
        System.out.println("=== 锐雯一键光速QA ===\n" + jiaoBen.锐雯());  
    }  
}

```

**输出结果**：![img](http://static.zybuluo.com/coder-pig/4448sefy9cphbibee3sb7uit/image_1bbtbrge51atb1nos1utf10o01ldbm.png)

------

## 十二. 享元模式（Flyweight Pattern）

当存在**多个相同对象**时，可以使用享元模式减少相同对象创建引起的内存消耗，提高程序性能。说到共享，还分**内部状态与外部状态**。

**内部状态**：**固定不变可共享**的的部分，存储在**享元对象内部**，比如例子中的**花色** 
**外部状态**：**可变不可共享**的部分，一般由**客户端传入享元对象内部**，比如例子里的**大小**。

![img](http://static.zybuluo.com/coder-pig/svruhckkq8wm306nzxe7tx02/image_1bbt6cq7p1btg1mr5mh9bvq4hq9.png)

**示例代码**

Java代码

```
/* 抽象对象的父类 */  
abstract class Card {  
    abstract void showCard(String num);  //传入外部状态参数，大小  
}  
/* 具体享元对象 */  
public class SpadeCard extends Card{  
    public SpadeCard() { super(); }  
    @Override public void showCard(String num) { System.out.println("黑桃：" + num); }  
}  
public class HeartCard extends Card { /* ... */ }  
public class ClubCard extends Card { /* ... */ }  
public class DiamondCard extends Card { /* ... */ }  
/* 享元工厂 */  
public class PokerFactory {  
    static final int Spade = 0;  //黑桃  
    static final int Heart  = 1; //红桃  
    static final int Club  = 2; //梅花  
    static final int Diamond  = 3;   //方块  
    public static Map<Integer, Card> pokers = new HashMap<>();  
    public static Card getPoker(int color) {  
        if (pokers.containsKey(color)) {  
            System.out.print("对象已存在，对象复用...");  
            return pokers.get(color);  
        } else {  
            System.out.print("对象不存在，新建对象...");  
            Card card;  
            switch (color) {  
                case Spade: card = new SpadeCard(); break;  
                case Heart: card = new HeartCard(); break;  
                case Club: card = new ClubCard(); break;  
                case Diamond: card = new DiamondCard(); break;  
                default: card = new SpadeCard(); break;  
            }  
            pokers.put(color,card);  
            return card;  
        }  
    }  
/* 客户端调用 */  
public class Player {  
    public static void main(String[] args) {  
        for (int k = 0; k < 10; k ++){  
            Card card = null;  
            //随机花色  
            switch ((int)(Math.random()*4)) {  
                case 0: card = PokerFactory.getPoker(PokerFactory.Spade); break;  
                case 1: card = PokerFactory.getPoker(PokerFactory.Heart); break;  
                case 2: card = PokerFactory.getPoker(PokerFactory.Club); break;  
                case 3: card = PokerFactory.getPoker(PokerFactory.Diamond); break;  
            }  
            if(card != null) {  
                //随机大小  
                int num = (int)(Math.random()*13 + 1);  
                switch (num) {  
                    case 11: card.showCard("J"); break;  
                    case 12: card.showCard("Q"); break;  
                    case 13: card.showCard("K"); break;  
                    default: card.showCard(num+""); break;  
                }  
            }  
        }  
    }  
} 

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/xxv55v1qi1ggx2o2r855ardu/image_1bbt70nee15rosfpe5a1t36feom.png)

------

## 十三.代理模式（Proxy Pattern）

**引用代理对象的方式来访问目标对象**，简单点说，就是在调用某个对象时加了一层，然后你可以在这一层做些手脚，比如权限控制，或者附加操作等。

![img](http://static.zybuluo.com/coder-pig/wpevexy3y271fh5b9344hz7t/image_1bbtc9vmq16971va81tbv1gldvid9.png)

**代码示例**

Java代码

```
/* 抽象对象 */  
public interface FetchGoods {  
    public void fetchShoes();  
}  
/* 真实对象 */  
public class Custom implements FetchGoods{  
    @Override public void fetchShoes() { System.out.println("拿货"); }  
}  
/* 代理对象 */  
public class Agent implements FetchGoods{  
    @Override public void fetchShoes() {  
        Custom custom = new Custom();  
        custom.fetchShoes();  
        this.callCustom();  
    }  
    public void callCustom() { System.out.println("通知顾客过来取件！"); }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        Agent agent = new Agent();  
        agent.fetchShoes();  
    }  
} 

```

**输出结果**：![img](http://static.zybuluo.com/coder-pig/gxby0y60rhlr2aezigxveujw/image_1bbtcfq0h1h0ep951ielme7d89m.png)

------

## 十四.策略模式（Strategy Pattern）

定义一系列的算法，把每个**算法封装**起来，并使得他们可以**相互替换**，**让算法独立于使用它的客户而变化**。 一般用来替换if-else，个人感觉是面向过程与面向对象思想的过渡。

![img](http://static.zybuluo.com/coder-pig/hlh3kxzgva02ath1p4ajt8px/image_1besv47qanid1ug9hhs880gaj9.png)

**代码示例**：(面向过程与面向对象的简易计算器)

**面向过程简易计算器**

Java代码

```
public class Calculator {  
    public static void main(String[] args) {  
        System.out.println("计算：1 + 1 = " + compute("+", 1, 1));  
        System.out.println("计算：1 - 1 = " + compute("-", 1, 1));  
        System.out.println("计算：1 * 1 = " + compute("*", 1, 1));  
        System.out.println("计算：1 ? 1 = " + compute("/", 1, 1));  
    }  
    public static float compute(String operator, int first, int second) {  
        switch (operator) {  
            case "+": return first + second;  
            case "-": return first - second;  
            case "*": return first * second;  
            case "/": return first / second;  
            default: return 0.0f;  
        }  
    }  
}

```

**面向对象(策略模式)简易计算器**

Java代码

```
/* 抽象策略类 */  
public interface Compute {  
    String compute(int first, int second);  
}  
/* 具体策略类 */  
public class Add implements Compute{  
    @Override public String compute(int first, int second) {  
        return "输出结果：" + first + " + " + second + " = " + (first + second);  
    }  
}  
public class Sub implements Compute{ /* ... */ }  
public class Mul implements Compute{ /* ... */ }  
public class Div implements Compute{ /* ... */ }  
/* 上下文环境类 */  
public class Context {  
    private Compute compute;  
    public Context() { compute = new Add(); }  
    public void setCompute(Compute compute) { this.compute = compute; }  
    public void calc(int first, int second) {   
        System.out.println(compute.compute(first, second));   
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        Context context = new Context();  
        context.setCompute(new Add());  
        context.calc(1,2);  
        context.setCompute(new Sub());  
        context.calc(3,4);  
        context.setCompute(new Mul());  
        context.calc(5,6);  
        context.setCompute(new Div());  
        context.calc(7,8);  
    }  
}  

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/sw7317xkctylemmmhcidxr49/image_1bev1mn87181u1opl14a918f01thnm.png)        ![img](http://static.zybuluo.com/coder-pig/q5eoiypyulnxubmflczmf0ub/image_1bev1m733j0c7v61bdvca6vv09.png)

------

## 十五.观察者模式(Observer Pattern)

定义对象见的一种**一对多**的**依赖关系**，当一个对象的**状态发生改变时**，所有依赖于它的对象都得到**通知并且自动更新**。

当对象间存在**一对多关系**的时候，使用观察者模式，当一个对象(**被观察者**)被修改时，会自动通知它的依赖对象们(**观察者**)。

这个模式基本都应该用过和听说过，关于概念就不多解释了，有兴趣看原文去~

![img](http://static.zybuluo.com/coder-pig/39bgfz59zjedycjehdm25gqr/image_1bf73jtrbi3io0v1mpv1jvguuv9.png)

![img](http://static.zybuluo.com/coder-pig/fyej7l2jyb5g92vnj9c7w0i0/image_1bf73l0ah1frq1u6cam21ths11vpm.png)

**代码示例**：

Java代码

```
/* 抽象观察者 —— 昆虫类 */  
public interface Insect {  
    void work();  
    void unWork();  
}  
/* 具体观察者 —— 蜜蜂类 */  
public class Bee implements Insect{  
    private int bId;    //蜜蜂编号  
    public Bee(int bId) { this.bId = bId; }  
    @Override public void work() { System.out.println("蜜蜂"+ bId + "采蜜"); }  
    @Override public void unWork() { System.out.println("蜜蜂"+ bId + "回巢"); }  
}  
/* 抽象被观察者（注册，移除，通知观察者） —— 植物类 */  
public interface Plant {  
    public void registerInsect(Insect insect);  
    public void unregisterInsect(Insect insect);  
    public void notifyInsect(boolean isOpen);  
}  
/* 具体被观察者（定义一个集合存储观察者，实现相关方法） —— 花朵类 */  
public class Flower implements Plant {  
    private boolean state;  
    private List<Insect> insects = new ArrayList<>();  
    public boolean isState() { return state; }  
    @Override public void registerInsect(Insect insect) { insects.add(insect); }  
    @Override public void unregisterInsect(Insect insect) { insects.remove(insect); }  
    @Override public void notifyInsect(boolean isOpen) {  
        state = isOpen;  
        if (state) {  
            System.out.println("花开");  
            for (Insect insect : insects) { insect.work(); }  
        } else {  
            System.out.println("花闭");  
            for (Insect insect : insects) { insect.unWork(); }  
        }  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        //创建被观察者  
        Plant flower = new Flower();  
        //创建三个观察者  
        Insect bee1 = new Bee(1);  
        Insect bee2 = new Bee(2);  
        Insect bee3 = new Bee(3);  
        //注册观察者  
        flower.registerInsect(bee1);  
        flower.registerInsect(bee2);  
        flower.registerInsect(bee3);  
        //改变被观察者状态，先开后合  
        flower.notifyInsect(true);  
        System.out.println("=== 太阳从东边到西边... ===");  
        flower.notifyInsect(false);  
        //最后解除注册  
        flower.unregisterInsect(bee1);  
        flower.unregisterInsect(bee2);  
        flower.unregisterInsect(bee3);  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/jz9n96dplt8hz1t1r2fwiobe/image_1bf74kfjckdp1dvg1g9g3p1it613.png)

------

**观察者模式的推与拉**

**推方式**

被观察者对象向观察者推送主题的详细信息，**不管观察者是否需要**，推送的信息通常是**被观察者对象的全部或部分数据**。(上面的例子就是推方式)

**拉方式**

被观察者对象再通知观察者时，**只传递少量信息**。如果**观察者需要更****详细的信息**，可以**主动到被观察者中获取**，相当于观察者从被观察者中拉取数据。一般的套路是：**把主题对象自身通过update()方法传递给观察者**，然后观察者在需要获取的时候，**通过这个引用来获取**。

**代码示例**：

微信订阅了某个公众号，当有更新的时候会推送提醒，收到提醒后，我们需要进入公众号然后点击对应信息查看详细内容。

Java代码

```
/* 抽象观察者 —— 用户 */  
public interface User {  
    public void update(OfficialAccount account);  
}  
/* 具体观察者 —— Android读者 */  
public class AndroidDev implements User {  
    @Override public void update(OfficialAccount account) {  
        System.out.println("读者查看公众号更新信息：" +  ((CoderPig)account).getMsg());  
    }  
}  
/* 抽象被观察者 —— 公众号 */  
public abstract class OfficialAccount {  
    private List<User> userList = new ArrayList<>();  
    public void registerUser(User user) { userList.add(user); }  
    public void unregisterUser(User user) { userList.remove(user); }  
    public void notifyUse() {  
        for (User user: userList) {  
            user.update(this);  
        }  
    }  
}  
/* 具体被观察者 —— CoderPig公众号 */  
public class CoderPig extends OfficialAccount {  
    private String msg; //更新的文章  
    public String getMsg() { return msg; }  
    public void update(String msg) {  
        this.msg = msg;  
        System.out.println("公众号更新了文章：" + msg);  
        this.notifyUse();   //通知用户有更新  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        OfficialAccount account = new CoderPig();  
        User user = new AndroidDev();  
        account.registerUser(user);  
        ((CoderPig)account).update("《观察者模式》");  
        account.unregisterUser(user);  
    }  
} 

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/dhrsvd3evd9n88d1bnc7310y/image_1bajj7gjm17vqbr13dhl8n1nd56p.png)

------

**Java中对观察者模式的支持(在Java.util中)**

**口诀**：**被观察者实现继承Observable**，**观察者实现Observer接口，**然后有个很关键的地方：当通知变化的时候，需要调用**setChange()**方法！！！！ **不用自己另外去写抽象观察者或抽象被观察者类**，直接继承就能玩了，另外有一点要注意的是：Java内置的观察者模式**通知**多个观察者的**顺序****不是固定**的，如果对通知顺序有所依赖的话，还是得自己实现观察者模式！

**代码示例**：

Java代码

```
/* 具体观察者 */  
public class AndroidDev implements Observer{  
    @Override public void update(Observable o, Object object) {  
        System.out.println("收到公众号更新信息：" + object);  
    }  
}  
/* 具体被观察者 */  
public class CoderPig extends Observable {  
    private String msg;  
    public String getMsg() { return msg; }  
    public void update(String msg) {  
        this.msg = msg;  
        System.out.println("公众号更新了文章：" + msg);  
        this.setChanged();  //这句话必不可少，通知改变  
        this.notifyObservers(this.msg); //这里用推的方式  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        CoderPig coderPig = new CoderPig();  
        AndroidDev dev = new AndroidDev();  
        coderPig.addObserver(dev);  
        coderPig.update("Java中对观察者模式的支持~");  
        coderPig.deleteObserver(dev);  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/6oq6y5q7jiwjj57p7uw5mb9h/image_1bajkl3t816nnpo6md4u6g1og89k.png)

------

## 十六.迭代器模式(Iterator Pattern)

提供一种方法**顺序访问**一个**容器(聚合)对象**中**各个元素**，而又**不暴露**该对象的**内部表示**。

从上面的定义可以知道，这个模式的使用场景：**容器对象中的元素迭代访问**

**四个角色**

![img](http://static.zybuluo.com/coder-pig/1zao4nky0voqxjse24psxdig/image_1bfdtdukc1p341o4cibb2u01pp0p.png)

**UML类图**

![img](http://static.zybuluo.com/coder-pig/imh3juaavhjiplisxwd4wk5a/image_1bar4vkf5eb9pp916b81fbuk662m.png)

**代码示例**：

Java代码

```
/* 集合中的元素 */  
public class Song {  
    private String name;  
    private String singer;  
    public Song(String name, String singer) {  
        this.name = name;  
        this.singer = singer;  
    }  
    /* getter和setter方法 */  
    @Override public String toString() {   
        return "【歌名】" + name + " - " + singer;   
    }  
}  
/* 迭代器角色，第一项，下一个，判断是否能下一个，获取当前项。 */  
public interface Iterator {  
    Song first();  
    Song next();  
    boolean hashNext();  
    Song currentItem();  
}  
/* 抽象容器，定义一个生成迭代器的方法 */  
interface SongList {  
    Iterator getIterator();  
}  
/* 具体容器，继承抽象容器，并定义一个具体迭代器内部类 */  
public class MyStoryList implements SongList{  
    private List<Song> list = new ArrayList<>();  
    public MyStoryList(List<Song> list) {  
        this.list = list;  
    }  
    @Override public Iterator getIterator() {  
        return new SongListIterator();  
    }  
    private class SongListIterator implements Iterator {  
        private int cursor;  
        @Override public Song first() {  
            cursor = 0;  
            return list.get(cursor);  
        }  
        @Override public Song next() {  
            Song song = null;  
            cursor++;  
            if(hashNext()) {  
                song = list.get(cursor);  
            }  
            return song;  
        }  
        @Override public boolean hashNext() {  
            return !(cursor == list.size());  
        }  
        @Override public Song currentItem() {  
            return list.get(cursor);  
        }  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        List<Song> list = new ArrayList<>();  
        list.add(new Song("空白格","杨宗纬"));  
        list.add(new Song("那时候的我","刘惜君"));  
        list.add(new Song("黑泽明","陈奕迅"));  
        list.add(new Song("今天只做一件事","陈奕迅"));  
        list.add(new Song("童话镇","陈一发儿"));  
        MyStoryList songList = new MyStoryList(list);  
        Iterator iterator = songList.getIterator();  
        while (iterator.hashNext()) {  
            System.out.println(iterator.currentItem().toString());  
            iterator.next();  
        }  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/8f9zrttfknck3nz3qkkplvey/image_1bfdu1g7u1so5a1mjgg1tffokp1t.png)

PS：由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。

------

## 十七.命令模式(Command Pattern)

**使用场景**：**行为请求者**与**行为实现者**的**解耦**

**定义**：将一个请求封装成一个对象，从而可用不同的请求对客户端参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

![img](http://static.zybuluo.com/coder-pig/chpgv8a6luldku78qrvlrnww/image_1bfdujs131od1cpo141313p11bel2a.png)

![img](http://static.zybuluo.com/coder-pig/3fr91j7ur4z2arfx2vr4vt1r/image_1bfduk94c14pn1j5o1dft1nrlum52n.png)

**代码示例**：

Java代码

```
/* 元素对象  */  
public class Story {  
    private String sName;  
    private String sUrl;  
    public Story(String sName, String sUrl) {  
        this.sName = sName;  
        this.sUrl = sUrl;  
    }  
    /getter和setter方法/  
}  
/* 命令执行者 */  
public class StoryPlayer {  
    private int cursor = 0; //当前播放项  
    private int pauseCursor = -1;   //暂停播放项  
    private List<Story> playList = new ArrayList<>();   //播放列表  
    public void setPlayList(List<Story> list) {  
        this.playList = list;  
        cursor = 0;  
        System.out.println("更新播放列表...");  
    }  
    public void play() { /* 播放 */ }  
    public void play(int cursor) { /* 根据游标播放 */ }  
    public void next() { /* 下一首 */ }  
    public void pre() { /* 上一首 */ }  
    public void pause() { /* 暂停 */ }  
}  
/* 抽象命令接口 */  
public interface Command { void execute(); }  
/* 具体命令类 */  
public class SetListCommand implements Command {  
    private StoryPlayer mPlayer;  
    private List<Story> mList = new ArrayList<>();  
    public SetListCommand(StoryPlayer mPlayer) { this.mPlayer = mPlayer; }  
    @Override public void execute() { mPlayer.setPlayList(mList); }  
    public void setPlayList(List<Story> list) { this.mList = list; }  
}  
public class PlayCommand implements Command {  
    private StoryPlayer mPlayer;  
    public PlayCommand(StoryPlayer mPlayer) { this.mPlayer = mPlayer; }  
    @Override public void execute() { mPlayer.play(); }  
}  
public class PlayCommand implements Command { /* ... */ }  
public class PauseCommand implements Command { /* ... */ }  
public class NextCommand implements Command { /* ... */ }  
public class PreCommand implements Command { /* ... */ }  
/* 请求者类，调用命令对象执行具体操作 */  
public class Invoker {  
    private SetListCommand setListCommand;  
    private PlayCommand playCommand;  
    private PauseCommand pauseCommand;  
    private NextCommand nextCommand;  
    private PreCommand preCommand;  
    public void setSetListCommand(SetListCommand setListCommand) {  
        this.setListCommand = setListCommand;  
    }  
    public void setPlayCommand(PlayCommand playCommand) {  
        this.playCommand = playCommand;  
    }  
    public void setPauseCommand(PauseCommand pauseCommand) {  
        this.pauseCommand = pauseCommand;  
    }  
    public void setNextCommand(NextCommand nextCommand) {  
        this.nextCommand = nextCommand;  
    }  
    public void setPreCommand(PreCommand preCommand) {  
        this.preCommand = preCommand;  
    }  
    /* 设置播放列表 */  
    public void setPlayList(List<Story> list) {   
        setListCommand.setPlayList(list);  
        setListCommand.execute();  
    }  
    public void play() { playCommand.execute(); } /* 播放 */  
    public void pause() { pauseCommand.execute(); } /* 暂停 */  
    public void next() { nextCommand.execute(); }   /* 下一首 */  
    public void pre() { preCommand.execute(); }    /* 上一首 */  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        //实例化播放列表  
        List<Story> mList = new ArrayList<>();  
        mList.add(new Story("白雪公主",""));  
        mList.add(new Story("青蛙的愿望",""));  
        mList.add(new Story("驴和妈",""));  
        mList.add(new Story("小青蛙的烦恼",""));  
        mList.add(new Story("三字经",""));  
        //实例化接收者  
        StoryPlayer mPlayer = new StoryPlayer();  
        //实例化命令对象  
        Command setListCommand = new SetListCommand(mPlayer);  
        Command playCommand = new PlayCommand(mPlayer);  
        Command pauseCommand = new PauseCommand(mPlayer);  
        Command nextCommand = new NextCommand(mPlayer);  
        Command preCommand = new PreCommand(mPlayer);  
        //实例化请求者  
        Invoker invoker = new Invoker();  
        invoker.setSetListCommand((SetListCommand) setListCommand);  
        invoker.setPlayList(mList);  
        invoker.setPlayCommand((PlayCommand) playCommand);  
        invoker.setPauseCommand((PauseCommand) pauseCommand);  
        invoker.setNextCommand((NextCommand) nextCommand);  
        invoker.setPreCommand((PreCommand) preCommand);  
        //测试调用  
        invoker.play();  
        invoker.next();  
        invoker.next();  
        invoker.next();  
        invoker.next();  
        invoker.next();  
        invoker.pause();  
        invoker.play();  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/vcc5jxfsf94mt3qes9k26x9y/image_1bfe031v51edrj30h2o1ia0klr3b.png)

------

## 十八.备忘录模式(Memento Pattern)

简单点说，就是**存档**，**保存一个对象在某个时刻的状态或部分状态**，**在未来某个时段需要时**，**将其还原到原来记录状态的模式**

![img](http://static.zybuluo.com/coder-pig/ir5sqycrhype4amfqtiuxpzt/image_1bfe0fa8n4purkj7314fl1uvh45.png)

![img](http://static.zybuluo.com/coder-pig/4uivq03fe2s2ppkiymka1ugq/image_1bfe0fqq719l818tligd1350g8v4i.png)

**代码示例**：

Java代码

```
/* 备忘录角色 —— 存档类*/  
public class Memento {  
    private int hp;  
    private int mp;  
    private int money;  
    public Memento(int hp, int mp, int money) {  
        this.hp = hp;  
        this.mp = mp;  
        this.money = money;  
    }  
    /getter和setter方法/  
}  
/* 发起人角色 —— 角色类，属性定义，定义保存与恢复自身状态的方法 */  
public class Character {  
    private int hp;  
    private int mp;  
    private int money;  
    public Character(int hp, int mp, int money) {  
        this.hp = hp;  
        this.mp = mp;  
        this.money = money;  
    }  
    /getter和setter方法/  
    public void showMsg() {  
        System.out.println("当前状态：| HP：" + hp + " | MP：" + mp + " | 金钱：" + money + "\n");  
    }  
    //创建一个备忘录，保存当前自身状态  
    public Memento save() { return new Memento(hp, mp, money); }  
    //传入一个备忘录对象，恢复内部状态  
    public void restore(Memento memento) {  
        this.hp = memento.getHp();  
        this.mp = memento.getMp();  
        this.money = memento.getMoney();  
    }  
}  
/* 备忘录管理者角色 —— 只负责备忘录对象的传递！ 多个存档的话可用集合存，根据索引取*/  
public class Caretaker {  
    private Memento memento;  
    public Memento getMemento() { return memento; }  
    public void setMemento(Memento memento) { this.memento = memento; }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        Caretaker caretaker= new Caretaker();  
        Character character = new Character(2000,1000,500);  
        //存档  
        System.out.println("=== 存档中... ===");  
        character.showMsg();  
        caretaker.setMemento(character.save());  
        System.out.println("=== 单挑Boss，不敌，金钱扣除一半... ===");  
        character.setHp(0);  
        character.setHp(0);  
        character.setHp(250);  
        character.showMsg();  
        //读档  
        System.out.println("=== 读取存档中... ===");  
        character.restore(caretaker.getMemento());  
        character.showMsg();  
    }  
}

```



------

## 十九.中介者模式(Mediator Pattern)

用一个中介对象来**封装**一系列的对象**交互**，使得各对象不需要显式的相互引用， 从而使其耦合松散，而且可以独立的改变他们之间的交互。

中介者持有所有同事引用，然后在里面做一些逻辑操作，然后每个同事类持有中介者引用，依次完成交互。

这里的话需要与前面的外观模式，代理模式进行区分！

**外观模式**：**结构型**，对子系统提供统一的接口，**单向**，所有请求都委托子系统完成，**树型** 
**代理模式**：**结构型**，**引用代理对象的方式来访问目标对象**，**单向** 
**中介者模式**：**行为型**，用一个**中介对象**来**封装**一系列同事对象的**交互行为**，**双向**，**一对多星型**

![img](http://static.zybuluo.com/coder-pig/duzvmyoc4rgpicu36ml4eyj0/image_1bfeb7ks6t1vdgk1l4i160aim64v.png)

**UML类图**

![img](http://static.zybuluo.com/coder-pig/h4c68nfvjuq68uk0knotw95p/image_1bfeb8al51ej6ngesab1447qcr5c.png)

**代码示例**：

Java代码

```
/* 抽象中介类，有连接同事进行交互的方法*/  
public abstract class Mediator {  
    abstract void contact(People people, String msg);  
}  
/* 抽象同事类，相关属性，还有一个中介类的引用，因为所有同事都知道中介*/  
public abstract class People {  
    protected String name;  
    protected Mediator mediator;    //每个人都知道中介  
    public People(String name, Mediator mediator) {  
        this.name = name;  
        this.mediator = mediator;  
    }  
}  
/* 具体同事类，这里是房东和房客*/  
public class Landlord extends People {  
    public Landlord(String name, Mediator mediator) { super(name, mediator); }  
    public void contact(String msg) { mediator.contact(this, msg); }  
    public void getMessage(String msg) { System.out.println("【房东】" + name + "：" + msg); }  
}  
public class Tenant extends People {  
    public Tenant(String name, Mediator mediator) { super(name, mediator); }  
    public void contact(String msg) { mediator.contact(this, msg); }  
    public void getMessage(String msg) { System.out.println("【房客】" + name + "：" + msg); }  
}  
/* 具体中介类，中介者知道所有的同事，实现交互方法时对调用者进行判断 
 实现对应的逻辑，比如这里的信息显示*/  
public class HouseMediator extends Mediator {  
    //中介者知道所有同事  
    private Landlord landlord;  
    private Tenant tenant;  
    public Landlord getLandlord() { return landlord; }  
    public void setLandlord(Landlord landlord) { this.landlord = landlord; }  
    public Tenant getTenant() { return tenant; }  
    public void setTenant(Tenant tenant) { this.tenant = tenant; }  
    @Override void contact(People people, String msg) {  
        if(people == tenant) tenant.getMessage(msg);  
        else landlord.getMessage(msg);  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        //实例化中介者  
        HouseMediator mediator = new HouseMediator();  
        //实例化同事对象，传入中介者实例  
        Landlord landlord = new Landlord("包租婆",mediator);  
        Tenant tenant = new Tenant("小猪",mediator);  
        //为中介者传入同事实例  
        mediator.setLandlord(landlord);  
        mediator.setTenant(tenant);  
        //调用  
        landlord.contact("单间500一个月，有兴趣吗？");  
        tenant.contact("热水器，空调，网线有吗？");  
        landlord.contact("都有。");  
        tenant.contact("好吧，我租了。");  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/1rot45wwcg9u452yhuw4nyrs/image_1bfec6i47jsh1sj58dm1iah1tk15p.png)

------

## 二十.解释器模式(Interpreter Pattern)

用得比较少的一种模式，定义也比较枯涩难懂，实在不理解可以先看代码：

给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器，客户端可以使用这个解释器来解释这个语言中的句子。

**个人理解**：

定义了一套简单语法，**每个终结符**都**有一个对应的值**存起来了，然后当你**输了一串终结符**，最后**解释**能得**出一个正确结果**。

![img](http://static.zybuluo.com/coder-pig/72o7hivsn7xcyzqa93lpljts/image_1bfecv2uh1drd1vvu1r071oet1ev566.png)

![img](http://static.zybuluo.com/coder-pig/8b2pzog6po44t3xd35y2118i/image_1bfecvein1nf4dgc152m3r1a106j.png)

**代码示例**：**能够解释加减法的解释器**

Java代码

```
/* 抽象表达式 */  
public abstract class Expression {  
    public abstract int interpret(Context context);  
    @Override public abstract String toString();  
}  
/* 非终结符表达式 —— 加法和减法 */  
public class PlusExpression extends Expression{  
    private Expression leftExpression;  
    private Expression rightExpression;  
    public PlusExpression(Expression leftExpression, Expression rightExpression) {  
        this.leftExpression = leftExpression;  
        this.rightExpression = rightExpression;  
    }  
    @Override public int interpret(Context context) {  
        return leftExpression.interpret(context) + rightExpression.interpret(context);  
    }  
    @Override public String toString() {  
        return leftExpression.toString() + " + " + rightExpression.toString();  
    }  
}  
public class MinusExpression extends Expression{ /* 和减法类似 */ }  
/* 终结符表达式 —— 常量与变量*/  
public class ConstantExpression extends Expression {  
    private int value;  
    public ConstantExpression(int value) { this.value = value; }  
    @Override public int interpret(Context context) { return value; }  
    @Override public String toString() { return Integer.toString(value); }  
}  
public class VariableExpression extends Expression {  
    private String name;  
    public VariableExpression(String name) { this.name = name; }  
    @Override public int interpret(Context context) { return context.lookup(this); }  
    @Override public String toString() { return name; }  
}  
/* 上下文环境 —— 用Map存放各个终结符对应的具体值*/  
public class Context {  
    private Map<Expression, Integer> map = new HashMap<>();  
    public void addExpression(Expression expression, int value) { map.put(expression, value); }  
    public int lookup(Expression expression) { return map.get(expression); }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        Context context = new Context();  
        VariableExpression a = new VariableExpression("a");  
        VariableExpression b = new VariableExpression("b");  
        ConstantExpression c = new ConstantExpression(6);  
        context.addExpression(a, 2);  
        context.addExpression(b, 3);  
        Expression expression = new PlusExpression(new PlusExpression(a,b),new MinusExpression(a,c));  
        System.out.println(expression.toString() + " = " + expression.interpret(context));  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/vknr60lqs6ufpdb5fohvazws/image_1bbksspqu1msk848pmp141gtqp3h.png)

------

## 二十一.访问者模式(Visitor Pattern)

**核心**：**数据结构不变**，**操作可变**，结构与操作解耦的一种模式。 
**定义**：封装一些作用域某种数据结构中的个元素的操作，在**不改变**这个 
**数据结构**的前提下，**定义**作用于这些元素的**新的操作**。

![img](http://static.zybuluo.com/coder-pig/balwy84npiq76qu650nv237h/image_1bfeg77fs1sk41a1111n528l1ih377.png)

![img](http://static.zybuluo.com/coder-pig/9xgthl6rrc1zmid0gnhdlplb/image_1bfeg7i851nab1qk8udu1ikn1fmd7k.png)

**代码示例**：

Java代码

```
/* 元素角色 —— 游戏机接口，有一个传入访问者实例的方法 */  
public interface Machine {  
    public void accept(Player player);  
}  
/* 具体元素 —— 投篮机，跳舞机和开车 */  
public class Shooting implements Machine {  
    @Override public void accept(Player player) { player.visit(this); }  
    public String feature() { return "投篮机"; }  
}  
public class Dancing implements Machine { /.../ }  
public class Driving implements Machine { /.../ }  
/* 抽象访问者 —— 定义元素对应的访问方法，传入相应实例*/  
public interface Player {  
    public void visit(Shooting machine);  
    public void visit(Dancing machine);  
    public void visit(Driving machine);  
}  
/* 具体访问者 —— 男女性玩家 */  
public class MalePlayer implements Player{  
    @Override public void visit(Shooting machine) {   
        System.out.println("男性玩家玩：" + machine.feature());  
    }  
    @Override public void visit(Dancing machine) {  
        System.out.println("男性玩家玩：" + machine.feature());  
    }  
    @Override public void visit(Driving machine) {  
        System.out.println("男性玩家玩：" + machine.feature());  
    }  
}  
public class FemalePlayer implements Player{ /.../ }  
/* 对象结构 —— 管理元素集合，并且可迭代访问者访问 */  
public class GameRoom  {  
    private List<Machine> machines = new ArrayList<>();  
    public void add(Machine machine) { machines.add(machine); }  
    public void action(Player player) {  
        for (Machine machine: machines) { machine.accept(player); }  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        GameRoom room = new GameRoom();  
        room.add(new Shooting());  
        room.add(new Dancing());  
        room.add(new Driving());  
        Player player1 = new MalePlayer();  
        Player player2 = new FemalePlayer();  
        room.action(player1);  
        room.action(player2);  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/lm1rv6bqze9ggkowe8sx1fit/image_1bfeh5jb51bok685jih1ktfapb81.png)

------

## 二十二.责任链模式(Chain of Responsibility Pattern)

使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。(典型代表：Android里的事件传递机制)

![img](http://static.zybuluo.com/coder-pig/cwxe2j6qzpf8hnrqv5ub3aby/image_1bfeheavi1v0a10oe1bu918jc10m48e.png)

![img](http://static.zybuluo.com/coder-pig/1t7chmw99mzieqq7mkfb6dcq/image_1bfehemmm1qjpnbhj8g15kl11po8r.png)

**代码示例**：

Java代码

```
/* 抽象处理者 */  
public abstract class Handler {  
    private Handler nextHandler; /* 下家处理者 */  
    public Handler getNextHandler() { return  nextHandler; }  
    public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; }  
    public abstract void handlerRequest(String str, int money);   /* 请求 */  
}  
/* 具体处理者 —— 哥哥，爸爸，妈妈，依次传递*/  
public class Brother extends Handler {  
    @Override public void handlerRequest(String str, int money) {  
        if(money <= 100) {  
            System.out.println("哥哥：100块，哥哥还是有的，给你~");  
        } else {  
            if(getNextHandler() != null) {  
                System.out.println("哥哥：大于100块，哥哥木有那么多钱，找粑粑去~");  
                getNextHandler().handlerRequest(str, money);  
            } else {  
                System.out.println("哥哥：大于100块，哥哥木有那么多钱，粑粑不在家~");  
            }  
        }  
    }  
}  
public class Father extends Handler {  
    @Override public void handlerRequest(String str, int money) {  
        if(money <= 500) {  
            System.out.println("粑粑：500块，粑粑还是有的，给你~");  
        } else {  
            if(getNextHandler() != null) {  
                System.out.println("粑粑：大于500块，粑粑木有那么多钱，找麻麻去~");  
                getNextHandler().handlerRequest(str, money);  
            } else {  
                System.out.println("粑粑：大于500块，粑粑木有那么多钱，麻麻不在家~");  
            }  
        }  
    }  
}  
public class Mother extends Handler {  
    @Override public void handlerRequest(String str, int money) {  
        if(money <= 1000) {  
            System.out.println("麻麻：1000块，麻麻还是有的，给你~");  
        } else {  
            System.out.println("麻麻：你拿那么多钱干嘛？");  
        }  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        Brother brother = new Brother();  
        Father father = new Father();  
        Mother mother = new Mother();  
        //指定下家  
        brother.setNextHandler(father);  
        father.setNextHandler(mother);  
        brother.handlerRequest("要钱",1200);  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/zx82015a6sm07mvvcltjyici/image_1bfehmma918slkhr1qm81rns7qd98.png)

另外责任链模式还分纯与不纯

- **纯责任链**，要么承担全部责任，要么责任推个下家，**不允许**在某处**承担**了**部分**或者**全部责任**，然后**又把责任推给下家**。
- **不纯责任链**，责任在某处部分或全部被处理后，还向下传递。

------

## 二十三.状态模式(State Pattern)

**定义**：当一个对象的内在状态发生改变时允许改变其行为，这个对象看起来像是改变了它的类。

**套路**：

抽象出状态State，然后实现该接口，然后具体化不同状态，做不同的操作，然后写一个Context，里面存储一个State的实例，然后定义一个可以修改State实例的方法，并在里面去调用实例的行为方法。

![img](http://static.zybuluo.com/coder-pig/qjt16kb7xb2nil8fhd3w90yu/image_1bfehviru2231uhm13v7h0n1uf69l.png)

**示例代码**：

Java代码

```
/* 抽象状态 */  
public interface State {  
    public void doSomeThing();  
}  
/* 具体状态 */  
public class MorningState implements State {  
    @Override public void doSomeThing() { System.out.println("早上赖床！"); }  
}  
public class AfternoonState implements State {  
    @Override public void doSomeThing() { System.out.println("下午学习！"); }  
}  
public class EveningState implements State {  
    @Override public void doSomeThing() { System.out.println("晚上打球！"); }  
}  
/* 上下文环境 */  
public class Context {  
    public void setState(State state) {  
        System.out.println("状态改变");  
        state.doSomeThing();  
    }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        MorningState morningState = new MorningState();  
        AfternoonState afternoonState = new AfternoonState();  
        EveningState eveningState = new EveningState();  
        Context context = new Context();  
        context.setState(morningState);  
        context.setState(afternoonState);  
        context.setState(eveningState);  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/go8qfa4spc9bmjmb1fs1xdlx/image_1bfej2glk9p9dl4n9u4tc15cfa2.png)

------

## 二十四.模板方法模式(Template Method Pattern)

**定义**：定义一个操作中的算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可冲定义该算法的某些特定步骤。(定义比较抽象，举之前工厂模式做奶茶的例子帮助理解下)

**奶茶的制作步骤**：加奶，加茶，加料，打包

在这几个步骤中，加奶，加茶，加料这几步是固定，而打包的话则是不固定的，有些用户喜欢找个小桌子喝喝奶茶吹吹水，有些喜欢带回家，存在可变性。

对于这种可变的步骤，可以使用一个叫做**钩子**的东西，其实就是一种被声明在抽象类的方法，可以为空或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩，是否需要挂钩由子类决定。比如例子通过一个标记确定是否需要打包，子类中可以定义一个方法来调用这个方法。

![img](http://static.zybuluo.com/coder-pig/x2ehss3p7x6ohnhra2h0eonx/image_1bfeku8us7nm1bh5g6n75p1vqlaf.png)

**代码示例**：

Java代码

```
/* 抽象模板 */  
public abstract class Tea {  
    protected void 加奶() { System.out.println("加入三花淡奶"); }  
    protected abstract void 加茶();  
    protected abstract void 加料();  
    protected  void 打包() { System.out.println("用打包机打包"); }  
    protected boolean 是否打包() { return true; }     //钩子方法  
    public final void make() {  
        System.out.println("=== 开始制作 ===");  
        加奶();  
        加茶();  
        加料();  
        if(是否打包()) { 打包(); }  
        System.out.println("=== 制作完毕 ===");  
    }  
}  
/* 具体模板 */  
public class RedTeaMilkTea extends Tea {  
    @Override protected void 加茶() { System.out.println("加入红茶"); }  
    @Override protected void 加料() { System.out.println("加入珍珠"); }  
}  
public class GreenTeaMilkTea extends Tea {  
    private boolean isPack = true;  
    public GreenTeaMilkTea(boolean isPack) { this.isPack = isPack; }  
    @Override protected void 加茶() { System.out.println("加入绿茶"); }  
    @Override protected void 加料() { System.out.println("加入椰果"); }  
    @Override protected boolean 是否打包() { return isPack; }  
}  
/* 客户端调用 */  
public class Client {  
    public static void main(String[] args) {  
        Tea tea1 = new RedTeaMilkTea();  
        Tea tea2 = new GreenTeaMilkTea(false);  
        tea1.make();  
        System.out.println("");  
        tea2.make();  
    }  
}

```

**输出结果**：

![img](http://static.zybuluo.com/coder-pig/ycivn6bdw7y8cfdz8nl9j27r/image_1bflt6acgqbu2lq157hbne1bdb9.png)

------

**To be continue**…

如果想学习Java工程化、高性能及分布式、深入浅出。性能调优、Spring，MyBatis，Netty源码分析的朋友可以加我的Java高级架构进阶群：180705916，群里有阿里大牛直播讲解技术，以及Java大型互联网技术的视频免费分享给大家