
# 深度强化学习综述(上) - SIGAI_CSDN的博客 - CSDN博客
# [SIGAI_CSDN的博客](https://blog.csdn.net/sigai_csdn)


[博客首页](https://blog.csdn.net/SIGAI_CSDN)
[关于我们](https://me.csdn.net/SIGAI_CSDN)

2018年11月08日 15:52:08[SIGAI_csdn](https://me.csdn.net/SIGAI_CSDN)阅读数：3064


人工智能中的很多应用问题需要算法在每个时刻做出决策并执行动作。对于围棋，每一步需要决定在棋盘的哪个位置放置棋子，以最大可能的战胜对手；对于自动驾驶算法，需要根据路况来确定当前的行驶策略以保证安全的行驶到目的地；对于机械手，要驱动手臂运动以抓取到设定的目标物体。这类问题有一个共同的特点：要根据当前的条件作出决策和动作，以达到某一预期目标。解决这类问题的机器学习算法称为强化学习（reinforcement learning，RL）。虽然传统的强化学习理论在过去几十年中得到了不断的完善，但还是难以解决现实世界中的复杂问题。
深度强化学习（DRL，deep reinforcement learning）是深度学习与强化学习相结合的产物，它集成了深度学习在视觉等感知问题上强大的理解能力，以及强化学习的决策能力，实现了端到端学习。深度强化学习的出现使得强化学习技术真正走向实用，得以解决现实场景中的复杂问题。从2013年DQN（深度Q网络，deep Q network）出现到目前为止，深度强化学习领域出现了大量的算法，以及解决实际应用问题的论文。在这篇文章中，SIGAI将对深度强化学习的算法与应用进行总结。整个综述分为上下两篇，本篇介绍强化学习的基本原理，深度强化学习的基本思想，以及基于价值函数的深度强化学习算法。下篇介绍基于策略的深度强化学习算法，基于搜索与监督的深度强化学习算法，以及深度强化学习算法的应用情况与未来的方向。
## 什么是强化学习
强化学习[1]是一类特殊的机器学习算法，借鉴于行为主义心理学。与有监督学习和无监督学习的目标不同，算法要解决的问题是智能体（agent，即运行强化学习算法的实体）在环境中怎样执行动作以获得最大的累计奖励。例如，对于自动行驶的汽车，强化学习算法控制汽车的动作，保证安全行驶到目的地。对于围棋算法，算法要根据当前的棋局来决定如何走子，以赢得这局棋。对于第一个问题，环境是车辆当前行驶状态（如速度）、路况这样的参数构成的系统的抽象，奖励是我们期望得到的结果，即汽车正确的在路面上行驶，到达目的地而不发生事故。
很多控制、决策问题都可以抽象成这种模型。和有监督学习类似，强化学习也有训练过程，需要不断的执行动作，观察执行动作后的效果，积累经验形成一个模型。与有监督学习不同的是，这里每个动作一般没有直接标定的标签值作为监督信号，系统只给算法执行的动作一个反馈，这种反馈一般具有延迟性，当前的动作所产生的后果在未来才会完全体现，另外未来还具有随机性，例如下一个时刻路面上有哪些行人、车辆在运动，算法下一个棋子之后对手会怎么下，都是随机的而不是确定的。当前下的棋产生的效果，在一局棋结束时才能体现出来。
强化学习应用广泛，被认为是通向强人工智能/通用人工智能的核心技术之一。所有需要做决策和控制的地方，都有它的身影。典型的包括游戏与博弈，如打星际争霸、Atari游戏：
![](https://img-blog.csdnimg.cn/2018110815430924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
算法需要根据当前的游戏画面和状态决定其要执行的动作，如按游戏的键盘、手柄，鼠标。
围棋，象棋等棋类游戏：
![](https://img-blog.csdnimg.cn/20181108154329319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
算法需要根据当前的棋局决定当前该怎么走子。
自动驾驶系统/无人车：
![](https://img-blog.csdnimg.cn/20181108154357546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
算法需要根据当前的路况，无人车自身的状态（如速度、加速度）决定其行驶的行为，如控制方向盘，油门，刹车等。
机器人控制：
![](https://img-blog.csdnimg.cn/20181108154413818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
机器人要根据当前所处的环境，自身的状态，决定其要执行的动作。
所有这些问题总计起来都有一个特点，即智能体需要观察环境和自身的状态，然后决定要执行的动作，以达到想要的目标：
![](https://img-blog.csdnimg.cn/20181108154430211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
智能体是强化学习的动作实体。对于自动驾驶的汽车，环境是当前的路况；对于围棋，状态是当前的棋局。在每个时刻，智能体和环境有自己的状态，如汽车当前位置和速度，路面上的车辆和行人情况。智能体根据当前状态确定一个动作，并执行该动作。之后它和环境进入下一个状态，同时系统给它一个反馈值，对动作进行奖励或惩罚，以迫使智能体执行期望的动作。
强化学习是解决这种决策问题的一类方法。算法要通过样本学习得到一个映射函数，称为策略函数，其输入是当前时刻环境信息，输出是要执行的动作：
![](https://img-blog.csdnimg.cn/2018110815451646.png)
其中s为状态，a为要执行的动作，状态和动作分别来自状态集合和动作集合。动作和状态可以是离散的，如左转30度、右转30度，也可以是连续的实数，如左转30度、右转30度。对于前者，动作和状态集合是有限集，对于后者，是无限集。执行动作的目标是要达到某种目的，如无人汽车安全的行驶，赢得本次围棋比赛，用回报函数对此进行建模。
马尔可夫决策过程
强化学习要解决的问题可以抽象成马尔可夫决策过程（Markov Decision Process，简称MDP）。马尔可夫过程的特点是系统下一个时刻的状态由当前时刻的状态决定，与更早的时刻无关。与马尔可夫过程不同的是，在MDP中系智能体可以执行动作，从而改变自己和环境的状态，并且得到惩罚或奖励。马尔可夫决策过程可以表示成一个五元组：
![](https://img-blog.csdnimg.cn/20181108154518613.png)
其中S和A分别为状态和动作的集合。假设t时刻状态为*st*，智能体执行动作a，下一时刻进入状态*st+*1。这种状态转移与马尔可夫模型类，不同的是下一时刻的状态由当前状态以及当前采取的动作决定，是一个随机性变量，这一状态转移的概率为：
这是当前状态为s时行动作a，下一时刻进入状态*s*'的条件概率。下一时刻的状态与更早时刻的状态和动作无关，状态转换具有马尔可夫性。有一种特殊的状态称为终止状态（也称为吸收状态），到达该状态之后不会再进入其他后续状态。对于围棋，终止状态是一局的结束。
执行动作之后，智能体会收到一个立即回报：
![](https://img-blog.csdnimg.cn/2018110815452444.png)
立即回报与当前状态、当前采取的动作以及下一时刻的状态有关。在每个时刻t，智能体选择一个动作*at*执行，之后进入下一状态*st+*1，环境给出回报值。智能体从某一初始状态开始，每个时刻选择一个动作执行，然后进入下一个状态，得到一个回报，如此反复：
![](https://img-blog.csdnimg.cn/20181108154601592.png)
问题的核心是执行动作的策略，它可以抽象成一个函数π，定义了在每种状态时要选择执行的动作。这个函数定义了在状态s所选择的动作为：
![](https://img-blog.csdnimg.cn/20181108154625788.png)
这是确定性策略。对于确定性策略，在每种状态下智能体要执行的动作是唯一的。另外还有随机性策略，智能体在一种状态下可以执行的动作有多种，策略函数给出的是执行每种动作的概率：
![](https://img-blog.csdnimg.cn/20181108154621969.png)
即按概率从各种动作中随机选择一种执行。策略只与当前所处的状态有关，与时间点无关，在不同时刻对于同一个状态所执行的策略是相同的。
强化学习的目标是要达到某种预期，当前执行动作的结果会影响系统后续的状态，因此需要确定动作在未来是否能够得到好的回报，这种回报具有延迟性。对于围棋，当前走的一步棋一般不会马上结束，但会影响后续的棋局，需要使得未来赢的概率最大化，而未来又具有随机性，这为确定一个正确的决策带来了困难。
选择策略的目标是按照这个策略执行后，在各个时刻的累计回报值最大化，即未来的预期回报最大。按照某一策略执行的累计回报定义为：
![](https://img-blog.csdnimg.cn/2018110815463454.png)
这里使用了带衰减系数的回报和。按照策略π，智能体在每个时刻t执行的动作为：
![](https://img-blog.csdnimg.cn/20181108154646103.png)
其中γ称为折扣因子，是[0, 1]之间的一个数。在每个时刻t执行完动作*at*得到的回报为：
![](https://img-blog.csdnimg.cn/20181108154653498.png)
使用折扣因子是因为未来具有更大的不确定性，所以回报值要随着时间衰减。另外如果不加上这种按照时间的指数级衰减会导致整个求和项趋向于无穷大。这里假设状态转移概率以及每个时刻的回报是已知的，算法要寻找最佳策略来最大化上面的累计回报。
如果每次执行一个动作进入的下一个状态是确定的，则可以直接用上面的累计回报计算公式。如果执行完动作后进入的下一个状态是随机的，则需要计算各种情况的数学期望。类似于有监督学习中需要定义损失函数来评价预测函数的优劣，在强化学习中也需要对策略函数的优劣进行评价。为此定义状态价值函数的概念，它是在某个状态s下，按照策略π执行动作，累计回报的数学期望，衡量的是按照某一策略执行之后的累计回报。状态价值函数的计算公式为：
![](https://img-blog.csdnimg.cn/20181108154703968.png)
这是一个递归的定义，函数的自变量是状态与策略函数，将它们映射成一个实数，每个状态的价值函数依赖于从该状态执行动作后能到达的后续状态的价值函数。在状态s时执行动作π(s)，下一时刻的状态*s*'是不确定的，进入每个状态的概率为*pπ(s)*(*s*,*s*'),当前获得的回报是*Rπ(s)*(*s*,*s*')，因此需要对下一时刻所有状态计算数学期望即概率意义上的均值，而总的回报包括当前的回报，以及后续时刻的回报值之和即*Vπ*(*s*')。在这里R(s)表示当前时刻获得的回报。如果是非确定性策略，还要考虑所有的动作，这种情况的状态价值函数计算公式为：
![](https://img-blog.csdnimg.cn/2018110815471419.png)
对于终止状态，无论使用什么策略函数，其状态价值函数为0。类似的可以定义动作价值函数。它是智能体按照策略*π*执行，在状态s时执行具体的动作a后的预期回报，计算公式为：
![](https://img-blog.csdnimg.cn/20181108154722776.png)
动作价值函数除了指定初始状态s与策略*π*之外，还指定了在当前的状态s时执行的动作a。这个函数衡量的是按照某一策略，在某一状态时执行各种动作的价值。这个值等于在当前状态s下执行一个动作后的立即回报*Ra*(*s*,*s*')，以及在下一个状态*s*'时按照策略*π*执行所得到的状态价值函数*Vπ*(*s*')之和，此时也要对状态转移*pa*(*s*,*s*')概率求数学期望。状态价值函数和动作值函数的计算公式称为贝尔曼方程，它们是马尔可夫决策过程的核心。
因为算法要寻找最优策略，因此需要定义最优策略的概念。因为状态价值函数定义了策略的优劣，因此我们可以根据此函数值对策略的优劣进行排序。对于两个不同的策略*π*和*π*'，如果对于任意状态s都有：
![](https://img-blog.csdnimg.cn/2018110815474475.png)
则称策略*π*优于策略*π*'。对于任意有限状态和动作的马尔可夫决策过程，都至少存在一个最优策略，它优于其他任何不同的策略。
一个重要结论是，所有的最优策略有相同的状态价值函数和动作价值函数值。最优动作价值函数定义为：
![](https://img-blog.csdnimg.cn/20181108154810699.png)
对于状态-动作对(s,a)，最优动作价值函数给出了在状态s时执行动作a，后续状态时按照最优策略执行时的预期回报。找到了最优动作价值函数，根据它可以得到最优策略，具体做法是在每个状态时执行动作价值函数值最大的那个动作：
![](https://img-blog.csdnimg.cn/20181108154807343.png)
因此可以通过寻找最优动作价值函数而得到最优策略函数。如果只使用状态价值函数，虽然能找到其极值，但不并知道此时所采用的策略函数。
最优状态价值函数和最优动作价值函数都满足贝尔曼最优性方程。对于状态价值函数，有：
![](https://img-blog.csdnimg.cn/20181108154818709.png)
上式的意义是对任何一个状态s，要保证一个策略*π*能让状态价值函数取得最大值，则需要本次执行的动作a所带来的回报与下一状态*s*'的最优状态价值函数值之和是最优的。对于动作价值函数，类似的有：
![](https://img-blog.csdnimg.cn/2018110815483933.png)
其意义是要保证一个策略使得动作价值函数是最优的，则需要保证在执行完本动a之后，在下一个状态*s*'所执行的动作*a*'是最优的。对于任意有限状态和动作的马尔可夫决策过程，贝尔曼最优方程有唯一解，且与具体的策略无关。可以将贝尔曼最优性方程看成一个方程组，每个状态有一个方程，未知数的数量也等于状态的数量。
## 时序差分算法
如果能知道所有状态的状态转移概率，以及回报值，则理论上可以用动态规划算法求解，这是一种迭代法，从一个随机设定的初始值开始，用某种规则进行迭代，直到收敛到状态价值函数或者动作价值函数的极大值。迭代的规则一般是贝尔曼方程或贝尔曼最优性方程。
但在很多实际应用中，我们无法得到所有状态的转移概率，例如自动驾驶、围棋，此时无法使用动态规划算法求解，只能采用随机算法，其核心思想是：从一个初始的随机策略开始随机的执行一些动作，然后观察回报和状态转移，以此估计价值函数的值，或者更新价值函数的值。形象的说，就是加大效果的动作的执行力度，减小效果不好的动作的执行力度。蒙特卡洛算法和时序差分算法是典型的代表，在这里我们重点介绍时序差分算法的一种实现-Q学习。
时序差分算法（Temporal Difference learning，简称TD学习）[2]在执行一个动作之后进行动作价值函数更新。TD算法无需依赖状态转移概率，直接通过生成随机的样本来计算。TD算法用贝尔曼方程估计价值函数的值，然后构造更新项。其典型实现有SARSA算法和Q学习算法。
Q学习算法[3]是时序差分算法的一种，它估计每个动作价值函数的最大值，通过迭代可以直接找到Q函数的极值，从而确定最优策略。Q学习训练算法的流程如下：
初始化，将所有非终止状态的Q(s, a)初始化为任意值，终止状态的初始化为0
![](https://img-blog.csdnimg.cn/20181108154855312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
实现时需要根据当前的动作价值函数的估计值为每个状态选择一个动作来执行，有3种方案。第1种是随机选择一个动作，称为探索（exploration）。第2种是根据当前的动作函数值选择一个价值最大的动作执行：
![](https://img-blog.csdnimg.cn/20181108154920983.png)
称为利用（exploitation）。第3种是前两者的结合，即ε-贪心策略。执行完动作之后，进入状态*s*'，然后寻找状态*s*'下所有动作的价值函数的极大值，构造更新项。算法最终会收敛到动作价值函数的最优值。
用于预测时，在每个状态下选择函数值最大的动作执行，这就是最优策略，具体实现时同样可以采用ε-贪心策略。
具体实现时，将所有状态、动作的Q(s, a)存储在一个二维表格中，先初始化，然后通过此表格来确定一些动作执行，然后更新表格的值，直到收敛。
## 深度强化学习的早期探索
前面介绍的Q学习都只能用于状态和动作的集合是有限的离散基且状态和动作数量较少的情况，状态和动作需要人工预先设计，Q函数值需要存储在一个二维表格中。实际应用中的场景可能会很复杂，很难定义出离散的状态；即使能够定义，数量也非常大，无法用数组存储。
对于强化学习来说，很多实际应用问题的输入数据是高维的，如图像，声音，算法要根据它们来选择一个动作执行以达到某一预期的目标。比如，对于自动驾驶算法，要根据当前的画面决定汽车的行驶方向和速度。经典的强化学习算法如Q学习需要列举出所有可能的情况（称为状态，这是对当前所处环境的抽象），然后进行迭代。Q学习的经典实现是列举出所有的状态和动作，构建Q函数表，这是一个二维的表，然后迭代计算各种状态下执行各种动作的预期回报的最大值。对于高维的输入数据，显然是不现实的，因为如果直接以原始数据作为状态，维数太高，而且状态数量太多。
一种解决方案是从高维数据中抽象出特征，作为状态，然后用强化学习建模，但这种做法很大程度上依赖于人工特征的设计。如从画面中提取出目标的位置、速度等信息，也非常困难，这也是一个难题。
用一个函数来逼近价值函数或策略函数成为解决这个问题的一种思路，函数的输入是原始的状态数据，函数的输出是价值函数值或策略函数值。
在有监督学习中，我们用神经网络来拟合分类或回归函数，同样的，也可以用神经网络可来拟合强化学习中的价值函数和策略函数，这就是深度强化学习的基本思想。
将神经网络与强化学习进行结合并不是一个新的想法，早在1995年就有人进行了这一的尝试。首先是TD-gammon算法[4]，这是一种用强化学习玩西洋双陆棋的方法，取得了比人类选手更好的成绩。这种方法采用了与Q学习类似的策略，用多层感知器模型来逼近状态价值函数（V函数而不是Q函数）。
对这个算法感兴趣的话，可以阅读文献[4]。然而，后来将这种算法用于国际象棋，围棋，西洋跳棋时，效果却非常差。这使得人们认为TD-gammon算法只是一个特例，而不具有通用性。
后面的分析表明，将Q学习这样的无模型强化学习算法（即不知道环境的状态转移概率，以及回报函数）与非线性价值函数逼近结合使用时会导致Q网络不收敛。即在训练时Q网络无法收敛到Q函数的极大值。相比之下，用线性函数来逼近价值函数，会有更好的收敛性。对于收敛性问题，文献[5]有详细的分析与证明。
深度学习出现之后，将深度神经网络用于强化学习是一个很自然的想法。深度神经网络能够实现端到端的学习，直接从图像，声音等高维数据中学习得到有用的特征，这比人工设计的特征更为强大和通用。
在文献[6]中，受限玻尔兹曼机被用于表示价值函数，在文献[7]中，被用于表示策略函数。神经网络用于Q学习时不收敛的问题被gradient temporal-difference算法部分解决。用非线性函数来学习一个固定的策略时，这些方法的收敛性是可以得到保证的，感兴趣的可以阅读文献[]。用线性函数来近似价值函数，采用Q学习训练，收敛性也可以得到保证，文献[]对此有详细的分析与论证。
文献[8]提出了neural fitted Q-learning (NFQ)。这种方法优化方程上面定义的目标函数，采用 RPROP算法更新Q网络的参数。需要强调的是，它采用了批量梯度下降法进行更新迭代，即每次进行梯度下降法迭代时使用了所有训练样本，因此单次迭代的计算量太大。这种方法需要反复的对神经网络进行从头开始的上百次的迭代，因此不适合训练大规模的神经网络，因为效率太低。
NFQ也被用于现实世界中的控制任务[9]。以自动编码器作为提取特征的网络，直接接收视觉输入信号，然后将NFQ算法作用于提取出的特征表示。文献[10]将Q学习与经验回放机制进行整合，采用简单的神经作为逼近器。这里还是用低维的状态向量作为神经网络的输入，而不是高维的图像等原始数据。
深度学习取得了成功，在计算机视觉，语音识别领域，深度神经网络可以直接从场景数据如图像、声音中提取出高层特征，实现端到端的学习，而无需再人工设计特征。一个很自然的想法是能否用深度学习来为强化学习的输入原始数据进行建模。如果用神经王来近似Q函数，则网络的输入值为状态数据，如原始的游戏画面，输出值为在当前状态下执行各种动作所得到的最大预期回报。训练样本为状态，目标Q函数值对。但是将深度学习用于强化学习将面临几个挑战：
首先，深度学习需要大量的有标签的训练样本，而在强化学习中，算法要根据标量回报值进行学习，这个回报值往往是稀疏的，即不是执行每个动作都立刻能得到回报。例如对于打乒乓球这样的游戏，只有当自己或者对手失球时得分才会变化，此时才有回报，其他时刻没有回报。回报值带有噪声，另外还具有延迟，当前时刻的动作所得到的回报在未来才能得到体现。例如，在下棋时，当前所走的一步的结果会延迟一段时间后才能得到体现。
第2个问题是有监督学习一般要求训练样本之间是相互独立的，在强化学习中，经常遇到的是前后高度相关的状态序列。在某个状态下执行一个动作之后进入下一个状态，前后两个状态之间存在着明显的概率关系，不是独立的。
第3个问题是在强化学习中，随着学习到新的动作，样本数据的概率分布会发生变化，而在深度学习中，要求训练样本的概率分布是固定的。
## 基于价值函数的算法
基于价值函数的深度强化学习的典型代表是DQN（深度Q网络），由DeepMind公司在2013年提出，2015年其改进型发表在Nature上。这种方法用卷积神经网络拟合价值函数，一般是Q函数。网络的输入为原始场景数据，如游戏的画面图像，输出为在这种场景下执行各种动作时所能得到的Q函数的极大值。
文献[11]第一次提出了DQN算法，是深度强化学习真正意义上的开山之作。这篇文章用Atari游戏对算法进行了测试。算法用深度卷积神经网络来拟合Q函数，这个网络称为Q网络。网络的输入为经过处理后的游戏画面（最近4帧游戏画面），输出为在这种状态下执行各种动作的Q函数值。网络结构如下图所示：
![](https://img-blog.csdnimg.cn/20181108154948221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
损失函数用神经网络的输出值与Q学习每次迭代时的更新值构造，是神经网络的输出值与Q函数估计值之间的误差，与Q学习中的更新项相同：
![](https://img-blog.csdnimg.cn/20181108155059207.png)
和Q学习类似，可以通过执行动作来生成样本。实现时，给定一个状态，用当前的神经网络进行预测，得到所有动作的Q函数，然后按照策略选择一个动作执行，得到下一个状态以及回报值，以此构造训练样本。
确定网络结构和损失函数之后，剩下的就是神经网络的训练，与普通的有监督学习不同，这里的训练样本是通过不停的执行动作而动态生成的。为了解决训练样本之间存在相关性，以及样本的概率分布不固定的问题，采用了经验回放机制，具体做法是，先把执行动作构造的训练样本存储到一个大的集合中，在训练Q网络时每次从这个集合中随机抽取出部分样本作为训练样本，以此打破样本之间的相关性。
训练算法的流程如下：
![](https://img-blog.csdnimg.cn/20181108155032106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
一旦训练出了神经网络，便可以得到任何画面下要执行的动作，这通过使用Q函数值和贪心策略来实现，从而完成游戏的控制。
实验结果证明了DQN的收敛性，作者对此也进行了细致的分析。文章分析了游戏片段的平均回报值，随着迭代的进行，回报会升高，虽然有震荡。另外还分析了动作价值函数值，即Q函数的均值。同样的，随着迭代的进行会升高，虽然会震荡。
另外还在实验中比较了DQN与其他各种算法，以及人类选手的性能。参加比较的算法有SARSA算法，采用人工设计的特征。Contingency算法，采用和SARSA相同的方法，但是通过学习部分屏幕的表达增强了特征，特征提取采用图像处理方法如背景减除。人类的得分是人类玩两小时的结果。在绝大部分游戏上，DQN超过了之前最好的算法，在部分游戏上，甚至超过了人类玩家的水平。
DQN实现了端到端学习，无需人工提取状态和特征，整合了深度学习与强化学习，深度学习用于感知任务。可以解决复杂环境下的决策问题。方法具有通用性，可以用于各种不同的问题。
DQN在随机尝试执行动作，生成训练样本的过程中，需要用当前的Q网络来计算训练样本的标签值，这存在着自身依赖：
![](https://img-blog.csdnimg.cn/2018110815511185.png)
即Q值与Q学习的目标值*r+γ*max*a*'Q(*s*',*a*')之间的相关性。为了解决此问题，文献[12]对DQN进行了改进。它提出的算法和2013年DQN主要的不同是计算目标值是使用了另外一个Q网络，两个网络周期性的进行同步。
Q学习在第i次迭代时的损失函数为：
![](https://img-blog.csdnimg.cn/20181108155112612.png)
其中*γ*为折扣因子，θ*i*为Q网络在第次迭代时的参数值，为第第次迭代时用于计算目标值的Q网络的参数值，这个神经网络称为目标网络。目标网络与当前的Q网络分离开来，这是与2013年DQN最大的区别，当前Q网络的值在训练时每次都迭代更新，而目标网络则周期性的从当前Q网络同步过来，每多次迭代执行一次拷贝。系统结构如下图所示：
![](https://img-blog.csdnimg.cn/20181108155128820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NJR0FJX0NTRE4=,size_16,color_FFFFFF,t_70)
除了分析训练算法的收敛性、与其他算法以及人类进行比较之外，文献[12]还对DQN学习到的表达进行了分析，正是由它支撑了算法在游戏环境中的成功表现。这通过使用一种对高维数据进行可视化的方法-t-SNE而实现。t-SNE可以将感知上相似的状态通过DQN学习到的表达映射为相邻的点。作者发现，对于有些画面，t-SNE对DQN学习得到的表示的投影结果非常相近，这些游戏画面不相似，但Q函数值很相似，这意味着在这些画面下要采用类似的动作。这与我们的观点一致，神经网络可以从场景数据中学习得到支撑自适应行为的表示，即不同的场景下可能会使用相同的行为。
虽然DQN取得了成功，但还有很大的优化空间，此后DQN出现了大量改进型算法，这些改进包括系统整体结构、训练样本的构造、神经网络结构等方面。
文献[13]提出了Double DQN（DDQN）算法。DDQN中有两组不同的参数，和θ和θ-。θ用于选择对应最大Q值的动作，θ-用于评估最优动作的Q值。这两组参数将动作选择和策略评估分离，降低了过高估计Q值的风险。DDQN 使用当前值网络的参数θ选择最优动作，用目标值网络的参数θ-评估该最优动作。实验结果证明，DDQN能更准确的估计Q函数值，使得训练算法和训练得到的策略更为稳定。
![](https://img-blog.csdnimg.cn/20181108155137848.png)
文献[14]提出了基于优先级采样的DQN，是对经验回放机制的改进。在之前的DQN中，经验回放通过经验池中的样本等概率随机抽样来获得每次迭代时的训练样本。显然，这没有利用每个样本的重要性。文献[14]的方法为经验池中的每个样本计算优先级，增大有价值的训练样本在采样时的概率。样本的优先级用时序差分算法的误差项进行构造，计算公式为：
这个值的绝对值越大，样本在采样时的概率越大。实验结果证明这种算法有更快的训练速度，并且在运行时有更好的效果。
文献[15]提出了基于竞争架构的 DQN。其主要改进是将CNN卷积层之后的全连接层替换为两个分支，其中一个分支拟合状态价值函数，另外一个分支拟合动作优势函数。最后将两个分支的输出值相加，形成Q函数值。实验表明，这种改进能够更准确的估计价值函数值。
DQN中的深度神经网络是卷积神经网络，不具有长时间的记忆能力。为此，文献[16]提出了一种整合了循环神经网络（RNN）的DQN算法（DRQN）。这种方法在CNN的卷积层之后加入了循环层（LSTM单元），能够记住之前的信息。
参考文献
[1] Sutton, R. & Barto, A. Reinforcement Learning: An Introduction (MIT Press, 1998).
[2] Richard Sutton. Learning to predict by the methods of temporal differences. Machine Learning. 3 (1): 9-44.1988.
[3] Christopher JCH Watkins and Peter Dayan. Q-learning. Machine learning, 8(3-4):279–292, 1992.
[4] Gerald Tesauro. Temporal difference learning and td-gammon. Communications of the ACM,
38(3):58–68, 1995.
[5] Tsitsiklis J N, Van R B. An analysis of temporal-difference learning with function approximation. IEEE Transactions on Automatic Control, 1997, 42(5): 674-690
[6] Brian Sallans and Geoffrey E. Hinton. Reinforcement learning with factored states and actions.
Journal of Machine Learning Research, 5:1063–1088, 2004.
[7] Nicolas Heess, David Silver, and Yee Whye Teh. Actor-critic reinforcement learning with
energy-based policies. In European Workshop on Reinforcement Learning, page 43, 2012.
[8] Riedmiller M. Neural fitted q iteration-first experiences with a data efficient neural reinforcement learning method. Proceedings of the Conference on Machine Learning. Berlin, German, 2005: 317-328
[9] Sascha Lange and Martin Riedmiller. Deep auto-encoder neural networks in reinforcement
learning. In Neural Networks (IJCNN), The 2010 International Joint Conference on, pages
1–8. IEEE, 2010.
[10] Long-Ji Lin. Reinforcement learning for robots using neural networks. Technical report, DTIC
Document, 1993.
[11] Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Alex Graves, Ioannis Antonoglou. Playing Atari with Deep Reinforcement Learning. NIPS 2013.
[12] Mnih, Volodymyr, et al. Human-level control through deep reinforcement learning. Nature. 518 (7540): 529-533, 2015.
[13] Van H V, Guez A, Silver D. Deep reinforcement learning with double q-learning. Proceedings of the AAAI Conference on Artificial Intelligence. Phoenix, USA, 2016: 2094-2100.
[14] Schaul T, Quan J, Antonoglou I, Silver D. Prioritized experience replay. Proceedings of the 4th International Conference on Learning Representations. San Juan, Puerto Rico, 2016:322-355.
[15] Wang Z, Freitas N D, Lanctot M. Dueling network architectures for deep reinforcement learning. Proceedings of the International Conference on Machine Learning. New York, USA, 2016: 1995-2003.
[16] Hausknecht M, Stone P. Deep recurrent q-learning for partially observable MDPs. arXiv preprint arXiv:1507.06527, 2015.

