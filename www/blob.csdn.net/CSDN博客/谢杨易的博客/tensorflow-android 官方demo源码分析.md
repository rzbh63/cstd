
# tensorflow-android 官方demo源码分析 - 谢杨易的博客 - CSDN博客

2018年04月05日 16:24:44[谢杨易](https://me.csdn.net/u013510838)阅读数：3572


系列文章，请多关注
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[带你深入AI（2）- 深度学习激活函数，准确率，优化方法等总结](https://blog.csdn.net/u013510838/article/details/79845455)
[带你深入AI（3）- 物体分类领域：AlexNet VGG Inception ResNet mobileNet](https://blog.csdn.net/u013510838/article/details/79866740)
[带你深入AI（4）- 目标检测领域：R-CNN，faster R-CNN，yolo，SSD, yoloV2](https://blog.csdn.net/u013510838/article/details/79947553)
[带你深入AI（5）- 自然语言处理领域：RNN LSTM GRU](https://blog.csdn.net/u013510838/article/details/80024144)
[带你深入AI（6）- 详解bazel](https://blog.csdn.net/u013510838/article/details/80102438)
[带你深入AI（7）- 深度学习重要Python库](https://blog.csdn.net/u013510838/article/details/80412127)
## 1 引言
目前深度学习模型已经应用到了各个领域，将TensorFlow训练模型部署到终端上也逐步变为了现实。特别是mobileNet等体积小，占用内存少的模型出现后，将深度学习应用到终端上逐渐变得火热起来。mobileNet针对于终端，将标准的卷积分解成了一个depthwise 卷积和一个1x1的标准卷积，大大降低了模型参数数量。同时支持输入channel和resolution的裁剪，也大大降低了模型体积。官方训练的MobileNet_v1_0.25_128_quant, 在输入channel裁剪为原先1/4, 图像尺寸变为128*128后，模型体积仅仅为4.1MB，但识别准确度仍然可以达到65.8%. 本文聚焦于TensorFlow模型在Android app中的如何应用，就不对mobileNet进行详细分析了。
官方在TensorFlow源码的tensorflow/examples/android/ 目录下提供了一个app demo，配置好环境后，就可以在Android studio中run起来并安装到手机中了。下面详细分析这个demo的源码。掌握了官方demo原理后，我们就能够一方面改造这个demo app，来实现其他功能，比如相册内容识别等。另一方面可以用自己训练好的模型来替换官方demo中的TensorFlow模型。
## 2 工程目录结构
![工程目录](https://img.alicdn.com/tfs/TB1Wt7liVOWBuNjy0FiXXXFxVXa-539-953.png)
重要的文件如下
assets：pb文件存放训练好的TensorFlow模型，txt文件为能够识别的物体的名字，也叫label。model和label成对出现。官方给出的inceptionV1模型能够识别1000种物体，基本能够满足我们的日常需求。添加自己的模型时，需要在assets目录中加入自己训练好的model和对应label文件。
jni：物体识别使用了摄像头等组件，需要调用到jni。我们不需要详细了解
res：资源文件，学过Android的小伙伴都知道
src：demo中包含了四个子项目，分别为物体识别Classifier， 物体检测Detector，语音识别Speech，图片个性化Stylize。四个demo只是在训练模型上有差别，与Android的结合大同小异。故本文重点分析物体识别Classifier。其中的关键类如下ClassifierActivity：app中物体识别的主页面，也是入口类
CameraActivity：ClassifierActivity的父类，包含了相机权限获取，初始化，图片转换等操作。
CameraConnectionFragment， LegacyCameraConnectionFragment：主页面中相机实时预览图片的区域，分为传统方式和当前方式两种。
TensorFlowImageClassifier：利用TensorFlow模型来预测物体的关键所在，包含识别器classifier的构造和图像识别两个主要方法。后面详细分析。
build.gradle: 编译项目的配置文件，工程环境配置时比较关键，本文重点讲解TensorFlow在Android上应用的原理，就不展开说了。
## 3 app进行物体识别的流程
### 3.1 onCreate中请求相机权限并设置页面内容区的fragment
我们从ClassifierActivity的onCreate()看起，它继承于CameraActivity。主要作用为设置Activity的contentView，以及请求打开相机的权限。如下
```python
protected
```
```python
void
```
```python
onCreate
```
```python
(
```
```python
final
```
```python
Bundle savedInstanceState
```
```python
)
```
```python
{
```
```python
// 设置window layout，以及设置contentView
```
```python
LOGGER
```
```python
.
```
```python
d
```
```python
(
```
```python
"onCreate "
```
```python
+
```
```python
this
```
```python
)
```
```python
;
```
```python
super
```
```python
.
```
```python
onCreate
```
```python
(
```
```python
null
```
```python
)
```
```python
;
```
```python
getWindow
```
```python
(
```
```python
)
```
```python
.
```
```python
addFlags
```
```python
(
```
```python
WindowManager
```
```python
.
```
```python
LayoutParams
```
```python
.
```
```python
FLAG_KEEP_SCREEN_ON
```
```python
)
```
```python
;
```
```python
setContentView
```
```python
(
```
```python
R
```
```python
.
```
```python
layout
```
```python
.
```
```python
activity_camera
```
```python
)
```
```python
;
```
```python
// 有相机权限，则进行设置相机实时图片预览区域的Fragment，否则，请求权限，让用户确定
```
```python
if
```
```python
(
```
```python
hasPermission
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
setFragment
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
requestPermission
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
相机权限请求requestPermission，通过发送android.permission.CAMERA 权限请求即可，做过Android的小伙伴都知道，不详细分析了。下面看setFragment()方法
```python
protected
```
```python
void
```
```python
setFragment
```
```python
(
```
```python
)
```
```python
{
```
```python
// 获取相机，通过CameraService选择正确的摄像头。本app中不使用前置摄像头
```
```python
String cameraId
```
```python
=
```
```python
chooseCamera
```
```python
(
```
```python
)
```
```python
;
```
```python
// 构建相机的Fragment.注册Camera.PreviewCallback，android.hardware.Camera的callback
```
```python
Fragment fragment
```
```python
;
```
```python
if
```
```python
(
```
```python
useCamera2API
```
```python
)
```
```python
{
```
```python
// 摄像头支持高级的图像处理功能时，构造CameraConnectionFragment实例。后面详细分析
```
```python
CameraConnectionFragment camera2Fragment
```
```python
=
```
```python
CameraConnectionFragment
```
```python
.
```
```python
newInstance
```
```python
(
```
```python
new
```
```python
CameraConnectionFragment
```
```python
.
```
```python
ConnectionCallback
```
```python
(
```
```python
)
```
```python
{
```
```python
@Override
```
```python
// 选择了预览图片的大小时的回调
```
```python
public
```
```python
void
```
```python
onPreviewSizeChosen
```
```python
(
```
```python
final
```
```python
Size size
```
```python
,
```
```python
final
```
```python
int
```
```python
rotation
```
```python
)
```
```python
{
```
```python
previewHeight
```
```python
=
```
```python
size
```
```python
.
```
```python
getHeight
```
```python
(
```
```python
)
```
```python
;
```
```python
previewWidth
```
```python
=
```
```python
size
```
```python
.
```
```python
getWidth
```
```python
(
```
```python
)
```
```python
;
```
```python
CameraActivity
```
```python
.
```
```python
this
```
```python
.
```
```python
onPreviewSizeChosen
```
```python
(
```
```python
size
```
```python
,
```
```python
rotation
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
,
```
```python
this
```
```python
,
```
```python
getLayoutId
```
```python
(
```
```python
)
```
```python
,
```
```python
getDesiredPreviewFrameSize
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
camera2Fragment
```
```python
.
```
```python
setCamera
```
```python
(
```
```python
cameraId
```
```python
)
```
```python
;
```
```python
fragment
```
```python
=
```
```python
camera2Fragment
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
// 摄像头只支持部分功能时，fallback到传统的API
```
```python
fragment
```
```python
=
```
```python
new
```
```python
LegacyCameraConnectionFragment
```
```python
(
```
```python
this
```
```python
,
```
```python
getLayoutId
```
```python
(
```
```python
)
```
```python
,
```
```python
getDesiredPreviewFrameSize
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
// fragment填充到container位置处
```
```python
getFragmentManager
```
```python
(
```
```python
)
```
```python
.
```
```python
beginTransaction
```
```python
(
```
```python
)
```
```python
.
```
```python
replace
```
```python
(
```
```python
R
```
```python
.
```
```python
id
```
```python
.
```
```python
container
```
```python
,
```
```python
fragment
```
```python
)
```
```python
.
```
```python
commit
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
下面来看CameraConnectionFragment，构造fragment时我们传入了两个比较重要的回调，一个是cameraConnectionCallback，它在打开摄像头时回调，一个是imageListener，它在摄像头拍摄到图片时回调。我们后面会详细分析。先来看fragment的生命周期中的几个重要方法。onCreateView() onViewCreated()基本没做太多事情，onResume()中有个关键动作，它调用了openCamera()方法来打开摄像头。我们来详细分析。
```python
public
```
```python
void
```
```python
onResume
```
```python
(
```
```python
)
```
```python
{
```
```python
super
```
```python
.
```
```python
onResume
```
```python
(
```
```python
)
```
```python
;
```
```python
startBackgroundThread
```
```python
(
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
textureView
```
```python
.
```
```python
isAvailable
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
// 屏幕没有处于关闭状态时，打开摄像头。textureView是fragment中展示摄像头实时捕获的图片的区域。
```
```python
openCamera
```
```python
(
```
```python
textureView
```
```python
.
```
```python
getWidth
```
```python
(
```
```python
)
```
```python
,
```
```python
textureView
```
```python
.
```
```python
getHeight
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
textureView
```
```python
.
```
```python
setSurfaceTextureListener
```
```python
(
```
```python
surfaceTextureListener
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
### 3.2 打开摄像头，并注册ConnectionCallback和OnImageAvailableListener
下面来看openCamera()方法。
```python
private
```
```python
void
```
```python
openCamera
```
```python
(
```
```python
final
```
```python
int
```
```python
width
```
```python
,
```
```python
final
```
```python
int
```
```python
height
```
```python
)
```
```python
{
```
```python
// 设置camera捕获图片的一些输出参数，图片预览大小previewSize，摄像头方向sensorOrientation等。最重要的是回调我们之前传入到fragment中的cameraConnectionCallback的onPreviewSizeChosen()方法。
```
```python
setUpCameraOutputs
```
```python
(
```
```python
)
```
```python
;
```
```python
// 设置手机旋转后的适配，这儿不用关心
```
```python
configureTransform
```
```python
(
```
```python
width
```
```python
,
```
```python
height
```
```python
)
```
```python
;
```
```python
// 利用CameraManager这个Android底层类，打开摄像头。这儿也不是我们关注的重点
```
```python
final
```
```python
Activity activity
```
```python
=
```
```python
getActivity
```
```python
(
```
```python
)
```
```python
;
```
```python
final
```
```python
CameraManager manager
```
```python
=
```
```python
(
```
```python
CameraManager
```
```python
)
```
```python
activity
```
```python
.
```
```python
getSystemService
```
```python
(
```
```python
Context
```
```python
.
```
```python
CAMERA_SERVICE
```
```python
)
```
```python
;
```
```python
try
```
```python
{
```
```python
if
```
```python
(
```
```python
!
```
```python
cameraOpenCloseLock
```
```python
.
```
```python
tryAcquire
```
```python
(
```
```python
2500
```
```python
,
```
```python
TimeUnit
```
```python
.
```
```python
MILLISECONDS
```
```python
)
```
```python
)
```
```python
{
```
```python
throw
```
```python
new
```
```python
RuntimeException
```
```python
(
```
```python
"Time out waiting to lock camera opening."
```
```python
)
```
```python
;
```
```python
}
```
```python
manager
```
```python
.
```
```python
openCamera
```
```python
(
```
```python
cameraId
```
```python
,
```
```python
stateCallback
```
```python
,
```
```python
backgroundHandler
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
final
```
```python
CameraAccessException e
```
```python
)
```
```python
{
```
```python
LOGGER
```
```python
.
```
```python
e
```
```python
(
```
```python
e
```
```python
,
```
```python
"Exception!"
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
final
```
```python
InterruptedException e
```
```python
)
```
```python
{
```
```python
throw
```
```python
new
```
```python
RuntimeException
```
```python
(
```
```python
"Interrupted while trying to lock camera opening."
```
```python
,
```
```python
e
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
上面setUpCameraOutputs()比较重要，它设置了camera捕获图片的一些参数。如图片预览大小previewSize，摄像头方向sensorOrientation等。最重要的是回调我们之前传入到fragment中的cameraConnectionCallback的onPreviewSizeChosen()方法。我们来看之前CameraActivity中传入的cameraConnectionCallback
```python
new
```
```python
CameraConnectionFragment
```
```python
.
```
```python
ConnectionCallback
```
```python
(
```
```python
)
```
```python
{
```
```python
@Override
```
```python
// 预览图片的宽高确定后回调
```
```python
public
```
```python
void
```
```python
onPreviewSizeChosen
```
```python
(
```
```python
final
```
```python
Size size
```
```python
,
```
```python
final
```
```python
int
```
```python
rotation
```
```python
)
```
```python
{
```
```python
// 获取相机捕获的图片的宽高，以及相机旋转方向。
```
```python
previewHeight
```
```python
=
```
```python
size
```
```python
.
```
```python
getHeight
```
```python
(
```
```python
)
```
```python
;
```
```python
previewWidth
```
```python
=
```
```python
size
```
```python
.
```
```python
getWidth
```
```python
(
```
```python
)
```
```python
;
```
```python
// 相机捕获的图片的大小确定后，需要对捕获图片做裁剪等预操作。这将回调到ClassifierActivity中。我们后面重点分析。
```
```python
CameraActivity
```
```python
.
```
```python
this
```
```python
.
```
```python
onPreviewSizeChosen
```
```python
(
```
```python
size
```
```python
,
```
```python
rotation
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
我们这就分析清楚了打开摄像头前cameraConnectionCallback的回调流程了，还记得我们传入了另外一个listener吧，也就是onImageAvailableListener， 它在摄像头被打开后，捕获的图片available时由系统回调到。摄像头打开后，会create一个新的预览session，其中就会设置OnImageAvailableListener到CameraDevice中。这个过程我们不做详细分析了。
### 3.3 相机预览图片宽高确定后，回调onPreviewSizeChosen
上面分析到onPreviewSizeChosen会调用到ClassifierActivity中。它主要做了两件事，构造分类器classifier，它是模型分类预测的一个比较关键的类。另外就是预处理输入图片，如裁剪到和模型训练所使用的图片相同的尺寸。
```python
// 图片预览展现出来时回调。主要是构造分类器classifier，和裁剪输入图片为224*224
```
```python
@Override
```
```python
public
```
```python
void
```
```python
onPreviewSizeChosen
```
```python
(
```
```python
final
```
```python
Size size
```
```python
,
```
```python
final
```
```python
int
```
```python
rotation
```
```python
)
```
```python
{
```
```python
final
```
```python
float
```
```python
textSizePx
```
```python
=
```
```python
TypedValue
```
```python
.
```
```python
applyDimension
```
```python
(
```
```python
TypedValue
```
```python
.
```
```python
COMPLEX_UNIT_DIP
```
```python
,
```
```python
TEXT_SIZE_DIP
```
```python
,
```
```python
getResources
```
```python
(
```
```python
)
```
```python
.
```
```python
getDisplayMetrics
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
borderedText
```
```python
=
```
```python
new
```
```python
BorderedText
```
```python
(
```
```python
textSizePx
```
```python
)
```
```python
;
```
```python
borderedText
```
```python
.
```
```python
setTypeface
```
```python
(
```
```python
Typeface
```
```python
.
```
```python
MONOSPACE
```
```python
)
```
```python
;
```
```python
// 构造分类器，利用了TensorFlow训练出来的Model，也就是.pb文件。这是后面做物体分类识别的关键
```
```python
classifier
```
```python
=
```
```python
TensorFlowImageClassifier
```
```python
.
```
```python
create
```
```python
(
```
```python
getAssets
```
```python
(
```
```python
)
```
```python
,
```
```python
MODEL_FILE
```
```python
,
```
```python
LABEL_FILE
```
```python
,
```
```python
INPUT_SIZE
```
```python
,
```
```python
IMAGE_MEAN
```
```python
,
```
```python
IMAGE_STD
```
```python
,
```
```python
INPUT_NAME
```
```python
,
```
```python
OUTPUT_NAME
```
```python
)
```
```python
;
```
```python
previewWidth
```
```python
=
```
```python
size
```
```python
.
```
```python
getWidth
```
```python
(
```
```python
)
```
```python
;
```
```python
previewHeight
```
```python
=
```
```python
size
```
```python
.
```
```python
getHeight
```
```python
(
```
```python
)
```
```python
;
```
```python
sensorOrientation
```
```python
=
```
```python
rotation
```
```python
-
```
```python
getScreenOrientation
```
```python
(
```
```python
)
```
```python
;
```
```python
LOGGER
```
```python
.
```
```python
i
```
```python
(
```
```python
"Camera orientation relative to screen canvas: %d"
```
```python
,
```
```python
sensorOrientation
```
```python
)
```
```python
;
```
```python
LOGGER
```
```python
.
```
```python
i
```
```python
(
```
```python
"Initializing at size %dx%d"
```
```python
,
```
```python
previewWidth
```
```python
,
```
```python
previewHeight
```
```python
)
```
```python
;
```
```python
rgbFrameBitmap
```
```python
=
```
```python
Bitmap
```
```python
.
```
```python
createBitmap
```
```python
(
```
```python
previewWidth
```
```python
,
```
```python
previewHeight
```
```python
,
```
```python
Config
```
```python
.
```
```python
ARGB_8888
```
```python
)
```
```python
;
```
```python
croppedBitmap
```
```python
=
```
```python
Bitmap
```
```python
.
```
```python
createBitmap
```
```python
(
```
```python
INPUT_SIZE
```
```python
,
```
```python
INPUT_SIZE
```
```python
,
```
```python
Config
```
```python
.
```
```python
ARGB_8888
```
```python
)
```
```python
;
```
```python
// 将照相机获取的原始图片，转换为224*224的图片，用来作为模型预测的输入。
```
```python
frameToCropTransform
```
```python
=
```
```python
ImageUtils
```
```python
.
```
```python
getTransformationMatrix
```
```python
(
```
```python
previewWidth
```
```python
,
```
```python
previewHeight
```
```python
,
```
```python
INPUT_SIZE
```
```python
,
```
```python
INPUT_SIZE
```
```python
,
```
```python
sensorOrientation
```
```python
,
```
```python
MAINTAIN_ASPECT
```
```python
)
```
```python
;
```
```python
cropToFrameTransform
```
```python
=
```
```python
new
```
```python
Matrix
```
```python
(
```
```python
)
```
```python
;
```
```python
frameToCropTransform
```
```python
.
```
```python
invert
```
```python
(
```
```python
cropToFrameTransform
```
```python
)
```
```python
;
```
```python
addCallback
```
```python
(
```
```python
new
```
```python
DrawCallback
```
```python
(
```
```python
)
```
```python
{
```
```python
@Override
```
```python
public
```
```python
void
```
```python
drawCallback
```
```python
(
```
```python
final
```
```python
Canvas canvas
```
```python
)
```
```python
{
```
```python
renderDebug
```
```python
(
```
```python
canvas
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
)
```
```python
;
```
```python
}
```
#### 3.3.1 分类器classifier的构造
classifier分类器是模型预测图片分类中比较重要的类，其中一些概念和深度学习以及TensorFlow紧密相关。代码如下
```python
// 构造物体识别分类器
```
```python
public
```
```python
static
```
```python
Classifier
```
```python
create
```
```python
(
```
```python
AssetManager assetManager
```
```python
,
```
```python
String modelFilename
```
```python
,
```
```python
String labelFilename
```
```python
,
```
```python
int
```
```python
inputSize
```
```python
,
```
```python
int
```
```python
imageMean
```
```python
,
```
```python
float
```
```python
imageStd
```
```python
,
```
```python
String inputName
```
```python
,
```
```python
String outputName
```
```python
)
```
```python
{
```
```python
// 1 构造TensorFlowImageClassifier分类器，inputName和outputName分别为模型输入节点和输出节点的名字
```
```python
TensorFlowImageClassifier c
```
```python
=
```
```python
new
```
```python
TensorFlowImageClassifier
```
```python
(
```
```python
)
```
```python
;
```
```python
c
```
```python
.
```
```python
inputName
```
```python
=
```
```python
inputName
```
```python
;
```
```python
c
```
```python
.
```
```python
outputName
```
```python
=
```
```python
outputName
```
```python
;
```
```python
// 2 读取label文件内容，将内容设置到出classifier的labels数组中
```
```python
String actualFilename
```
```python
=
```
```python
labelFilename
```
```python
.
```
```python
split
```
```python
(
```
```python
"file:///android_asset/"
```
```python
)
```
```python
[
```
```python
1
```
```python
]
```
```python
;
```
```python
Log
```
```python
.
```
```python
i
```
```python
(
```
```python
TAG
```
```python
,
```
```python
"Reading labels from: "
```
```python
+
```
```python
actualFilename
```
```python
)
```
```python
;
```
```python
BufferedReader br
```
```python
=
```
```python
null
```
```python
;
```
```python
try
```
```python
{
```
```python
// 读取label文件流，label文件表征了可以识别出来的物体分类。我们预测的物体名称就是其中之一。
```
```python
br
```
```python
=
```
```python
new
```
```python
BufferedReader
```
```python
(
```
```python
new
```
```python
InputStreamReader
```
```python
(
```
```python
assetManager
```
```python
.
```
```python
open
```
```python
(
```
```python
actualFilename
```
```python
)
```
```python
)
```
```python
)
```
```python
;
```
```python
// 将label存储到TensorFlowImageClassifier的labels数组中
```
```python
String line
```
```python
;
```
```python
while
```
```python
(
```
```python
(
```
```python
line
```
```python
=
```
```python
br
```
```python
.
```
```python
readLine
```
```python
(
```
```python
)
```
```python
)
```
```python
!=
```
```python
null
```
```python
)
```
```python
{
```
```python
c
```
```python
.
```
```python
labels
```
```python
.
```
```python
add
```
```python
(
```
```python
line
```
```python
)
```
```python
;
```
```python
}
```
```python
br
```
```python
.
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
IOException
```
```python
e
```
```python
)
```
```python
{
```
```python
throw
```
```python
new
```
```python
RuntimeException
```
```python
(
```
```python
"Problem reading label file!"
```
```python
,
```
```python
e
```
```python
)
```
```python
;
```
```python
}
```
```python
// 3 读取model文件名，并设置到classifier的interface变量中。
```
```python
c
```
```python
.
```
```python
inferenceInterface
```
```python
=
```
```python
new
```
```python
TensorFlowInferenceInterface
```
```python
(
```
```python
assetManager
```
```python
,
```
```python
modelFilename
```
```python
)
```
```python
;
```
```python
// 4 利用输出节点名称，获取输出节点的shape，也就是最终分类的数目。
```
```python
// 输出的shape为二维矩阵[N, NUM_CLASSES], N为batch size，也就是一批训练的图片个数。NUM_CLASSES为分类个数
```
```python
final
```
```python
Operation operation
```
```python
=
```
```python
c
```
```python
.
```
```python
inferenceInterface
```
```python
.
```
```python
graphOperation
```
```python
(
```
```python
outputName
```
```python
)
```
```python
;
```
```python
final
```
```python
int
```
```python
numClasses
```
```python
=
```
```python
(
```
```python
int
```
```python
)
```
```python
operation
```
```python
.
```
```python
output
```
```python
(
```
```python
0
```
```python
)
```
```python
.
```
```python
shape
```
```python
(
```
```python
)
```
```python
.
```
```python
size
```
```python
(
```
```python
1
```
```python
)
```
```python
;
```
```python
Log
```
```python
.
```
```python
i
```
```python
(
```
```python
TAG
```
```python
,
```
```python
"Read "
```
```python
+
```
```python
c
```
```python
.
```
```python
labels
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
+
```
```python
" labels, output layer size is "
```
```python
+
```
```python
numClasses
```
```python
)
```
```python
;
```
```python
// 5. 设置分类器的其他变量
```
```python
c
```
```python
.
```
```python
inputSize
```
```python
=
```
```python
inputSize
```
```python
;
```
```python
// 物体分类预测时输入图片的尺寸。也就是相机原始图片裁剪后的图片。默认为224*224
```
```python
c
```
```python
.
```
```python
imageMean
```
```python
=
```
```python
imageMean
```
```python
;
```
```python
// 像素点RGB通道的平均值，默认为117。用来将0~255的数值做归一化的
```
```python
c
```
```python
.
```
```python
imageStd
```
```python
=
```
```python
imageStd
```
```python
;
```
```python
// 像素点RGB通道的归一化比例，默认为1
```
```python
// 6. 分配Buffer给输出变量
```
```python
c
```
```python
.
```
```python
outputNames
```
```python
=
```
```python
new
```
```python
String
```
```python
[
```
```python
]
```
```python
{
```
```python
outputName
```
```python
}
```
```python
;
```
```python
// 输出节点名字
```
```python
c
```
```python
.
```
```python
intValues
```
```python
=
```
```python
new
```
```python
int
```
```python
[
```
```python
inputSize
```
```python
*
```
```python
inputSize
```
```python
]
```
```python
;
```
```python
c
```
```python
.
```
```python
floatValues
```
```python
=
```
```python
new
```
```python
float
```
```python
[
```
```python
inputSize
```
```python
*
```
```python
inputSize
```
```python
*
```
```python
3
```
```python
]
```
```python
;
```
```python
// RGB三通道
```
```python
c
```
```python
.
```
```python
outputs
```
```python
=
```
```python
new
```
```python
float
```
```python
[
```
```python
numClasses
```
```python
]
```
```python
;
```
```python
// 预测完的结果，也就是图片对应到每个分类的概率。我们取概率最大的前三个显示在app中
```
```python
return
```
```python
c
```
```python
;
```
```python
}
```
#### 3.3.2 预处理预览图片
```python
// 预处理预览图片，裁剪，旋转等操作。
```
```python
// srcWidth, srcHeight为预览图片宽高。dstWidth dstHeight为训练模型时使用的图片的宽高
```
```python
// applyRotation 旋转角度，必须是90的倍数，
```
```python
// maintainAspectRatio 如果为true，旋转时缩放x而保证y不变
```
```python
public
```
```python
static
```
```python
Matrix
```
```python
getTransformationMatrix
```
```python
(
```
```python
final
```
```python
int
```
```python
srcWidth
```
```python
,
```
```python
final
```
```python
int
```
```python
srcHeight
```
```python
,
```
```python
final
```
```python
int
```
```python
dstWidth
```
```python
,
```
```python
final
```
```python
int
```
```python
dstHeight
```
```python
,
```
```python
final
```
```python
int
```
```python
applyRotation
```
```python
,
```
```python
final
```
```python
boolean
```
```python
maintainAspectRatio
```
```python
)
```
```python
{
```
```python
// 定义预处理后的图片像素矩阵
```
```python
final
```
```python
Matrix matrix
```
```python
=
```
```python
new
```
```python
Matrix
```
```python
(
```
```python
)
```
```python
;
```
```python
// 处理旋转
```
```python
if
```
```python
(
```
```python
applyRotation
```
```python
!=
```
```python
0
```
```python
)
```
```python
{
```
```python
// 旋转只能处理90度的倍数
```
```python
if
```
```python
(
```
```python
applyRotation
```
```python
%
```
```python
90
```
```python
!=
```
```python
0
```
```python
)
```
```python
{
```
```python
LOGGER
```
```python
.
```
```python
w
```
```python
(
```
```python
"Rotation of %d % 90 != 0"
```
```python
,
```
```python
applyRotation
```
```python
)
```
```python
;
```
```python
}
```
```python
// translate平移，保持圆心不变
```
```python
matrix
```
```python
.
```
```python
postTranslate
```
```python
(
```
```python
-
```
```python
srcWidth
```
```python
/
```
```python
2.0f
```
```python
,
```
```python
-
```
```python
srcHeight
```
```python
/
```
```python
2.0f
```
```python
)
```
```python
;
```
```python
// rotate旋转
```
```python
matrix
```
```python
.
```
```python
postRotate
```
```python
(
```
```python
applyRotation
```
```python
)
```
```python
;
```
```python
}
```
```python
// 输出矩阵是否需要转置。如果旋转为90度和270度时需要。转置后，宽高互换。
```
```python
final
```
```python
boolean
```
```python
transpose
```
```python
=
```
```python
(
```
```python
Math
```
```python
.
```
```python
abs
```
```python
(
```
```python
applyRotation
```
```python
)
```
```python
+
```
```python
90
```
```python
)
```
```python
%
```
```python
180
```
```python
==
```
```python
0
```
```python
;
```
```python
final
```
```python
int
```
```python
inWidth
```
```python
=
```
```python
transpose
```
```python
?
```
```python
srcHeight
```
```python
:
```
```python
srcWidth
```
```python
;
```
```python
final
```
```python
int
```
```python
inHeight
```
```python
=
```
```python
transpose
```
```python
?
```
```python
srcWidth
```
```python
:
```
```python
srcHeight
```
```python
;
```
```python
// 如果src尺寸和dest尺寸不同，则需要做裁剪
```
```python
if
```
```python
(
```
```python
inWidth
```
```python
!=
```
```python
dstWidth
```
```python
||
```
```python
inHeight
```
```python
!=
```
```python
dstHeight
```
```python
)
```
```python
{
```
```python
final
```
```python
float
```
```python
scaleFactorX
```
```python
=
```
```python
dstWidth
```
```python
/
```
```python
(
```
```python
float
```
```python
)
```
```python
inWidth
```
```python
;
```
```python
final
```
```python
float
```
```python
scaleFactorY
```
```python
=
```
```python
dstHeight
```
```python
/
```
```python
(
```
```python
float
```
```python
)
```
```python
inHeight
```
```python
;
```
```python
if
```
```python
(
```
```python
maintainAspectRatio
```
```python
)
```
```python
{
```
```python
// 保持宽高比例不变，不会有形变，但可能会被剪切。此时宽高scale的因子相同
```
```python
final
```
```python
float
```
```python
scaleFactor
```
```python
=
```
```python
Math
```
```python
.
```
```python
max
```
```python
(
```
```python
scaleFactorX
```
```python
,
```
```python
scaleFactorY
```
```python
)
```
```python
;
```
```python
matrix
```
```python
.
```
```python
postScale
```
```python
(
```
```python
scaleFactor
```
```python
,
```
```python
scaleFactor
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
// 不用保持宽高不变，直接匹配为dest的尺寸。可能会发生形变
```
```python
matrix
```
```python
.
```
```python
postScale
```
```python
(
```
```python
scaleFactorX
```
```python
,
```
```python
scaleFactorY
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
if
```
```python
(
```
```python
applyRotation
```
```python
!=
```
```python
0
```
```python
)
```
```python
{
```
```python
// 平移变换
```
```python
matrix
```
```python
.
```
```python
postTranslate
```
```python
(
```
```python
dstWidth
```
```python
/
```
```python
2.0f
```
```python
,
```
```python
dstHeight
```
```python
/
```
```python
2.0f
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
matrix
```
```python
;
```
```python
}
```
### 3.4 相机预览图片available时，OnImageAvailableListener回调
当相机预览图片准备好时，Android系统的cameraDevice会回调之前注册的OnImageAvailableListener。下面来看OnImageAvailableListener都做了哪些事情。
```python
public
```
```python
void
```
```python
onImageAvailable
```
```python
(
```
```python
final
```
```python
ImageReader reader
```
```python
)
```
```python
{
```
```python
// onPreviewSizeChosen被回调后，设置了previewWidth和previewHeight，才处理预览图片
```
```python
if
```
```python
(
```
```python
previewWidth
```
```python
==
```
```python
0
```
```python
||
```
```python
previewHeight
```
```python
==
```
```python
0
```
```python
)
```
```python
{
```
```python
return
```
```python
;
```
```python
}
```
```python
// 构造图片输出矩阵
```
```python
if
```
```python
(
```
```python
rgbBytes
```
```python
==
```
```python
null
```
```python
)
```
```python
{
```
```python
rgbBytes
```
```python
=
```
```python
new
```
```python
int
```
```python
[
```
```python
previewWidth
```
```python
*
```
```python
previewHeight
```
```python
]
```
```python
;
```
```python
}
```
```python
try
```
```python
{
```
```python
// 获取图片
```
```python
final
```
```python
Image image
```
```python
=
```
```python
reader
```
```python
.
```
```python
acquireLatestImage
```
```python
(
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
image
```
```python
==
```
```python
null
```
```python
)
```
```python
{
```
```python
return
```
```python
;
```
```python
}
```
```python
// 正在处理图片时，则直接返回
```
```python
if
```
```python
(
```
```python
isProcessingFrame
```
```python
)
```
```python
{
```
```python
image
```
```python
.
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
return
```
```python
;
```
```python
}
```
```python
// yuv转换为rgb格式
```
```python
isProcessingFrame
```
```python
=
```
```python
true
```
```python
;
```
```python
Trace
```
```python
.
```
```python
beginSection
```
```python
(
```
```python
"imageAvailable"
```
```python
)
```
```python
;
```
```python
final
```
```python
Plane
```
```python
[
```
```python
]
```
```python
planes
```
```python
=
```
```python
image
```
```python
.
```
```python
getPlanes
```
```python
(
```
```python
)
```
```python
;
```
```python
fillBytes
```
```python
(
```
```python
planes
```
```python
,
```
```python
yuvBytes
```
```python
)
```
```python
;
```
```python
yRowStride
```
```python
=
```
```python
planes
```
```python
[
```
```python
0
```
```python
]
```
```python
.
```
```python
getRowStride
```
```python
(
```
```python
)
```
```python
;
```
```python
final
```
```python
int
```
```python
uvRowStride
```
```python
=
```
```python
planes
```
```python
[
```
```python
1
```
```python
]
```
```python
.
```
```python
getRowStride
```
```python
(
```
```python
)
```
```python
;
```
```python
final
```
```python
int
```
```python
uvPixelStride
```
```python
=
```
```python
planes
```
```python
[
```
```python
1
```
```python
]
```
```python
.
```
```python
getPixelStride
```
```python
(
```
```python
)
```
```python
;
```
```python
imageConverter
```
```python
=
```
```python
new
```
```python
Runnable
```
```python
(
```
```python
)
```
```python
{
```
```python
@Override
```
```python
public
```
```python
void
```
```python
run
```
```python
(
```
```python
)
```
```python
{
```
```python
ImageUtils
```
```python
.
```
```python
convertYUV420ToARGB8888
```
```python
(
```
```python
yuvBytes
```
```python
[
```
```python
0
```
```python
]
```
```python
,
```
```python
yuvBytes
```
```python
[
```
```python
1
```
```python
]
```
```python
,
```
```python
yuvBytes
```
```python
[
```
```python
2
```
```python
]
```
```python
,
```
```python
previewWidth
```
```python
,
```
```python
previewHeight
```
```python
,
```
```python
yRowStride
```
```python
,
```
```python
uvRowStride
```
```python
,
```
```python
uvPixelStride
```
```python
,
```
```python
rgbBytes
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
;
```
```python
postInferenceCallback
```
```python
=
```
```python
new
```
```python
Runnable
```
```python
(
```
```python
)
```
```python
{
```
```python
@Override
```
```python
public
```
```python
void
```
```python
run
```
```python
(
```
```python
)
```
```python
{
```
```python
image
```
```python
.
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
isProcessingFrame
```
```python
=
```
```python
false
```
```python
;
```
```python
}
```
```python
}
```
```python
;
```
```python
// 这儿是关键，利用训练模型来预测图片，后面详细分析
```
```python
processImage
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
final
```
```python
Exception e
```
```python
)
```
```python
{
```
```python
LOGGER
```
```python
.
```
```python
e
```
```python
(
```
```python
e
```
```python
,
```
```python
"Exception!"
```
```python
)
```
```python
;
```
```python
Trace
```
```python
.
```
```python
endSection
```
```python
(
```
```python
)
```
```python
;
```
```python
return
```
```python
;
```
```python
}
```
```python
Trace
```
```python
.
```
```python
endSection
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
onImageAvailable()先做一些预校验，如previewWidth是否被设置，当前是否正在处理图片等。然后将相机捕获的yuv格式图像转为rgb格式。最后，也是最重要的一步，调用processImage，利用TensorFlow模型来处理图片。下面我们详细分析processImage
```python
protected
```
```python
void
```
```python
processImage
```
```python
(
```
```python
)
```
```python
{
```
```python
// 图片的绘制等，不是模型预测的重点，不分析了
```
```python
rgbFrameBitmap
```
```python
.
```
```python
setPixels
```
```python
(
```
```python
getRgbBytes
```
```python
(
```
```python
)
```
```python
,
```
```python
0
```
```python
,
```
```python
previewWidth
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
previewWidth
```
```python
,
```
```python
previewHeight
```
```python
)
```
```python
;
```
```python
final
```
```python
Canvas canvas
```
```python
=
```
```python
new
```
```python
Canvas
```
```python
(
```
```python
croppedBitmap
```
```python
)
```
```python
;
```
```python
canvas
```
```python
.
```
```python
drawBitmap
```
```python
(
```
```python
rgbFrameBitmap
```
```python
,
```
```python
frameToCropTransform
```
```python
,
```
```python
null
```
```python
)
```
```python
;
```
```python
// For examining the actual TF input.
```
```python
if
```
```python
(
```
```python
SAVE_PREVIEW_BITMAP
```
```python
)
```
```python
{
```
```python
ImageUtils
```
```python
.
```
```python
saveBitmap
```
```python
(
```
```python
croppedBitmap
```
```python
)
```
```python
;
```
```python
}
```
```python
// 利用分类器classifier对图片进行预测分析，得到图片为每个分类的概率. 比较耗时，放在子线程中
```
```python
runInBackground
```
```python
(
```
```python
new
```
```python
Runnable
```
```python
(
```
```python
)
```
```python
{
```
```python
@Override
```
```python
public
```
```python
void
```
```python
run
```
```python
(
```
```python
)
```
```python
{
```
```python
final
```
```python
long
```
```python
startTime
```
```python
=
```
```python
SystemClock
```
```python
.
```
```python
uptimeMillis
```
```python
(
```
```python
)
```
```python
;
```
```python
// 1 classifier对图片进行识别，得到输入图片为每个分类的概率
```
```python
final
```
```python
List
```
```python
<
```
```python
Classifier
```
```python
.
```
```python
Recognition
```
```python
>
```
```python
results
```
```python
=
```
```python
classifier
```
```python
.
```
```python
recognizeImage
```
```python
(
```
```python
croppedBitmap
```
```python
)
```
```python
;
```
```python
lastProcessingTimeMs
```
```python
=
```
```python
SystemClock
```
```python
.
```
```python
uptimeMillis
```
```python
(
```
```python
)
```
```python
-
```
```python
startTime
```
```python
;
```
```python
LOGGER
```
```python
.
```
```python
i
```
```python
(
```
```python
"Detect: %s"
```
```python
,
```
```python
results
```
```python
)
```
```python
;
```
```python
// 2 将得到的前三个最大概率的分类的名字及概率，反馈到app上。也就是results区域
```
```python
cropCopyBitmap
```
```python
=
```
```python
Bitmap
```
```python
.
```
```python
createBitmap
```
```python
(
```
```python
croppedBitmap
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
resultsView
```
```python
==
```
```python
null
```
```python
)
```
```python
{
```
```python
resultsView
```
```python
=
```
```python
(
```
```python
ResultsView
```
```python
)
```
```python
findViewById
```
```python
(
```
```python
R
```
```python
.
```
```python
id
```
```python
.
```
```python
results
```
```python
)
```
```python
;
```
```python
}
```
```python
resultsView
```
```python
.
```
```python
setResults
```
```python
(
```
```python
results
```
```python
)
```
```python
;
```
```python
// 3 请求重绘，并准备下一次的识别
```
```python
requestRender
```
```python
(
```
```python
)
```
```python
;
```
```python
readyForNextImage
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
)
```
```python
;
```
```python
}
```
processImage()先做图片绘制方面的工作，将相机捕获的图片绘制出来。然后利用分类器classifier来识别图片，获取图片为每个分类的概率。最后将概率最大的前三个分类，展示在result区域上。这儿我们重点来看分类器是如何来识别图片的。也就是classifier.recognizeImage()
```python
public
```
```python
List
```
```python
<
```
```python
Recognition
```
```python
>
```
```python
recognizeImage
```
```python
(
```
```python
final
```
```python
Bitmap bitmap
```
```python
)
```
```python
{
```
```python
// 1 预处理输入图片，读取像素点，并将RGB三通道数值归一化. 归一化后分布于 -117 ~ 138
```
```python
bitmap
```
```python
.
```
```python
getPixels
```
```python
(
```
```python
intValues
```
```python
,
```
```python
0
```
```python
,
```
```python
bitmap
```
```python
.
```
```python
getWidth
```
```python
(
```
```python
)
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
bitmap
```
```python
.
```
```python
getWidth
```
```python
(
```
```python
)
```
```python
,
```
```python
bitmap
```
```python
.
```
```python
getHeight
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
intValues
```
```python
.
```
```python
length
```
```python
;
```
```python
++
```
```python
i
```
```python
)
```
```python
{
```
```python
final
```
```python
int
```
```python
val
```
```python
=
```
```python
intValues
```
```python
[
```
```python
i
```
```python
]
```
```python
;
```
```python
floatValues
```
```python
[
```
```python
i
```
```python
*
```
```python
3
```
```python
+
```
```python
0
```
```python
]
```
```python
=
```
```python
(
```
```python
(
```
```python
(
```
```python
val
```
```python
>>
```
```python
16
```
```python
)
```
```python
&
```
```python
0xFF
```
```python
)
```
```python
-
```
```python
imageMean
```
```python
)
```
```python
/
```
```python
imageStd
```
```python
;
```
```python
// 归一化通道R
```
```python
floatValues
```
```python
[
```
```python
i
```
```python
*
```
```python
3
```
```python
+
```
```python
1
```
```python
]
```
```python
=
```
```python
(
```
```python
(
```
```python
(
```
```python
val
```
```python
>>
```
```python
8
```
```python
)
```
```python
&
```
```python
0xFF
```
```python
)
```
```python
-
```
```python
imageMean
```
```python
)
```
```python
/
```
```python
imageStd
```
```python
;
```
```python
// 归一化通道G
```
```python
floatValues
```
```python
[
```
```python
i
```
```python
*
```
```python
3
```
```python
+
```
```python
2
```
```python
]
```
```python
=
```
```python
(
```
```python
(
```
```python
val
```
```python
&
```
```python
0xFF
```
```python
)
```
```python
-
```
```python
imageMean
```
```python
)
```
```python
/
```
```python
imageStd
```
```python
;
```
```python
// 归一化通道B
```
```python
}
```
```python
Trace
```
```python
.
```
```python
endSection
```
```python
(
```
```python
)
```
```python
;
```
```python
// 2 将输入数据填充到TensorFlow中，并feed数据给模型
```
```python
// inputName为输入节点
```
```python
// floatValues为输入tensor的数据源，
```
```python
// dims构成了tensor的shape, [batch_size, height, width, in_channel], 此处为[1, inputSize, inputSize, 3]
```
```python
Trace
```
```python
.
```
```python
beginSection
```
```python
(
```
```python
"feed"
```
```python
)
```
```python
;
```
```python
inferenceInterface
```
```python
.
```
```python
feed
```
```python
(
```
```python
inputName
```
```python
,
```
```python
floatValues
```
```python
,
```
```python
1
```
```python
,
```
```python
inputSize
```
```python
,
```
```python
inputSize
```
```python
,
```
```python
3
```
```python
)
```
```python
;
```
```python
Trace
```
```python
.
```
```python
endSection
```
```python
(
```
```python
)
```
```python
;
```
```python
// 3 跑TensorFlow预测模型
```
```python
// outputNames为输出节点名， 通过session来run tensor
```
```python
Trace
```
```python
.
```
```python
beginSection
```
```python
(
```
```python
"run"
```
```python
)
```
```python
;
```
```python
inferenceInterface
```
```python
.
```
```python
run
```
```python
(
```
```python
outputNames
```
```python
,
```
```python
logStats
```
```python
)
```
```python
;
```
```python
Trace
```
```python
.
```
```python
endSection
```
```python
(
```
```python
)
```
```python
;
```
```python
// 4 将tensorflow预测模型输出节点的输出值拷贝出来
```
```python
// 找到输出节点outputName的tensor，并复制到outputs中。outputs为分类预测的结果，是一个一维向量，每个值对应labels中一个分类的概率。
```
```python
Trace
```
```python
.
```
```python
beginSection
```
```python
(
```
```python
"fetch"
```
```python
)
```
```python
;
```
```python
inferenceInterface
```
```python
.
```
```python
fetch
```
```python
(
```
```python
outputName
```
```python
,
```
```python
outputs
```
```python
)
```
```python
;
```
```python
Trace
```
```python
.
```
```python
endSection
```
```python
(
```
```python
)
```
```python
;
```
```python
// 5 得到概率最大的前三个分类，并组装为Recognition对象
```
```python
PriorityQueue
```
```python
<
```
```python
Recognition
```
```python
>
```
```python
pq
```
```python
=
```
```python
new
```
```python
PriorityQueue
```
```python
<
```
```python
Recognition
```
```python
>
```
```python
(
```
```python
3
```
```python
,
```
```python
new
```
```python
Comparator
```
```python
<
```
```python
Recognition
```
```python
>
```
```python
(
```
```python
)
```
```python
{
```
```python
@Override
```
```python
public
```
```python
int
```
```python
compare
```
```python
(
```
```python
Recognition lhs
```
```python
,
```
```python
Recognition rhs
```
```python
)
```
```python
{
```
```python
// Intentionally reversed to put high confidence at the head of the queue.
```
```python
return
```
```python
Float
```
```python
.
```
```python
compare
```
```python
(
```
```python
rhs
```
```python
.
```
```python
getConfidence
```
```python
(
```
```python
)
```
```python
,
```
```python
lhs
```
```python
.
```
```python
getConfidence
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
outputs
```
```python
.
```
```python
length
```
```python
;
```
```python
++
```
```python
i
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
outputs
```
```python
[
```
```python
i
```
```python
]
```
```python
>
```
```python
THRESHOLD
```
```python
)
```
```python
{
```
```python
pq
```
```python
.
```
```python
add
```
```python
(
```
```python
new
```
```python
Recognition
```
```python
(
```
```python
""
```
```python
+
```
```python
i
```
```python
,
```
```python
labels
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
>
```
```python
i
```
```python
?
```
```python
labels
```
```python
.
```
```python
get
```
```python
(
```
```python
i
```
```python
)
```
```python
:
```
```python
"unknown"
```
```python
,
```
```python
outputs
```
```python
[
```
```python
i
```
```python
]
```
```python
,
```
```python
null
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
final
```
```python
ArrayList
```
```python
<
```
```python
Recognition
```
```python
>
```
```python
recognitions
```
```python
=
```
```python
new
```
```python
ArrayList
```
```python
<
```
```python
Recognition
```
```python
>
```
```python
(
```
```python
)
```
```python
;
```
```python
int
```
```python
recognitionsSize
```
```python
=
```
```python
Math
```
```python
.
```
```python
min
```
```python
(
```
```python
pq
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
,
```
```python
MAX_RESULTS
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
recognitionsSize
```
```python
;
```
```python
++
```
```python
i
```
```python
)
```
```python
{
```
```python
recognitions
```
```python
.
```
```python
add
```
```python
(
```
```python
pq
```
```python
.
```
```python
poll
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
Trace
```
```python
.
```
```python
endSection
```
```python
(
```
```python
)
```
```python
;
```
```python
// "recognizeImage"
```
```python
return
```
```python
recognitions
```
```python
;
```
```python
}
```
图片识别主要分为5步
预处理输入图片，读取像素点，并将RGB三通道数值归一化. 归一化后分布于 -117 ~ 138
将输入数据填充到TensorFlow中，并feed数据给模型
跑TensorFlow预测模型
将tensorflow预测模型输出节点的输出值拷贝出来
得到概率最大的前三个分类，并组装为Recognition对象
TensorFlow-Android sdk对TensorFlow封装得很好，暴露了TensorFlowInferenceInterface这个对象来作为接口供我们调用底层TensorFlow代码。其中feed用来填充输入图片，run用来跑模型并得到结果，fetch用来从TensorFlow内部获取输出节点的输出值。
这样我们就将打开摄像头，注册监听器，构造分类器classifier，预处理相机图片和利用模型预测图片分类的整个流程分析清楚了。对于自己实现一个应用TensorFlow模型的Android app应该了然于心了吧。
## 4 总结
掌握了官方demo的整个流程后，我们完全可以一方面改造app，来定制我们其他功能需求，比如实现一个相册中照片识别分类的app。另一方面替换模型为自己训练好的其他模型，比如将官方的inceptionV1替换为更小的mobilenet。随着深度学习在终端应用的普及，TensorFlow在Android上的应用将会发挥更大的用武之地。
系列文章，请多关注
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[带你深入AI（2）- 深度学习激活函数，准确率，优化方法等总结](https://blog.csdn.net/u013510838/article/details/79845455)
[带你深入AI（3）- 物体分类领域：AlexNet VGG Inception ResNet mobileNet](https://blog.csdn.net/u013510838/article/details/79866740)
[带你深入AI（4）- 目标检测领域：R-CNN，faster R-CNN，yolo，SSD, yoloV2](https://blog.csdn.net/u013510838/article/details/79947553)
[带你深入AI（5）- 自然语言处理领域：RNN LSTM GRU](https://blog.csdn.net/u013510838/article/details/80024144)
[带你深入AI（6）- 详解bazel](https://blog.csdn.net/u013510838/article/details/80102438)
[带你深入AI（7）- 深度学习重要Python库](https://blog.csdn.net/u013510838/article/details/80412127)

