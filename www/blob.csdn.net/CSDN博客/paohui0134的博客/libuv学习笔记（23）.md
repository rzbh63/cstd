
# libuv学习笔记（23） - paohui0134的博客 - CSDN博客


2016年07月02日 14:32:16[paohui0134](https://me.csdn.net/paohui0134)阅读数：650


# libuv学习笔记（23）
## 线程相关数据结构与函数（1）
### 数据结构
```python
typedef
```
```python
HANDLE uv_thread_t;
```
```python
//就是句柄
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
//线程局部变量使用
```
```python
DWORD tls_index;
} uv_key_t;
```
```python
typedef
```
```python
struct
```
```python
uv_once_s {
```
```python
//libuv用此结构保证某一函数只执行一次
```
```python
unsigned
```
```python
char
```
```python
ran;
  HANDLE event;
} uv_once_t;
```
```python
typedef
```
```python
CRITICAL_SECTION uv_mutex_t;
```
```python
//通过临界区实现互斥量
```
### 线程相关API
#### 创建线程
```python
int uv_thread_create(uv_thread_t
```
```python
*
```
```python
tid,
```
```python
void
```
```python
(
```
```python
*
```
```python
entry)(
```
```python
void
```
```python
*
```
```python
arg),
```
```python
void
```
```python
*
```
```python
arg) {
  struct thread_ctx
```
```python
*
```
```python
ctx;
  int err;
```
```python
HANDLE
```
```python
thread
```
```python
;
  ctx
```
```python
=
```
```python
uv__malloc(sizeof(
```
```python
*
```
```python
ctx));
```
```python
//将在uv__thread_start中释放
```
```python
if
```
```python
(ctx
```
```python
==
```
```python
NULL
```
```python
)
```
```python
return
```
```python
UV_ENOMEM;
  ctx
```
```python
->
```
```python
entry
```
```python
=
```
```python
entry;
  ctx
```
```python
->
```
```python
arg
```
```python
=
```
```python
arg;
```
```python
//创建线程
```
```python
thread
```
```python
=
```
```python
(
```
```python
HANDLE
```
```python
) _beginthreadex(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
                                   uv__thread_start,
                                   ctx,
                                   CREATE_SUSPENDED,
```
```python
NULL
```
```python
);
```
```python
if
```
```python
(
```
```python
thread
```
```python
==
```
```python
NULL
```
```python
) {
    err
```
```python
=
```
```python
errno;
    uv__free(ctx);
  }
```
```python
else
```
```python
{
    err
```
```python
=
```
```python
0
```
```python
;
```
```python
*
```
```python
tid
```
```python
=
```
```python
thread
```
```python
;
    ctx
```
```python
->
```
```python
self
```
```python
=
```
```python
thread
```
```python
;
    ResumeThread(
```
```python
thread
```
```python
);
  }
  switch (err) {
```
```python
case
```
```python
0
```
```python
:
```
```python
return
```
```python
0
```
```python
;
```
```python
case
```
```python
EACCES:
```
```python
return
```
```python
UV_EACCES;
```
```python
case
```
```python
EAGAIN:
```
```python
return
```
```python
UV_EAGAIN;
```
```python
case
```
```python
EINVAL:
```
```python
return
```
```python
UV_EINVAL;
  }
```
```python
return
```
```python
UV_EIO;
}
```
新线程调用的函数
```python
static
```
```python
UINT __stdcall uv__thread_start(
```
```python
void
```
```python
* arg) {
```
```python
struct
```
```python
thread_ctx *ctx_p;
```
```python
struct
```
```python
thread_ctx ctx;
  ctx_p = arg;
  ctx = *ctx_p;
  uv__free(ctx_p);
```
```python
//释放
```
```python
//调用uv_key_create初始化TLS  key   uv__current_thread_key
```
```python
uv_once(&uv__current_thread_init_guard, uv__init_current_thread_key);
```
```python
//将本线程的句柄存入线程本地存储，通过uv__current_thread_key标识
```
```python
uv_key_set(&uv__current_thread_key, (
```
```python
void
```
```python
*) ctx.self);
  ctx.entry(ctx.arg);
```
```python
//调用真正的任务函数
```
```python
return
```
```python
0
```
```python
;
}
```
#### 获取线程句柄，需要在线程中调用，该线程通过uv_thread_create创建
```python
uv_thread_t
```
```python
uv_thread_self(void)
```
```python
{
```
```python
uv_once(&uv__current_thread_init_guard, uv__init_current_thread_key)
```
```python
;
  return (uv_thread_t)
```
```python
uv_key_get(&uv__current_thread_key)
```
```python
;
}
```
#### 等待线程执行完成
```python
int
```
```python
uv_thread_join(uv_thread_t
```
```python
*tid
```
```python
) {
```
```python
if
```
```python
(WaitForSingleObject(
```
```python
*tid
```
```python
, INFINITE))
```
```python
return
```
```python
uv_translate_sys_error(GetLastError());
```
```python
else
```
```python
{
    CloseHandle(
```
```python
*tid
```
```python
);
```
```python
*tid
```
```python
=
```
```python
0
```
```python
;
```
```python
return
```
```python
0
```
```python
;
  }
}
```
### 线程本地存储
#### 创建TLS key，注意线程本地存储大小有限，本函数可能会失败，无法创建更多的本地存储
```python
int
```
```python
uv_key_create(uv_key_t* key) {
  key->tls_index = TlsAlloc();
```
```python
if
```
```python
(key->tls_index == TLS_OUT_OF_INDEXES)
```
```python
return
```
```python
UV_ENOMEM;
```
```python
return
```
```python
0
```
```python
;
}
```
#### 释放线程本地存储变量
```python
void
```
```python
uv_key_delete(uv_key_t
```
```python
*
```
```python
key) {
```
```python
if
```
```python
(TlsFree(key
```
```python
->
```
```python
tls_index)
```
```python
==
```
```python
FALSE
```
```python
)
```
```python
abort
```
```python
();
  key
```
```python
->
```
```python
tls_index
```
```python
=
```
```python
TLS_OUT_OF_INDEXES;
}
```
#### 获取线程本地存储变量
```python
void
```
```python
* uv_key_get(uv_key_t* key) {
```
```python
void
```
```python
*
```
```python
value
```
```python
;
```
```python
value
```
```python
= TlsGetValue(key->tls_index);
```
```python
//调用API
```
```python
if
```
```python
(
```
```python
value
```
```python
== NULL)
```
```python
if
```
```python
(GetLastError() != ERROR_SUCCESS)
      abort();
```
```python
return
```
```python
value
```
```python
;
}
```
#### 设置线程本地存储变量
```python
void
```
```python
uv_key_set(uv_key_t
```
```python
*
```
```python
key,
```
```python
void
```
```python
*
```
```python
value) {
```
```python
if
```
```python
(TlsSetValue(key
```
```python
->
```
```python
tls_index, value)
```
```python
==
```
```python
FALSE
```
```python
)
```
```python
//TLS API
```
```python
abort
```
```python
();
}
```
### 只运行一次的方法，通过uv_once_t标识
```python
void
```
```python
uv_once(uv_once_t
```
```python
*
```
```python
guard,
```
```python
void
```
```python
(
```
```python
*
```
```python
callback)(
```
```python
void
```
```python
)) {
```
```python
if
```
```python
(guard
```
```python
->
```
```python
ran) {
```
```python
//如果正在运行，返回
```
```python
return
```
```python
;
  }
  uv__once_inner(guard, callback);
}
```
```python
static
```
```python
void
```
```python
uv__once_inner(uv_once_t
```
```python
*
```
```python
guard,
```
```python
void
```
```python
(
```
```python
*
```
```python
callback)(
```
```python
void
```
```python
)) {
  DWORD result;
```
```python
HANDLE
```
```python
existing_event, created_event;
  created_event
```
```python
=
```
```python
CreateEvent(
```
```python
NULL
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//创建事件句柄
```
```python
if
```
```python
(created_event
```
```python
==
```
```python
0
```
```python
) {
    uv_fatal_error(GetLastError(),
```
```python
"CreateEvent"
```
```python
);
  }
```
```python
//原子改变变量的值，并返回原来的值
```
```python
existing_event
```
```python
=
```
```python
InterlockedCompareExchangePointer(
```
```python
&
```
```python
guard
```
```python
->
```
```python
event,
                                                     created_event,
```
```python
NULL
```
```python
);
```
```python
//如果existing_event 原来为空，表示是第一次执行
```
```python
if
```
```python
(existing_event
```
```python
==
```
```python
NULL
```
```python
) {
    callback();
```
```python
//调用回调
```
```python
result
```
```python
=
```
```python
SetEvent(created_event);
```
```python
//改变event状态
```
```python
assert(result);
    guard
```
```python
->
```
```python
ran
```
```python
=
```
```python
1
```
```python
;
```
```python
//已经运行，修改表计量
```
```python
}
```
```python
else
```
```python
{
```
```python
//并不是第一次，说明有线程通过相同的uv_once_t在本线程之前调用了uv_once
```
```python
CloseHandle(created_event);
```
```python
//等待直到先运行的线程调用回调函数执行完成
```
```python
result
```
```python
=
```
```python
WaitForSingleObject(existing_event, INFINITE);
    assert(result
```
```python
==
```
```python
WAIT_OBJECT_0);
  }
}
```
### 互斥锁相关函数
#### 初始化
```python
int
```
```python
uv_mutex_init(uv_mutex_t* mutex) {
  InitializeCriticalSection(mutex);
```
```python
//初始化临界区
```
```python
return
```
```python
0
```
```python
;
}
```
#### 释放互斥锁
```python
void
```
```python
uv_mutex_destroy(uv_mutex_t* mutex)
```
```python
{
```
```python
DeleteCriticalSection(mutex)
```
```python
;
```
```python
//释放临界区
```
```python
}
```
#### 锁定
```python
void
```
```python
uv_mutex_lock(uv_mutex_t* mutex)
```
```python
{
```
```python
EnterCriticalSection(mutex)
```
```python
;
```
```python
//进入临界区
```
```python
}
```
#### 尝试锁定
```python
int
```
```python
uv_mutex_trylock(uv_mutex_t* mutex) {
```
```python
if
```
```python
(TryEnterCriticalSection(mutex))
```
```python
//尝试进入临界区
```
```python
return
```
```python
0
```
```python
;
```
```python
else
```
```python
return
```
```python
UV_EBUSY;
}
```
#### 解锁
```python
void
```
```python
uv_mutex_unlock(uv_mutex_t* mutex)
```
```python
{
```
```python
LeaveCriticalSection(mutex)
```
```python
;
```
```python
//离开临界区
```
```python
}
```

