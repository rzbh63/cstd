
# 在分类及预测任务中对高维类别（category）变量的预处理方法 - OraYang的博客 - CSDN博客

2017年11月12日 19:20:48[OraYang](https://me.csdn.net/u010665216)阅读数：3844所属专栏：[机器学习](https://blog.csdn.net/column/details/16605.html)



## 引言
众所周知，数据挖掘中大约有80%的时间被用来做数据预处理。其中高维类别数据是数据挖掘算法（比如神经网络、线性or逻辑回归、SVM）最具挑战性的数据类型。事实上，在一些像决策树或者一些规则归纳的学习算法中，对类别数据并不需要额外的处理。但是一些回归算法却需要将每一个输入特征都转变成数值类型的特征。而且在现实生活中，我们需要解决的分类或者预测问题的数据集中，充满了类别属性，比如：ZIP码，SIC，IP，区号，域名等等。这就需要有种系统的方法能够将高维类别数据映射到可供回归任务学习的准连续标量属性上。我读了篇SIGKDD上的解决上述问题的文章：[A Preprocessing Scheme for High-Cardinality Categorical ](http://download.csdn.net/download/u010665216/10115124)
Attributes in Classification and Prediction Problems[，并总结了文章的方法，特分享如下。](http://download.csdn.net/download/u010665216/10115124)
## 文章方法综述
该论文提出了一种将高维类别属性的数据映射到可供回归任务学习的准连续标量属性上。转换的关键之处在于将**高维类别属性的每个值映射成基于目标属性的概率估计**。
> 在分类场景下，被映射成，给定类别属性值的条件下，目标属性的后验概率。

> 在预测场景下，被映射成，给定类别属性值的条件下，目标的期望值。
该方法听起来是统计相关的，而且可以应用于分类与回归的任务场景中，它还优雅地处理了类别属性是缺失值的情况。这种方法听起来是不是牛掰爆了，大家会担心，这种方法是不是很难呀。在这里我要说的是：很简单~。论文的组织结构如下：第二节讲述了处理类别属性的最通用的方法；第三节讲述了本文要重点分析的方法；第四节描述了该方法在层次化数据上的应用拓展；第五节就总结了文章。接下来，本文也会按照论文的组织结构，给大家分析下这篇论文的。
## 处理类别属性的通用方法
这里处理类别属性的通用方法有两大类，这两大类按照数据的维度划分。因此可以分为低维类别数据及高维类别数据。
### 低维类别数据预处理方法
对于低维度的类别数据最普遍的做法就是二值化。我们简单举个例子：
|ID|Gender|Color of cloth|
|---|---|---|
|1|male|blue|
|2|female|white|
|3|male|red|
上面的表格中存放了我们构造的三个样本数据，其中属性栏，有三个属性，ID，Gender，Color of cloth，其中很明显，Gender与Color of cloth是类别属性。我们将其二值化，从而将二值化后的新表格如下图所示：
|ID|male|female|blue|white|red|
|---|---|---|---|---|---|
|1|1|0|1|0|0|
|2|0|1|0|1|0|
|3|1|0|0|0|1|
二值化编码的核心思想就是将第i个组成标记为1，其余标记为0。这是一种1到N的映射关系，当面对高维类别数据即N很大的时候，这种方法就不太适用（矩阵很稀疏）。那么为了解决高维类别属性，又该采用何种方法呢？
### 高维类别数据
现如今，处理高维类别数据的最常用方法就是聚类。核心思想就是将1到N的映射问题降维到1到K的映射问题上来（$k\ll N$）。
因此该方法的工作流程就是：
> *先采用诸如层次聚类的聚类算法，有效地将N个原始数据聚类成K个簇

> *再将K个簇二值化

> 然后论文就说了下这些通用方法的缺点啊，不足啊，又吹捧了下自己提出的方法。

> 使用目标统计方法来对类别属性进行编码

> 终于来到正文了，首先说下，接下来提到的方法，就如我们章节标题所写，是个典型的统计学方法，而且历史悠久，应用领域颇多，但是，在类似这些分类预测任务中作为预处理方法的应用，其他文献没有提到过，所以文章还是有一定创新性的。

> 这一章节将按照目标变量的类型分成三个小节：二值型变量、连续型变量、多类别变量

> 二值型变量

> 当目标属性
> Y
> 是二值的，
> Y\in\{0，1\}
> ，将高维类别属性
> X
> 的一个值
> X_i
> 映射成一个标量
> S_i
> ，其中
> S_i
> 就代表给定
> X=X_i
> 的条件下
> Y=1
> 的概率估计：

> X_i \to S_i \cong P(Y|X=X_i) \tag{$1$}

> 有了这个映射关系，接下来就需要来算出这个“概率估计”了。这里我们假设训练集有
> n_{TR}
> 个样本，测试集有
> n_{TS}
> 个样本。既然
> 概率估计是在训练模型过程中的一部分
> （即概率估计是发生在模型训练的过程中，而不是测试模型时），那么概率估计只与训练数据的
> n_{TR}
> 个样本有关。

> 假如训练样本足够大，那么概率估计直接可以用下面的公式计算：

> S_i=\frac{n_{iY}}{n_i} \tag{$2$}

> 其中
> n_i
> 是
> X_i
> 的数量，
> n_{iY}
> 是
> Y=1
> 的数量。

> 但是在实际场景中，
> n_i
> 的数量很小，因此公式（2）来计算后验概率并不是很可信。为了削弱某些样本个数较小带来的影响，文章提出了一种计算混合概率的方法：将公式（2）的后验概率与Y的先验概率同时利用起来。方法如下：

> S_i = \lambda(n_i)\frac{n_{iY}}{n_i}+(1-\lambda(n_i))\frac{n_Y}{n_{TR}}\tag{$3$}

> 其中
> n_Y
> 是
> Y=1
> 的训练样本数，权重因子
> \lambda(n_i)
> 是边界为0，1的单调递增函数。

> 当
> n_i
> 的数量很大的时候，
> \lambda \cong 1
> ，我们给后验概率分配更多的权重，此时等价于公式（2）；但是如果
> n_i
> 的数量很小，
> \lambda \cong 0
> ，我们直接采用先验概率。

> 其中可以给权重因子指定一个函数，例如：

> \lambda(n) = \frac{1}{1+e^{-\frac{n-k}{f}}} \tag{$4$}

> 很显然，该函数是个sigmoid函数变种。当n=k时，函数大小为0.5，此处为S型曲线的拐点。参数
> f
> 控制该函数在拐点处的斜率。

> 公式（3）在统计与精算学中有着很长的一段历史。事实上公式（3）是贝叶斯概率的分支之一被称作经验贝叶斯（Empirical Bayesian）。

> 公式如下：

> P_i = B_iy_i+(1-B_i)\bar{y}\tag{$5$}

> 其中
> \bar{y}
> 指先验概率，
> y_i
> 指后验概率。
> B_i
> 称作shrinkage因子（
> 0< B<1
> ）。假设数据及后验估计的概率分布均满足高斯分布，那么
> B_i
> 采用如下形式：

> B_i=\frac{n_i\tau^2}{\sigma^2+n_i\tau^2}\tag{$6$}

> 其中
> \sigma^2
> 为
> X=X_i
> 数据集方差，
> \tau^2
> 是整个样本的方差。
> n_i
> 是
> X=X_i
> 数据集的大小。很显然
> B_i
> 是
> \lambda(n)
> 的一种特殊形式，
> B_i
> 不仅考虑了样本大小，还考虑了数据集的方差。

> 处理缺失数据

> 在大多数情况下，数据集里会存在缺失数据。根据属性的特性及所采用的具体算法有不同的处理方法：

> 如果
> X
> 是数值型数据，一般通过均值或者基于其他属性的估计来填充空缺值

> 如果
> X
> 是低维类别数据，那么如果采用二值化编码（有m个元素的向量），那么空缺值可以初始化为m个0的向量。

> 有些决策树算法会直接丢弃空缺值，或者用另外一个值来填充。

> 这篇论文提出了一种方法来补全空缺值：引入一个空缺值
> X_0
> ，然后再给定条件
> X=X_0
> 的情况下求：

> S_0=\lambda(n_0)\frac{n_{0Y}}{n_0}+(11-\lambda(n_0))\frac{n_Y}{n_{TR}}\tag{$7$}

> 这个方法的好处是，如果缺失值与目标值有很大相关性，那么这个公式就能很好的表达出相关信息。如果缺失值与目标值没有太大关系，那么
> S_0
> 也会很快收敛于先验概率，这也是对缺失值的中立表示。

> 连续型变量

> 上面提出的方法，也能应用到目标变量是连续值得情况下。无非就是将
> 概率估计
> 转变成
> 期望估计
> 。现在我们就是要考虑期望了，公式如下：

> S_i =\lambda(n_i)\frac{\sum_{k\in L_i}Y_k}{n_i}+(1-\lambda(n_i))\frac{\sum^{N_{TR}}_{k=1}Y_k}{n_{TR}} \tag{$8$}

> 多类别变量

> 当目标变量是多类别的，扩展的方法也很直接，就是直接求

> P(Y=Y_j|X=X_i)\tag{$9$}

> 在具有层次结构类别数据上的应用

> 一些高维类别数据通常是定义好的层次结构，这样便于做聚合运算。一个典型的案例就是美国的邮政编码系统：一个5位的ZIP码，如果在一个大都市区域，那么该ZIP码的前三位是一样的。所以可以在基于ZIP3或ZIP4的基础上聚合ZIP5。其他的一些例子像手机号码，IP地址都有这样的层次编码结构。

> 论文提出的方法可以很好的利用层次结构这一特性来讲结构数据进行转换。直接举例说明，以ZIP5编码作为说明。ZIP5级别的公式如下：

> S_i^5=\lambda(n_i)\frac{n_{il}}{n_i}+(1-\lambda(n_i))\frac{n_Y}{n_{TR}}\tag{$10$}

> 如果ZIP5类别很稀疏，那么可以“降维”成ZIP4，对ZIP4级别的类别数据进行估计。
> 因为大多数估计都与先验概率近似
> ，因此可以讲ZIP5级别的先验概率有ZIP4的估计代替：

> S_i^5=\lambda(n_i)\frac{n_{il}}{n_i}+(1-\lambda(n_i))S_i^4\tag{$11$}

> 以此类推ZIP3，ZIP2。从上述公式可以看到这个公式可以自动根据数据的密度进行调节。

> 总结

> 这篇论文，基本介绍完了，就是提出了EB（经验贝叶斯）的通用方法，然后应用到了机器学习分类回归任务的预处理中，关于这个方法到底好用不好用，现在我还不清楚，因为在做Kaggle一个赛题，有人分享了这篇文章，我分析了下，准备试试具体效果，如果效果好，我会再来给本文写个附加的评论的~


