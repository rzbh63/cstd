# 早期（编译期）优化

 		

Java语言的“编译期”是一段不确定的操作过程，可能是：

- 前端编译器（编译器的前端）把Java文件转换为class文件。Sun 的 Javac、 Eclipse JDT 中的增量式编译器（ ECJ）。
- 后端编译器（JIT编译期 Just in time compiler）把字节码变成机器码。JIT 编译器： HotSpot VM 的 C1、 C2 编译器。
- 静态编译器（AOT编译器 ahead of time compiler）直接把Java编译成本地机器代码。
- AOT 编译器： GNU Compiler for the Java（GCJ）、Excelsior JET。

Javac  这类编译器对代码的运行效率几乎没有任何优化措施，而虚拟机设计团队把对性能的优化集中到了后端的即时编译器中，这样可以让那些不是由javac产生的Class文件（如JRuby、Groovy等语言的Class文件）也同样能享受到编译器优化所带来的好处。

Javac做了很多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效率。相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖虚拟机的低层改进来支持。 
 Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。

本节中以Javac编译器作为示范来说明。

从Sun Javac的代码来看，编译过程大概可以分为3个部分，分别是：

- 解析与填充符号表过程；
- 插入式注解处理器的注解处理过程；
- 分析与字节码生成过程；

其关系如下图所示：

![java-compile](https://img-blog.csdn.net/20180220113400311?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzU5NTQxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# 解析与填充符号表

## 解析

解析部分分为词法分析和语法分析两部分。

- 词法分析是将源代码的字符流转变为标记(Token)集合，**单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素。**
- 语法分析是根据Token序列构造抽象语法树的过程。

> 标记(Token)是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。 
>    抽象语法树（Abstract Syntax  Tree,AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。

## 填充符号表

符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，可以想象成K-V的形式。

> 符号表中所登记的信息在编译的不同阶段都要用到。 
>    在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。

# 注解处理器

在JDK1.6中实现了JSR-269规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，可以将它简单的看作是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是关系图中的回环部分。

注解处理器是用于提供对注解的支持，可以将其看成一组编译器的插件

# 分析与字节码生成

这里的分析指的是语义分析。

在语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。是否合乎语义逻辑必须限定在具体的语言与具体的上下文环境之中才有意义。

Javac 的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个步骤。

## 标注检查

标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠。

> 常量折叠是指，比如代码里面定义” a= 1+ 2”，编译器会直接优化成为” a= 3”，这样做并不会增加程序运行期哪怕仅仅一个 CPU 指令的运算量。

## 数据及控制流分析

数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。

编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致，但是校验范围有所区别，有一些校验项只有在编译器或运行期才能进行。

## 解语法糖

语法糖(Syntactic Sugar)也称为糖衣语法，是由英国计算机科学家[彼得·约翰·兰达(Peter Landin)](https://www.wikiwand.com/en/Peter_Landin)发明的一个术语。指在计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。通常来说，使用语法糖能够增加程序的可读性，从而减少程序代码的出错机会。

在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。解语法糖的过程由 desugar() 方法触发。

## 字节码生成

字节码生成是 Javac 编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。

在完成了对语法树的遍历和调整之后，便会把填充了所有所需信息的符号表交给 `com. sun. tools. javac. jvm. ClassWriter` 类，由这个类的 writeClass() 方法输出字节码，生成最终的 Class 文件，到此为止整个编译过程宣告结束。

------

# Java语法糖

## 范型与类型擦除

Java 语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type， 也称为裸类型）了，并且在相应的地方插入了强制转型代码。

当然所谓的擦除，仅仅是对方法的 Code 属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。

## 自动装箱、拆箱与遍历循环

遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现 Iterable 接口的原因。 
 包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们 equals() 方法不处理数据转型的关系

## 条件编译

Java 语言当然也可以进行条件编译，方法就是使用条件为常量的 if 语句。