
# 数据结构实践——停车场模拟(栈和队列综合) - 迂者-贺利坚的专栏 - CSDN博客

2015年10月05日 22:04:54[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：13972


本文是针对[数据结构基础系列网络课程(3)：栈和队列](http://edu.csdn.net/course/detail/1405)的实践项目。
设停车场是一个可停放n辆汽车的狭长死胡同，南边封口，汽车只能从北边进出（这样的停车场世间少有）。汽车在停车场内按车辆到达时间的先后顺序，最先到达的第一辆车停放在车场的最南端，依次向北排开。若车场内已停满n辆汽车，则后来的汽车只能在门外的候车场上等候，一旦有车开走，则排在候车场上的第一辆车即可开入。当停车场内某辆车要离开时，在它之后进入的车辆必须先退出车场为它让路（假定停车场内设有供车辆进出的便道，所有的司机也必须在车内随时待命），待该辆车开出大门外，其他车辆再按原次序进入车场。每辆停放在车场的车在它离开停车场时，要按停留的时间长短交纳费用。试为停车场编制按上述要求进行管理的模拟程序。
![这里写图片描述](https://img-blog.csdn.net/20151005220250359)
> 提示：以栈模拟停车场，以队列模拟车场外的候车场，有车离开时，供车辆进出的便道也应该用栈表示。按照从键盘读入的输入数据序列进行模拟管理。汽车到达和离开时，每一组输入数据包括汽车牌照号码（设为整数）以及到达或离去的时刻（为简单化，也设为整数，如1，代表停车场开始营业的第1小时）。对每一组输入数据进行操作后的输出信息为：若是车辆到达，则输出汽车在停车场内或修车场上的停车位置；若是车辆离去，则输出汽车在停车场内停留的时间和应交纳的费用（在候车场上停留的时间不收费）。栈以顺序结构实现，队列以链表结构实现。
[参考解答]
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#define N 10                    /*停车场内最多的停车数*/
```
```python
#define M 10                    /*候车场内最多的停车数*/
```
```python
#define Price 2             /*每单位时间停车费用*/
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
CarNo[N];
```
```python
/*车牌号*/
```
```python
int
```
```python
CarTime[N];
```
```python
/*进场时间*/
```
```python
int
```
```python
top;
```
```python
/*栈指针*/
```
```python
} SqStack;
```
```python
/*定义顺序栈类型，用于描述停车场*/
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
CarNo[M];
```
```python
/*车牌号*/
```
```python
int
```
```python
front,rear;
```
```python
/*队首和队尾指针*/
```
```python
} SqQueue;
```
```python
/*定义循环队类型，用于描述候车场*/
```
```python
/*以下为顺序栈的基本运算算法*/
```
```python
void
```
```python
InitStack(SqStack *&s)
{
    s=(SqStack *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(SqStack));
    s->top=-
```
```python
1
```
```python
;
}
```
```python
int
```
```python
StackEmpty(SqStack *s)
{
```
```python
return
```
```python
(s->top==-
```
```python
1
```
```python
);
}
```
```python
int
```
```python
StackFull(SqStack *s)
{
```
```python
return
```
```python
(s->top==N-
```
```python
1
```
```python
);
}
```
```python
int
```
```python
Push(SqStack *&s,
```
```python
int
```
```python
e1,
```
```python
int
```
```python
e2)
{
```
```python
if
```
```python
(s->top==N-
```
```python
1
```
```python
)
```
```python
return
```
```python
0
```
```python
;
    s->top++;
    s->CarNo[s->top]=e1;
    s->CarTime[s->top]=e2;
```
```python
return
```
```python
1
```
```python
;
}
```
```python
int
```
```python
Pop(SqStack *&s,
```
```python
int
```
```python
&e1,
```
```python
int
```
```python
&e2)
{
```
```python
if
```
```python
(s->top==-
```
```python
1
```
```python
)
```
```python
return
```
```python
0
```
```python
;
    e1=s->CarNo[s->top];
    e2=s->CarTime[s->top];
    s->top--;
```
```python
return
```
```python
1
```
```python
;
}
```
```python
void
```
```python
DispStack(SqStack *s)
{
```
```python
int
```
```python
i;
```
```python
for
```
```python
(i=s->top; i>=
```
```python
0
```
```python
; i--)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,s->CarNo[i]);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
/*以下为循环队列的基本运算算法*/
```
```python
void
```
```python
InitQueue(SqQueue *&q)
{
    q=(SqQueue *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(SqQueue));
    q->front=q->rear=
```
```python
0
```
```python
;
}
```
```python
int
```
```python
QueueEmpty(SqQueue *q)
{
```
```python
return
```
```python
(q->front==q->rear);
}
```
```python
int
```
```python
QueueFull(SqQueue *q)
```
```python
/*判断队满*/
```
```python
{
```
```python
return
```
```python
((q->rear+
```
```python
1
```
```python
)%M==q->front);
}
```
```python
int
```
```python
enQueue(SqQueue *&q,
```
```python
int
```
```python
e)
```
```python
/*进队*/
```
```python
{
```
```python
if
```
```python
((q->rear+
```
```python
1
```
```python
)%M==q->front)
```
```python
/*队满*/
```
```python
return
```
```python
0
```
```python
;
    q->rear=(q->rear+
```
```python
1
```
```python
)%M;
    q->CarNo[q->rear]=e;
```
```python
return
```
```python
1
```
```python
;
}
```
```python
int
```
```python
deQueue(SqQueue *&q,
```
```python
int
```
```python
&e)
```
```python
/*出队*/
```
```python
{
```
```python
if
```
```python
(q->front==q->rear)
```
```python
/*队空的情况*/
```
```python
return
```
```python
0
```
```python
;
    q->front=(q->front+
```
```python
1
```
```python
)%M;
    e=q->CarNo[q->front];
```
```python
return
```
```python
1
```
```python
;
}
```
```python
void
```
```python
DispQueue(SqQueue *q)
```
```python
/*输出队中元素*/
```
```python
{
```
```python
int
```
```python
i;
    i=(q->front+
```
```python
1
```
```python
)%M;
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,q->CarNo[i]);
```
```python
while
```
```python
((q->rear-i+M)%M>
```
```python
0
```
```python
)
    {
        i=(i+
```
```python
1
```
```python
)%M;
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,q->CarNo[i]);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
//main函数用于模拟停车场的工作
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
comm;
```
```python
int
```
```python
no,e1,time,e2;
```
```python
int
```
```python
i,j,t;
    SqStack *St,*St1;
```
```python
//St是停车场，St1是在有车离开时，记录为该车移开位置的车辆
```
```python
SqQueue *Qu;
```
```python
//Qu是候车场
```
```python
InitStack(St);
    InitStack(St1);
    InitQueue(Qu);
```
```python
do
```
```python
{
```
```python
printf
```
```python
(
```
```python
"输入指令(1:到达 2:离开 3:显示停车场 4:显示候车场 0:退出):"
```
```python
);
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
,&comm);
```
```python
switch
```
```python
(comm)
        {
```
```python
case
```
```python
1
```
```python
:
```
```python
/*汽车到达*/
```
```python
printf
```
```python
(
```
```python
"输入车号和时间(设车号和时间均为整数): "
```
```python
);
```
```python
scanf
```
```python
(
```
```python
"%d%d"
```
```python
,&no,&time);
```
```python
if
```
```python
(!StackFull(St))
```
```python
/*停车场不满*/
```
```python
{
                Push(St,no,time);
```
```python
printf
```
```python
(
```
```python
"  >>停车场位置:%d\n"
```
```python
,St->top+
```
```python
1
```
```python
);
            }
```
```python
else
```
```python
/*停车场满*/
```
```python
{
```
```python
if
```
```python
(!QueueFull(Qu))
```
```python
/*候车场不满*/
```
```python
{
                    enQueue(Qu,no);
```
```python
printf
```
```python
(
```
```python
"  >>候车场位置:%d\n"
```
```python
,Qu->rear);
                }
```
```python
else
```
```python
printf
```
```python
(
```
```python
"  >>候车场已满,不能停车\n"
```
```python
);
            }
```
```python
break
```
```python
;
```
```python
case
```
```python
2
```
```python
:
```
```python
/*汽车离开*/
```
```python
printf
```
```python
(
```
```python
"输入车号和时间(设车号和时间均为整数): "
```
```python
);
```
```python
scanf
```
```python
(
```
```python
"%d%d"
```
```python
,&no,&time);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<=St->top && St->CarNo[i]!=no; i++);
```
```python
//在栈中找
```
```python
if
```
```python
(i>St->top)
```
```python
printf
```
```python
(
```
```python
"  >>未找到该编号的汽车\n"
```
```python
);
```
```python
else
```
```python
{
                t = St->top - i;
```
```python
//需要出栈的车辆数目
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<t; j++)
```
```python
//for (j=i; j<=St->top; j++)1楼评论讲的原错误写法
```
```python
{
                    Pop(St,e1,e2);
                    Push(St1,e1,e2);
```
```python
/*倒车到临时栈St1中*/
```
```python
}
                Pop(St,e1,e2);
```
```python
/*该汽车离开*/
```
```python
printf
```
```python
(
```
```python
"  >>%d汽车停车费用:%d\n"
```
```python
,no,(time-e2)*Price);
```
```python
while
```
```python
(!StackEmpty(St1))
```
```python
/*将临时栈St1重新回到St中*/
```
```python
{
                    Pop(St1,e1,e2);
                    Push(St,e1,e2);
                }
```
```python
if
```
```python
(!QueueEmpty(Qu))
```
```python
/*队不空时,将队头进栈St*/
```
```python
{
                    deQueue(Qu,e1);
                    Push(St,e1,time);
```
```python
/*以当前时间开始计费*/
```
```python
}
            }
```
```python
break
```
```python
;
```
```python
case
```
```python
3
```
```python
:
```
```python
/*显示停车场情况*/
```
```python
if
```
```python
(!StackEmpty(St))
            {
```
```python
printf
```
```python
(
```
```python
"  >>停车场中的车辆:"
```
```python
);
```
```python
/*输出停车场中的车辆*/
```
```python
DispStack(St);
            }
```
```python
else
```
```python
printf
```
```python
(
```
```python
"  >>停车场中无车辆\n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
4
```
```python
:
```
```python
/*显示候车场情况*/
```
```python
if
```
```python
(!QueueEmpty(Qu))
            {
```
```python
printf
```
```python
(
```
```python
"  >>候车场中的车辆:"
```
```python
);
```
```python
/*输出候车场中的车辆*/
```
```python
DispQueue(Qu);
            }
```
```python
else
```
```python
printf
```
```python
(
```
```python
"  >>候车场中无车辆\n"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
0
```
```python
:
```
```python
/*结束*/
```
```python
if
```
```python
(!StackEmpty(St))
            {
```
```python
printf
```
```python
(
```
```python
"  >>停车场中的车辆:"
```
```python
);
```
```python
/*输出停车场中的车辆*/
```
```python
DispStack(St);
            }
```
```python
if
```
```python
(!QueueEmpty(Qu))
            {
```
```python
printf
```
```python
(
```
```python
"  >>候车场中的车辆:"
```
```python
);
```
```python
/*输出候车场中的车辆*/
```
```python
DispQueue(Qu);
            }
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
/*其他情况*/
```
```python
printf
```
```python
(
```
```python
"  >>输入的命令错误\n"
```
```python
);
```
```python
break
```
```python
;
        }
    }
```
```python
while
```
```python
(comm!=
```
```python
0
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```

