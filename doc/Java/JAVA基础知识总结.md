# JAVA基础知识总结  



##  》一：

### 一、软件开发的常识

####  1.什么是软件？

一系列按照特定顺序组织起来的计算机数据或者指令

常见的软件：
系统软件：Windows\Mac OS \Linux
应用软件：QQ,一系列的播放器(爱奇艺，乐视，腾讯。。。。)，一系列的浏览器（谷歌，IE....）

####  2.什么是开发？

就是制作软件的过程
软件的出现实现了人与计算机之间的人机交互
交互方式：图形化方式：操作简单，用户容易上手
命令行方式：在控制台输入输入相应的指令，根据指令让计算机完成相关的操作



####  3.命令行指令(Windows+r-----调起控制台)

dir:列出当前目录下所有的文件以及文件夹
cd:进入到指定目录
cd..:退回到上一级目录
rd:删除目录
cls:清空控制台
exit:退出控制台

命令行让计算机执行相应的操作，相当于人和计算机之间的交流，计算机能识别的“话” -----计算机语言
计算机语言：c\c++\c#\html5\php\OC\Swift\Java.....



### 二、Java简介

#### 1.Java语言的由来

1995年，由Sun（Stanford University Network,斯坦福大学网络公司）公司发布的一门高级编程语言

#### 2.Java语言的技术架构

**J2SE**:标准版，为开发打基础
**J2EE**:企业版---Web方向
**J2ME**:小型版，小型的电子消费产品

JDK1.5之后，更名为JAVASE\JAVAEE\JAVAME

1996年，Sun发布了JDK1.0
目前JDK最新版本是1.9（bate）,推荐使用JDK1.8


跟Java相似的语言：c#\Ruby\Python

#### 3.Java语言的特点：跨平台性


通过Java编写的应用程序可以在不同的系统平台上运行，Java具有良好的可移植性，目前成为Web应用程序开发的首选语言

工作原理：在需要运行Java程序的操作系统上安装对应的Java虚拟机（JVM）

注意：Java语言具有跨平台性，JVM是不跨平台的



### 三、开发程序之前需要做的准备工作

**JDK**(Java Development Kit)；Java开发工具包 
**JRE**(Java Runtime Environment):java运行环境
**JVM**(Java Virtual Machine):Java虚拟机    

####  1.三者之间的关系

a. 如果只需要运行一个已经开发好的Java程序的话，只需要安装JRE
b. 作为程序员，就需要安装JDK,其中包含了Java的开发工具，同时也包含了JRE
c. JVM和JRE的关系：JRE包含了JVM，JVM是运行Java程序的核心虚拟机，同时也包含了Java程序所需的环境支持

总结:JDK>JRE>JVM(使用JDK开发的Java程序，交给JRE中JVM去运行)

####  2.安装

a.下载地址
www.oracle.com/java.sun.com
b.了解JDK
bin:binary----二进制文件，里面存放的是可执行的程序，比如javac.exe   java.exe等

####  3.配置环境变量 

用户变量和系统变量的区别：本质上是没有区别的，用户变量配置的内容只对当前用户有效，不会影响其他的用户，系统环境变量所做的修改会影响到这台电脑上所有的用户

%JAVA_HOME%\bin;C:\ProgramData\Oracle\Java\javapath;C:\Program Files  (x86)\Parallels\Parallels  Tools\Applications;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem

配置环境变量的作用：可以在任何目录下直接访问javac和java命令，主要是为了方便开发

### 四、Java程序的运行机制


Java程序的运行需要经过先编译，后运行的步骤


1.编译阶段：不会生成特定平台的机器码，而是生成一种和平台无关的字节码，这种字节码不是可执行的

2.运行阶段：起核心作用的是JVM，它是可以运行字节码文件的（编译器生成虚拟机能理解的代码，交给虚拟机来执行）

### 五、Java程序初体验

demo:样片，样品

开发工具：文本文档，EditPlus，Eclipse

1.创建一个扩展名为.java的文件
2.在文件中定义一个类，类是Java程序的最小单元，格式为：public class 类名（类名和文件名称相同）

3.要让程序有一个执行入口的话，需要在类中定义一个main函数（主函数），格式为：public static void main(String[] args) 

4.在main函数中写相应的代码，例如；System.out.print("hello world!");

5.编译阶段：使用javac命令，格式为：javac Java文件名称，例如：javac FirstDemo.java
6.运行阶段：使用java命令，格式为：java 类名，例如：java FirstDemo

注意事项：a.一个Java文件中可以同时存在多个类，并且编译之后会生成多个class文件
b。如果一个类被public修饰的话，则这个类的类名必须和Java文件的名称保持一致，
c。被public修饰的类在一个Java文件中有且只能有一个


### 六、注释

在编写程序时，写程序的人给代码做的一些解释和提示，能提高代码的可读性，为了日后的更改和阅读

注释是解释性文本，在运行程序的时候，注释会被程序跳过，不过任何处理

```java
1.//xxxxxx  单行注释

2./*
xxxxxx           多行注释
xxxxxxx
*/
3./**
xxxxxxx        文档注释
xxxxxx

*/
```



### 七、API文档 

养成自学的好习惯，经常翻阅API文档，（当作字典使用）

### 八、Java编码规范

1.Java源程序文件名的后缀必须是,java
2.Java中的每句代码必须以分号结尾
3.驼峰法则：在命名的时候，单词之间通过首字母大写来进行分隔，除包名和静态常量，例如：FirstDemo,
4.英文和中文，一般情况下，要求尽量使用通俗易懂的英文进行命名，例如：download   xiaZai（不推荐）



Java基础语言包含：注释、关键字、标识符、常量和变量、运算符、函数和数组

### 九、关键字和标识符

#### 1.关键字

在Java语言中，被赋予了特殊含义的英文单词，例如：class public import interface ....
特点：关键字中的字母全部小写

#### 2.标识符

在Java中自定义的一些英文单词

定义合法的标识符需要满足的规则：
a.由数字、字母、下划线（_）、美元符号（\$）组成
b.不能以数字开头   abc    1abc(不合法)
c.不能使用关键字   class(不合法)
d。遵循驼峰命名法
e.不可以包含空格     abc def(不合法)
f. 不能包含除了​\$之外的特殊字符    abc&（不合法）

在Java中，严格区分大小写
abc Abc 

### 十、进制转换

####  1.什么是进制？

进制指的是进位制，例如：十进制是逢十进一，二进制是逢二进一

常见的进制：十进制（0~9），二进制（0~1），八进制（0~7，以数字0开头），十六进制（0~9，a~f或者A~F,以0x开头）

在计算机底层，所有数字都是以二进制的形式存在的

为什么计算机采用二进制？
采用开头原理，只有0和1两个数值，相当于开关的打开和闭合状态，计算机运算的速率会比较高，八进制和十六进制是通过二进制演变而来的

#### 2. 进制之间的相互转化

#####  a. 计算机中存储数据的单位

计算机中表示数据的最小单位是比特（bit）,又称为位
计算机中处理数据的单位是字节（Byte）  1B = 8b
KB MB GB TB PB EB ...DB

1KB = 1024B
1MB = 1024KB


#####  b. 十进制---->二进制

转换原理：对十进制进行除2运算，直到商为0为止，然后将各个步骤中得到的余数倒着写出来 
对于小数而言， 整数部分除2取余数，小数部分乘以2取整
10.25

#####  c. 二进制 ----->十进制

转换原理：将二进制数按权进行展开，将得到的多项式相加（二进制的权是2）
$$
110--->1*2^2 + 1*2^1 + 0 = 6
12345 ---->1*10^4 + 2 * 10^3....
$$
#####  d. 二进制---->八进制

转换原理：将二进制数进行分组，从右向左进行分组，三位为一组，不够时进行补0
```
010 010 110 ---->226
2    2   6
```


#####  e. 二进制--->十六进制

转换原理：将二进制从右向左进行分组，四位为一组，不够时补0
```
1001 01100------>96
9    6
```

#####  f.十进制--->八进制或者十六进制

转换原理：方法一：先将十进制转换为二进制，然后再将二进制进行分组，转化为对应的八进制或者十六进制

方法二：可以将十进制进行除8或者16，直到商为0，类似十进制转二进制

#####  g.八进制或者十六进制---->十进制

类比二进制转换十进制

#### 3. 计算机是如何处理数据运算的

数值有正负之分

```
0000 0110---->6
```

原码：就是这个数对应的二进制形式，高位表示符号位，0表示正数，1表示负数

**注意**：反吗和补码主要针对的是负数
**反码**：就是将原码除符号位之外的各位进行求反，
**补码**：将原码除符号位之外的各位进行求反，然后再加1  ，

正数的原码，反码以及补码都是相同的，和源码相同

```
10 + （-10） = 0
```

原码
```
0000 1010
1000 1010
---------
1001 0100   ----->明显不是0，说明计算机处理数据不是通过原码进行的
```

反码
```
0000 1010
1111 0101
---------
1111 1111---->-127，明显不是0，说明计算机处理数据不是通过反码进行的
```



补码
```
-10的补码
1111 0101
0000 0001
----------
1111 0110---->-10的补码
0000 1010
---------
0000 0000---->结果为0，
```

结论：计算机处理数据的计算是通过补码进行的



## 》二：

### 一、数据类型

####  1.常量

在程序运行的过程中，值不会发生改变的标识符
常量的分类：整数常量、小数常量、布尔值常量、字符常量、字符串常量、null常量



####  2.变量

表示的值可以发生改变
定义一个变量，需要在内存【运算区域】中开辟一个空间，将不确定的数据存储到这个空间中
语法：数据类型  标识符 = 数值

特点：a.变量的值是可以变动的
b.需要在内存中开辟空间
c.命名规范：小驼峰命名。例如：gradeNum

####  3.数据类型

Java语言是强类型语言，每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间，来进行数据的存储


分类：基本数据类型和引用数据类型

基本数据类型：数值型（byte\short\int\long）、字符型(char)、浮点型(float\double)、布尔型(boolean)
引用数据类型：类、数组、接口

基本数据类型和取值范围
|类型名|  关键字|  占用的字节数|  取值范围|
|-----|-----|-----|-----|
|字节整型|   byte  |  1  | -2^7~2^7-1(-128~127) |
|短整型  |short  |  2 | -2^15~2^15-1|
|整型 | int  |  4 | -2^31~2^31-1|
|长整型 | long    |  8 | -2^63~2^63-1|
|单精度 | float |  4 | -2^128~2^127|
|双精度 | double |  8 | -2^1024~2^1023|
|字符型 | char |  2 | 0~65535|
|布尔型 | boolean |  1 | true\false|



- 特殊情况:String(类)
浮点数在计算机底层是以科学计数法进行存储的

####  4.类型转换

不同数据类型之间是没有办法直接进行计算的，我们需要将他们转换为同一类型才可以参与运算

#####  1>自动类型转换

相兼容的数据类型，将取值范围较小的数值或者变量赋值给取值范围较大的类型对应的变量

注意：a.整型的默认类型为int，浮点型的默认类型为double
b.byte.short,char类型的变量在进行运算时，首先会将类型提升为int型，然后参与运算

c.整型核浮点型进行计算时，会将整型提升为浮点型，然后参与运算

#####  2>强制类型转换

相兼容的数据类型，将取值范围较大的数值或者变量赋值给取值范围较小的类型对应的变量

### 二、运算符

####  1.算术运算符

+ - * / %(求余)，++（自增） --（自减）

####  2.赋值运算符

= += -= *= /= %=(复合赋值运算符)-----给变量进行赋值

####  3.关系运算符

< > <= >= ==(恒等于) != (不等于)
用于两个变量之间比较大小，如果成立则结果为true，如果不成立则结果为false

####  4.逻辑运算符

用于链接布尔型的表达式
int x = 4;
数学中：3 < x < 5---->true
代码中：

与（&，&&（短路与））、或（|、||）、异或（^）、非（！）




####  5.位运算符【0为false，1为true】

&  | ^  ~(取反) <<(左移)   >>(右移) >>>(无符号右移)


注意：除了无符号右移之外，其余的运算均包含符号

####  6.三目运算符

//格式：条件表达式？表达式1：表达式2；
//表示的意思是：判断条件表达式是否成了，如果成立，则结果为表达式1，如果不成立，则结果为表达式2
//计算完成之后必定会返回一个结果

####  7.转义运算符

通过\来改变后面字母或者符号的含义




## 》三：

### 一、Java语句的执行结构

1.顺序语句
按照顺序从上往下依次执行的语句，中间没有任何的判断和跳转

2.分支语句
根据不同的条件来产生不同的分支
if语句、switch语句

3.循环语句
重复执行某句代码
for语句、while语句、do-while语句

### 二、分支语句

####  1.什么是分支？

判断所给定的条件是否满足，根据不同的结果执行对应的不同的语句

####  2.if语句

使用布尔表达式或者布尔值作为条件来进行分支控制

#####  1>简单if语句（单分支）

语法：

```java
if(条件表达式) {

//执行语句
}
```

这里的条件表达式一般为关系运算符
使用方式：首先判断条件表达式是否成立，如果成立则执行语句，反之，不执行


#####  2>if-else语句（双分支） 

语法：

```java
if(条件表达式) {
//执行语句1
}
else {
//执行语句2
}
```

使用方式：首先判断条件表达式是否成立，如果成立则执行语句1，如果不成立，则执行语句2

#####  3>多重if-else语句

语法：

```java
if(条件表达式1) {
//执行语句1
} else if(条件表达式2) {
//执行语句2
}else if(条件表达式3) {
//执行语句3
}
。。。。。。

else {
//执行语句
}
```

使用方式：根据不同表达式的成立与否执行对应的语句。只执行其中的一个分支，如果其中的一个分支条件满足，则停止继续向下执行


#####  4>扩展：嵌套if语句

语法：

```java
if(条件表达式1) {
//执行语句1
if(条件表达式2) {
//执行语句2
}
}
```

从语法的角度来说，嵌套的层数没有限制，但是从代码的可读性来说，建议嵌套的层数不要多于3层

注意：使用if语句时容易出现的错误：
1.

```java
if(条件表达式);
{

}
```

2.忘记必要的括号

####  3.switch语句

语法：


```java
switch(表达式或者变量) {
case 常量值1：
{
//执行语句1
}
break;
case 常量值2：
{
//执行语句2
}
break;
case 常量值3：
{
//执行语句3
}
break;
.。。。。。
default:
{
//执行语句
}
}
```

根据表达式或者变量的值进行匹配，如果case中有能匹配到的，则执行对应的语句，如果所有的case语句都不满足，则执行default中的语句

**注意**：a.表达式或者变量的取值类型：byte\short\int\char\String\枚举，（不能使用long和boolean）
b.若表达式的值和case分支后的常量值匹配的话，则执行该case分支
c.break表示跳出switch-case语句
d.当所有的case分支都不匹配的情况下，则执行default语句

**扩展**：Scanner类的使用

if语句和switch语句的区别：
a.如果对具体的数值进行判断，并且数值不多的情况下，而且符合byte\short\int\char这四种类型，推荐使用Switch完成，执行效率相对高一点
b。如果对区间进行判断，结果为布尔值的情况下，推荐使用if，if的使用范围更广

### 三、循环语句

####  1.什么是循环？

在满足条件的情况下，反复执行某一段代码，这段被反复执行的代码就被称为循环体
当反复执行这段循环体时，需要在合适的时候将循环条件改为假，从而结束循环，否则循环会一直执行下去，形成死循环

####  2.while循环

语法：

```java
while(条件表达式) {
//循环体
}
```

当条件表达式成立时，才会执行循环体
循环体的执行次数取决于条件表达式

####  3.do-while语句

语法：

```java
do{
//循环体

}while(条件表达式);
```



#### 4.for循环语句

语法：

```java
for(表达式1；表达式2；表达式3){

//循环体
}
```

表达式1：初始化表达式
表达式2：循环条件表达式
表达式3：循环后的操作表达式

执行顺序：表达式1（int x = 0）--->表达式2---->循环体--->表达式3----->表达式2---->循环体--->表达式3。。。。。。
其中，表达式1只执行一次

扩展：嵌套for循环



### 四、特殊流程控制语句

####  1.break


应用范围：分支结构和循环结构
作用：跳出对应的结构

#### 2.continue

应用范围：循环结构
作用：表示结束当前循环，继续下一次循环，并不会结束整个循环

#### 3.return

return并不是专门用于跳出循环的，作用是结束一个方法
return直接结束一个方法，不管这个return处于多少层循环之中

####  三者之间的区别：

a.break和continue的应用范围不同
b.当程序中出现break和continue时，在他们的后面不能出现语句，因为执行不到
c.continue是结束当前循环，break是结束整个循环
d.return直接结束整个方法







## 》四：

## 一、方法

###  1.什么是方法？

对于功能相同的代码段，为了简化代码，会把功能相同的代码抽取出来，方便多次使用，Java中，我们使用【方法】，也被称为函数


2.函数的声明
语法：
访问权限修饰符 其他修饰符 返回值类型 函数名称（参数列表）{

//函数体
}

```java
public static void main(String[] args) {

}
```

a.访问权限修饰符：目前全部要求使用public，和main函数保持一致
b.其他的修饰符：只有static（要么写，要不不写）
c.返回值类型：函数运行后所得结果对应的数据类型，void表示空
d。函数名称：见名知意
e.参数列表：如果方法中有未知数参与运算，未知数对应的类型和变量名

3.函数的调用


4.static的使用
1》全局变量和局部变量
全局变量：在类中定义的变量，和main函数是并列的，在整个类中有效
局部变量：在方法内定义，并且只能在方法内部使用，当方法执行完成之后，这个变量就消失了
注意：局部变量在使用的时候一定要先进行初始化
局部变量局部有效，只在定义这个变量的方法内有效  {}


注意：在使用全局变量和局部变量的时候，尽量避免命名相同


2》静态方法：被static修饰的方法称为静态方法，不加static则为非静态方法


5.方法中参数
分类：形式参数（形参）和实际参数（实参）
调用方法的时候，用实参给形参赋值，这个过程称为传参
传参时需要注意：实参的数量和类型要与形参的数量以及类型相匹配


6.方法压栈
栈：是内存中的一块空间（开口向上的容器）
入栈和出栈：先进后出，后进先出
局部变量在栈中开辟空间

注意：a.JVM首先执行main函数，main函数入栈
b.当执行到swap方法的时候，swap函数入栈
c.当所有的操作执行完成之后，方法需要出栈，swap先出栈，mian函数后出栈，所占有的空间全部被释放



7.方法的返回值
一个方法执行完成之后所得到的结果
void表示没有返回值

使用return得到最终的结果，用于结束整个方法


8.提取一个方法注意事项
a。明确实现的功能，当调用函数的时候，是否需要返回结果----返回值类型
b,明确是否有未知项参与运算-------参数列表



8.函数的递归
递归：在一个方法中调用它自身，称为方法的递归
方法递归中包含了隐式的循环，他会重复执行某段代码，但是在这里不需要循环



## 》五：

### 一、初步认识数组

#### 1.理解数组

数组是用来存储相兼容数据类型的定长的容器
特点：

a.只能存放相兼容数据类型，不能存放多种数据类型
b.可以存放基本数据类型和引用数据类型
c.数组是定长的，一旦被初始化，数组的长度就不能发生改变
d.将数组中存储的数据称为元素

#### 2.使用数组的好处：

可以自动给数组中的数据从0开始编号，方便操作这些数据，我们把这些编号叫做下标（索引）

#### 3.定义数组

数组是一种引用数据类型
int x = 4;
int 是一种基本数据类型，int[]是一种引用数据类型，用来表示数组

int[] y = xxx;


方式一:数据类型[] 数组名称，例如：int[] x,String[] s
方式二：数据类型 数组名称[]
推荐使用方式一

### 二、数组的初始化

Java中的数组必须先初始化，然后才可以使用，所谓初始化，就是为数组中的每个数组元素开辟内存空间，并且为每个元素赋初始值

#### 1.静态初始化

初始化的时候由程序员指定每个数组元素的初始值，交给系统去计算数组的长度（大小）
语法：元素类型[] 数组名称 = new  元素类型[]{元素0，元素1，元素2.。。。。。}；

#### 2.动态初始化

初始化是程序员只需要指定数组的大小（长度），对应的初始值由系统自行进行分配
语法：元素类型[] 数组名称 = new 元素类型[数组的长度];

系统对初始值的分配规则：
a.整型：0
b.浮点型：0.0
c.boolean:false
d.字符型：‘\u0000’(在不同的系统平台上的展示结果是不一样的，有的是方框（口），有的是空格)
e.引用数据类型：null

**注意**：在初始化数组时，静态初始化和动态初始化一定不要同时使用（在指定数组长度的同时，不要给数组中每个元素赋初始值）

数组初始化完成之后，就可以使用数组了，包括数组元素的访问，给数组元素赋值，获取数组的长度等

### 三、数组的使用

见代码

### 四、内存中的数组

数组是一种引用数据类型，数组元素和引用变量在内存中时分开存放的
数组引用变量存放在栈空间中，数组元素存放在堆空间中

扩展：

#### 1>基本数据类型和引用数据类型在内存中的区别？

基本数据类型

```java
int x = 4;
int y = x;
y = 20;
x = ?
```

引用数据类型

```java
int[] a = {22,33};
int[] b = a;
b[0] = 18;
a[0] = ?
```

#### 2>内存的分类：

a.寄存器：最快的存储区，由编译器根据需求进行分配，我们在程序中无法控制
b.栈：存放基本数据类型的变量和引用数据类型的引用
特点：被执行完成之后，函数或者变量所占用的空间会被销毁
c.堆：存放new出来的对象，例如：new出来的实际的数组元素
d.静态域：存放静态成员（static）
e.常量池：基本类型常量和字符串常量


举例：内存结构------>一套房子
卧室----睡觉 
厨房----做饭
客厅----招待客人







### 五、数组的应用

#### 1.排序

##### 1>冒泡排序

思路：比较相邻两个下标对应的元素值，如果符合条件就交换位置（最值出现在最右边）

##### 2>选择排序

思路：固定一个下标，然后使用这个下标对应的值依次和他后面的值进行比较



#### 2.查找

1>顺序查找
思路：遍历数组，依次把每一位元素和要比较的数值进行比较

2>二分法查找
思路：前提是一个数组是有序，通过折半来缩小查找范围，提高效率



## 》六：

### 一、不定长参数

1.语法：数据类型... 变量名称

使用注意事项：a.不定长参数就相当于是一个数组
b.不定长参数只能出现在参数列表的最后面
c.一个函数的参数列表中只能出现一次不定长参数
d.对于不定长参数的使用，调用函数的时候，可以传入不定长的数值，或者可以直接传入数组

### 二、Arrays工具类



### 三、二维数组

在一个一维数组中，数组的元素为一个数组

1.定义二维数组
int[] arr
语法：元素类型[][] 数组名称



## 》七：

### 一、面向对象编程

#### 1.什么是面向对象？

万物皆对象


案例一：我想吃大盘鸡
面向过程  面向对象
1.我自己去买一只鸡 1.委托一个会砍价的人去帮忙买鸡
2.我自己宰鸡  2.委托一个胆大的人宰鸡
3.我自己准备菜  3.委托一个厨师帮忙择菜
4.我自己做菜  4.委托一个厨师帮忙做菜
5.我自己吃  5.我自己吃

案例二：小明是一个电脑小白，想要配一台电脑，买完零件后需要搬到家里，组装起来开始玩游戏
面向过程   面向对象
1.小明补充电脑知识  1.委托一个懂电脑的朋友帮忙去买零件
2.小明去买零件   2,。委托一个快递小哥将零件搬到家里
3.小明将零件搬到家里  3.委托一个会组装电脑的人帮忙将电脑组装起来
4.小明组装电脑   4.小明开始玩游戏
5.小明开始玩游戏

#### 2. 面向过程和面向对象的区别：

面向过程：一种看待问题的思维方式，在解决问题的时候，着眼于问题是怎样一步一步解决的，然后亲力亲为的去解决每个步骤中遇到的问题
面向对象：一种看待问题的思维方式，着眼于找到一个具有特殊功能的具体的个体，然后委托这个个体去帮忙做某件事情，这个个体就被称为对象

区别总结：
a.都是一种看待问题的思维方式
b.面向过程着眼于所有的问题亲力亲为解决
c.面向对象着眼于找到一个具有特殊功能的对象，然后委托这个对象去帮忙做某件事情


Java语言是一门纯粹的面向对象的程序设计语言，类和对象是面向对象编程的核心

### 二、类和对象

#### 1.类和对象的概念

类：一个具有特殊功能的实体的集合（群体）
对象：在一个类中，一个具有特殊功能的实体，能够帮忙解决特定的问题，对象也被称为实例

二者之间的关系：类用于描述某一类对象的共同特征，而对象则是类的具体存在（包含关系）


类  对象
人  张三，李四，杨阳，凌桃根。。。
快递  圆通、申通、顺丰、汇通。。。
superHero  蝙蝠侠，奥特曼，蜘蛛侠，美国队长。。。。。。。。

帮助理解：我们可以将类当做是一种自定义的数据类型，可以使用类来进行定义变量，这种类型的变量统称为引用型变量，也就是说，类是引用数据类型



#### 2.声明一个类

语法：访问权限修饰符  class 类名　｛
／／类体
｝

说明：ａ．访问权限修饰符：只能是public(可以被省略)
b.类名只要是一个合法的标识符即可，要求：类名首字母必须大写，遵循驼峰命名法
c.类名尽量使用单个或者多个有意义的单词连接而成



注意：a.一个Java文件中可以同时存在多个类，如果有多个类的话，编译之后会生成多个class文件

b。一个Java文件中只能出现一个由public修饰的类，这个类的类名必须和Java源文件的名称保持一致
c.如果一个Java文件中只有一个类的话，并且这个类不使用public修饰，这时类名和Java文件名可以不一样



#### 3.类中成员变量和方法的定义

1>成员变量
a.成员变量也被称为属性
b.成员变量其实就是全局变量
c.分为静态变量和非静态变量
d.在静态方法中只能访问静态变量，在非静态方法中可以访问静态变量和非静态变量


2>类中方法的定义
a.分为静态方法和非静态方法
b.在静态方法中只能调用静态方法，在非静态方法中可以调用静态方法和非静态方法



成员变量------类具有的特征，举例：人----身高，性别，三围，姓名。。。。
成员方法------类具有的行为，举例：人----吃喝玩乐。。。。

#### 4.对象的创建以及内存分析

对象的创建也称为实例化对象
语法：类名 标识符 = new 类名();

Person xiaoming = new Person();
说明：xiaoming这个变量是一个引用型变量，存放于栈空间中，实际的Person对象存放于堆空间中
所有new出来的对象全部存放于堆空间中，对应的对象的引用存放于栈空间中



#### 5.类中成员变量和方法的访问

总结：a.静态成员变量和静态方法是属于类的，使用 类名. 的方式访问
b.非静态成员变量和非静态方法是属于对象的，使用 对象. 的方式访问
c.开辟空间的时机是不同的

#### 6.方法重载

在同一个类中，如果满足以下的条件时，我们就称为这几个方法之间彼此重载
a.方法名相同
b.参数不同（数量不同，类型不同）
c.跟返回值类型没有关系



#### 7.构造方法

构造方法也叫作构造器，是当实例化一个对象（创建一个对象）的时候，第一个被调用的方法
语法：访问权限修饰符 类名（） {


}
普通方法：
访问权限修饰符 其他的修饰符 返回值类型 函数名（参数列表） {

}

**注意**：a.构造方法是在实例化对象的过程中自动调用的
b.系统会默认为我们提供一个无参的构造方法


构造方法和普通方法的区别
a.构造方法没有返回值
b。构造方法的方法名必须和类名保持一致


使用构造方法的过程中容易出现的问题;。
a.如果没有写有参的构造方法，系统会为我们提供一个默认的无参的构造方法
b。如果手动写了有参的构造方法之后，系统将不再提供无参的构造方法，如果需要使用，则需要手动加上（要求：一般情况下，将无参的构造方法加上，哪怕方法里面什么都不写）



## 》八：

面向对象语言的三大特性;封装、继承、多态

### 一、面向对象语言特性之封装

#### 1.什么是封装？

一个类中某些属性，如果不希望外界直接访问，我们可以将这个属性作为私有的，可以给外界暴露出来一个访问的方法
使用封装解决私有化的问题

私有化使用private关键字

#### 2.private的使用

1>修饰成员变量，表示这个成员变量只能在当前类中被访问
2>修饰成员方法，表示这个方法只能在当前类中被调用

#### 3.get/set方法

对于private修饰的成员变量，如果要在外界使用，则使用get和set方法进行取值和赋值


语法
get------获取值
访问权限修饰符 返回值类型（成员变量的类型）getXxx() {   例如：public int getAge() {}
}

set-----赋值
访问权限修饰符 void setXxx(成员变量类型 变量名称) {   例如：public void setAge(int a){}
}

#### 4.this关键字

this表示的是对当前对象的引用

1>this.属性：访问本类中的成员变量
总结：一般情况下，当私有变量的set方法中参数名称和成员变量相同的时候，使用this进行区分，有参构造方法中也是同样的道理（当局部变量名和成员变量名相同时，this表示的是成员变量名）

2>this.方法：访问本类中的方法

3>this():访问本类中的构造方法

注意：a.this()只能写在构造方法中
b.this()只能出现在其他构造方法中执行语句的第一行
c.this()具体调用的是哪个构造方法，取决于所传的参数

#### 5.static关键字

##### 1>静态成员变量

由static修饰的成员变量被称为静态成员变量
语法：访问权限修饰符 static 数据类型 变量名称；

**特点**：
a.静态成员变量是属于类的，通过 类名. 的方式和 对象.的方式都可以进行访问
b。静态成员变量的声明出现在实例之前（静态成员变量随着类的字节码文件加载到JVM中，且只会加载一次）
c.使用类和不同对象访问的静态成员变量都属于同一块内存空间

##### 2>静态方法

特点：
a.静态方法是属于类的，通过类名.的方式访问
b.静态方法优先于实例被加载到JVM中，与静态成员变量类似
c.在同一个类中，静态方法只能访问静态方法


什么时候使用静态？
当所有的对象需要共享数据的时候，就定义成静态成员变量----静态成员变量
对于一些普遍或者需要多次使用的功能，我们将它抽取成方法的时候就声明成静态方法

##### 3>静态代码块

什么是代码块？
在类中独立存在的语句块，可以有多个，位置随意{}
什么是静态代码块？
被static修饰，直接出现在类中的语句块
语法：static {
//执行语句

}

用法：a.静态代码块用于为类的属性进行初始化
b.静态代码块是属于类的，随着类的加载而运行，每个静态代码块只会执行一次，静态代码块的执行优先于main函数

扩展：

##### 4>普通代码块：在方法或者语句中出现的{}

普通代码块和一般语句的执行顺序由他们在代码中出现的顺序决定

##### 5>构造代码块：直接在类中定义，且没有加static关键字的代码块

#### 6.单例

单例是一种设计模式，
什么是设计模式？
前人总结的用来解决特定问题的方案
Java中有23中设计模式，常用的有单例设计模式，工厂设计模式

什么是单例设计模式？

在程序运行过程中，确保某一个类只有一个实例（对象），不管在哪个模块获取这个类的对象，获取到的都是同一个对象

实现方式：
a.懒汉式（饱汉式）

b.饿汉式

区别：a.懒汉式在一定程度上节约内存，但是数据是不安全的（线程不安全）
b.饿汉式，不节约内存，但是数据比较安全


7.包（package）
用来组织文件而存在的，和文件夹的功能相同
语法：package xx.yy.zz  ---->class文件的存放位置

编译命令：javac -d . Java源文件名称（只要类中使用了package关键字）

注意：a.类编译生成的class文件存在于对应的包下
b。一般情况下，不同的类编译生成的class文件必须存在于同一个包下才能相互访问
c.当不同类的class文件存在于不同包下的时候，要相互访问，则使用import，格式：import 包名.文件名称





## 》九：

### 二、面向对象特性之继承

#### 1.什么是继承？

如果两个或者两个以上的类具有相同的属性和方法，我们可以抽取一个类出来，在抽取出来的类中声明各个类中公共的部分
被抽取出来的类-------父类，基类，超类
两个或者两个以上的类-----子类，派生类
二者之间的关系：子类  继承自  父类（基类）

#### 2,语法

访问权限修饰符 class 子类类名 extends 父类类名 {
}

a.当子类继承自父类的时候，子类对象可以访问父类中的成员变量
b.子类同样可以调用父类中的方法
c.一个父类，可以有多个对应的子类
d.一个子类，只能有一个父类（单继承）

#### 3.super

this是对当前对象的引用
super是对父类对象的引用

1》super.属性：访问父类中的成员变量
2》super.方法：访问的是父类中的方法
3》super():访问的是父类的构造方法
注意：a.super()必须出现在子类构造方法的第一行语句
b.super()具体调用的是父类中的哪个构造方法，取决于所传的参数

### 二、访问权限修饰符

1.访问权限修饰符：public\private\protected\default
2.default:如果没有添加访问权限修饰符的话，其实就是default权限（注意：default一定不能写出来）
3.修饰类：类的访问权限修饰符只有两个：public和default

访问权限修饰符        同包  不同包
public      可以 可以
default       可以 不可以

说明：
public修饰的类在不同包下可以访问，但是需要注意：
a.进行导包（需要使用类的全限定名，例如：包名.包名.类名；import com.b.Student;）
b.如果在不同包中有相同名字的类，在使用的时候一定要注意使用类的全限定名

4.修饰属性:四个访问权限修饰符都能用
权限大小：public>protected>default>private


访问权限修饰符   本类 同包不同类 子类（不同包） 不同包
private  可以 不可以  不可以  不可以
default  可以 可以  不可以  不可以
protected 可以 可以  可以  不可以
public   可以 可以  可以  可以

### 三、方法重写

1.重写规则
在具有继承关系的两个类中，子类中的方法如果满足了以下条件，就说子类重写了父类的方法
a.方法名相同
b.参数相同
c.子类方法的返回值类型必须和父类方法的返回值类型相同，或者是父类方法返回值类型的子类型
d.子类方法的访问权限必须大于等于父类方法的访问权限



2.final关键字
1》final修饰类：这个类不能被继承
2》final修饰方法：这个方法不能被重写
3》final修饰变量

当final修饰一个成员变量的时候，系统不会再给这个成员变量赋初始值，所以在使用之前需要我们手动进行初始化
静态成员变量:在声明变量的时候或者在静态代码块中进行初始化
非静态成员变量：在声明变量的时候或者构造代码块中或者构造方法中直接初始化
局部变量：
注意：final修饰基本数据类型和引用数据类型的区别？
当final修饰基本数据类型的时候，不能再对基本数据类型变量进行赋值
当final修饰引用数据类型的时候，引用类型变量不能再被重新赋值，但是可以改变引用变量所指向的内容

总结：a.final和访问权限修饰符没有关系，是相互独立的
b.对于基本数据类型变量，命名字母全部大写，不同单词之间使用下划线进行分隔
c.对于引用数据类型变量，命名不需要遵循常量命名规范

### 四、Object类

是Java中所有类的父类，在其中定义了一些常用的方法
1》toString()
2>getClass()
3>hashCode()
4>equals()



## 》十：

### 一、抽象类

1、定义
当多个类中出现相同功能，但是功能主体是不同的，这是可以进行向上抽取的，只抽取功能的定义部分，使用抽象类实现

抽象类的存在就是为了被继承


2.使用
abstract

3.抽象类的特点
a.使用关键字abstract修饰的类
b.抽象类不可以使用new关键字进行创建对象
c.抽象类中既可以写抽象方法，也可以写普通方法
d.如果子类只实现了抽象类中的部分抽象方法，那么这个时候子类仍然是一个抽象类

4.抽象方法的特点：
a.抽象方法必须存在于抽象类中
b.使用abstract修饰的方法
c.只有声明，没有实现

5.抽象类和一般类的区别
a.抽象类是在一般类的基础上，使用abstract修饰的类
b.抽象类中既可以有抽象方法，也可以有普通方法，普通类中只能有普通方法
c.抽象类不能用于实例化对象

### 二、接口

1.概念
初期理解：可以认为接口是一种特殊的抽象类，当抽象类中的方法全部是抽象方法的时候，我们就可以使用接口来表示

接口是抽象方法的集合，

2.使用
interface

语法：访问权限修饰符 interface 接口名称 
{
}

3.接口的特点
a.接口不能实例化对象
b.接口中不能写成员变量
接口中成员变量的修饰符是固定的，public  static final,在接口中出现的变量统统认为是常量
c.接口中默认所有的方法都是抽象方法
接口中方法的修饰符也是固定的，public abstract,接口中默认所有的方法都是抽象方法


4.接口的实现和类之间的关系
一个类如果要实现另外一个类中的方法的话，使用继承实现
一个类如果要实现一个接口中的方法的话，则需要实现这个接口

语法：
访问权限修饰符 class 子类类名 implements 接口名 {

}
其中，把实现了这个接口的类称为接口的实现类

注意：
a.子类必须实现接口中的全部的抽象方法，子类才可以实例化，否则，子类仍然是一个抽象类
b.一个类是可以实现多个接口，需要把实现的接口中的方法全部实现了 
c.实现接口和类的继承之间没有关系，一个类在实现接口的同时也可以继承
d.接口之间是可以进行继承的，并且是多继承

总结
接口其实是对外暴露的规则
接口可以实现程序功能的扩展
接口可以用来多实现
接口之间是可以继承的，并且是多继承的关系
一个类在继承的同时可以实现接口

### 三、多态

一种事物的多种体现形式
Java中的体现形式：
1>父类的引用指向子类的对象
2>接口的引用指向实现类的对象

### 四、对象转型

1.对象的向上转型 
由子类类型转换为父类类型
由实现类类型转换为接口类型

对象向上转型之后就不能再访问子类中特有的方法和属性
对象向上转型之后就不能再访问实现类中特有的方法，

2.对象的向下转型
由父类类型转换为子类类型:强制类型转换


3.instanceof
语法：对象 instanceof 对象匹配的类型
作用：判断这个对象是不是指定的类型

### 五。工厂设计模式

多态的应用

当需要一个对象的时候，并不是直接通过new的方式实例化对象，而是通过工厂类的工厂方法直接去获取



## 》十一：

### 一、内部类

一个类中包含着另外一个类，里面的类被称为内部类，外面的称为外部类

#### 1.成员内部类

和成员变量或者成员方法平级的内部类
语法：
访问权限修饰符  class 外部类类名{

//成员变量
//成员方法
访问权限修饰符 class 内部类类名 {

//内部类的类体
} 
}

特点；
a.实例化对象的语法
Out out = new Out();
Out.In in = out.new In();
b。成员内部类四种访问权限修饰符都可以使用（一般类只能使用public和default）
c.成员内部类编译生成的class文件的格式：外部类类名$内部类类名，例如：Out$In.class

#### 2.局部内部类

是和局部变量平级，存在于方法中的内部类
语法：
访问权限修饰符  class 外部类类名{

//成员变量
//成员方法
访问权限修饰符 返回值类型 方法名（参数列表） {


访问权限修饰符 class 内部类类名 {

//内部类的类体
}
}
}

特点：
a.局部内部类具有和局部变量相同的作用域
b.和局部变量类似，不能使用访问权限修饰符进行修饰
c.编译生成的class文件的格式：外部类类名$编号内部类类名 ，例如：Out$1In.class,Out$2In.class,
d。局部内部类如果要访问和他平级的局部变量，这个局部变量必须是一个常量
e.如果需要往外部类的方法中传入参数，外部类的方法形参必须使用final修饰

#### 3.静态内部类

使用static修饰的成员内部类被称为静态内部类
语法：
访问权限修饰符  class 外部类类名{

//成员变量
//成员方法
访问权限修饰符 static  class 内部类类名 {

//内部类的类体
} 
}

特点：
a.实例化内部类对象的格式：Out.In in = new Out.In();
b.静态内部类类似于静态成员变量，可以使用访问权限修饰符进行访问
c.静态内部类编译生成的class文件的格式：外部类类名$内部类类名，例如：Out$In.class
d.在静态内部类中只能访问外部类中的静态成员变量
e.在静态内部类中也可以写静态成员变量

#### 4.私有内部类

被private修饰的成员内部类

语法：
访问权限修饰符  class 外部类类名{

//成员变量
//成员方法
private class 内部类类名 {

//内部类的类体
} 
}

#### 5.匿名内部类（重要）

没有名字的内部类
正因为没有名字，所以匿名内部类只能使用一次，通常用来简化代码，匿名内部类使用的前提条件：必须继承一个父类或者实现一个接口

特点：
a.匿名内部类没有名字
b.匿名内部类其实是指定类的子类或者指定接口的实现类
c.编译生成class文件的格式：测试类类名$编号，例如：InnerClassDemo05$1.class



## 》十二：

### 一、String类

字符串是一种特殊的对象，一旦被初始化就不能被改变了

字符串常量存储于常量池中

### 二、StringBuffer类

是一个字符串缓冲区，相当于一个容器

特点
a.可以对字符串进行增加和删除的操作
b.长度是可变的
c.可以进行操作多种数据类型
d.最终可以通过toString()转换为字符串

### 三、StringBuilder类

JDK1.5之后出现的
StringBuffer是线程同步的，StringBuilder是线程不同步的

建议：多线程使用StringBuffer，单线程使用StringBuilder
实际开发中，建议使用StringBuilder

### 四、常用类

#### 1.对象包装类

int ----->Integer
byte-----Byte
short----Short
long------Long
boolean---Boolean
float-----Float
double----Double
char------Character

#### 2.数据的装箱和拆箱

装箱：将基本数据类型转化为对应的对象包装类
拆箱：将对象包装类转化为对应的基本数据类型

#### 3.String类和基本数据类型之间的转换

a.对象包装类的常见作用：用于基本数据类型和字符串类型之间的转换

#### 4.Date类

用来表示日期的

#### 5.SimpleDateFormat

#### 6.Calendar

#### 7.Random

获取随机数

#### 8.Math

是一个工具类

Math类的构造器被私有化了，所以Math类中的方法全部是静态方法，可以直接通过类名进行调用，而且还提供了两个静态属性，PI和E,他俩的值其实就是π和e



## 》十三：

测试
用一个字符串常量创建一个字符串对象
1.获取这个字符串的长度
2.获取任意长度的子串
3.判断这个字符串是否为空
4.将这个字符串中的小写字母转化为大写字母
5.获取某个字符在字符串中第一次出现的位置
6.判断这个字符串是否是以某个前缀开始的


7.用这个字符串创建一个StringBuffer对象
修改索引为1处的字符为‘a’
将字符串反转
在索引为3的位置插入一个字符串“hello”



### 一、枚举 

JDK1.5之后引入的一个新的特性，存在于java.lang

表示取值范围限定的变量（四季，星期，月份）

枚举类和普通类的区别：
a.枚举类的父类java.lang.Enum，而不是Object
b。使用enum关键字（enumeration）
c.枚举类的构造器只能使用private访问权限修饰符
d.枚举类的的所有实例必须在枚举类中显式列出，系统会自动给这些实例添加修饰符public static final
e。所有的枚举类都提供了一个values方法，可以用来遍历枚举中所有的枚举值

语法
访问权限修饰符 enum 枚举名称 {
//枚举值
可能取得值1，可能取得值2，可能取得值3，....,可能取得值n;
}

注意：枚举值的命名需要全部大写，不同单词之间使用下划线分隔

### 二、异常

#### 1.概念：

程序在编译运行过程中遇到的种种不正常的现象
Java通过Throwable类来描述各种不同的异常，Java中的异常都是面向对象的，所有的异常都是Throwable
的子类

#### 2.分类

Throwable的子类：Exception Error 
Error:大多数与代码编写者没有关系，表示当代码运行时，JVM出现的问题，例如：StackOverFlow（栈溢出）
Exception:程序能够捕获并且处理的异常
CheckedException:编译时异常,这种异常必须要处理，否则编译都无法通过
RuntimeException：运行时异常，编译可以通过，但是在程序运行的时候被发现

#### 3.处理异常

处理机制：抛出异常，捕捉异常


a.捕捉异常：try catch
语法：
try{
//可能会有异常的代码
}
catch(Exception e){

//捕捉并处理try代码块中出现的异常
}
说明：关键词try后面的代码块中写可能会有异常的代码，这块区域被称为监控区域，
如果在try中检测到了异常，程序在运行的时候系统会试图匹配对应的catch代码块
如果匹配到了对应catch代码块，则运行并处理异常，结束之后整个try-catch语句结束



b.抛出异常throw throws
throw ：抛出一个异常的对象，调用这个对象所在的方法的时候就会出现这种异常
throws：声明在方法定义的时候，用来表示这个方法可能会抛出的异常


补充问题：
1.多个catch
2.e1.printStackTrace();

//返回异常的消息信息
System.out.println(e1.getMessage());//String

3.如果在try中出现多个异常的时候，只处理位于最前面的异常，但是后面的异常不会对程序产生影响

#### 4、自定义异常

在实际项目开发中，如果系统提供的异常不能够满足实际的需求的话，就需要自定义异常

实现方式：
编译时异常：继承自Exception类，
运行时异常：继承自RuntimeException

### 三、集合

1.概念
数组：用来存储相兼容数据类型的定长的容器（基本数据类型和引用数据类型）
集合：存储引用数据类型的变长的容器（引用数据类型）



## 》十四：

### 一、泛型

1.概念
泛型指的是泛指的类型。主要用于子类和父类，接口和实现类之间的数据传递


JDK1.5之后新增的特性，主要用于解决安全问题，是一个安全机制


好处：
a.可以提高代码的复用性
b.避免了强制类型转换的麻烦
c.提高了代码的安全性
d.可以把运行时的异常提前到编译时


泛型：通过<>来定义要操作的引用数据类型

什么时候使用泛型？
通常使用在集合框架中，当遇到<>的时候，一般需要定义泛型

2.泛型的应用场景
a.泛型应用在类中

访问权限修饰符 class 类名<类型1，类型2。。。> 
{
}

b.泛型应用在接口中
interface 接口名称<类型1，类型2。。。>  {

}

c。泛型应用在方法中
访问权限修饰符 <类型1，类型2.。。。> 返回值类型  方法名（参数列表） {


}

d.应用在集合中


e.通配符-------- ？
可以匹配任意类型
1><? super 类名>：可以是指定类或者指定类的父类

2><? extends 类名>:可以是指定类或者执行类的子类

### 二、List接口

List是Collection接口的一个子接口，可以使用Collection中的所有的方法
List在Java中代表一个有序的集合，集合中的每个元素都有对应的索引，List允许添加重复元素，可以通过索引来访问集合中的元素

1.ArrayList-----List接口的一个实现类
特点：
a.不排重（同一个元素，可以被添加多次）
b.有序的（元素的添加顺序和底层的存储顺序是相同的）
c.底层存储采用类似“数组”的数据结构，查询和修改的效率比较高，新增和删除的效率比较低


2.LinkedList
特点：
a.不排重（同一个元素，可以被添加多次）
b。有序的（元素的添加顺序和底层的存储顺序是相同的）
c.底层存储采用链表的数据结构，查询和修改的效率比较低，新增和删除的效率比较高

链表的存储：当添加第一个元素的时候，会自动的添加进去第二个元素的地址



3.Vector
特点：
a.在用法上和ArrayList几乎完全相同
b.Vetor是一个古老的集合。（JDK1.0开始）
c。Vector是线程安全的，ArrayList是线程不安全的（推荐使用ArrayList，Collections工具类可以将一个ArrayList变成线程安全的）
d.在性能上比ArrayList低


4.Satck

是Vector的子类，用于模拟栈这种数据结构，栈通常是先进后出
最后push进栈的元素，将最先被pop出栈，进栈出栈都是Object，从栈中取出元素后必须要做强制类型转换

### 三、遍历集合

1.增强for循环
2.迭代器Iterator（接口）
3.ListIterator迭代器



## 》十五：

### 一、Set接口

Set集合不允许包含相同的元素，如果试图将两个相同的元素添加到一个集合中，使用add方法，添加失败，返回false
1、HashSet
HashSet是Set集合的一个实现类，大多数情况使用它

特点：
a,排重（相同的元素不能被重复添加）
原理：如果两个对象的hashCode相同，并且通过equals方法比较返回的结果也是相同的，HashSet集合会认为这两个元素是同一个，集合中只会被添加一次
b。无序的（元素的添加的顺序和底层存储的顺序不同，是随机的，是由一套算法决定的，每次的顺序很可能不一样）
c.集合元素值可以是null
d.底层存储采用的数据结构是哈希算法，具有很好的存取和查找功能
原理：hashCode值决定了元素在内存中的存储地址，可以通过hashCode值就可以访问到集合的元素



2.LinkedHashSet
是hashSet的一个子类，使用和HashSet基本相同

特点：
a.排重的
b。有序的（元素的添加顺序和底层的存储顺序相同）
c。底层存储采用的数据结构是链表


3.TreeSet
是Set接口的一个实现类，同时也是SortedSet接口的唯一实现类，可以确保集合元素处于排序状态

特点：
a.排重的
b.有序的
c.底层存储采用的数据结构是二叉树（红黑树）（数据结构）


排序方式：
a。自然排序
TreeSet会调用集合元素的compareTo()方法比较元素之间的大小关系，然后按照升序进行排序

Java提供了一个Comparable接口，这个接口里有compareTo()方法，该方法返回一个整数。实现该接口的类必须重写compareTo()方法
规则是：
obj1 compareTo(obj2):
0:相等
正整数：obj1 > obj2
负整数：obj1 < obj2

Java中的一些常用类已经实现了Comparable接口，并重写了compareTo()方法，提供了比较大小的一套标准，Integer、Character（unicode编码）、Boolean(true  > false),String(unicode编码),Date（后面的日期比前面的日期大）

b.定制排序
如果要实现降序排序，可以采用定制排序，主要需要实现一个Comparator接口，其中包含了一个compare（）方法

规则：
int compare(obj1，obj2)
0:相等
正整数：obj1 > obj2
负整数：obj1 < obj2

### 二、Map接口

Map同样是一个集合的接口，同样用来存储引用数据类型，变长的容器，主要用于保存具有映射关系的数据，Map中的元素是以键值对的形式存在的
key:键
value:值
userName:zhangsan
password:1243134


key和value之间是单向的一对一的关系，可以通过指定的key就可以找到对应的value

特点：
a.Map中的元素是以键值对的形式存在的，一个键对应一个值，不允许只有键没有值，也不允许一个键对应多个值
b.Map中的元素是按照键进行排重的，Map中的键不允许重复，如果添加相同的键，这时后添加的会覆盖原来的
c。键和值都是引用数据类型
d.键和值可以为null（针对部分）

1.HashMap
特点：
a.无序的，
b.底层存储采用的数据结构是哈希算法


2.LinkedHashMap

特点：
a.有序的，
b.底层存储采用的数据结构是链表


3.Hashtable
Hashtable和HashMap之间的关系就相当于是Vector和ArrayList之间的关系

区别：
a.在用法上和HashMap基本相同
b.Hashtable是一个古老的Map实现类（JDK1.0开始就存在了）
c。Hashtable是线程安全的，HashMap是不安全的，推荐使用HashMap、
d.Hashtable的性能比HashMap的低
e.Hashtable是不允许将null作为键和值的。如果试图将null添加到Hashtable中时，将引发NullPointerException，


4.TreeMap
TreeMap是Map集合的一个实现类，同时也是SortedMap的实现类

特点：
a.有序的
b.底层存储采用的数据结构是二叉树（红黑树）


TreeMap中的排序主要针对的是Key
排序方式：自然排序和定制排序


5.Map的遍历、

a.增强for循环
b迭代器Iterator
c。entrySet

### 三、Collections工具类（Arrays工具类）



### 四。集合的总结

1.是否排重
XxxxxxList：不排重
XxxxxxSet：排重
XxxxxMap:按照键排重

2.底层存储的数据结构
ArrayList:数组结构
HashXxxxx:哈希算法
LinkedXxxx:链表
TreeXxxx:二叉树（红黑树）

3.是否有序
HashXxxx:无序的
LinkedHashXxxx:有序的



## 》十六：

### 一、File类

主要用于文件操作
对存储在磁盘上的文件和目录的抽取和封装

### 二、IO流

1.概念
File类只能创建或者修改文件或者文件夹的层级结构，如果要访问文件中的内容的话，就需要用到IO流（Input Output，输入输出流）


操作磁盘上的文件内容，实现数据的输入输出操作，磁盘上的文件和内存之间进行交互需要有一个媒介或者管道，这个媒介或者管道就称为IO流


2.流的分类
a.按流的流向分：
输入流：数据从磁盘到内存，只能从中读取数据，不能写入数据，例如：InputStream(字节输入流)，Reader(字符输入流)
输出流：数据从内存到磁盘，只能向其写入数据，不能读取数据，例如:OutputStream（字节输出流），Writer(字符输出流)


b。按数据单位分：
区别：所操作的数据单元不同，字节流操作的最小数据单元是8位的字节，而字符流操作的最小数据单元是16位的字符
字符流：主要使用Reader和Writer作为基类
字节流：主要使用InputStream和OutStream作为基类

c.按层次分
节点流：可以从/向一个磁盘读/写数据的流，
处理流：用于对一个已经存在的流进行连接或者封装，高级流

3.实现
1>InputStream和Reader
抽象类，是不能用来实例化对象的
FileInputStream   FileReader

2>OutputStream和Writer
FileOutputStream   FileWriter


注意：流在使用完毕之后需要关闭，释放和此流有关的系统资源



## 》十七：

### 一、转换流

作用：实现将字节流转换为字符流

a.InputStreamReader:字节字符转换输入流：字节输入流----->字符输入流
b.OutputStreamWriter:字节字符转换输出流：字节输出流----->字符输出流

问题一：为什么没有将字符流转换为字节流的转换流？？
字节流比字符流的使用范围更广，字符流比字节流操作方便


问题：使用字符输入流读取一个文件中的内容，默认处理文件的编码格式为GBK，当文件的内容是GBK以外的格式时，读取出来的内容是乱码的，所以需要转换流去处理这个问题

问题二：什么时候使用转换流？
如果需要处理其他编码格式的文本（默认为GBK），这个时候使用转换流



### 二、缓冲流

1.概念
当需要操作数据的时候，为了提高工作效率，并不是直接去操作流中的数据，而是在流中有一种缓冲区（数组），我们要操作的其实是缓冲区的中数据

2.分类
缓冲字节输入流：BufferedInputStream
缓冲字节输出流：BufferedOutputStream
缓冲字符输入流：BufferedReader
缓冲字符输出流：BufferedWriter



### 三、Properties类-----扩展

是Map接口的一个实现类，并且是Hashtable的子类



四、对象流-----本地化
操作的数据是对象
常用：将一个对象固化到本地磁盘上，可以用作存储和加载
ObjectInputStream
OBjectOutputStream



### 》十八：

#### 一、进程和线程

1.进程
是一个程序的运行状态和资源占用的描述

进程的特点：
a.独立性：不同的进程之间是独立的，相互之间资源不共享
b.动态性：进程在系统中不是静止不动的，而是一直活动的
c.并发性：多个进程可以在同一个处理器上同时进行，互不影响

多进程：一个操作系统可以运行多个应用程序

2.线程
线程是进程的组成部分，一个进程可以有多个线程，每个线程用来处理一个指定的子任务

举例：打开酷狗软件------->这是一个进程
播放歌曲/刷新歌词------>两个线程（并发的）

线程的执行是抢占式的，多个线程可以在一个进程中并发执行，其实质是CPU在不同的线程之间进行快速的切换，也就是说，当前运行的线程在任何时候都有可能被挂起，以便于别的线程去执行对应的任务，同样的，被挂起的线程随时有可能争抢到时间片，继续执行

多线程：在一个进程中，多个线程同时进行
应用：一个浏览器可以同时下载多张图片
一个服务器可以同时响应多个用户请求


3.进程和线程之间的关系
a.一个程序运行后至少有一个进程
b.一个进程可以包含多个线程，但至少需要有一个线程，否则进程是没有意义的


为什么要选用多线程编程而不选用多进程呢？/线程相对于进程的优点？
a.进程间资源不能进行共享，但是线程之间可以共享资源
b.系统如果要创建进程的话，需要为这个进程重新分配系统资源，而创建线程的话则相对容易的多，因此使用线程处理并发任务比进程的效率高
c.Java中内置了多线程的功能支持，简化了多线程编程

#### 二、线程的实现

1.继承自Thread类 
Thread类是所有线程类的父类，实现了对线程的抽取和封装
1>使用Thread类创建并开启线程的步骤：
a.定义一个类，继承自Thread类，重写该类的run方法，该run方法的方法体就代表了线程需要完成的任务，因此，run方法体也被称为线程执行体
b.创建子类的对象，即相当于创建了一个线程
c.需要使用start方法手动开启线程


关于线程的执行，需要注意的问题：
a.如果一个线程中的所有的任务都处理完了，那么这个线程会自动停止（正常情况）
b.如果在一个线程a中开辟了子线程a0,a1,a2.....那么线程a停止后，在这个线程中开辟的子线程会全部停止
c.多个线程并发执行，其实就是在争抢CPU时间片


2.实现接口Runnable
使用实现Runnable接口的方式创建并开启线程的步骤：
a.定义一个类，这个类实现Runnable接口，需要重写对应的run方法，run方法的方法体同样是线程的执行体
b.创建实现了Runnable接口对应类的对象，并以此实例作为Thread类的target对象
c.手动调用start方法开启线程


两种方式实现线程的比较：
1.实现Runnabel接口
a.自定义的类只是实现了Runnable接口，同时还可以去继承其他的类
b.多个线程可以共享同一个target对象，所以非常适合多个相同的线程来处理同一份资源的情况
弊端：不直观，如果要获取当前正在运行的线程，只能通过Thread.currentThread()
2.继承Thread类
直观，如果要访问正在运行的线程，除了可以通过Thread.currentThread()方式之外，还可以使用super关键字

弊端：因为线程类已经继承了Thread类，所以不能再去继承其他的类（单继承）


实际上，大多数的多线程应用都采用实现Runnable接口的方式实现(推荐使用匿名内部类)

#### 三、线程的生命周期

对象的生命周期：从一个对象被实例化到这个对象被销毁的过程中，这个对象经历的种种状态

举例：人的生命周期：出生---婴儿---儿童---少年---青年----中年---老年---死亡


对于线程，当一个线程被创建并启动之后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，同样的也会经历各种过程（在一个进程中，多个线程可以并发，争抢CPU时间片）


New(新生):线程被实例化，但是还没有开始执行
Runnable(就绪)：没有争抢到时间片
Running（运行）：争抢到了时间片，开始执行线程中的任务
Blocked(阻塞)：线程再执行的过程中遇到突发状况，使得其他的线程争抢去了时间片，被阻塞的线程会等待合适的时机重新进入就绪状态
Dead(死亡)：线程终止
a.run方法执行完毕，线程正常结束
b.直接调用该线程的stop方法强制终止这个线程（这种做法比较危险，死锁）

#### 四、线程的常用方法

1.设置线程的优先级
可以通过设置优先级来改变线程抢到时间片的概率，优先级高的线程抢到时间片的概率比较高，可以获得更多的执行机会

默认情况下，每个线程的优先级都与创建它的的父线程具有相同的优先级
setPriority（），所传的参数范围1~10，默认为5，对应的数值越大，说明优先级越高，这个方法的设置一定要在start之前

2.使得线程休眠
使得当前正在执行的线程休眠一段时间，释放时间片，导致线程进入阻塞状态
sleep(5000);5000代表的是毫秒
设置了sleep就相当于将当前线程挂起5s,这个操作跟线程的优先级无关，当对应的时间到了之后，还会再执行，
如果只设置了优先级的话，等于给设置了优先级的线程设置冲突，那么被挂起的是优先级比较低的那个线程

3.中断线程
interrupt（）
interrupt只是改变一个线程的状态，并不是真正的停止一个线程
如果线程处于阻塞状态（sleep,join），则中断状态被清除
如果一个线程没有处于阻塞状态，这时调用interrupt将不起作用，否则，会引起InterruptedException异常（该线程预先准备好处理此状况）

实际看到的效果：停止了线程

在线程的执行体中，可以通过 boolean isInterrupted() 来测试线程是否已经中断。 


4.线程合并
join()
优先执行被合并进来的线程，执行完合并进来的线程之后，再执行原来的线程


5.后台线程
setDeamon（）
又被称为守护线程或者精灵线程
特征：如果所有的前台线程都死亡，后台线程会自动死亡

这个方法的调用需要在start之前

6.线程让步
yield（）
yield方法是一个和sleep方法相似的方法
它可以让当前正在执行的线程暂停，但他不会阻塞该线程，它只是将该线程转入就绪状态，完全会出现的一个情况是：当某个线程调用了yield方法暂停之后，线程调度器可能会将该线程立马调起来进入执行状态
实际上，只有优先级相同或者优先级更高的线程才有可能获取执行的机会



yield方法和sleep方法的区别：
a.sleep方法暂停当前线程之后，会给其他线程执行的机会的，但是跟线程的优先级没有关系，yield只有优先级相同或者优先级更高的线程才有可能获取执行的机会
b.sleep会将一个线程转入阻塞状态，但是yield不会，只是做出了让步
c.sleep会有InterruptedException的异常，但是yield没有
d.sleep可以有更好的可移植性，通常不要依靠yield来控制并发的线程



## 》十九：

### 一、多线程使用过程中的临界资源问题

1.临界资源：被多个线程同时访问的资源

临界资源产生的原因：有多个线程同时访问一个资源的时候，如果一个线程在取值的过程中，时间片又被其他的线程抢走了，临界资源问题就产生了


如何解决临界资源问题？
一个线程在访问临界资源的时候，如果给这个资源上一把锁，这个时候如果其他线程也要访问这个资源的话，就需要在锁外面等待


2.锁： 

对象锁：在Java中，任意的对象都可以被当做锁来使用
类锁：把一个类当做锁，语法：类名.class

### 二、使用锁来解决临界资源问题

1.同步代码块
语法：
synchronized(锁) {

}

说明：
a.程序执行到了同步代码块中，就使用锁锁住了临界资源，这个时候，其他的线程是不能执行代码段中的代码的，只能在锁外面进行等待
b.执行完代码段中的代码，会进行自动解锁，那么这个时候其他的线程开始争抢时间片
c.一定要保证不同的线程看到的是同一把锁，否则同步代码块没有意义


2.同步方法
synchronized 访问权限修饰符 返回值类型  函数名（参数列表） {
//被多个线程可以同时访问的临界资源
}

3.同步锁（JDK1.5之后新增的）
可以通过定义同步锁对象来实现同步，和同步代码块以及同步方法具有相同的效果

1>使用ReentrantLock类来进行锁的操作，实现了Lock接口
lock（）：加锁
unlock（）：解锁

### 三、单例在多线程中的应用

### 四、生产者与消费者设计模式

1.对临界资源问题的应用
它描述的是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者可以从仓库中取走产品，解决生产者消费者问题，我们需要做的就是保证生产者和消费者之间的同步

同步问题的核心：常用的方式就是加锁，目的是为了保证在任意时刻资源只能被一个线程访问

2.实现
wait():当缓冲区已满或者为空的情况下，生产者/消费者停止自己的执行，放弃锁，使自己处于等待状态，让其他线程执行
Object的方法
调用方法：对象.wait()
释放 对象 这个锁标记，然后再锁外面进行等待(sleep是持有锁进行休眠)
必须放到同步代码段中执行


notify():当生产者/消费者向缓冲区中放入/取走一个产品时，向其他等待的线程发出通知，同时使自己放弃锁，处于等待状态
Object的方法
调用方法：对象.notify()
表示唤醒 对象  锁标记外面正在等待的一个线程


notifyAll():全部唤醒
调用方法：对象.notify()
表示唤醒 对象  锁标记外面正在等待的所有线程

## 》二十： 

### 一、网络编程基础

#### 1.概念

所谓计算机网络，就是把分布在不同区域的计算机与专门的外部设备使用通信线路连接成一个规模大，功能比较强的网络系统，从而使得计算机之间可以相互通信，共享资源
所谓的网络编程，在同一个网络中不同的机器之间进行通信

#### 2.计算机之间进行通信的必要条件

ip地址，端口，网络协议

1>ip地址
ip地址其实就是计算机在网络中的地址，是一个32位的二进制数，通常被分为4个8位二进制
一台计算机在网络中的地址，在同一个网段内，ip地址是唯一的
ipv4:由4个字节组成，分为四段
ipv6：由6个字节组成，分为六段
ip地址的分类（5类）
A：保留给政府机构，1.0.0.1~126.255.255.254
B:分配给中型企业,128.0.0.1~191.255.255.254
C:分配给任何需要的个人，192.0.0.1~223.255.255.254
D：用于组播，224 ~ 239
E：用于实验，240~255
127.一般指的是本机的ip，localhost

2>端口
数据的发送和接受都是需要通过端口出入机器的，在同一台机器上，两个不同的程序不能占用同一个端口，端口号的范围：0~65535

a.公认端口：0~1023
b.注册端口：1025~49151
c.动态或私有端口：1024~65535


3>网络协议
需要通信的设备之间要实现相同的通信协议，才能进行相互通信
网络分层：物理层，数据链路层 ，网络层，传输层，会话层，表示层，应用层
传输层协议：TCP\UDP
应用层协议：HTTP(是一个被动的协议，只有客户端主动给服务端发送请求的时候，服务端才会给客户端响应)

环信   融云

#### 3.InetAddress类

在java中，使用InetAddress类来代表ip地址，是对ip地址的抽取和封装，有两个子类：Inet4Address,Inet6Address.,分别是ipv4和ipv6的抽象
Java中涉及到网络的类基本都存在于java.net包下

#### 4.使用UDP实现数据的接受和发送

UDP:是一个面向无连接的，效率高的，但是相对不安全的通信协议

UDP传输的数据是封装到数据报包中进行的，该协议并不能保证数据能够正确的到达目的地

涉及的类：
Socket：实现数据的接受和发送，又被称为套接字，是两台机器之间进行通信的端口
DatagramSocket：用来表示发送和接收数据报包的套接字，在这个类上总是启用UDP进行数据发送

DatagramPacket:数据报包，用来将指定长度的包接收或者发送到指定主机上的指定端口号上

## 5.使用TCP实现数据的接受和发送

TCP：面向连接的，安全的，基于字节流的传输层通信协议，但是效率没有UDP高

面向连接：需要在通信的两个机器之间建立通信

使用经典的三次握手建立连接
a.客户端向服务端发送一个请求
b.服务端收到请求之后，回客户端一个响应
c.当客户端收到服务端的响应之后，回服务端一个确认信息


总结：使用TCP实现数据的发送和接收需要有发送方和接收方

涉及到的类
Socket：此类实现客户端套接字
ServerSocket：此类实现服务器套接字

a.客户端发送消息，服务端接收消息
b.客户端发送消息，服务端回复消息
c.客户端上传文件到服务端（图片）
d.客户端从服务端下载文件（图片）



## 》二十一：

### 一、URL和URLConnection

#### 1.HTTP

超文本传输协议
是一个应用层的协议
是一个被动的协议
只有客户端主动给服务端发送消息，服务端才会给客户端一个响应

#### 2.URL

统一的资源定位符（网址）
指向一个网络上的资源

格式：网络通信协议：//主机：端口/要访问的文件路径？参数键1=参数值1&参数键2=参数值2.。。。。
如果没有写端口号的话，默认为80
举例：http://image.baidu.com/search/index?tn=baiduimage&ct=201326592&lm=-1&cl=2&ie=gbk&word=%CD%BC%C6%AC&fr=ala&ala=1&alatpl=others&pos=0

常用构造方法：
URL(String spec) 
根据 String 表示形式创建 URL 对象。
URLConnection openConnection() 
返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。 

URL：为了建立一个本机到网络指定资源的通道，就可以直接访问网络资源

#### 3.URLConnection

是一个抽象类，无法实例化对象
如果要访问指定的网络资源，则需要用到URLConnection，表示应用程序和URL之间的连接，

常用方法：
getInputStream:获取一个网络到本机的输入流
getOutputStream：获取本机到网络的输出流

#### 4.HttpURLConnection

也是一个抽象类，是URLConnection的子类
定义了一些常用的字段
HTTP_OK     200   请求成功
HTTP_NOT_FOUND    404  要请求的资源不存在
HTTP_FORBIDDEN    403  访问被拒绝
HTTP_UNAVAILABLE  503      服务无法访问

常用的方法
int getResponseCode() 
从 HTTP 响应消息获取状态码。

String getResponseMessage() 
获取与来自服务器的响应代码一起返回的 HTTP 响应消息（如果有）。 

setReadTimeout
设置一个请求的超时时间
一个请求在发出去之后，如果在指定的时间之内未收到响应，则认为请求超时
区分sleep，sleep会阻塞线程，在设置的时间之内是静态的，setReadTimeout在设置的时间之内是动态的，一直在向服务器请求数据
如果在指定的时间之内服务器没有响应的话，则会抛出SocketTimeoutException


应用：
a.使用URLconnection将一张网络图片下载到本地
b.使用URLConnection请求网络数据到本地





## 》 二十二：

### 一、反射机制

#### 1.概念

反射机制指的是程序在运行的过程中，对于任意一个类，都能够知道这个类对应的所有的属性和方法；对于任意一个对象，都能够调用其中的任意的方法和属性，在Java中，把这种动态获取信息以及动态调用对象的方法的功能称为Java语言的反射机制
一个类编译之后会生成对应的class字节码文件，可以通过这个字节码文件动态的去获取所有的类，对类中的属性和方法进行访问


在Java中，对类、构造方法、属性、普通方法分别抽象除了对应的类：Class、Constructor、Field、Method

```java
class Animal {
String name;
int age;

public Animal() {
}

public void show() {
}
}

class Cat extends Animal{

public Cat() {
}

}

class Dog extends Animal{

public Dog() {
} 
}

class Desk {
String color;
float weight;

}

class Text {
//属性
Field field;

//构造方法
Constructor con;

//普通方法
Method me;

}
```

反射到底能做什么？
1.判断任意一个对象所属的类
2.构造任意一个类的对象
3.可以判断任意一个类所具有的成员变量和方法
4.调用任意一个对象的方法

a.获取一个Class对象
b.实例化一个Class对象
c。获取构造方法
d。获取属性
e.获取普通方法


应用：反射结合工厂设计模式的使用


每天多努力一点，你将会变得更好。