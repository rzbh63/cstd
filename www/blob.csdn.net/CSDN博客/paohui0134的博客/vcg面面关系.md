
# vcg面面关系 - paohui0134的博客 - CSDN博客


2016年12月11日 20:26:21[paohui0134](https://me.csdn.net/paohui0134)阅读数：330


# vcg面面关系
vcg的面面关系通过`tri::UpdateTopology<CMeshO>::FaceFace`方法初始化
## FaceFace
1.先获取所有的边
```python
static
```
```python
void
```
```python
FillEdgeVector(MeshType &m,
```
```python
std
```
```python
::
```
```python
vector
```
```python
<PEdge>
```
```python
&e,
```
```python
bool
```
```python
includeFauxEdge=
```
```python
true
```
```python
)
。。。
```
```python
//先遍历面获取边的数量
```
```python
for
```
```python
(fi = m.face.begin(); fi != m.face.end(); ++fi)
```
```python
if
```
```python
(! (*fi).IsD()) n_edges+=(*fi).VN();
```
```python
//遍历所有的面获取边信息
```
```python
(*p).Set(&(*pf),j)
```
```python
//pf为面  j代表第几个顶点（边）
```
```python
//对所有的边进行排序，排序的依据取决于 inline bool operator <  ( const PEdge & pe ) const
```
```python
//先比较第一个点的地址，然后比较第二个，由于顶点是存储在vector中，所以地址是连续的
```
```python
//根据边信息获取面信息
```
```python
//重第一条边开始
```
```python
typename
```
```python
std
```
```python
::
```
```python
vector
```
```python
<PEdge>
```
```python
::iterator pe,ps;
  ps = e.begin();pe=e.begin();
```
```python
//循环分析关系
```
```python
do
```
```python
{
```
```python
//判断是否已到结尾或者边是否相等（两个顶点相同）
```
```python
if
```
```python
( pe==e.end() || !(*pe == *ps) )          
    {
```
```python
typename
```
```python
std
```
```python
::
```
```python
vector
```
```python
<PEdge>
```
```python
::iterator q,q_next;
```
```python
//遍历重开始到迭代器结尾迭代器前一个迭代器的所有边
```
```python
for
```
```python
(q=ps;q<pe-
```
```python
1
```
```python
;++q)                     
      {
```
```python
//边序号必须大于-1
```
```python
assert((*q).z>=
```
```python
0
```
```python
);
```
```python
//获取相对于当前迭代器的下一个迭代器
```
```python
q_next = q;
        ++q_next;
```
```python
//确保下一个迭代器边序号大于-1
```
```python
assert((*q_next).z>=
```
```python
0
```
```python
);
```
```python
//确保下一个迭代器变序号小于面的顶点数
```
```python
assert((*q_next).z< (*q_next).f->VN());
```
```python
//FFp函数：(*this).Base().AF[(*this).Index()]._fp[j]
```
```python
//(*this).Index()表示当前面的序号，也就是(*q).f这个面的序号
```
```python
//AF为std::vector<struct AdjTypePack> AV
```
```python
//整句代码表示(*q).f这个面的第q->z条边的邻接面为(*q_next).f
```
```python
(*q).f->FFp(q->z) = (*q_next).f;
```
```python
//类似的，(*q).f这个面的第q->z个点（边）是(*q_next).f这个面的第z个点（边）
```
```python
(*q).f->FFi(q->z) = (*q_next).z;
      }
      assert((*q).z>=
```
```python
0
```
```python
);
      assert((*q).z< (*q).f->VN());
```
```python
//回过头来处理q_next的信息
```
```python
(*q).f->FFp((*q).z) = ps->f;
      (*q).f->FFi((*q).z) = ps->z;
```
```python
//下个循环从pe开始
```
```python
ps = pe;
      ++ne;                                     
    }
```
```python
//结尾的迭代器已到结尾那么分析结束
```
```python
if
```
```python
(pe==e.end())
```
```python
break
```
```python
;
```
```python
//否则结尾迭代器往前进一位
```
```python
++pe;
  }
```
```python
while
```
```python
(
```
```python
true
```
```python
);
```
分析边的几种情况
1.ps边没有是边界边，也就是没有多个三角形共用这条边，这种情况下pe为ps+1，也就是说`for (q=ps;q<pe-1;++q)`循环无法进入，但是for循环下面的代码会执行，也就是
```python
(*q).f->
```
```python
FFp
```
```python
((*q).z) = ps->f;
(*q).f->
```
```python
FFi
```
```python
((*q).z) = ps->z;
此时q==ps，所以边界边的邻接三角形就是自己
```
2.ps边为两个三角形共用的边，这是比较常规的情况，此时pe=pe+1，由于边数据是排过序的，所以此时pe=ps，那么++pe，接着进行下一次判断，此时q_next就是pe+1，由于pe与q_next是同一条边当时属于两个三角形，所以三角形的邻接关系就出来了，处理完两条边相互之间的邻接关系之后，ps=pe，++pe，开始下一轮循环
3.ps边为超过两个三角形共用的边，也就是交叠边现象，此时pe会多次++跳过这些三角形，for循环中会依次处理这些交叠的三角形，但是否循环之后，只会处理最后一个三角形与倒数第一个三角形关于这条边的邻接关系：
比如 f1   f2    f3是这种交叠的关系，
那么f1对于交叠边的邻接三角形是f2
f2对于交叠边的邻接三角形是f3
f3对于交叠边的临界三角形是f1
情况二是情况三的一种特殊情况
## tri::Clean<CMeshO>::CountNonManifoldEdgeFF
获取交叠边的数量
主要方法为
```python
//
```
```python
如果是流形边，返回
```
```python
true
```
```python
，否则返回
```
```python
false
```
```python
template <
```
```python
class
```
```python
FaceType
```
```python
>
```
```python
inline bool IsManifold( FaceType
```
```python
const
```
```python
& f,
```
```python
const
```
```python
int j )
{
```
```python
//
```
```python
确保面面关系不为空，也就是经过了FaceFace函数
  assert(f.cFFp(j) !=
```
```python
0
```
```python
);
```
```python
//
```
```python
never
```
```python
try
```
```python
to use
```
```python
this
```
```python
on
```
```python
uncomputed topology
```
```python
if
```
```python
(
```
```python
FaceType
```
```python
::HasFFAdjacency())
```
```python
//
```
```python
f.cFFp(j) == &f代表边界边
```
```python
//
```
```python
f.cFFp
```
```python
(j)
```
```python
->
```
```python
cFFp(f.cFFi(j)) f第j条边的邻接面的对应边的邻接面f1，如果f==f1，说明是正常的邻
```
```python
//
```
```python
接关系
```
```python
return
```
```python
( f.cFFp(j) == &f || &f == f.cFFp(j)->cFFp(f.cFFi(j)) )
```
```python
;
```
```python
else
```
```python
return
```
```python
true
```
```python
;
}
```

