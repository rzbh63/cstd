
# 6.6 函数指针与指针识别 -  芝麻软件工作室的专栏 - CSDN博客


2016年06月13日 09:02:39[seven-soft](https://me.csdn.net/softn)阅读数：129个人分类：[C++																](https://blog.csdn.net/softn/article/category/6266511)



## 函数指针及其应用
◆1、函数名与函数指针
函数名对应于该函数执行代码的入口地址。通过取地址运算符“&”也可以取得函数的入口地址。指向函数的指针可以作为函数的参数传递。定义方式如下：
返回类型
 (*指针变量名)(参数表)
由于一个函数不能以函数作为参数，所以当一个函数需要将函数作为参数时必须借用指向函数的指针（也可以用包含该函数的类对象）。
◆2、函数指针的使用方法
如有函数void scopy(char *q,char *p)，函数名scopy代表函数的入口地址，或者说是一个指向该函数的指针，该指针的类型为：
void (*)(char *q,char *p) //q与p写与不写是一样的
定义这种函数指针类型的变量pf并用scopy初始化：
void(* pf)(char *,char *)=scopy; //或者=&scopy，两者等效
pf将存储scopy函数的入口地址。
【例6.13】梯形法求积分的函数integer()作为通用函数，可求任一函数的定积分。（[查看源码](http://www.weixueyuan.net/templets/default/cpp/source/Ex6_13.txt)）
## 指向类成员的指针
◆1、指向类成员函数的指针
在类对象中有隐含的this指针，用以正确访问成员函数。所以指向类成员函数的指针有其特殊性。
成员函数有一个非成员函数没有的属性：它所属的类（class）。所以指向成员函数的指针需要三个方面的匹配：参数的类型和个数，返回类型和所属的类类型。
普通函数指针存储函数的地址，可以直接用来调用指定函数。成员函数指针必须首先被绑定在一个对象或指针上，才能获得被调用对象的this指针，然后才能调用指针所指向的成员函数。虽然两者都被称为指针，但是它们是不同类型的数据。
◆2、指向类成员函数的指针的说明及初始化
以指向商品类 GetPrice()函数的指针为例：
float (CGoods::*pf)()= CGoods::GetPrice;
◆3、成员函数指针的用法(绑定)
CGoods car;
(car.*pf)();
//将指针pf与对象car绑定，最终等效调用car. GetPrice ();
上式表示指针pf与对象car绑定，指向了car. GetPrice ()。所以指向成员函数的指针存储的不是成员函数的地址，绑定后才获得地址。
也可以用对象代替类进行初始化，效果一样：
CGoods car,motor;
float (CGoods::*pf)()=motor.GetPrice;
//等效float (CGoods::*pf)()= CGoods::GetPrice; 并未绑定
(car.*pf)(); //将指针pf与对象car绑定
## 指针的识别方法
◆1、复杂说明的阅读和理解的方法
说明中包括多种说明符容易造成阅读和理解的困难。
一种理解和构造对象说明的方法是：先撇开标识符，按从右到左的顺序逐个解释每个说明符，如果有括号则改变解释的先后，先解释括号内再解释扩号外。例如：
int *arrp[5];
按下列顺序理解：五个元素的数组、每个元素是一个指针、指针指向整型，所以arrp是一个有五个整型指针作为数组元素的数组。又如：
int (*parr)[5];
按下列顺序理解：是一个指针，指针指向一个包含五个元素的数组，每个元素是一个整型，所以parr是一个指向五个整型数的数组的指针。
◆2、复杂说明的实例
int i, *ip, f(), *fp(), (*pf)()；
*(*pfp)(), a[5], *ap[5], (*pa)[5], (*(*fap)[])();
答案：
i —— 是一个整型的变量；
ip—— 是一个指向整型变量的指针，即 ip 中存储的是另一个整型变量的地址；
f —— 是一个返回整型值的函数；
fp—— 是一个返回整型指针的函数，即 fp 返回的是一个指向整型变量的指针；
pf—— 是一个指向返回整型值的函数的指针；
pfp——是一个指向函数的指针，该函数返回一个整型指针；
a —— 是一个有五个整型元素的数组；
ap—— 是一个指针数组，每个元素是一个指向整型的指针；
pa—— 是一个指向整型数组的指针，该数组有五个整型元素；
fap——是一个指向数组的指针，该数组的每个元素都是一个指向函数的指针，而所指的函数的返回值是整型。

