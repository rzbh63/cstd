
# 数据结构例程——应用图的深度优先遍历思路求解问题 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月03日 21:45:48[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2825


本文是[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]中第8课时[[图的邻接矩阵存储结构及算法](http://edu.csdn.net/course/detail/1595/24598?auto_start=1)]的例程。
（程序中graph.h是图存储结构的“算法库”中的头文件，详情请[单击链接…](http://blog.csdn.net/sxhelijian/article/details/49591419)）
1、是否有简单路径?
问题：假设图G采用邻接表存储，设计一个算法，判断顶点u到v是否有简单路径。
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
int
```
```python
visited[MAXV];
```
```python
//定义存放节点的访问标志的全局数组
```
```python
void
```
```python
ExistPath(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v,
```
```python
bool
```
```python
&has)
{
```
```python
int
```
```python
w;
    ArcNode *p;
    visited[u]=
```
```python
1
```
```python
;
```
```python
if
```
```python
(u==v)
    {
        has=
```
```python
true
```
```python
;
```
```python
return
```
```python
;
    }
    p=G->adjlist[u].firstarc;
```
```python
while
```
```python
(p!=NULL)
    {
        w=p->adjvex;
```
```python
if
```
```python
(visited[w]==
```
```python
0
```
```python
)
            ExistPath(G,w,v,has);
        p=p->nextarc;
    }
}
```
```python
void
```
```python
HasPath(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v)
{
```
```python
int
```
```python
i;
```
```python
bool
```
```python
flag =
```
```python
false
```
```python
;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
        visited[i]=
```
```python
0
```
```python
;
```
```python
//访问标志数组初始化
```
```python
ExistPath(G,u,v,flag);
```
```python
printf
```
```python
(
```
```python
" 从 %d 到 %d "
```
```python
, u, v);
```
```python
if
```
```python
(flag)
```
```python
printf
```
```python
(
```
```python
"有简单路径\n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"无简单路径\n"
```
```python
);
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
A[
```
```python
5
```
```python
][
```
```python
5
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
},
    };
```
```python
//请画出对应的有向图
```
```python
ArrayToList(A[
```
```python
0
```
```python
],
```
```python
5
```
```python
, G);
    HasPath(G,
```
```python
1
```
```python
,
```
```python
0
```
```python
);
    HasPath(G,
```
```python
4
```
```python
,
```
```python
1
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试图结构及存储
![这里写图片描述](https://img-blog.csdn.net/20151103213225990)
2、输出简单路径
问题：假设图G采用邻接表存储，设计一个算法输出图G中从顶点u到v的一条简单路径（假设图G中从顶点u到v至少有一条简单路径）。
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
int
```
```python
visited[MAXV];
```
```python
//定义存放节点的访问标志的全局数组
```
```python
void
```
```python
FindAPath(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v,
```
```python
int
```
```python
path[],
```
```python
int
```
```python
d)
{
```
```python
//d表示path中的路径长度，初始为-1
```
```python
int
```
```python
w,i;
    ArcNode *p;
    visited[u]=
```
```python
1
```
```python
;
    d++;
    path[d]=u;
```
```python
//路径长度d增1，顶点u加入到路径中
```
```python
if
```
```python
(u==v)
```
```python
//找到一条路径后输出并返回
```
```python
{
```
```python
printf
```
```python
(
```
```python
"一条简单路径为:"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<=d; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,path[i]);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
;
```
```python
//找到一条路径后返回
```
```python
}
    p=G->adjlist[u].firstarc;
```
```python
//p指向顶点u的第一个相邻点
```
```python
while
```
```python
(p!=NULL)
    {
        w=p->adjvex;
```
```python
//相邻点的编号为w
```
```python
if
```
```python
(visited[w]==
```
```python
0
```
```python
)
            FindAPath(G,w,v,path,d);
        p=p->nextarc;
```
```python
//p指向顶点u的下一个相邻点
```
```python
}
}
```
```python
void
```
```python
APath(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v)
{
```
```python
int
```
```python
i;
```
```python
int
```
```python
path[MAXV];
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
        visited[i]=
```
```python
0
```
```python
;
```
```python
//访问标志数组初始化
```
```python
FindAPath(G,u,v,path,-
```
```python
1
```
```python
);
```
```python
//d初值为-1，调用时d++，即变成了0
```
```python
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
A[
```
```python
5
```
```python
][
```
```python
5
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
},
    };
```
```python
//请画出对应的有向图
```
```python
ArrayToList(A[
```
```python
0
```
```python
],
```
```python
5
```
```python
, G);
    APath(G,
```
```python
1
```
```python
,
```
```python
0
```
```python
);
    APath(G,
```
```python
4
```
```python
,
```
```python
1
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
3、输出所有路径
问题：输出从顶点u到v的所有简单路径。
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
int
```
```python
visited[MAXV];
```
```python
//定义存放节点的访问标志的全局数组
```
```python
void
```
```python
FindPaths(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v,
```
```python
int
```
```python
path[],
```
```python
int
```
```python
d)
```
```python
//d是到当前为止已走过的路径长度，调用时初值为-1
```
```python
{
```
```python
int
```
```python
w,i;
    ArcNode *p;
    visited[u]=
```
```python
1
```
```python
;
    d++;
```
```python
//路径长度增1
```
```python
path[d]=u;
```
```python
//将当前顶点添加到路径中
```
```python
if
```
```python
(u==v && d>
```
```python
1
```
```python
)
```
```python
//输出一条路径
```
```python
{
```
```python
printf
```
```python
(
```
```python
"  "
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<=d; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,path[i]);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    p=G->adjlist[u].firstarc;
```
```python
//p指向u的第一条边
```
```python
while
```
```python
(p!=NULL)
    {
        w=p->adjvex;
```
```python
//w为u的邻接顶点
```
```python
if
```
```python
(visited[w]==
```
```python
0
```
```python
)
```
```python
//若顶点未标记访问，则递归访问之
```
```python
FindPaths(G,w,v,path,d);
        p=p->nextarc;
```
```python
//找u的下一个邻接顶点
```
```python
}
    visited[u]=
```
```python
0
```
```python
;
```
```python
//恢复环境
```
```python
}
```
```python
void
```
```python
DispPaths(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v)
{
```
```python
int
```
```python
i;
```
```python
int
```
```python
path[MAXV];
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
        visited[i]=
```
```python
0
```
```python
;
```
```python
//访问标志数组初始化
```
```python
printf
```
```python
(
```
```python
"从%d到%d的所有路径:\n"
```
```python
,u,v);
    FindPaths(G,u,v,path,-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
A[
```
```python
5
```
```python
][
```
```python
5
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
}
    };
```
```python
//请画出对应的有向图
```
```python
ArrayToList(A[
```
```python
0
```
```python
],
```
```python
5
```
```python
, G);
    DispPaths(G,
```
```python
1
```
```python
,
```
```python
4
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试用的图结构、存储结构、运行结果
![这里写图片描述](https://img-blog.csdn.net/20151103214106628)
4、输出一些简单回路
问题：输出图G中从顶点u到v的长度为s的所有简单路径。
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
int
```
```python
visited[MAXV];
```
```python
//定义存放节点的访问标志的全局数组
```
```python
void
```
```python
SomePaths(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v,
```
```python
int
```
```python
s,
```
```python
int
```
```python
path[],
```
```python
int
```
```python
d)
```
```python
//d是到当前为止已走过的路径长度，调用时初值为-1
```
```python
{
```
```python
int
```
```python
w,i;
    ArcNode *p;
    visited[u]=
```
```python
1
```
```python
;
    d++;
```
```python
//路径长度增1
```
```python
path[d]=u;
```
```python
//将当前顶点添加到路径中
```
```python
if
```
```python
(u==v && d==s)
```
```python
//输出一条路径
```
```python
{
```
```python
printf
```
```python
(
```
```python
"  "
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<=d; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,path[i]);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    p=G->adjlist[u].firstarc;
```
```python
//p指向u的第一条边
```
```python
while
```
```python
(p!=NULL)
    {
        w=p->adjvex;
```
```python
//w为u的邻接顶点
```
```python
if
```
```python
(visited[w]==
```
```python
0
```
```python
)
```
```python
//若顶点未标记访问，则递归访问之
```
```python
SomePaths(G,w,v,s,path,d);
        p=p->nextarc;
```
```python
//找u的下一个邻接顶点
```
```python
}
    visited[u]=
```
```python
0
```
```python
;
```
```python
//恢复环境
```
```python
}
```
```python
void
```
```python
DispSomePaths(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v,
```
```python
int
```
```python
s)
{
```
```python
int
```
```python
i;
```
```python
int
```
```python
path[MAXV];
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
        visited[i]=
```
```python
0
```
```python
;
```
```python
//访问标志数组初始化
```
```python
printf
```
```python
(
```
```python
"从%d到%d长为%d的路径:\n"
```
```python
,u,v,s);
    SomePaths(G,u,v,s,path,-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
A[
```
```python
5
```
```python
][
```
```python
5
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
}
    };
```
```python
//请画出对应的有向图
```
```python
ArrayToList(A[
```
```python
0
```
```python
],
```
```python
5
```
```python
, G);
    DispSomePaths(G,
```
```python
1
```
```python
,
```
```python
4
```
```python
,
```
```python
3
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试的图结构、运行结果
![这里写图片描述](https://img-blog.csdn.net/20151103214239111)
5、输出通过一个节点的所有简单回路
问题：求图中通过某顶点k的所有简单回路（若存在）
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
int
```
```python
visited[MAXV];
```
```python
//全局变量
```
```python
void
```
```python
DFSPath(ALGraph *G,
```
```python
int
```
```python
u,
```
```python
int
```
```python
v,
```
```python
int
```
```python
path[],
```
```python
int
```
```python
d)
```
```python
//d是到当前为止已走过的路径长度，调用时初值为-1
```
```python
{
```
```python
int
```
```python
w,i;
    ArcNode *p;
    visited[u]=
```
```python
1
```
```python
;
    d++;
    path[d]=u;
    p=G->adjlist[u].firstarc;
```
```python
//p指向顶点u的第一条边
```
```python
while
```
```python
(p!=NULL)
    {
        w=p->adjvex;
```
```python
//w为顶点u的相邻点
```
```python
if
```
```python
(w==v && d>
```
```python
0
```
```python
)
```
```python
//找到一个回路，输出之
```
```python
{
```
```python
printf
```
```python
(
```
```python
"  "
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<=d; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,path[i]);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,v);
        }
```
```python
if
```
```python
(visited[w]==
```
```python
0
```
```python
)
```
```python
//w未访问，则递归访问之
```
```python
DFSPath(G,w,v,path,d);
        p=p->nextarc;
```
```python
//找u的下一个邻接顶点
```
```python
}
    visited[u]=
```
```python
0
```
```python
;
```
```python
//恢复环境：使该顶点可重新使用
```
```python
}
```
```python
void
```
```python
FindCyclePath(ALGraph *G,
```
```python
int
```
```python
k)
```
```python
//输出经过顶点k的所有回路
```
```python
{
```
```python
int
```
```python
path[MAXV],i;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
        visited[i]=
```
```python
0
```
```python
;
```
```python
//访问标志数组初始化
```
```python
printf
```
```python
(
```
```python
"经过顶点%d的所有回路\n"
```
```python
,k);
    DFSPath(G,k,k,path,-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
int
```
```python
main()
{
    ALGraph *G;
```
```python
int
```
```python
A[
```
```python
5
```
```python
][
```
```python
5
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
},
        {
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
}
    };
```
```python
//请画出对应的有向图
```
```python
ArrayToList(A[
```
```python
0
```
```python
],
```
```python
5
```
```python
, G);
    FindCyclePath(G,
```
```python
0
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试用图结构、输出结果
![这里写图片描述](https://img-blog.csdn.net/20151103214408532)

