
# Qt moc和元对象系统 -  芝麻软件工作室的专栏 - CSDN博客


2016年06月16日 17:31:20[seven-soft](https://me.csdn.net/softn)阅读数：470


Qt 不使用标准的C++语言，而是进行了一定程度的扩展，增加了一些新的关键字（例如 signals、slots、emit 等），并实现了反射（内省）机制。
我们知道，C++的对象内存模型非常干净，只有成员变量和成员函数，没有保留额外的类型信息，这使得C++非常高效。所谓类型信息，就是对象所属的类、所包含的成员函数和成员变量（以及它们的修饰符）、所在的继承关系等。类型信息用来描述一个对象的各种属性。
虽然C++提供了RTTI机制，但非常简陋，对象被创建后仅能获得类的名字，这使得RTTI不堪重用，如同鸡肋。像Java、C\#等面向对象的语言，可以通过对象完整还原出类的信息，例如类的名字、父类、类所包含的成员变量和成员函数以及它们的修饰符等。这被称作反射机制或内省机制，也就是说对象可以认知自己。
反射机制无疑会增加额外的存储空间，在效率上有所牺牲，而且在普通程序中没有用武之地，为了保持几乎与C同等的效率，C++不提供反射机制也有一定的道理。
但对于大型框架或类库来说，反射机制有时很有必要，它会增加程序的灵活性和动态性，例如动态加载类、解耦等。最明显的一个例子是编译器的智能提示，当输入完对象的名称，再输入`.`或`->`，就会提示该对象拥有的变量和函数，这是反射机制的典型应用。
如今，C++的反射机制在 Qt、Boost 等框架中的实现已经非常成熟。
## moc
Qt 在将源代码交给标准C++编译器之前，例如GCC、VS等，需要提前将这些扩展的语法去除掉。完成这一操作的就是 moc。
moc 全称是"Meta-Object Compiler"，也就是”元对象编译器“。moc 就是一个源代码分析程序，它会读取C++源文件，如果发现在一个头文件中包含了宏 Q_OBJECT，则会生成另外一个C++源文件。这个源文件中包含了
 Q_OBJECT 宏的实现代码。这个新文件的名字将由源文件名加上`moc_`前缀构成，读者可以在
 Debug 或 Release 目录中找到。
新文件并不会替换旧文件，而是与旧文件一起进入编译系统，最终被链接到二进制代码中去。
可以发现，moc 的执行在C++预处理器之前，因为预处理器执行之后会进行宏替换，Q_OBJECT 就不存在了。

