# 最近整理的一些常见的面试题，面试大全，黑马程序员面试宝典题库---JavaSE高级篇

2018年09月03日 14:23:31 [高数老师](https://me.csdn.net/qq_29073921) 阅读数：100



 版权声明：代码共享，欢迎copy	https://blog.csdn.net/qq_29073921/article/details/82347998

## 一、 Java 中的反射（评论留言获取原件）

### 1.说说你对 Java 中反射的理解

Java 中 的 反 射 首 先 是 能 够 获 取 到 Java 中 要 反 射 类 的 字 节 码 ， 获 取 字 节 码 有 三 种 方 法 ，
①.**Class.forName(className)** ②.**类名.class** ③.**this.getClass()**。然后将字节码中的方法，变量，构造函数等映射成
相应的 Method、 Filed、 Constructor 等类，这些类提供了丰富的方法可以被我们所使用。

##  二、 Java 中的动态代理  

### 2.动静态代理的区别，什么场景使用？

静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。
静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。
动态代理是实现 JDK 里的 InvocationHandler 接口的 invoke 方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过 Proxy 里的 newProxyInstance 得到代理对象。
还有一种动态代理 CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行时，动态修改字节码达到修改类的目的。
AOP 编程就是基于动态代理实现的，比如著名的 Spring 框架、 Hibernate 框架等等都是动态代理的使用例子。
三、 Java 中的设计模式&回收机制
 

### 3.你所知道的设计模式有哪些

Java 中一般认为有 23 种设计模式，我们不需要所有的都会，但是其中常用的几种设计模式应该去掌握。下面列出了所有的设计模式。需要掌握的设计模式我单独列出来了，当然能掌握的越多越好。
总体来说设计模式分为三大类：
创建型模式，共五种： **工厂方法模式**、 **抽象工厂模式**、 **单例模式**、 建造者模式、原型模式。
结构型模式，共七种： **适配器模式**、装饰器模式、 **代理模式**、外观模式、桥接模式、组合模式、 **享元模式**。
行为型模式，共十一种： **策略模式**、模板方法模式、 **观察者模式**、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
 

### 4.单例设计模式（写出一个单例模式）

①**饿汉式：**

```
public class Singleton {



    // 直接创建对象



    public static Singleton instance = new Singleton();



    // 私有化构造函数



    private Singleton() {



    }



    // 返回对象实例



    public static Singleton getInstance() {



        return instance;



    }



}
```

**②懒汉式**

```
public class Singleton {



    // 声明变量



    private static volatile Singleton singleton = null;



    // 私有构造函数



    private Singleton() {



    }



    // 提供对外方法



    public static Singleton getInstance() {



        if (singleton == null) {



        synchronized (Singleton.class) {



            if (singleton == null) {



                singleton = new Singleton();



            }



        }



    }



    return singleton;



}
```

### 5.JVM 垃圾回收机制和常见算法

①1. 如何确定某个对象是垃圾

​        1.1. 引用计数法

​        1.2. 可达性分析

②.释放空间
         垃圾回收算法

​         1）标记-清除（Mark-Sweep）：最基础的垃圾回收算法

​         2）.Copying（复制）算法

​         3）标记—整理算法（Mark-Compact）

​         4）分代收集（Generational Collection）

具体可参考<https://blog.csdn.net/ymrfzr/article/details/51354380>

### 6.Java 中引用类型都有哪些？（重要）

Java 中对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。

①强引用（StrongReference）
这个就不多说，我们写代码天天在用的就是强引用。如果一个对象被被人拥有强引用，那么垃圾回收器绝不会回收它。当内存空间不足， Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
Java 的对象是位于 heap 中的， heap 中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到达对象。应用的强弱顺序是强、软、弱、和虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。
②软引用（SoftReference）
如果一个对象只具有软引用，那么如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收， Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。
软引用是主要用于内存敏感的高速缓存。在 jvm 报告内存不足之前会清除所有的软引用，这样以来 gc 就有可能收集软可及的对象，可能解决内存吃紧问题，避免内存溢出。什么时候会被收集取决于 gc 的算法和 gc 运行时可用内存的大小。

③弱引用（WeakReference）
如果一个对象只具有弱引用，那该类就是可有可无的对象，因为只要该对象被 gc 扫描到了随时都会把它干掉。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收， Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

④虚引用（PhantomReference）
"虚引用"[顾名思义](https://www.baidu.com/s?wd=%E9%A1%BE%E5%90%8D%E6%80%9D%E4%B9%89&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，就是[形同虚设](https://www.baidu.com/s?wd=%E5%BD%A2%E5%90%8C%E8%99%9A%E8%AE%BE&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。

**虚引用与软引用和弱引用的一个区别在于**： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个         对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
        程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。
        建立虚引用之后通过 get 方法返回结果始终为 null,通过源代码你会发现,虚引用通向会把引用的对象写进referent,只是 get 方法返回结果为 null。

### 7.heap 和 stack 有什么区别

可参见：<https://blog.csdn.net/Fiorna0314/article/details/49757195>

 

### 8.解释内存中的栈 (stack) 、堆 (heap) 和方法区 (method area) 的用法

通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用 JVM 中的栈空
间；而通过 new 关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器
都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为 Eden、 Survivor（又可分为
From Survivor 和 To Survivor）、 Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被 JVM 加载
的类信息、常量、静态变量、 JIT 编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的 100、 "hello"
和常量都是放在常量池中，常量池是方法区的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆
空间，栈和堆的大小都可以通过 JVM 的启动参数来进行调整，栈空间用光了会引发 StackOverflowError，而堆和常
量池空间不足则会引发 OutOfMemoryError。
String str = new String("hello");
上面的语句中变量 str 放在栈上，用 new 创建出来的字符串对象放在堆上，而"hello"这个字面量是放在方法区
的。

##  四、 Java 的类加载器  

### 9.类什么时候被初始化？

1）创建类的实例，也就是 new 一个对象
2）访问某个类或接口的静态变量，或者对该静态变量赋值
3）调用类的静态方法
4）反射（Class.forName("com.lyj.load")）
5）初始化一个类的子类（会首先初始化子类的父类）
6） JVM 启动时标明的启动类，即文件名和类名相同的那个类
      只有这 6 中情况才会导致类的类的初始化。
      类的初始化步骤：
      1）如果这个类还没有被加载和链接，那先进行加载和链接
      2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直        接的父类（不适用于接口）
      3)加入类中存在初始化语句（如 static 变量和 static 块），那就依次执行这些初始化语句。
 

### 10.描述一下 JVM 加载 class

JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的， Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时,JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的 Class 对象。加载完成后， Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对类进行初始化，包括：

如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；
如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。
从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。 PDM 更好的保证了 Java 平台的安全性，在该机制中， JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器[无能为力](https://www.baidu.com/s?wd=%E6%97%A0%E8%83%BD%E4%B8%BA%E5%8A%9B&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)时才由其子类加载器自行加载。 JVM 不会向 Java 程序提供对 Bootstrap 的引用。
**下面是关于几个类加载器的说明：**
• Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；
• Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；
• System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量 classpath或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。
 

### 11.获得一个类对象有哪些方式？

类型.class，例如： String.class
对象.getClass()，例如：” hello” .getClass()
Class.forName()，例如： Class.forName(“java.lang.String” )
 

## 五、 JVM 基础知识  

### 12.既然有 GC 机制，为什么还会有内存泄露的情况


理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）。然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收，因此也会导致内存泄露的发生。
例如 hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。

##  六、 GC 基础知识  

### 13.Java 中为什么会有 GC 机制呢？

Java 中为什么会有 GC 机制呢？
• 安全性考虑； -- for security.
• 减少内存泄露； -- erase memory leak in some degree.
• 减少程序员工作量。 -- Programmers don't worry about memory releasing.
 

### 14.对于 Java 的 GC 哪些内存需要回收

​        内存运行时 JVM 会有一个运行时数据区来管理内存。它主要包括 5 大部分：**程序计数器(Program CounterRegister)、虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)**.

​        而其中程序计数器、虚拟机栈、本地方法栈是每个线程私有的内存空间，随线程而生，随线程而亡。例如栈中每一个栈帧中分配多少内存基本上在类结构确定是哪个时就已知了，因此这 3 个区域的内存分配和回收都是确定的，无需考虑内存回收的问题。
​        但方法区和堆就不同了，一个接口的多个实现类需要的内存可能不一样，我们只有在程序运行期间才会知道会创建哪些对象，这部分内存的分配和回收都是动态的， GC 主要关注的是这部分内存。
​        总而言之， GC 主要进行回收的内存是 JVM 中的方法区和堆；
 

### 15.Java 的 GC 什么时候回收垃圾

总而言之:
        对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而根据我们实际对引用的不同需求，又分成了 4 中引用，每种引用的回收机制也是不同的。
        对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无用类，就可以被回收了。

##  七、 Java8 的新特性以及使用  

### 16.java8的十大新特性

可参考：<https://blog.csdn.net/u014470581/article/details/54944384>

## 八、 在开发中遇到过内存溢出么？原因有哪些？解决方法有哪些？


**.引起内存溢出的原因有很多种，常见的有以下几种：**
       1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
       2.集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收；
       3.代码中存在死循环或循环产生过多重复的对象实体；
       4.使用的第三方软件中的 BUG；
       5.启动参数内存值设定的过小；
内存溢出的解决方案：

第一步，修改 JVM 启动参数，直接增加内存。 (-Xms， -Xmx 参数一定不要忘记加。 )
第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
重点排查以下几点：
       1.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
       2.检查代码中是否有死循环或递归调用。
       3.检查是否有大循环重复产生新对象实体。
       4.检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中 数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。
        5.检查 List、 MAP 等集合对象是否有使用完后，未清除的问题。 List、 MAP 等集合对象会始终存有对对象的引用，使得这些对象不能被 GC 回收。
第四步，使用内存查看工具动态查看内存使用情况。