
# uCOS-II任务机制 -  芝麻软件工作室的专栏 - CSDN博客


2016年07月13日 10:00:51[seven-soft](https://me.csdn.net/softn)阅读数：213


1．任务是一个无返回的无穷循环。uc/os-ii总是运行进入就绪状态的最高优先级的任务。
2． 任务是如何调度（切换）的？
因为uc/os-ii总是运行进入就绪状态的最高优先级的任务。所以，确定哪个任务优先级最高，下面该哪个任务运行，这个工作就是由调度器（scheduler）来完成的。
任务级的调度是由函数OSSched()完成的，而中断级的调度是由函数 OSIntExt()完成。对于OSSched()，它内部调用的是 OS_TASK_SW()完成实际的调度（人为模仿一次中断）；OSIntExt()内部调用的是OSCtxSw()实现调度。参考：P92，P106
任务切换其实很简单，由如下2步完成：（1）将被挂起任务的处理器寄存器推入自己的任务堆栈。（2）然后将进入就绪状态的最高优先级的任务的寄存器值从堆栈中恢复到寄存器中。参见P92
（1）作为uc/os-ii的一条普通原则，调用uc/os-ii功能函数时，中断总应当是开着的。
（2）任务永不返回，就算任务自我删除，也绝对不会返回。（任务删除并非代码删除，只是ucos-ii不会理会这任务。）
（3）OSTimeTick()函数是ucos-ii内部函数，用户无需调用。
（4）ucos-ii从中断返回之前，要判断被中断的任务是否还是就绪状态任务中优先级最高的任务。
3．    OSInit()初始化示意图
我做了一个很好的图示，竟然粘贴不出来，没办法...
4． 任务的5种状态
睡眠态(task dormat)：任务驻留于程序空间（rom或ram）中，暂时没交给ucos-ii处理。
就绪态（task ready）：任务一旦建立，这个任务就进入了就绪态。
运行态（task running）：调用OSStart（）可以启动多任务。OSStart（）函数只能调用一次，一旦调用，系统将运行进入就绪态并且优先级最高的任务。
等待状态（task waiting）：正在运行的任务，通过延迟函数或pend（挂起）相关函数后，将进入等待状态。
中断状态（ISR running）：正在运行的任务是可以被中断的，除非该任务将中断关闭或者ucos-ii将中断关闭。
5． 任务控制块(OS_TBC)
任务一旦建立，任务控制块OS_TBC将被赋值。
OS_TBC是一个数据结构，当任务的CPU使用权被剥夺后，ucos-ii将把当前的任务状态存放于OS-TBC数据结构中；当任务的CPU使用权得到恢复后，任务控制块能确保任务能从被中断点那一点丝毫不差地继续执行。
每个任务都有自己的OS_TBC控制块，OS_TBC的数量由OS_MAX_TASK决定，任务数量少，当然OS_TBC占用RAM的空间就少。
所有的任务控制块OS_TBC都是放在任务控制块列表数组OSTCBTbl[]中。在ucos-ii初始化时，所有任务控制块OS_TBC都被链表连接成单向空任务链表。
注意：OS_TBC全部驻留于RAM中。
6．关于任务切换使用到的OS_TASK_SW()函数，其中调用软中断实现寄存器的保持和弹出。开始调用含软中断，ucos-ii强制处理器保存psw、pc的当前值，最后通过执行中断返回指令，pc和psw的值装回到cpu中。

