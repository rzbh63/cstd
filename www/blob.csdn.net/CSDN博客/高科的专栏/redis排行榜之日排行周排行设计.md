
# redis排行榜之日排行周排行设计 - 高科的专栏 - CSDN博客

2018年07月20日 13:34:33[高科](https://me.csdn.net/pbymw8iwm)阅读数：1266


排行榜功能是一个很普遍的需求。使用 Redis 中有序集合的特性来实现排行榜是又好又快的选择。
一般排行榜都是有实效性的，比如“用户积分榜”。如果没有实效性一直按照总榜来排，可能榜首总是几个老用户，对于新用户来说，那真是太令人沮丧了。
首先，来个“今日积分榜”吧，排序规则是今日用户新增积分从多到少。
那么用户增加积分时，都操作一下记录当天积分增加的有序集合。 假设今天是 2015 年 04 月 01 日，UID 为 1 的用户因为某个操作，增加了 5 个积分。 Redis 命令如下：
`bash``ZINCRBY rank:20150401 5 1`假设还有其他几个用户也增加了积分：
`bash`ZINCRBY rank:20150401 1 2
ZINCRBY rank:20150401 10 3
看看现在有序集合 rank:20150401 中的数据（withscores 参数可以附带获取元素的 score）：
`bash``ZRANGE rank:20150401 0 -1 withscores``bash`1)"2"
2)"1"
3)"1"
4)"5"
5)"3"
6)"10"
按照分数从高到低，获取 top10：
`bash``ZREVRANGE rank:20150401 0 9 withscores``bash`1)"3"
2)"10"
3)"1"
4)"5"
5)"2"
6)"1"
因为只有三个元素，所以就查询出了这些数据。
如果每天记录当天的积分排行榜，那么其他花样百出的榜单也就简单了。 比如“昨日积分榜”：
`bash``ZREVRANGE rank:20150331 0 9 withscores`利用并集实现多天的积分总和，实现“上周积分榜”：
`bash``ZUNIONSTORE rank:last_week 7 rank:20150323 rank:20150324 rank:20150325 rank:20150326 rank:20150327 rank:20150328 rank:20150329 WEIGHTS 1 1 1 1 1 1 1`这样就将 7 天的积分记录合并到有序集合 rank:last_week 中了。权重因子 WEIGHTS 如果不给，默认就是 1。为了不隐藏细节，特意写出。 那么查询上周积分榜 Top10 的信息就是：
`bash``ZREVRANGE rank:last_week 0 9 withscores`“月度榜”、“季度榜”、“年度榜”等等就以此类推。

