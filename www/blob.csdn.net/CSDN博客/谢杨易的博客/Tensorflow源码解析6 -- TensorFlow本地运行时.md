
# Tensorflow源码解析6 -- TensorFlow本地运行时 - 谢杨易的博客 - CSDN博客

2018年11月18日 17:14:40[谢杨易](https://me.csdn.net/u013510838)阅读数：1008标签：[TensorFlow																](https://so.csdn.net/so/search/s.do?q=TensorFlow&t=blog)[本地运行时																](https://so.csdn.net/so/search/s.do?q=本地运行时&t=blog)[Graph																](https://so.csdn.net/so/search/s.do?q=Graph&t=blog)[剪枝																](https://so.csdn.net/so/search/s.do?q=剪枝&t=blog)[分裂																](https://so.csdn.net/so/search/s.do?q=分裂&t=blog)[
							](https://so.csdn.net/so/search/s.do?q=剪枝&t=blog)[
																					](https://so.csdn.net/so/search/s.do?q=Graph&t=blog)个人分类：[深度学习																](https://blog.csdn.net/u013510838/article/category/7566761)
[
																								](https://so.csdn.net/so/search/s.do?q=Graph&t=blog)
[
				](https://so.csdn.net/so/search/s.do?q=本地运行时&t=blog)
[
			](https://so.csdn.net/so/search/s.do?q=本地运行时&t=blog)
[
		](https://so.csdn.net/so/search/s.do?q=TensorFlow&t=blog)

Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)
# 1 概述
TensorFlow后端分为四层，运行时层、计算层、通信层、设备层。运行时作为第一层，实现了session管理、graph管理等很多重要的逻辑，是十分关键的一层。根据任务分布的不同，运行时又分为本地运行时和分布式运行时。本地运行时，所有任务运行于本地同一进程内。而分布式运行时，则允许任务运行在不同机器上。
Tensorflow的运行，通过session搭建了前后端沟通的桥梁，前端几乎所有操作都是通过session进行。session的生命周期由创建、运行、关闭、销毁组成，前文已经详细讲述过。可以将session看做TensorFlow运行的载体。而TensorFlow运行的核心对象，则是计算图Graph。它由计算算子和计算数据两部分构成，可以完整描述整个计算内容。Graph的生命周期包括构建和传递、剪枝、分裂、执行等步骤，本文会详细讲解。理解TensorFlow的运行时，重点就是理解会话session和计算图Graph。
本地运行时，client master和worker都在本地机器的同一进程内，均通过DirectSession类来描述。由于在同一进程内，三者间可以共享内存，通过DirectSession的相关函数实现调用。
client前端直接面向用户，负责session的创建，计算图Graph的构造。并通过session.run()将Graph序列化后传递给master。master收到后，先反序列化得到Graph，然后根据反向依赖关系，得到几个最小依赖子图，这一步称为剪枝。之后master根据可运行的设备情况，将子图分裂到不同设备上，从而可以并发执行，这一步称为分裂。最后，由每个设备上的worker并行执行分裂后的子图，得到计算结果后返回。

# 2 Graph构建和传递
session.run()开启了后端Graph的构建和传递。在前文session生命周期的讲解中，session.run()时会先调用_extend_graph()将要运行的Operation添加到Graph中，然后再启动运行过程。extend_graph()会先将graph序列化，得到graph_def，然后调用后端的TF_ExtendGraph()方法。下面我们从c_api.cc中的TF_ExtendGraph()看起。
```python
// 增加节点到graph中，proto为序列化后的graph
```
```python
void
```
```python
TF_ExtendGraph
```
```python
(
```
```python
TF_DeprecatedSession
```
```python
*
```
```python
s
```
```python
,
```
```python
const
```
```python
void
```
```python
*
```
```python
proto
```
```python
,
```
```python
size_t proto_len
```
```python
,
```
```python
TF_Status
```
```python
*
```
```python
status
```
```python
)
```
```python
{
```
```python
GraphDef g
```
```python
;
```
```python
// 先将proto转换为GrapDef。graphDef是图的序列化表示，反序列化在后面。
```
```python
if
```
```python
(
```
```python
!
```
```python
tensorflow
```
```python
:
```
```python
:
```
```python
ParseProtoUnlimited
```
```python
(
```
```python
&
```
```python
g
```
```python
,
```
```python
proto
```
```python
,
```
```python
proto_len
```
```python
)
```
```python
)
```
```python
{
```
```python
status
```
```python
->
```
```python
status
```
```python
=
```
```python
InvalidArgument
```
```python
(
```
```python
"Invalid GraphDef"
```
```python
)
```
```python
;
```
```python
return
```
```python
;
```
```python
}
```
```python
// 再调用session的extend方法。根据创建的不同session类型，多态调用不同方法。
```
```python
status
```
```python
->
```
```python
status
```
```python
=
```
```python
s
```
```python
->
```
```python
session
```
```python
->
```
```python
Extend
```
```python
(
```
```python
g
```
```python
)
```
```python
;
```
```python
}
```
后端系统根据生成的Session类型，多态的调用Extend方法。如果是本地session，则调用DirectSession的Extend()方法。下面看DirectSession的Extend()方法。
```python
Status DirectSession
```
```python
:
```
```python
:
```
```python
Extend
```
```python
(
```
```python
const
```
```python
GraphDef
```
```python
&
```
```python
graph
```
```python
)
```
```python
{
```
```python
// 保证线程安全，然后调用ExtendLocked()
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
graph_def_lock_
```
```python
)
```
```python
;
```
```python
return
```
```python
ExtendLocked
```
```python
(
```
```python
graph
```
```python
)
```
```python
;
```
```python
}
```
```python
// 主要任务就是创建GraphExecutionState对象。
```
```python
Status DirectSession
```
```python
:
```
```python
:
```
```python
ExtendLocked
```
```python
(
```
```python
const
```
```python
GraphDef
```
```python
&
```
```python
graph
```
```python
)
```
```python
{
```
```python
bool already_initialized
```
```python
;
```
```python
if
```
```python
(
```
```python
already_initialized
```
```python
)
```
```python
{
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
flib_def_
```
```python
->
```
```python
AddLibrary
```
```python
(
```
```python
graph
```
```python
.
```
```python
library
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
;
```
```python
// 创建GraphExecutionState
```
```python
std
```
```python
:
```
```python
:
```
```python
unique_ptr
```
```python
<
```
```python
GraphExecutionState
```
```python
>
```
```python
state
```
```python
;
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
execution_state_
```
```python
->
```
```python
Extend
```
```python
(
```
```python
graph
```
```python
,
```
```python
&
```
```python
state
```
```python
)
```
```python
)
```
```python
;
```
```python
execution_state_
```
```python
.
```
```python
swap
```
```python
(
```
```python
state
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
最终创建了GraphExecutionState对象。它主要工作有
负责将GraphDef反序列化为graph，从而构造出graph。在初始化方法InitBaseGraph()中
执行部分op编排工作，在初始化方法InitBaseGraph()中
```python
Status GraphExecutionState
```
```python
:
```
```python
:
```
```python
InitBaseGraph
```
```python
(
```
```python
const
```
```python
BuildGraphOptions
```
```python
&
```
```python
options
```
```python
)
```
```python
{
```
```python
const
```
```python
GraphDef
```
```python
*
```
```python
graph_def
```
```python
=
```
```python
&
```
```python
original_graph_def_
```
```python
;
```
```python
// graphDef反序列化得到graph
```
```python
std
```
```python
:
```
```python
:
```
```python
unique_ptr
```
```python
<
```
```python
Graph
```
```python
>
```
```python
new_graph
```
```python
(
```
```python
new
```
```python
Graph
```
```python
(
```
```python
OpRegistry
```
```python
:
```
```python
:
```
```python
Global
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
;
```
```python
GraphConstructorOptions opts
```
```python
;
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
ConvertGraphDefToGraph
```
```python
(
```
```python
opts
```
```python
,
```
```python
*
```
```python
graph_def
```
```python
,
```
```python
new_graph
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
;
```
```python
// 恢复有状态的节点
```
```python
RestoreStatefulNodes
```
```python
(
```
```python
new_graph
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
// 构造优化器的选项 optimization_options
```
```python
GraphOptimizationPassOptions optimization_options
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
session_options
```
```python
=
```
```python
session_options_
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
graph
```
```python
=
```
```python
&
```
```python
new_graph
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
flib_def
```
```python
=
```
```python
flib_def_
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
device_set
```
```python
=
```
```python
device_set_
```
```python
;
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
OptimizationPassRegistry
```
```python
:
```
```python
:
```
```python
Global
```
```python
(
```
```python
)
```
```python
->
```
```python
RunGrouping
```
```python
(
```
```python
OptimizationPassRegistry
```
```python
:
```
```python
:
```
```python
PRE_PLACEMENT
```
```python
,
```
```python
optimization_options
```
```python
)
```
```python
)
```
```python
;
```
```python
// plaer执行op编排
```
```python
Placer
```
```python
placer
```
```python
(
```
```python
new_graph
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
,
```
```python
device_set_
```
```python
,
```
```python
session_options_
```
```python
)
```
```python
;
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
placer
```
```python
.
```
```python
Run
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
OptimizationPassRegistry
```
```python
:
```
```python
:
```
```python
Global
```
```python
(
```
```python
)
```
```python
->
```
```python
RunGrouping
```
```python
(
```
```python
OptimizationPassRegistry
```
```python
:
```
```python
:
```
```python
POST_PLACEMENT
```
```python
,
```
```python
optimization_options
```
```python
)
```
```python
)
```
```python
;
```
```python
// 报春状态节点
```
```python
SaveStatefulNodes
```
```python
(
```
```python
new_graph
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
graph_
```
```python
=
```
```python
new_graph
```
```python
.
```
```python
release
```
```python
(
```
```python
)
```
```python
;
```
```python
return
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
### 构造Graph：反序列化GraphDef为Graph
由于client传递给master的是序列化后的计算图，所以master需要先反序列化。通过ConvertGraphDefToGraph实现。代码在graph_constructor.cc中，如下
```python
Status
```
```python
ConvertGraphDefToGraph
```
```python
(
```
```python
const
```
```python
GraphConstructorOptions
```
```python
&
```
```python
opts
```
```python
,
```
```python
const
```
```python
GraphDef
```
```python
&
```
```python
gdef
```
```python
,
```
```python
Graph
```
```python
*
```
```python
g
```
```python
)
```
```python
{
```
```python
ShapeRefiner
```
```python
refiner
```
```python
(
```
```python
gdef
```
```python
.
```
```python
versions
```
```python
(
```
```python
)
```
```python
.
```
```python
producer
```
```python
(
```
```python
)
```
```python
,
```
```python
g
```
```python
->
```
```python
op_registry
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
return
```
```python
GraphConstructor
```
```python
:
```
```python
:
```
```python
Construct
```
```python
(
```
```python
opts
```
```python
,
```
```python
gdef
```
```python
.
```
```python
node
```
```python
(
```
```python
)
```
```python
,
```
```python
&
```
```python
gdef
```
```python
.
```
```python
versions
```
```python
(
```
```python
)
```
```python
,
```
```python
&
```
```python
gdef
```
```python
.
```
```python
library
```
```python
(
```
```python
)
```
```python
,
```
```python
g
```
```python
,
```
```python
&
```
```python
refiner
```
```python
,
```
```python
/*return_tensors=*/
```
```python
nullptr
```
```python
,
```
```python
/*return_nodes=*/
```
```python
nullptr
```
```python
,
```
```python
/*missing_unused_input_map_keys=*/
```
```python
nullptr
```
```python
)
```
```python
;
```
```python
}
```
### 编排OP
Operation编排的目的是，将op以最高效的方式，放在合适的硬件设备上，从而最大限度的发挥硬件能力。通过Placer的run()方法进行，算法很复杂，在placer.cc中，我也看得不大懂，就不展开了。

# 3 Graph剪枝
反序列化构建好Graph，并进行了Operation编排后，master就开始对Graph剪枝了。剪枝就是根据Graph的输入输出列表，反向遍历全图，找到几个最小依赖的子图，从而方便并行计算。
```python
Status GraphExecutionState
```
```python
:
```
```python
:
```
```python
BuildGraph
```
```python
(
```
```python
const
```
```python
BuildGraphOptions
```
```python
&
```
```python
options
```
```python
,
```
```python
std
```
```python
:
```
```python
:
```
```python
unique_ptr
```
```python
<
```
```python
ClientGraph
```
```python
>
```
```python
*
```
```python
out
```
```python
)
```
```python
{
```
```python
std
```
```python
:
```
```python
:
```
```python
unique_ptr
```
```python
<
```
```python
Graph
```
```python
>
```
```python
ng
```
```python
;
```
```python
Status s
```
```python
=
```
```python
OptimizeGraph
```
```python
(
```
```python
options
```
```python
,
```
```python
&
```
```python
ng
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
s
```
```python
.
```
```python
ok
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
// 1 复制一份原始的Graph
```
```python
ng
```
```python
.
```
```python
reset
```
```python
(
```
```python
new
```
```python
Graph
```
```python
(
```
```python
flib_def_
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
)
```
```python
)
```
```python
;
```
```python
CopyGraph
```
```python
(
```
```python
*
```
```python
graph_
```
```python
,
```
```python
ng
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
// 2 剪枝，根据输入输出feed fetch，对graph进行增加节点或删除节点等操作。通过RewriteGraphForExecution()方法
```
```python
subgraph
```
```python
:
```
```python
:
```
```python
RewriteGraphMetadata rewrite_metadata
```
```python
;
```
```python
if
```
```python
(
```
```python
session_options_
```
```python
==
```
```python
nullptr
```
```python
||
```
```python
!
```
```python
session_options_
```
```python
->
```
```python
config
```
```python
.
```
```python
graph_options
```
```python
(
```
```python
)
```
```python
.
```
```python
place_pruned_graph
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
subgraph
```
```python
:
```
```python
:
```
```python
RewriteGraphForExecution
```
```python
(
```
```python
ng
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
,
```
```python
options
```
```python
.
```
```python
feed_endpoints
```
```python
,
```
```python
options
```
```python
.
```
```python
fetch_endpoints
```
```python
,
```
```python
options
```
```python
.
```
```python
target_nodes
```
```python
,
```
```python
device_set_
```
```python
->
```
```python
client_device
```
```python
(
```
```python
)
```
```python
->
```
```python
attributes
```
```python
(
```
```python
)
```
```python
,
```
```python
options
```
```python
.
```
```python
use_function_convention
```
```python
,
```
```python
&
```
```python
rewrite_metadata
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
// 3 处理优化选项optimization_options
```
```python
GraphOptimizationPassOptions optimization_options
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
session_options
```
```python
=
```
```python
session_options_
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
graph
```
```python
=
```
```python
&
```
```python
ng
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
flib_def
```
```python
=
```
```python
flib
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
;
```
```python
optimization_options
```
```python
.
```
```python
device_set
```
```python
=
```
```python
device_set_
```
```python
;
```
```python
TF_RETURN_IF_ERROR
```
```python
(
```
```python
OptimizationPassRegistry
```
```python
:
```
```python
:
```
```python
Global
```
```python
(
```
```python
)
```
```python
->
```
```python
RunGrouping
```
```python
(
```
```python
OptimizationPassRegistry
```
```python
:
```
```python
:
```
```python
POST_REWRITE_FOR_EXEC
```
```python
,
```
```python
optimization_options
```
```python
)
```
```python
)
```
```python
;
```
```python
// 4 复制一份ClientGraph
```
```python
std
```
```python
:
```
```python
:
```
```python
unique_ptr
```
```python
<
```
```python
ClientGraph
```
```python
>
```
```python
dense_copy
```
```python
(
```
```python
new
```
```python
ClientGraph
```
```python
(
```
```python
std
```
```python
:
```
```python
:
```
```python
move
```
```python
(
```
```python
flib
```
```python
)
```
```python
,
```
```python
rewrite_metadata
```
```python
.
```
```python
feed_types
```
```python
,
```
```python
rewrite_metadata
```
```python
.
```
```python
fetch_types
```
```python
)
```
```python
)
```
```python
;
```
```python
CopyGraph
```
```python
(
```
```python
*
```
```python
ng
```
```python
,
```
```python
&
```
```python
dense_copy
```
```python
->
```
```python
graph
```
```python
)
```
```python
;
```
```python
*
```
```python
out
```
```python
=
```
```python
std
```
```python
:
```
```python
:
```
```python
move
```
```python
(
```
```python
dense_copy
```
```python
)
```
```python
;
```
```python
return
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
剪枝的关键在RewriteGraphForExecution()方法中，在subgraph.cc文件中。
```python
Status
```
```python
RewriteGraphForExecution
```
```python
(
```
```python
Graph
```
```python
*
```
```python
g
```
```python
,
```
```python
const
```
```python
gtl
```
```python
:
```
```python
:
```
```python
ArraySlice
```
```python
<
```
```python
string
```
```python
>
```
```python
&
```
```python
fed_outputs
```
```python
,
```
```python
const
```
```python
gtl
```
```python
:
```
```python
:
```
```python
ArraySlice
```
```python
<
```
```python
string
```
```python
>
```
```python
&
```
```python
fetch_outputs
```
```python
,
```
```python
const
```
```python
gtl
```
```python
:
```
```python
:
```
```python
ArraySlice
```
```python
<
```
```python
string
```
```python
>
```
```python
&
```
```python
target_node_names
```
```python
,
```
```python
const
```
```python
DeviceAttributes
```
```python
&
```
```python
device_info
```
```python
,
```
```python
bool use_function_convention
```
```python
,
```
```python
RewriteGraphMetadata
```
```python
*
```
```python
out_metadata
```
```python
)
```
```python
{
```
```python
std
```
```python
:
```
```python
:
```
```python
unordered_set
```
```python
<
```
```python
string
```
```python
>
```
```python
endpoints
```
```python
;
```
```python
// 1 构建节点的name_index，从而快速索引节点。为FeedInputs，FetchOutputs等步骤所使用
```
```python
NameIndex name_index
```
```python
;
```
```python
name_index
```
```python
.
```
```python
reserve
```
```python
(
```
```python
g
```
```python
->
```
```python
num_nodes
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
Node
```
```python
*
```
```python
n
```
```python
:
```
```python
g
```
```python
->
```
```python
nodes
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
name_index
```
```python
[
```
```python
n
```
```python
->
```
```python
name
```
```python
(
```
```python
)
```
```python
]
```
```python
=
```
```python
n
```
```python
;
```
```python
}
```
```python
// 2 FeedInputs，添加输入节点
```
```python
if
```
```python
(
```
```python
!
```
```python
fed_outputs
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
FeedInputs
```
```python
(
```
```python
g
```
```python
,
```
```python
device_info
```
```python
,
```
```python
fed_outputs
```
```python
,
```
```python
use_function_convention
```
```python
,
```
```python
&
```
```python
name_index
```
```python
,
```
```python
&
```
```python
out_metadata
```
```python
->
```
```python
feed_types
```
```python
)
```
```python
;
```
```python
}
```
```python
// 3 FetchOutputs，添加输出节点
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Node
```
```python
*
```
```python
>
```
```python
fetch_nodes
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
fetch_outputs
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
FetchOutputs
```
```python
(
```
```python
g
```
```python
,
```
```python
device_info
```
```python
,
```
```python
fetch_outputs
```
```python
,
```
```python
use_function_convention
```
```python
,
```
```python
&
```
```python
name_index
```
```python
,
```
```python
&
```
```python
fetch_nodes
```
```python
,
```
```python
&
```
```python
out_metadata
```
```python
->
```
```python
fetch_types
```
```python
)
```
```python
;
```
```python
}
```
```python
// 4 剪枝，形成若干最小依赖子图
```
```python
if
```
```python
(
```
```python
!
```
```python
fetch_nodes
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
||
```
```python
!
```
```python
target_node_names
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
PruneForTargets
```
```python
(
```
```python
g
```
```python
,
```
```python
name_index
```
```python
,
```
```python
fetch_nodes
```
```python
,
```
```python
target_node_names
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
主要有4步
构建节点的name_index，从而快速索引节点。为FeedInputs，FetchOutputs等步骤所使用
FeedInputs，添加输入节点。输入节点的数据来源于session.run()时的feed列表。
FetchOutputs，添加输出节点。输出节点在session.run()时通过fetches所给出
剪枝PruneForTargets，形成若干最小依赖子图。这是剪枝算法最关键的一步。
PruneForTargets()从输出节点反向搜索，按照BFS广度优先算法，找到若干个最小依赖子图。
```python
static
```
```python
Status
```
```python
PruneForTargets
```
```python
(
```
```python
Graph
```
```python
*
```
```python
g
```
```python
,
```
```python
const
```
```python
subgraph
```
```python
:
```
```python
:
```
```python
NameIndex
```
```python
&
```
```python
name_index
```
```python
,
```
```python
const
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Node
```
```python
*
```
```python
>
```
```python
&
```
```python
fetch_nodes
```
```python
,
```
```python
const
```
```python
gtl
```
```python
:
```
```python
:
```
```python
ArraySlice
```
```python
<
```
```python
string
```
```python
>
```
```python
&
```
```python
target_nodes
```
```python
)
```
```python
{
```
```python
string not_found
```
```python
;
```
```python
std
```
```python
:
```
```python
:
```
```python
unordered_set
```
```python
<
```
```python
const
```
```python
Node
```
```python
*
```
```python
>
```
```python
targets
```
```python
;
```
```python
// 1 AddNodeToTargets添加节点到targets中，从输出节点按照BFS反向遍历。
```
```python
for
```
```python
(
```
```python
Node
```
```python
*
```
```python
n
```
```python
:
```
```python
fetch_nodes
```
```python
)
```
```python
{
```
```python
AddNodeToTargets
```
```python
(
```
```python
n
```
```python
->
```
```python
name
```
```python
(
```
```python
)
```
```python
,
```
```python
name_index
```
```python
,
```
```python
&
```
```python
targets
```
```python
)
```
```python
;
```
```python
}
```
```python
// 2 剪枝，得到多个最小依赖子图子图
```
```python
PruneForReverseReachability
```
```python
(
```
```python
g
```
```python
,
```
```python
targets
```
```python
)
```
```python
;
```
```python
// 修正Source和Sink节点的依赖边，将没有输出边的节点连接到sink node上
```
```python
FixupSourceAndSinkEdges
```
```python
(
```
```python
g
```
```python
)
```
```python
;
```
```python
return
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
主要有3步
AddNodeToTargets，从输出节点按照BFS反向遍历图的节点，添加到targets中。
PruneForReverseReachability，剪枝，得到多个最小依赖子图子图
FixupSourceAndSinkEdges，修正Source和Sink节点的依赖边，将没有输出边的节点连接到sink node上
PruneForReverseReachability()在algorithm.cc文件中，算法就不分析了，总体是按照BFS广度优先算法搜索的。
```python
bool
```
```python
PruneForReverseReachability
```
```python
(
```
```python
Graph
```
```python
*
```
```python
g
```
```python
,
```
```python
std
```
```python
:
```
```python
:
```
```python
unordered_set
```
```python
<
```
```python
const
```
```python
Node
```
```python
*
```
```python
>
```
```python
visited
```
```python
)
```
```python
{
```
```python
// 按照BFS广度优先算法，从输出节点开始，反向搜索节点的依赖关系
```
```python
std
```
```python
:
```
```python
:
```
```python
deque
```
```python
<
```
```python
const
```
```python
Node
```
```python
*
```
```python
>
```
```python
queue
```
```python
;
```
```python
for
```
```python
(
```
```python
const
```
```python
Node
```
```python
*
```
```python
n
```
```python
:
```
```python
visited
```
```python
)
```
```python
{
```
```python
queue
```
```python
.
```
```python
push_back
```
```python
(
```
```python
n
```
```python
)
```
```python
;
```
```python
}
```
```python
while
```
```python
(
```
```python
!
```
```python
queue
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
const
```
```python
Node
```
```python
*
```
```python
n
```
```python
=
```
```python
queue
```
```python
.
```
```python
front
```
```python
(
```
```python
)
```
```python
;
```
```python
queue
```
```python
.
```
```python
pop_front
```
```python
(
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
const
```
```python
Node
```
```python
*
```
```python
in
```
```python
:
```
```python
n
```
```python
->
```
```python
in_nodes
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
visited
```
```python
.
```
```python
insert
```
```python
(
```
```python
in
```
```python
)
```
```python
.
```
```python
second
```
```python
)
```
```python
{
```
```python
queue
```
```python
.
```
```python
push_back
```
```python
(
```
```python
in
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
}
```
```python
// 删除不在"visited"列表中的节点，说明最小依赖子图不依赖此节点
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Node
```
```python
*
```
```python
>
```
```python
all_nodes
```
```python
;
```
```python
all_nodes
```
```python
.
```
```python
reserve
```
```python
(
```
```python
g
```
```python
->
```
```python
num_nodes
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
Node
```
```python
*
```
```python
n
```
```python
:
```
```python
g
```
```python
->
```
```python
nodes
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
all_nodes
```
```python
.
```
```python
push_back
```
```python
(
```
```python
n
```
```python
)
```
```python
;
```
```python
}
```
```python
bool any_removed
```
```python
=
```
```python
false
```
```python
;
```
```python
for
```
```python
(
```
```python
Node
```
```python
*
```
```python
n
```
```python
:
```
```python
all_nodes
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
visited
```
```python
.
```
```python
count
```
```python
(
```
```python
n
```
```python
)
```
```python
==
```
```python
0
```
```python
&&
```
```python
!
```
```python
n
```
```python
->
```
```python
IsSource
```
```python
(
```
```python
)
```
```python
&&
```
```python
!
```
```python
n
```
```python
->
```
```python
IsSink
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
g
```
```python
->
```
```python
RemoveNode
```
```python
(
```
```python
n
```
```python
)
```
```python
;
```
```python
any_removed
```
```python
=
```
```python
true
```
```python
;
```
```python
}
```
```python
}
```
```python
return
```
```python
any_removed
```
```python
;
```
```python
}
```

# 4 Graph分裂
剪枝完成后，master即得到了最小依赖子图ClientGraph。然后根据本地机器的硬件设备，以及op所指定的运行设备等关系，将图分裂为多个Partition Graph，传递到相关设备的worker上，从而进行并行运算。这就是Graph的分裂。
Graph分裂的算法在graph_partition.cc的Partition()方法中。算法比较复杂，我们就不分析了。图分裂有两种
splitbydevice按设备分裂，也就是将Graph分裂到本地各CPU GPU上。本地运行时只使用按设备分裂。
staticstringSplitByDevice(constNode*node){returnnode->assigned_device_name();}
splitByWorker 按worker分裂, 也就是将Graph分裂到各分布式任务上，常用于分布式运行时。分布式运行时，图会经历两次分裂。先splitByWorker分裂到各分布式任务上，一般是各分布式机器。然后splitbydevice二次分裂到分布式机器的CPU GPU等设备上。
staticstringSplitByWorker(constNode*node){string task;string device;DeviceNameUtils::SplitDeviceName(node->assigned_device_name(),&task,&device);returntask;}

# 5 Graph执行
Graph经过master剪枝和分裂后，就可以在本地的各CPU GPU设备上执行了。这个过程的管理者叫worker。一般一个worker对应一个分裂后的子图partitionGraph。每个worker启动一个执行器Executor，入度为0的节点数据依赖已经ready了，故可以并行执行。等所有Executor执行完毕后，通知执行完毕。
各CPU GPU设备间可能需要数据通信，通过创建send/recv节点来解决。数据发送方创建send节点，将数据放在send节点内，不阻塞。数据接收方创建recv节点，从recv节点中取出数据，recv节点中如果没有数据则阻塞。这又是一个典型的生产者-消费者关系。
Graph执行的代码逻辑在direct_session.cc文件的DirectSession::Run()方法中。代码逻辑很长，我们抽取其中的关键部分。
```python
Status DirectSession
```
```python
:
```
```python
:
```
```python
Run
```
```python
(
```
```python
const
```
```python
RunOptions
```
```python
&
```
```python
run_options
```
```python
,
```
```python
const
```
```python
NamedTensorList
```
```python
&
```
```python
inputs
```
```python
,
```
```python
const
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
string
```
```python
>
```
```python
&
```
```python
output_names
```
```python
,
```
```python
const
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
string
```
```python
>
```
```python
&
```
```python
target_nodes
```
```python
,
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Tensor
```
```python
>
```
```python
*
```
```python
outputs
```
```python
,
```
```python
RunMetadata
```
```python
*
```
```python
run_metadata
```
```python
)
```
```python
{
```
```python
// 1 将输入tensor的name取出，组成一个列表，方便之后快速索引输入tensor
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
string
```
```python
>
```
```python
input_tensor_names
```
```python
;
```
```python
input_tensor_names
```
```python
.
```
```python
reserve
```
```python
(
```
```python
inputs
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
const
```
```python
auto
```
```python
&
```
```python
it
```
```python
:
```
```python
inputs
```
```python
)
```
```python
{
```
```python
input_tensor_names
```
```python
.
```
```python
push_back
```
```python
(
```
```python
it
```
```python
.
```
```python
first
```
```python
)
```
```python
;
```
```python
}
```
```python
// 2 传递输入数据给executor，通过FunctionCallFrame方式。
```
```python
// 2.1 创建FunctionCallFrame，用来输入数据给executor，并从executor中取出数据。
```
```python
FunctionCallFrame
```
```python
call_frame
```
```python
(
```
```python
executors_and_keys
```
```python
->
```
```python
input_types
```
```python
,
```
```python
executors_and_keys
```
```python
->
```
```python
output_types
```
```python
)
```
```python
;
```
```python
// 2.2 构造输入数据feed_args
```
```python
gtl
```
```python
:
```
```python
:
```
```python
InlinedVector
```
```python
<
```
```python
Tensor
```
```python
,
```
```python
4
```
```python
>
```
```python
feed_args
```
```python
(
```
```python
inputs
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
const
```
```python
auto
```
```python
&
```
```python
it
```
```python
:
```
```python
inputs
```
```python
)
```
```python
{
```
```python
if
```
```python
(
```
```python
it
```
```python
.
```
```python
second
```
```python
.
```
```python
dtype
```
```python
(
```
```python
)
```
```python
==
```
```python
DT_RESOURCE
```
```python
)
```
```python
{
```
```python
Tensor tensor_from_handle
```
```python
;
```
```python
ResourceHandleToInputTensor
```
```python
(
```
```python
it
```
```python
.
```
```python
second
```
```python
,
```
```python
&
```
```python
tensor_from_handle
```
```python
)
```
```python
;
```
```python
feed_args
```
```python
[
```
```python
executors_and_keys
```
```python
->
```
```python
input_name_to_index
```
```python
[
```
```python
it
```
```python
.
```
```python
first
```
```python
]
```
```python
]
```
```python
=
```
```python
tensor_from_handle
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
feed_args
```
```python
[
```
```python
executors_and_keys
```
```python
->
```
```python
input_name_to_index
```
```python
[
```
```python
it
```
```python
.
```
```python
first
```
```python
]
```
```python
]
```
```python
=
```
```python
it
```
```python
.
```
```python
second
```
```python
;
```
```python
}
```
```python
}
```
```python
// 2.3 将feed_args输入数据设置到Arg节点上
```
```python
const
```
```python
Status s
```
```python
=
```
```python
call_frame
```
```python
.
```
```python
SetArgs
```
```python
(
```
```python
feed_args
```
```python
)
```
```python
;
```
```python
// 3 开始执行executor
```
```python
// 3.1 创建run_state, 和IntraProcessRendezvous
```
```python
RunState
```
```python
run_state
```
```python
(
```
```python
args
```
```python
.
```
```python
step_id
```
```python
,
```
```python
&
```
```python
devices_
```
```python
)
```
```python
;
```
```python
run_state
```
```python
.
```
```python
rendez
```
```python
=
```
```python
new
```
```python
IntraProcessRendezvous
```
```python
(
```
```python
device_mgr_
```
```python
.
```
```python
get
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
CancellationManager step_cancellation_manager
```
```python
;
```
```python
args
```
```python
.
```
```python
call_frame
```
```python
=
```
```python
&
```
```python
call_frame
```
```python
;
```
```python
// 3.2 创建ExecutorBarrier，它是一个执行完成的计数器。同时注册执行完成的监听事件executors_done.Notify()
```
```python
const
```
```python
size_t num_executors
```
```python
=
```
```python
executors_and_keys
```
```python
->
```
```python
items
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
;
```
```python
ExecutorBarrier
```
```python
*
```
```python
barrier
```
```python
=
```
```python
new
```
```python
ExecutorBarrier
```
```python
(
```
```python
num_executors
```
```python
,
```
```python
run_state
```
```python
.
```
```python
rendez
```
```python
,
```
```python
[
```
```python
&
```
```python
run_state
```
```python
]
```
```python
(
```
```python
const
```
```python
Status
```
```python
&
```
```python
ret
```
```python
)
```
```python
{
```
```python
{
```
```python
mutex_lock
```
```python
l
```
```python
(
```
```python
run_state
```
```python
.
```
```python
mu_
```
```python
)
```
```python
;
```
```python
run_state
```
```python
.
```
```python
status
```
```python
.
```
```python
Update
```
```python
(
```
```python
ret
```
```python
)
```
```python
;
```
```python
}
```
```python
// 所有线程池计算完毕后，会触发Notify，发送消息。
```
```python
run_state
```
```python
.
```
```python
executors_done
```
```python
.
```
```python
Notify
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
```python
)
```
```python
;
```
```python
args
```
```python
.
```
```python
rendezvous
```
```python
=
```
```python
run_state
```
```python
.
```
```python
rendez
```
```python
;
```
```python
args
```
```python
.
```
```python
cancellation_manager
```
```python
=
```
```python
&
```
```python
step_cancellation_manager
```
```python
;
```
```python
args
```
```python
.
```
```python
session_state
```
```python
=
```
```python
&
```
```python
session_state_
```
```python
;
```
```python
args
```
```python
.
```
```python
tensor_store
```
```python
=
```
```python
&
```
```python
run_state
```
```python
.
```
```python
tensor_store
```
```python
;
```
```python
args
```
```python
.
```
```python
step_container
```
```python
=
```
```python
&
```
```python
run_state
```
```python
.
```
```python
step_container
```
```python
;
```
```python
args
```
```python
.
```
```python
sync_on_finish
```
```python
=
```
```python
sync_on_finish_
```
```python
;
```
```python
// 3.3 创建executor的运行器Runner
```
```python
Executor
```
```python
:
```
```python
:
```
```python
Args
```
```python
:
```
```python
:
```
```python
Runner default_runner
```
```python
=
```
```python
[
```
```python
this
```
```python
,
```
```python
pool
```
```python
]
```
```python
(
```
```python
Executor
```
```python
:
```
```python
:
```
```python
Args
```
```python
:
```
```python
:
```
```python
Closure c
```
```python
)
```
```python
{
```
```python
SchedClosure
```
```python
(
```
```python
pool
```
```python
,
```
```python
std
```
```python
:
```
```python
:
```
```python
move
```
```python
(
```
```python
c
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
;
```
```python
// 3.4 依次启动所有executor，开始运行
```
```python
for
```
```python
(
```
```python
const
```
```python
auto
```
```python
&
```
```python
item
```
```python
:
```
```python
executors_and_keys
```
```python
->
```
```python
items
```
```python
)
```
```python
{
```
```python
item
```
```python
.
```
```python
executor
```
```python
->
```
```python
RunAsync
```
```python
(
```
```python
args
```
```python
,
```
```python
barrier
```
```python
->
```
```python
Get
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
// 3.5 阻塞，收到所有executor执行完毕的通知
```
```python
WaitForNotification
```
```python
(
```
```python
&
```
```python
run_state
```
```python
,
```
```python
&
```
```python
step_cancellation_manager
```
```python
,
```
```python
operation_timeout_in_ms_
```
```python
)
```
```python
;
```
```python
// 4 接收执行器执行完毕的输出值
```
```python
if
```
```python
(
```
```python
outputs
```
```python
)
```
```python
{
```
```python
// 4.1 从RetVal节点中得到输出值sorted_outputs
```
```python
std
```
```python
:
```
```python
:
```
```python
vector
```
```python
<
```
```python
Tensor
```
```python
>
```
```python
sorted_outputs
```
```python
;
```
```python
const
```
```python
Status s
```
```python
=
```
```python
call_frame
```
```python
.
```
```python
ConsumeRetvals
```
```python
(
```
```python
&
```
```python
sorted_outputs
```
```python
)
```
```python
;
```
```python
// 4.2 处理原始输出sorted_outputs，保存到最终的输出outputs中
```
```python
outputs
```
```python
->
```
```python
clear
```
```python
(
```
```python
)
```
```python
;
```
```python
outputs
```
```python
->
```
```python
reserve
```
```python
(
```
```python
sorted_outputs
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
)
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i
```
```python
=
```
```python
0
```
```python
;
```
```python
i
```
```python
<
```
```python
output_names
```
```python
.
```
```python
size
```
```python
(
```
```python
)
```
```python
;
```
```python
++
```
```python
i
```
```python
)
```
```python
{
```
```python
const
```
```python
string
```
```python
&
```
```python
output_name
```
```python
=
```
```python
output_names
```
```python
[
```
```python
i
```
```python
]
```
```python
;
```
```python
if
```
```python
(
```
```python
first_indices
```
```python
.
```
```python
empty
```
```python
(
```
```python
)
```
```python
||
```
```python
first_indices
```
```python
[
```
```python
i
```
```python
]
```
```python
==
```
```python
i
```
```python
)
```
```python
{
```
```python
outputs
```
```python
->
```
```python
emplace_back
```
```python
(
```
```python
std
```
```python
:
```
```python
:
```
```python
move
```
```python
(
```
```python
sorted_outputs
```
```python
[
```
```python
executors_and_keys
```
```python
->
```
```python
output_name_to_index
```
```python
[
```
```python
output_name
```
```python
]
```
```python
]
```
```python
)
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
outputs
```
```python
->
```
```python
push_back
```
```python
(
```
```python
(
```
```python
*
```
```python
outputs
```
```python
)
```
```python
[
```
```python
first_indices
```
```python
[
```
```python
i
```
```python
]
```
```python
]
```
```python
)
```
```python
;
```
```python
}
```
```python
}
```
```python
}
```
```python
// 5 保存输出的tensor
```
```python
run_state
```
```python
.
```
```python
tensor_store
```
```python
.
```
```python
SaveTensors
```
```python
(
```
```python
output_names
```
```python
,
```
```python
&
```
```python
session_state_
```
```python
)
```
```python
)
```
```python
;
```
```python
return
```
```python
Status
```
```python
:
```
```python
:
```
```python
OK
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
主要步骤如下
将输入tensor的name取出，组成一个列表，方便之后快速索引输入tensor
传递输入数据给executor，通过FunctionCallFrame方式。本地运行时因为在同一个进程中，我们采用FunctionCallFrame函数调用的方式来实现数据传递。将输入数据传递给Arg节点，从RetVal节点中取出数据。
开始执行executor，并注册监听器。所有executor执行完毕后，会触发executors_done.Notify()事件。然后当前线程wait阻塞，等待收到执行完毕的消息。
收到执行完毕的消息后，从RetVal节点中取出输出值，经过简单处理后，就可以最终输出了
保存输出的tensor，方便以后使用。

6 总结
本文主要讲解了TensorFlow的本地运行时，牢牢抓住session和graph两个对象即可。Session的生命周期前文讲解过，本文主要讲解了Graph的生命周期，包括构建与传递，剪枝，分裂和执行。Graph是TensorFlow的核心对象，很多问题都是围绕它来进行的，理解它有一定难度，但十分关键。文章中可能有一些理解不正确的地方，希望小伙伴们不吝赐教。
Tensorflow源码解读系列文章，欢迎阅读
[带你深入AI（1） - 深度学习模型训练痛点及解决方法](https://blog.csdn.net/u013510838/article/details/79835563)
[自然语言处理1 – 分词](https://blog.csdn.net/u013510838/article/details/81673016)
[Tensorflow源码解析1 – 内核架构和源码结构](https://blog.csdn.net/u013510838/article/details/84103503)
[Tensorflow源码解析2 – 前后端连接的桥梁 - Session](https://blog.csdn.net/u013510838/article/details/84111031)
[Tensorflow源码解析3 – TensorFlow核心对象 - Graph](https://blog.csdn.net/u013510838/article/details/84139986)
[Tensorflow源码解析4 – 图的节点 - Operation](https://blog.csdn.net/u013510838/article/details/84141538)
[Tensorflow源码解析5 – 图的边 - Tensor](https://blog.csdn.net/u013510838/article/details/84144238)
[Tensorflow源码解析6 – TensorFlow本地运行时](https://blog.csdn.net/u013510838/article/details/84202248)
[Tensorflow源码解析7 – TensorFlow分布式运行时](https://blog.csdn.net/u013510838/article/details/84203683)

