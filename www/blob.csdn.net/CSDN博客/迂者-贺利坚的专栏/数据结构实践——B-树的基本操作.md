
# 数据结构实践——B-树的基本操作 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月29日 16:13:39[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2969


本文是针对[[数据结构基础系列(8)：查找](http://edu.csdn.net/course/detail/1669)]的实践。
【项目 - B-树的基本操作】
实现B-树的基本操作。基于序列{4, 9, 0, 1, 8, 6, 3, 5, 2, 7}完成测试。
（1）创建对应的3阶B-树b，用括号法输出b树。
（2）从b中分别删除关键字为8和1的节点，用括号法输出删除节点后的b树。
[参考解答]
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#define MAXM 10
```
```python
//定义B-树的最大的阶数
```
```python
typedef
```
```python
int
```
```python
KeyType;
```
```python
//KeyType为关键字类型
```
```python
typedef
```
```python
struct
```
```python
node
```
```python
//B-树结点类型定义
```
```python
{
```
```python
int
```
```python
keynum;
```
```python
//结点当前拥有的关键字的个数
```
```python
KeyType key[MAXM];
```
```python
//key[1..keynum]存放关键字,key[0]不用
```
```python
struct
```
```python
node *parent;
```
```python
//双亲结点指针
```
```python
struct
```
```python
node *ptr[MAXM];
```
```python
//孩子结点指针数组ptr[0..keynum]
```
```python
} BTNode;
```
```python
typedef
```
```python
struct
```
```python
//B-树的查找结果类型
```
```python
{
    BTNode *pt;
```
```python
//指向找到的结点
```
```python
int
```
```python
i;
```
```python
//1..m,在结点中的关键字序号
```
```python
int
```
```python
tag;
```
```python
//1:查找成功,O:查找失败
```
```python
}  Result;
```
```python
int
```
```python
m;
```
```python
//m阶B-树,为全局变量
```
```python
int
```
```python
Max;
```
```python
//m阶B-树中每个结点的至多关键字个数,Max=m-1
```
```python
int
```
```python
Min;
```
```python
//m阶B-树中非叶子结点的至少关键字个数,Min=(m-1)/2
```
```python
int
```
```python
Search(BTNode *p,KeyType k)
{
```
```python
//在p->key[1..keynum]中查找i,使得p->key[i]<=k<p->key[i+1]
```
```python
int
```
```python
i=
```
```python
0
```
```python
;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<p->keynum && p->key[i+
```
```python
1
```
```python
]<=k; i++);
```
```python
return
```
```python
i;
}
Result SearchBTree(BTNode *t,KeyType k)
{
```
```python
/*在m阶t树t上查找关键字k,返回结果(pt,i,tag)。若查找成功,则特征值
     tag=1,指针pt所指结点中第i个关键字等于k；否则特征值tag=0,等于k的
     关键字应插入在指针Pt所指结点中第i和第i+1个关键字之间*/
```
```python
BTNode *p=t,*q=NULL;
```
```python
//初始化,p指向待查结点,q指向p的双亲
```
```python
int
```
```python
found=
```
```python
0
```
```python
,i=
```
```python
0
```
```python
;
    Result r;
```
```python
while
```
```python
(p!=NULL && found==
```
```python
0
```
```python
)
    {
        i=Search(p,k);
```
```python
//在p->key[1..keynum]中查找i,使得p->key[i]<=k<p->key[i+1]
```
```python
if
```
```python
(i>
```
```python
0
```
```python
&& p->key[i]==k)
```
```python
//找到待查关键字
```
```python
found=
```
```python
1
```
```python
;
```
```python
else
```
```python
{
            q=p;
            p=p->ptr[i];
        }
    }
    r.i=i;
```
```python
if
```
```python
(found==
```
```python
1
```
```python
)
```
```python
//查找成功
```
```python
{
        r.pt=p;
        r.tag=
```
```python
1
```
```python
;
    }
```
```python
else
```
```python
//查找不成功,返回K的插入位置信息
```
```python
{
        r.pt=q;
        r.tag=
```
```python
0
```
```python
;
    }
```
```python
return
```
```python
r;
```
```python
//返回k的位置(或插入位置)
```
```python
}
```
```python
void
```
```python
Insert(BTNode *&q,
```
```python
int
```
```python
i,KeyType x,BTNode *ap)
{
```
```python
//将x和ap分别插入到q->key[i+1]和q->ptr[i+1]中
```
```python
int
```
```python
j;
```
```python
for
```
```python
(j=q->keynum; j>i; j--)
```
```python
//空出一个位置
```
```python
{
        q->key[j+
```
```python
1
```
```python
]=q->key[j];
        q->ptr[j+
```
```python
1
```
```python
]=q->ptr[j];
    }
    q->key[i+
```
```python
1
```
```python
]=x;
    q->ptr[i+
```
```python
1
```
```python
]=ap;
```
```python
if
```
```python
(ap!=NULL) ap->parent=q;
    q->keynum++;
}
```
```python
void
```
```python
Split(BTNode *&q,BTNode *&ap)
{
```
```python
//将结点q分裂成两个结点,前一半保留,后一半移入新生结点ap
```
```python
int
```
```python
i,s=(m+
```
```python
1
```
```python
)/
```
```python
2
```
```python
;
    ap=(BTNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(BTNode));
```
```python
//生成新结点*ap
```
```python
ap->ptr[
```
```python
0
```
```python
]=q->ptr[s];
```
```python
//后一半移入ap
```
```python
for
```
```python
(i=s+
```
```python
1
```
```python
; i<=m; i++)
    {
        ap->key[i-s]=q->key[i];
        ap->ptr[i-s]=q->ptr[i];
```
```python
if
```
```python
(ap->ptr[i-s]!=NULL)
            ap->ptr[i-s]->parent=ap;
    }
    ap->keynum=q->keynum-s;
    ap->parent=q->parent;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<=q->keynum-s; i++)
```
```python
//修改指向双亲结点的指针
```
```python
if
```
```python
(ap->ptr[i]!=NULL) ap->ptr[i]->parent = ap;
    q->keynum=s-
```
```python
1
```
```python
;
```
```python
//q的前一半保留,修改keynum
```
```python
}
```
```python
void
```
```python
NewRoot(BTNode *&t,BTNode *p,KeyType x,BTNode *ap)
{
```
```python
//生成含信息(T,x,ap)的新的根结点*t,原t和ap为子树指针
```
```python
t=(BTNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(BTNode));
    t->keynum=
```
```python
1
```
```python
;
    t->ptr[
```
```python
0
```
```python
]=p;
    t->ptr[
```
```python
1
```
```python
]=ap;
    t->key[
```
```python
1
```
```python
]=x;
```
```python
if
```
```python
(p!=NULL) p->parent=t;
```
```python
if
```
```python
(ap!=NULL) ap->parent=t;
    t->parent=NULL;
}
```
```python
void
```
```python
InsertBTree(BTNode *&t, KeyType k, BTNode *q,
```
```python
int
```
```python
i)
{
```
```python
/*在m阶t树t上结点*q的key[i]与key[i+1]之间插入关键字k。若引起
     结点过大,则沿双亲链进行必要的结点分裂调整,使t仍是m阶t树。*/
```
```python
BTNode *ap;
```
```python
int
```
```python
finished,needNewRoot,s;
    KeyType x;
```
```python
if
```
```python
(q==NULL)
```
```python
//t是空树(参数q初值为NULL)
```
```python
NewRoot(t,NULL,k,NULL);
```
```python
//生成仅含关键字k的根结点*t
```
```python
else
```
```python
{
        x=k;
        ap=NULL;
        finished=needNewRoot=
```
```python
0
```
```python
;
```
```python
while
```
```python
(needNewRoot==
```
```python
0
```
```python
&& finished==
```
```python
0
```
```python
)
        {
            Insert(q,i,x,ap);
```
```python
//将x和ap分别插入到q->key[i+1]和q->ptr[i+1]
```
```python
if
```
```python
(q->keynum<=Max) finished=
```
```python
1
```
```python
;
```
```python
//插入完成
```
```python
else
```
```python
{
```
```python
//分裂结点*q,将q->key[s+1..m],q->ptr[s..m]和q->recptr[s+1..m]移入新结点*ap
```
```python
s=(m+
```
```python
1
```
```python
)/
```
```python
2
```
```python
;
                Split(q,ap);
                x=q->key[s];
```
```python
if
```
```python
(q->parent)
```
```python
//在双亲结点*q中查找x的插入位置
```
```python
{
                    q=q->parent;
                    i=Search(q, x);
                }
```
```python
else
```
```python
needNewRoot=
```
```python
1
```
```python
;
            }
        }
```
```python
if
```
```python
(needNewRoot==
```
```python
1
```
```python
)
```
```python
//根结点已分裂为结点*q和*ap
```
```python
NewRoot(t,q,x,ap);
```
```python
//生成新根结点*t,q和ap为子树指针
```
```python
}
}
```
```python
void
```
```python
DispBTree(BTNode *t)
```
```python
//以括号表示法输出B-树
```
```python
{
```
```python
int
```
```python
i;
```
```python
if
```
```python
(t!=NULL)
    {
```
```python
printf
```
```python
(
```
```python
"["
```
```python
);
```
```python
//输出当前结点关键字
```
```python
for
```
```python
(i=
```
```python
1
```
```python
; i<t->keynum; i++)
```
```python
printf
```
```python
(
```
```python
"%d "
```
```python
,t->key[i]);
```
```python
printf
```
```python
(
```
```python
"%d"
```
```python
,t->key[i]);
```
```python
printf
```
```python
(
```
```python
"]"
```
```python
);
```
```python
if
```
```python
(t->keynum>
```
```python
0
```
```python
)
        {
```
```python
if
```
```python
(t->ptr[
```
```python
0
```
```python
]!=
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"("
```
```python
);
```
```python
//至少有一个子树时输出"("号
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<t->keynum; i++)
```
```python
//对每个子树进行递归调用
```
```python
{
                DispBTree(t->ptr[i]);
```
```python
if
```
```python
(t->ptr[i+
```
```python
1
```
```python
]!=NULL)
```
```python
printf
```
```python
(
```
```python
","
```
```python
);
            }
            DispBTree(t->ptr[t->keynum]);
```
```python
if
```
```python
(t->ptr[
```
```python
0
```
```python
]!=
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
")"
```
```python
);
```
```python
//至少有一个子树时输出")"号
```
```python
}
    }
}
```
```python
void
```
```python
Remove(BTNode *p,
```
```python
int
```
```python
i)
```
```python
//从*p结点删除key[i]和它的孩子指针ptr[i]
```
```python
{
```
```python
int
```
```python
j;
```
```python
for
```
```python
(j=i+
```
```python
1
```
```python
; j<=p->keynum; j++)
```
```python
//前移删除key[i]和ptr[i]
```
```python
{
        p->key[j-
```
```python
1
```
```python
]=p->key[j];
        p->ptr[j-
```
```python
1
```
```python
]=p->ptr[j];
    }
    p->keynum--;
}
```
```python
void
```
```python
Successor(BTNode *p,
```
```python
int
```
```python
i)
```
```python
//查找被删关键字p->key[i](在非叶子结点中)的替代叶子结点
```
```python
{
    BTNode *q;
```
```python
for
```
```python
(q=p->ptr[i]; q->ptr[
```
```python
0
```
```python
]!=NULL; q=q->ptr[
```
```python
0
```
```python
]);
    p->key[i]=q->key[
```
```python
1
```
```python
];
```
```python
//复制关键字值
```
```python
}
```
```python
void
```
```python
MoveRight(BTNode *p,
```
```python
int
```
```python
i)
```
```python
//把一个关键字移动到右兄弟中
```
```python
{
```
```python
int
```
```python
c;
    BTNode *t=p->ptr[i];
```
```python
for
```
```python
(c=t->keynum; c>
```
```python
0
```
```python
; c--)
```
```python
//将右兄弟中所有关键字移动一位
```
```python
{
        t->key[c+
```
```python
1
```
```python
]=t->key[c];
        t->ptr[c+
```
```python
1
```
```python
]=t->ptr[c];
    }
    t->ptr[
```
```python
1
```
```python
]=t->ptr[
```
```python
0
```
```python
];
```
```python
//从双亲结点移动关键字到右兄弟中
```
```python
t->keynum++;
    t->key[
```
```python
1
```
```python
]=p->key[i];
    t=p->ptr[i-
```
```python
1
```
```python
];
```
```python
//将左兄弟中最后一个关键字移动到双亲结点中
```
```python
p->key[i]=t->key[t->keynum];
    p->ptr[i]->ptr[
```
```python
0
```
```python
]=t->ptr[t->keynum];
    t->keynum--;
}
```
```python
void
```
```python
MoveLeft(BTNode *p,
```
```python
int
```
```python
i)
```
```python
//把一个关键字移动到左兄弟中
```
```python
{
```
```python
int
```
```python
c;
    BTNode *t;
    t=p->ptr[i-
```
```python
1
```
```python
];
```
```python
//把双亲结点中的关键字移动到左兄弟中
```
```python
t->keynum++;
    t->key[t->keynum]=p->key[i];
    t->ptr[t->keynum]=p->ptr[i]->ptr[
```
```python
0
```
```python
];
    t=p->ptr[i];
```
```python
//把右兄弟中的关键字移动到双亲兄弟中
```
```python
p->key[i]=t->key[
```
```python
1
```
```python
];
    p->ptr[
```
```python
0
```
```python
]=t->ptr[
```
```python
1
```
```python
];
    t->keynum--;
```
```python
for
```
```python
(c=
```
```python
1
```
```python
; c<=t->keynum; c++)
```
```python
//将右兄弟中所有关键字移动一位
```
```python
{
        t->key[c]=t->key[c+
```
```python
1
```
```python
];
        t->ptr[c]=t->ptr[c+
```
```python
1
```
```python
];
    }
}
```
```python
void
```
```python
Combine(BTNode *p,
```
```python
int
```
```python
i)
```
```python
//将三个结点合并到一个结点中
```
```python
{
```
```python
int
```
```python
c;
    BTNode *q=p->ptr[i];
```
```python
//指向右结点,它将被置空和删除
```
```python
BTNode *l=p->ptr[i-
```
```python
1
```
```python
];
    l->keynum++;
```
```python
//l指向左结点
```
```python
l->key[l->keynum]=p->key[i];
    l->ptr[l->keynum]=q->ptr[
```
```python
0
```
```python
];
```
```python
for
```
```python
(c=
```
```python
1
```
```python
; c<=q->keynum; c++)
```
```python
//插入右结点中的所有关键字
```
```python
{
        l->keynum++;
        l->key[l->keynum]=q->key[c];
        l->ptr[l->keynum]=q->ptr[c];
    }
```
```python
for
```
```python
(c=i; c<p->keynum; c++)
```
```python
//删除父结点所有的关键字
```
```python
{
        p->key[c]=p->key[c+
```
```python
1
```
```python
];
        p->ptr[c]=p->ptr[c+
```
```python
1
```
```python
];
    }
    p->keynum--;
```
```python
free
```
```python
(q);
```
```python
//释放空右结点的空间
```
```python
}
```
```python
void
```
```python
Restore(BTNode *p,
```
```python
int
```
```python
i)
```
```python
//关键字删除后,调整B-树,找到一个关键字将其插入到p->ptr[i]中
```
```python
{
```
```python
if
```
```python
(i==
```
```python
0
```
```python
)
```
```python
//为最左边关键字的情况
```
```python
if
```
```python
(p->ptr[
```
```python
1
```
```python
]->keynum>Min)
            MoveLeft(p,
```
```python
1
```
```python
);
```
```python
else
```
```python
Combine(p,
```
```python
1
```
```python
);
```
```python
else
```
```python
if
```
```python
(i==p->keynum)
```
```python
//为最右边关键字的情况
```
```python
if
```
```python
(p->ptr[i-
```
```python
1
```
```python
]->keynum>Min)
            MoveRight(p,i);
```
```python
else
```
```python
Combine(p,i);
```
```python
else
```
```python
if
```
```python
(p->ptr[i-
```
```python
1
```
```python
]->keynum>Min)
```
```python
//为其他情况
```
```python
MoveRight(p,i);
```
```python
else
```
```python
if
```
```python
(p->ptr[i+
```
```python
1
```
```python
]->keynum>Min)
        MoveLeft(p,i+
```
```python
1
```
```python
);
```
```python
else
```
```python
Combine(p,i);
}
```
```python
int
```
```python
SearchNode(KeyType k,BTNode *p,
```
```python
int
```
```python
&i)
```
```python
//在结点p中找关键字为k的位置i,成功时返回1,否则返回0
```
```python
{
```
```python
if
```
```python
(k<p->key[
```
```python
1
```
```python
])
```
```python
//k小于*p结点的最小关键字时返回0
```
```python
{
        i=
```
```python
0
```
```python
;
```
```python
return
```
```python
0
```
```python
;
    }
```
```python
else
```
```python
//在*p结点中查找
```
```python
{
        i=p->keynum;
```
```python
while
```
```python
(k<p->key[i] && i>
```
```python
1
```
```python
)
            i--;
```
```python
return
```
```python
(k==p->key[i]);
    }
}
```
```python
int
```
```python
RecDelete(KeyType k,BTNode *p)
```
```python
//查找并删除关键字k
```
```python
{
```
```python
int
```
```python
i;
```
```python
int
```
```python
found;
```
```python
if
```
```python
(p==NULL)
```
```python
return
```
```python
0
```
```python
;
```
```python
else
```
```python
{
```
```python
if
```
```python
((found=SearchNode(k,p,i))==
```
```python
1
```
```python
)
```
```python
//查找关键字k
```
```python
{
```
```python
if
```
```python
(p->ptr[i-
```
```python
1
```
```python
]!=NULL)
```
```python
//若为非叶子结点
```
```python
{
                Successor(p,i);
```
```python
//由其后继代替它
```
```python
RecDelete(p->key[i],p->ptr[i]);
```
```python
//p->key[i]在叶子结点中
```
```python
}
```
```python
else
```
```python
Remove(p,i);
```
```python
//从*p结点中位置i处删除关键字
```
```python
}
```
```python
else
```
```python
found=RecDelete(k,p->ptr[i]);
```
```python
//沿孩子结点递归查找并删除关键字k
```
```python
if
```
```python
(p->ptr[i]!=NULL)
```
```python
if
```
```python
(p->ptr[i]->keynum<Min)
```
```python
//删除后关键字个数小于MIN
```
```python
Restore(p,i);
```
```python
return
```
```python
found;
    }
}
```
```python
void
```
```python
DeleteBTree(KeyType k,BTNode *&root)
```
```python
//从B-树root中删除关键字k,若在一个结点中删除指定的关键字,不再有其他关键字,则删除该结点
```
```python
{
    BTNode *p;
```
```python
//用于释放一个空的root
```
```python
if
```
```python
(RecDelete(k,root)==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"   关键字%d不在B-树中\n"
```
```python
,k);
```
```python
else
```
```python
if
```
```python
(root->keynum==
```
```python
0
```
```python
)
    {
        p=root;
        root=root->ptr[
```
```python
0
```
```python
];
```
```python
free
```
```python
(p);
    }
}
```
```python
int
```
```python
main()
{
    BTNode *t=NULL;
    Result s;
```
```python
int
```
```python
j,n=
```
```python
10
```
```python
;
    KeyType a[]= {
```
```python
4
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
8
```
```python
,
```
```python
6
```
```python
,
```
```python
3
```
```python
,
```
```python
5
```
```python
,
```
```python
2
```
```python
,
```
```python
7
```
```python
},k;
    m=
```
```python
3
```
```python
;
```
```python
//3阶B-树
```
```python
Max=m-
```
```python
1
```
```python
;
    Min=(m-
```
```python
1
```
```python
)/
```
```python
2
```
```python
;
```
```python
printf
```
```python
(
```
```python
"创建一棵%d阶B-树:\n"
```
```python
,m);
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<n; j++)
```
```python
//创建一棵3阶B-树t
```
```python
{
        s=SearchBTree(t,a[j]);
```
```python
if
```
```python
(s.tag==
```
```python
0
```
```python
)
            InsertBTree(t,a[j],s.pt,s.i);
```
```python
printf
```
```python
(
```
```python
"   第%d步,插入%d: "
```
```python
,j+
```
```python
1
```
```python
,a[j]);
        DispBTree(t);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"  结果B-树: "
```
```python
);
    DispBTree(t);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"删除操作:\n"
```
```python
);
    k=
```
```python
8
```
```python
;
    DeleteBTree(k,t);
```
```python
printf
```
```python
(
```
```python
"  删除%d: "
```
```python
,k);
```
```python
printf
```
```python
(
```
```python
"B-树: "
```
```python
);
    DispBTree(t);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    k=
```
```python
1
```
```python
;
    DeleteBTree(k,t);
```
```python
printf
```
```python
(
```
```python
"  删除%d: "
```
```python
,k);
```
```python
printf
```
```python
(
```
```python
"B-树: "
```
```python
);
    DispBTree(t);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```

