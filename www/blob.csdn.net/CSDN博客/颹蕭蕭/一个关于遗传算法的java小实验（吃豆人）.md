
# 一个关于遗传算法的java小实验（吃豆人） - 颹蕭蕭 - CSDN博客


2018年09月26日 22:56:09[颹蕭蕭](https://me.csdn.net/itnerd)阅读数：1392


**遗传算法**就是利用遗传学中父代基因杂交产生子代的原理，通过良种配对、遗传进化来改良子代的算法。
遗传算法非常适合用来处理离散型的**决策问题**，通过对父代中优良模型的参数进行杂交，产生下一代模型，淘汰其中效果较差的杂种，保留表现优良的杂种，重复此过程，直到培育出满意的模型。
遗传算法的关键不仅在于良种配对，更在于杂交过程中随机出现的**少量突变**，正是由于这种偏离父代的突变存在使得子代有机会比父代更强！始终群进一步演化，避免停滞不前！
下面用一个简单吃豆人实验来说明。[源码在这里](https://download.csdn.net/download/itnerd/10689758)！
![GA算法在吃豆人中的应用](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
上图展示的是实验场景，可以看成“吃豆人”，或者在有些地方称为“扫地机器人”。**黑色空心圆**代表机器人，它的目标是在有限步数内，消灭网格中更多的**红色实心圆**。
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)机器人可以执行的动作有7种，分别是原地不动、向左、向右、向下、向上、随机移动、吃豆（捡垃圾）。
机器人的视野只有5格，即东西南北中。
游戏的规则为：撞墙扣5分，吃豆（前提是当前位置有豆）得10分、瞎jb吃扣1分。
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)图中展示的是一个利用遗传算法，从模型参数为随机初始化的祖先，在规模为100的种群中，择优杂交繁衍约1000代左右得到的一个优良品种。看它那沉着稳健的步伐，还是相当OK的。
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)下面来说说具体实现的步骤吧！具体代码（训练模型+图形界面）可以在[这里下载](https://download.csdn.net/download/itnerd/10689758)！
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)首先，模型中定义了这些属性+常量：
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
```java
public
```
```java
class
```
```java
Model
```
```java
{
```
```java
private
```
```java
int
```
```java
rowNum
```
```java
,
```
```java
colNum
```
```java
;
```
```java
// 场地的行数、列数
```
```java
private
```
```java
int
```
```java
currX
```
```java
,
```
```java
currY
```
```java
;
```
```java
// 机器人的当前位置
```
```java
private
```
```java
boolean
```
```java
fruits
```
```java
[
```
```java
]
```
```java
[
```
```java
]
```
```java
;
```
```java
// 判断每个位置是否有豆子的布尔矩阵
```
```java
private
```
```java
double
```
```java
percent
```
```java
;
```
```java
// 每个位置有豆子的概率
```
```java
private
```
```java
String strategy
```
```java
;
```
```java
// 机器人在每个位置对应的状态下采取的策略
```
```java
public
```
```java
static
```
```java
final
```
```java
int
```
```java
STRATEGY_LEN
```
```java
=
```
```java
243
```
```java
;
```
```java
// 策略的字符串长度
```
```java
public
```
```java
static
```
```java
final
```
```java
int
```
```java
ACTION_NUM
```
```java
=
```
```java
7
```
```java
;
```
```java
// 机器人的动作数
```
```java
public
```
```java
static
```
```java
final
```
```java
int
```
```java
DIRECTION
```
```java
[
```
```java
]
```
```java
[
```
```java
]
```
```java
=
```
```java
{
```
```java
{
```
```java
0
```
```java
,
```
```java
0
```
```java
}
```
```java
,
```
```java
{
```
```java
0
```
```java
,
```
```java
1
```
```java
}
```
```java
,
```
```java
{
```
```java
0
```
```java
,
```
```java
-
```
```java
1
```
```java
}
```
```java
,
```
```java
{
```
```java
1
```
```java
,
```
```java
0
```
```java
}
```
```java
,
```
```java
{
```
```java
-
```
```java
1
```
```java
,
```
```java
0
```
```java
}
```
```java
}
```
```java
;
```
```java
// 不动、东、西、南、北
```
```java
……
```
```java
}
```
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)**如何定义机器人当前的状态？**机器人的视野只有5格：*东、西、南、北、中*。每一格可以有3中状态：*墙、豆、空*。所以机器人的所有可能状态有
$$
3^5=243
$$
种。事实上，并不是所有状态都存在，比如当前位置有墙、或者四面都是墙等等。但这并不影响算法，只不过有一些存储上的冗余。
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)你可能发现了上面模型中定义的策略String的长度也是243：
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
```java
public
```
```java
static
```
```java
final
```
```java
int
```
```java
STRATEGY_LEN
```
```java
=
```
```java
243
```
```java
;
```
```java
// 策略的字符串长度
```
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)实际上每个字符都在{0,1,2,3,4,5,6}中取值，对应机器人在那个状态下的动作！
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)`* 0-不动
* 1-东
* 2-西
* 3-南
* 4-北
* 5-随机移动
* 6-吃豆`[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)这是判断机器人当前状态的函数，返回一个0~242之间的数：
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
```java
public
```
```java
int
```
```java
getState
```
```java
(
```
```java
)
```
```java
{
```
```java
int
```
```java
tempX
```
```java
,
```
```java
tempY
```
```java
;
```
```java
int
```
```java
state
```
```java
,
```
```java
wholeState
```
```java
=
```
```java
0
```
```java
;
```
```java
for
```
```java
(
```
```java
int
```
```java
i
```
```java
=
```
```java
0
```
```java
;
```
```java
i
```
```java
<
```
```java
5
```
```java
;
```
```java
++
```
```java
i
```
```java
)
```
```java
{
```
```java
// 遍历视野中的 5 个格子
```
```java
tempX
```
```java
=
```
```java
currX
```
```java
+
```
```java
DIRECTION
```
```java
[
```
```java
i
```
```java
]
```
```java
[
```
```java
0
```
```java
]
```
```java
;
```
```java
tempY
```
```java
=
```
```java
currY
```
```java
+
```
```java
DIRECTION
```
```java
[
```
```java
i
```
```java
]
```
```java
[
```
```java
1
```
```java
]
```
```java
;
```
```java
if
```
```java
(
```
```java
tempX
```
```java
<
```
```java
0
```
```java
||
```
```java
tempY
```
```java
<
```
```java
0
```
```java
||
```
```java
tempX
```
```java
>=
```
```java
rowNum
```
```java
||
```
```java
tempY
```
```java
>=
```
```java
colNum
```
```java
)
```
```java
{
```
```java
state
```
```java
=
```
```java
0
```
```java
;
```
```java
//如果是 墙（出界）
```
```java
}
```
```java
else
```
```java
{
```
```java
if
```
```java
(
```
```java
fruits
```
```java
[
```
```java
tempX
```
```java
]
```
```java
[
```
```java
tempY
```
```java
]
```
```java
)
```
```java
{
```
```java
state
```
```java
=
```
```java
1
```
```java
;
```
```java
//发现豆子
```
```java
}
```
```java
else
```
```java
{
```
```java
state
```
```java
=
```
```java
2
```
```java
;
```
```java
//什么也没有
```
```java
}
```
```java
}
```
```java
wholeState
```
```java
=
```
```java
3
```
```java
*
```
```java
wholeState
```
```java
+
```
```java
state
```
```java
;
```
```java
// 乘 3相当于在 3进制中进位，用位数为5的3进制数表示当前状态
```
```java
}
```
```java
return
```
```java
wholeState
```
```java
;
```
```java
}
```
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)获取当前策略下的动作（intent），之所以成为intent是因为有些动作是不会被执行的（撞墙、瞎吃）。
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
```java
public
```
```java
int
```
```java
getIntent
```
```java
(
```
```java
int
```
```java
state
```
```java
)
```
```java
{
```
```java
return
```
```java
strategy
```
```java
.
```
```java
charAt
```
```java
(
```
```java
state
```
```java
)
```
```java
-
```
```java
'0'
```
```java
;
```
```java
}
```
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)然后根据intent进行动作并得到每一步的分数
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
```java
public
```
```java
int
```
```java
checkAndMove
```
```java
(
```
```java
int
```
```java
intent
```
```java
)
```
```java
{
```
```java
int
```
```java
score
```
```java
=
```
```java
0
```
```java
;
```
```java
int
```
```java
tempX
```
```java
,
```
```java
tempY
```
```java
;
```
```java
Random rand
```
```java
=
```
```java
new
```
```java
Random
```
```java
(
```
```java
)
```
```java
;
```
```java
if
```
```java
(
```
```java
intent
```
```java
==
```
```java
5
```
```java
)
```
```java
{
```
```java
//随机移动，等价于转化为动作1-4之一
```
```java
intent
```
```java
=
```
```java
rand
```
```java
.
```
```java
nextInt
```
```java
(
```
```java
4
```
```java
)
```
```java
+
```
```java
1
```
```java
;
```
```java
// 5==>{1,2,3,4}
```
```java
}
```
```java
if
```
```java
(
```
```java
intent
```
```java
==
```
```java
6
```
```java
)
```
```java
{
```
```java
// 吃豆
```
```java
if
```
```java
(
```
```java
fruits
```
```java
[
```
```java
currX
```
```java
]
```
```java
[
```
```java
currY
```
```java
]
```
```java
)
```
```java
{
```
```java
// 吃到豆
```
```java
score
```
```java
=
```
```java
10
```
```java
;
```
```java
fruits
```
```java
[
```
```java
currX
```
```java
]
```
```java
[
```
```java
currY
```
```java
]
```
```java
=
```
```java
false
```
```java
;
```
```java
}
```
```java
else
```
```java
{
```
```java
// 瞎吃
```
```java
score
```
```java
=
```
```java
-
```
```java
1
```
```java
;
```
```java
}
```
```java
}
```
```java
else
```
```java
{
```
```java
tempX
```
```java
=
```
```java
currX
```
```java
+
```
```java
DIRECTION
```
```java
[
```
```java
intent
```
```java
]
```
```java
[
```
```java
0
```
```java
]
```
```java
;
```
```java
tempY
```
```java
=
```
```java
currY
```
```java
+
```
```java
DIRECTION
```
```java
[
```
```java
intent
```
```java
]
```
```java
[
```
```java
1
```
```java
]
```
```java
;
```
```java
if
```
```java
(
```
```java
tempX
```
```java
<
```
```java
0
```
```java
||
```
```java
tempY
```
```java
<
```
```java
0
```
```java
||
```
```java
tempX
```
```java
>=
```
```java
rowNum
```
```java
||
```
```java
tempY
```
```java
>=
```
```java
colNum
```
```java
)
```
```java
{
```
```java
// 撞墙
```
```java
score
```
```java
=
```
```java
-
```
```java
5
```
```java
;
```
```java
}
```
```java
else
```
```java
{
```
```java
currX
```
```java
=
```
```java
tempX
```
```java
;
```
```java
currY
```
```java
=
```
```java
tempY
```
```java
;
```
```java
}
```
```java
}
```
```java
return
```
```java
score
```
```java
;
```
```java
}
```
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)这样一来，我们已经完成**根据当前位置判断状态**、**根据状态获得动作**、**处理动作并得分**这几个基本模块。只要任意初始化一个Strategy，就可以通过规定步数内的得分来评估它的好坏！
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)终于来到重要一步，遗传进化！遗传进化需要考虑两个方面：1. 继承父辈的优良性状；2. 有所创新/突变。也就是人们常说的在**探索**和**开发**中保持平衡！
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
```java
public
```
```java
static
```
```java
String
```
```java
combineStrategy
```
```java
(
```
```java
String a
```
```java
,
```
```java
String b
```
```java
)
```
```java
{
```
```java
StringBuilder sb
```
```java
=
```
```java
new
```
```java
StringBuilder
```
```java
(
```
```java
)
```
```java
;
```
```java
Random rand
```
```java
=
```
```java
new
```
```java
Random
```
```java
(
```
```java
)
```
```java
;
```
```java
if
```
```java
(
```
```java
rand
```
```java
.
```
```java
nextInt
```
```java
(
```
```java
10
```
```java
)
```
```java
<
```
```java
1
```
```java
)
```
```java
{
```
```java
// 随机劈腿！！！
```
```java
b
```
```java
=
```
```java
genStrategy
```
```java
(
```
```java
)
```
```java
;
```
```java
}
```
```java
for
```
```java
(
```
```java
int
```
```java
i
```
```java
=
```
```java
0
```
```java
;
```
```java
i
```
```java
<
```
```java
STRATEGY_LEN
```
```java
;
```
```java
++
```
```java
i
```
```java
)
```
```java
{
```
```java
if
```
```java
(
```
```java
rand
```
```java
.
```
```java
nextInt
```
```java
(
```
```java
20
```
```java
)
```
```java
<
```
```java
1
```
```java
)
```
```java
{
```
```java
// 杂交出错！！！
```
```java
sb
```
```java
.
```
```java
append
```
```java
(
```
```java
(
```
```java
char
```
```java
)
```
```java
(
```
```java
rand
```
```java
.
```
```java
nextInt
```
```java
(
```
```java
ACTION_NUM
```
```java
)
```
```java
+
```
```java
'0'
```
```java
)
```
```java
)
```
```java
;
```
```java
}
```
```java
else
```
```java
{
```
```java
sb
```
```java
.
```
```java
append
```
```java
(
```
```java
rand
```
```java
.
```
```java
nextBoolean
```
```java
(
```
```java
)
```
```java
?
```
```java
a
```
```java
.
```
```java
charAt
```
```java
(
```
```java
i
```
```java
)
```
```java
:
```
```java
b
```
```java
.
```
```java
charAt
```
```java
(
```
```java
i
```
```java
)
```
```java
)
```
```java
;
```
```java
// 正常杂交
```
```java
}
```
```java
}
```
```java
return
```
```java
sb
```
```java
.
```
```java
toString
```
```java
(
```
```java
)
```
```java
;
```
```java
}
```
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)笔者在实验中发现，如果没有*劈腿、出错*这种事情发生，种群的基因会迅速的趋同，因为暂时最好的那些杂种凭借一时领先，获得垄断地位的交配机会，种群便永久地陷入半吊子水平，不得进步！！这有些类似神经网络在训练中陷入局部最优的烂坑！
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)可见**出错是进化的关键**！
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)接下来的事情就简单了（其实都很简单）：
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)创建一批随机祖先，即随机初始化一批（100个） Model 的 strategy，让他们在10*10且豆子概率为50%的网格中放飞自我；
挑选出最优的一批Model进行杂交；
评估子代Model的得分；
重复2、3，直到结果满意。
[
](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)实际实验中，1000代左右的模型在200步内就能达到460左右的高分，如文章开篇展示的动图所示。而理论上的最高分为500：
$$
500分 = 10行*10列*50\%*10分
$$
还是相当OK的！
[
						](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
[
	](https://img-blog.csdn.net/20180926233248802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2l0bmVyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
