
# 20160210.CCPP体系详解(0020天) - 尹成的技术博客 - CSDN博客

置顶2016年03月01日 13:51:07[尹成](https://me.csdn.net/yincheng01)阅读数：1581标签：[CCPP](https://so.csdn.net/so/search/s.do?q=CCPP&t=blog)个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)



程序片段(01):01.二级指针.c
内容概要:**二级指针**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.二级指针:
```
```python
//  1.使用场景:
```
```python
//      (1).跨函数修改一级指针变量的数据-->DLL注入技术!
```
```python
//      (2).指针数组作为函数形参,将会转化为二级指针-->函数形参!
```
```python
//  2.使用规律:
```
```python
//      如何快速定位取值运算符所操作的数据是什么?
```
```python
//          指针变量(定义级数-取值级数)<==>访问级数!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a =
```
```python
10
```
```python
;
```
```python
int
```
```python
b =
```
```python
15
```
```python
;
```
```python
int
```
```python
* p = &a;
```
```python
int
```
```python
** pp = &b;
    *pp = &b;
    **pp =
```
```python
3
```
```python
;
```
```python
//a-->b-->*p-->**pp
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):01.反外挂.c
内容概要:**游戏反外挂**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.关于赋值运算符的使用特点:
```
```python
//  赋值运算符针对于普通变量具备自动类型转换特性;
```
```python
//  赋值运算符针对于指着变量不具备自动类型转换的特性
```
```python
//02.指针类型与指针变量类型的重要性!
```
```python
//  只要涉及到指针的操作,一定要时刻注意类型的重要性
```
```python
//  注:数据类型<=>解析(步长+方式)
```
```python
//03.数组名以及指向数组首元素的指针区别:
```
```python
//  1.数组名和指向数组首元素的指针的数值层面一样
```
```python
//  2.数组名和指向数组首元素的指针都存在内存实体
```
```python
//      数组名:内存实体不可修改
```
```python
//          常量指针变量的指向不可改变,但是指向的数据可以改变
```
```python
//      指向数组首元素的指针(分变量指针和常量指针的情况)
```
```python
//          视指针变量的const修饰关键字使用情况而定
```
```python
//04.通过一级指针变量来模拟反外挂原理:
```
```python
//  一级指针变量当中的指针指向数组当中的某个血量刻度;
```
```python
//  通过修改一级指针变量的指针指向来获取具体的血量刻度;
```
```python
//  从而实现血量不可修改,只能修改指向(实现血量的只读权限)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
double
```
```python
arr[
```
```python
100
```
```python
];
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
    {
        arr[i] = i +
```
```python
1
```
```python
;
```
```python
//1.0~100.0
```
```python
}
```
```python
double
```
```python
* p = arr +
```
```python
60
```
```python
;
```
```python
//类型很重要,类型决定了(解析步长+解析方式)-->直接的一个数组名只是具备该数组首元素的内存首地址(首个字节)
```
```python
printf
```
```python
(
```
```python
"&p = %p \n"
```
```python
, &p);
```
```python
printf
```
```python
(
```
```python
"&arr = %p \n"
```
```python
, arr);
```
```python
printf
```
```python
(
```
```python
"%f \n"
```
```python
, *p);
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
printf
```
```python
(
```
```python
"此时的血=%lf \n"
```
```python
, *p);
        Sleep(
```
```python
1000
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(03):01.挂.c
内容概要:**挂**
```python
_declspec(dllexport) go01()
{
```
```python
double
```
```python
* p1 =
```
```python
0x2ef4a4
```
```python
;
```
```python
double
```
```python
* p2 =
```
```python
0x2ef4bc
```
```python
;
```
```python
//p1 = p2 + 92;//整数倍
```
```python
}
```
```python
//01.动态库函数的导出接口:
```
```python
//  _declspec(dllexport)
```
```python
//02.二级指针变量的用途:
```
```python
//  注入技术修改二级指针变量的数据
```
```python
//03.区分数值意义层面的整数
```
```python
//  没有数据类型的特点
```
```python
//04.指针变量的指针如果只是加上
```
```python
//  一个普通的数值,那么最好是该指针所
```
```python
//  指向内存块儿的内存字节整数倍!
```
```python
//  避免数据解析失败!
```
```python
//05.无论是自动类型转换还是强制类型转换
```
```python
//  都只是在对内存当中的二进制数据副本进行操作;
```
```python
//  原本数据不会被修改!
```
```python
_declspec(dllexport) go()                  
{
```
```python
double
```
```python
** pp =
```
```python
0x0018FAE4
```
```python
;
```
```python
//这里的pp+1<=>pp+1*(所存储的一级指针变量所占用的内存尺寸)
```
```python
//double * p = 0xB9F5D4;//p+1任何指针类型的变量都可以存储一个地址,地址本身无类型的情况之下,只能当做一个普通数据
```
```python
//*pp = 0xB9F5D4 + 0x50;//p+3普通的整数没有类型可言,只是一个数值层面的意义
```
```python
//*pp = *pp + 2;//修改方式1(明确类型)
```
```python
//*pp = 0x0018F794 + 3 * sizeof(double);//修改方式2(不明类型)-->错误,因为sizeof();会返回有类型的整型数值
```
```python
*pp =
```
```python
0x0018FAFC
```
```python
+
```
```python
3
```
```python
*
```
```python
8
```
```python
;
```
```python
//修改方式2(正确方式)
```
```python
//int a = 10;
```
```python
}
```
程序片段(04):01.指针类型.c
内容概要:**指针类型**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.指针的类型以及指针变量的类型重要性:
```
```python
//  1.数据类型:决定了(解析方式+解析步长)
```
```python
//  2.关于数据类型所决定的解析方式一共有三大类:
```
```python
//      (有符号整型+无符号整型+浮点型),这三种类型
```
```python
//      即使解析步长一样,如果解析方式不一样,解析结果照样异常!
```
```python
//  3.指针的类型决定了通过取值运算符进行取值运算的时候
```
```python
//      需要通过指针的数据(等同于内存首地址),向前解析的内存字节数
```
```python
//  4.printf();函数不会进行数据类型的转换,只是根据格式控制符所描述
```
```python
//      的解析方式对内存当中的二进制数据进行对应的解析
```
```python
//  注1:赋值号对于指针变量没有类型转换的意义,只有数值层面的意义!-->数值意义(地址数值,没有类型概念)
```
```python
//      赋值号只对于普通变量才存在着类型转换的意义!-->类型意义
```
```python
//  注2:指针变量的类型决定了取值运算符对指针变量当中所存储的指针的解析细节!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
int
```
```python
* p1 = &num;
```
```python
void
```
```python
* p3 = &num;
```
```python
//空类型的指针变量只是用于存储具备地址意义的数值,不含解析细节!
```
```python
double
```
```python
* p2 = &num;
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, p1, p2);
```
```python
//指针变量所存储的地址数值都一样
```
```python
printf
```
```python
(
```
```python
"%lf, %d \n"
```
```python
, *p2, *p1);
```
```python
//但是指针变量的类型决定了取值运算福对指针变量当中的指针解析方式
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.任何类型的变量进行赋值的时候,
```
```python
//  都应当注意数据类型是否一致!
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a =
```
```python
10
```
```python
;
```
```python
int
```
```python
* p1 = &a;
```
```python
int
```
```python
* p2 = p1;
```
```python
//类型一致的指针变量指针可以进行指针的赋值操作
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, p1, p2);
```
```python
//格式控制符只是描述对于内存二进制数据的解析方式
```
```python
printf
```
```python
(
```
```python
"%d, %d, %d \n"
```
```python
, *p1, *p2, a);
```
```python
//*p1 = 4;
```
```python
a =
```
```python
2
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d, %d, %d \n"
```
```python
, *p1, *p2, a);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.只要指针变量的类型和指针类型不一致
```
```python
//  就绝对不能正确的解析到结果
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
double
```
```python
db =
```
```python
10.9
```
```python
;
```
```python
int
```
```python
* p1 = &num;
```
```python
double
```
```python
* p2 = p1;
```
```python
//获取p2这个指针所指向的数据的时候,由于该指针变量(p2)的所描述的解析(方式+步长)不正确,因此解析出来的结果不可预料
```
```python
//赋值号,指针除了指针变量以外的其他变量,都会存在自动类型转换机制,唯独指针类型的变量特殊(只有地址意义的数值)
```
```python
//int a = 10.9;
```
```python
void
```
```python
*px = p1;
    px = p2;
```
```python
//空类型的指针变量只是用于临时存储地址意义的变量
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (
```
```python
int
```
```python
)db);
```
```python
//printf();不会进行自动类型转换,会导致解析某些数据失败
```
```python
printf
```
```python
(
```
```python
"%lf \n"
```
```python
, (
```
```python
float
```
```python
)num);
```
```python
//double * p = &num;
```
```python
//printf("%lf \n", *p);
```
```python
//*p = &db;
```
```python
//p = &db;
```
```python
//printf("%lf \n", *p);
```
```python
int
```
```python
*p = &db;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, *p);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.sizeof关键字用于求取实际占用的内存字节数!
```
```python
//  返回内存字节数类型为unsigned int
```
```python
//05.严格注意:
```
```python
//  是具体给指针变量赋值还是给普通变量赋值
```
```python
//  注:通过指针变量+取值运算符访问到的可能是普通内存实体!
```
```python
//      赋值运算符针对于普通内存实体也是具备自动类型转换机制的!
```
```python
//06.关于自动类型转换机制:
```
```python
//      两种处理方式
```
```python
//          同为整型:直接截断(图形化操作二进制位)
```
```python
//          不同类型:根据解析方式+解析步长进行决断!
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
100
```
```python
;
```
```python
int
```
```python
* p = &num;
```
```python
//sizeof(int)--int **pp-->sizeof(int *)
```
```python
*p =
```
```python
10.9
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, num);
```
```python
printf
```
```python
(
```
```python
"%u \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
*));
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
double
```
```python
*));
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//07.三个不同类型的指针变量所存储的地址是一样的
```
```python
//  但是由于指针变量的类型不一致,也就导致了指针类型不一致
```
```python
//  因此,对于同一个地址所对应的内存实体的解析方式也就不一样!
```
```python
//08.对局部变量的查询方式:
```
```python
//  局部变量的值+根据局部变量的值进行解析后的结果
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num = -
```
```python
1
```
```python
;
```
```python
int
```
```python
* p1 = &num;
```
```python
unsigned
```
```python
int
```
```python
* p2 = &num;
```
```python
float
```
```python
* p3 = &num;
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):01.Test.cpp+02.指针.c
内容概要:**指针的运算**
```python
///01.Test.cpp
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.区分:变量指针和常量指针以及指针常量!
```
```python
//      变量指针:可以修改的指针变量
```
```python
//      常量指针:不可以修改的指针变量,不能够修改指向,例如数组名
```
```python
//      指着常量:具备地址层面意义的地址数值!
```
```python
//02.数组名的本质:
```
```python
//  如果数组是一维数组,那就是指向数组当中收个元素的常量指针
```
```python
//  如果数组是高维数组(含二维),那就首先将该数组看作为一个一维数组
```
```python
//      而该数组名的本质就是指向(看做成一维数组)的首个元素的常量指针
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
int
```
```python
* p = arr;
```
```python
//变量指针=常量指针
```
```python
int
```
```python
*
```
```python
const
```
```python
px = arr;
```
```python
//数组名的本质就是数组当中第一个元素(所有数组都看作为一维数组进行处理!)的指针常量(地址常量|数值常量)
```
```python
*(arr +
```
```python
3
```
```python
);
```
```python
//arr = 1;//常量指针
```
```python
//px = 1;//const所修饰的常量指针,其指向不可以进行直接修改!
```
```python
system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
1
```
```python
;
}
```
```python
///
```
```python
02.指针.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.指针和指针变量都必须严格注重数据类型
```
```python
//02.指针变量的运算必须在同一个数组的情况之下,才具有意义!
```
```python
//  1.指针变量+|-一个整数:
```
```python
//      在数组当中向前或者向后移动几个数组元素
```
```python
//  2.指针变量-指针变量:
```
```python
//      求取两个指针变量之间相差了多少个数组元素
```
```python
//  注:指针变量没有乘法和乘法方面的运算,因为运算结果毫无意义！
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a =
```
```python
10
```
```python
;
```
```python
int
```
```python
b =
```
```python
20
```
```python
;
```
```python
int
```
```python
* p1 = &a;
```
```python
int
```
```python
* p2 = &b;
    p1 = p2;
```
```python
//同一个t类型的一级指in针变量之间可以进行相互赋值
```
```python
int
```
```python
arr[
```
```python
5
```
```python
];
    p1 = arr;
    p2 = &arr[
```
```python
2
```
```python
];
```
```python
//指针变量赋值运算,必须注意类型的统一性(而且:指针变量的赋值操作只具备数值层面的操作意义)
```
```python
p1 - p2;
```
```python
//得到的结果是在同一个数组当中的两个数组元素之间所相差的数组元素个数
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.C语言和C++语言的编译器特点:
```
```python
//  C语言属于"弱类型"语言;C++语言属于"强类型"语言
```
```python
//  注:强弱类型就是对数据类型是否精准匹配的严格校对!(编译时期校对)
```
```python
//04.关于指针变量和整型变量之间的赋值:
```
```python
//  1.类型不匹配,C语言允许
```
```python
//  2.给指针变量赋予的整型变量的数据具有地址层面的意义
```
```python
//  注:不可以对指针变量进行随意赋值操作!(唯恐赋予不规范内存地址)
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
* p =
```
```python
0x123123
```
```python
;
```
```python
//指针变量一般不允许直接赋值常规整数,因为不可预知(因为该地址所对应的内存块儿不知道是否有系统进行维护!)
```
```python
*p =
```
```python
1
```
```python
;
```
```python
//该指针变量当中的指针指向了操作系统所使用的内存,因此发生内存访问错误情况!
```
```python
int
```
```python
num = p;
```
```python
//指针变量和整型变量之间可以进行赋值,可以编译,但是整数表示的是具备地址意义层面的数值!
```
```python
printf(
```
```python
"%x \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
void
```
```python
select
```
```python
(
```
```python
int
```
```python
const
```
```python
* p)
{
```
```python
//*p = 123;
```
```python
printf(
```
```python
"银行有%d元! \n"
```
```python
, *p);
}
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
int
```
```python
const
```
```python
* p;
```
```python
//指针变量的指向可以改变,但是指向的数据数据不可以改变!
```
```python
int
```
```python
num1 =
```
```python
101
```
```python
;
```
```python
//银行的钱
```
```python
select
```
```python
(&num1);
```
```python
int
```
```python
num2 =
```
```python
102
```
```python
;
```
```python
//银行的钱
```
```python
select
```
```python
(&num2);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num1 =
```
```python
101
```
```python
;
```
```python
//银行的钱
```
```python
int
```
```python
num2 =
```
```python
102
```
```python
;
```
```python
//银行的钱
```
```python
const
```
```python
int
```
```python
* p = &num1;
    p = &num2;
```
```python
//*p = 10;
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main06(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num1 =
```
```python
101
```
```python
;
```
```python
//银行的钱
```
```python
int
```
```python
num2 =
```
```python
102
```
```python
;
```
```python
//银行的钱
```
```python
int
```
```python
*
```
```python
const
```
```python
p = &num1;
    *p +=
```
```python
3
```
```python
;
```
```python
//p = &num2;
```
```python
//int * const p;//指针变量的指向可以修改,但是所指向的数据不能修改
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.关于const关键字做权限控制的几种情况:
```
```python
//      const在*右边:跨函数数据只读权限,账户访问权限
```
```python
//          指针变量的指向不可修改,但所指向的数据可以修改
```
```python
//      const在*左边:跨函数账户只读权限,数据访问权限
```
```python
//          指着变量的指向可以修改,但所指向的数据不可修改
```
```python
//      双const情况:跨函数账户不可修改,数据不可修改
```
```python
//          指针变量的指向不可修改,所指向的数据不可修改
```
```python
//  注:严格区分账户情况和数据情况
```
```python
int
```
```python
main07(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
int
```
```python
num2 =
```
```python
100
```
```python
;
```
```python
const
```
```python
int
```
```python
*
```
```python
const
```
```python
p = &num;
```
```python
//*p = 101;
```
```python
//p = &num2;
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//05.关于const做权限控制的解决方案:
```
```python
//  const在*右边:
```
```python
//      1.指向变量数据的常量指针
```
```python
//      2.账户只读权限,数据访问权限
```
```python
//  const在*左边:
```
```python
//      1.指向常量数据的变量指针
```
```python
//      2.账户访问权限,数据只读权限
```
```python
//  const在双边:
```
```python
//      1.指向常量数据的常量指针
```
```python
//      2.账户只读权限,数据只读权限(代理查询)
```
```python
//  注:函数形参控制账户+函数实体控制数据
```
程序片段(06):01.Run.c
内容概要:**算数运算以及其他运算**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.针对于数组的两种常用遍历方式:
```
```python
//  索引遍历+指针遍历
```
```python
//  注:编译实质arr[i]<=>*(arr+i)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
};
```
```python
//arr[i]的编译实质:*(arr+i)
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
//下标遍历
```
```python
printf
```
```python
(
```
```python
"%p, %p, %d \n"
```
```python
, &arr[i], arr + i, arr[i]);
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
* p = arr; p < arr +
```
```python
10
```
```python
; ++p)
    {
```
```python
//指针遍历
```
```python
printf
```
```python
(
```
```python
"%p, %d \n"
```
```python
, p, *p);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.运算符的优先级:
```
```python
//  1.接触生效原理(谁先接触谁优先)
```
```python
//  2.自变运算符(++)的优先级大于取值运算符(星号:"*")
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
};
```
```python
int
```
```python
* p = &arr[
```
```python
3
```
```python
];
    p +=
```
```python
3
```
```python
;
```
```python
//printf("%d \n", *p++);//7
```
```python
//printf("%d \n", *(p++));//7
```
```python
//printf("%d \n", ++p);//8
```
```python
//printf("%d \n", *(++p));//8
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.指针变量的相等与不等比较特点!
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
int
```
```python
* p1 = &num;
```
```python
int
```
```python
* p2 = &num +
```
```python
1
```
```python
;
```
```python
if
```
```python
(p1 == p2)
    {
```
```python
printf
```
```python
(
```
```python
"情敌! \n"
```
```python
);
    }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"非情敌! \n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.指针变量的关系运算:
```
```python
//  1.数组内:索引前后关系
```
```python
//  2.数组外:栈内存所属位置
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
};
```
```python
int
```
```python
* p1 = arr;
```
```python
int
```
```python
* p2 = arr +
```
```python
3
```
```python
;
```
```python
//p2>p1:p2的下标比p1的下标大,数组内部可以说明排序
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//05.编译器的两种编译模式:
```
```python
//  Debug模式:栈结构的开口向上
```
```python
//      Debug情况之下:VC和GCC两个编译器的结果相同
```
```python
//  Release模式:栈结构的开口向下
```
```python
//      Release情况之下:存在着代码优化机制
```
```python
//  注:(代码优化机制:VC和GCC编译器都会根据变量的使用频率,自动优化该变量在栈结构当中的所属位置
```
```python
//      某变量的使用频率越高,那么该变量在Release模式下越有几率被存放于栈结构开口处!)
```
```python
//06.几种进栈实质区分:
```
```python
//  1.代码进栈
```
```python
//  2.函数形参:形参变量进栈
```
```python
//  3.函数实体:局部变量进栈
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a;
```
```python
int
```
```python
b;
```
```python
int
```
```python
c;
```
```python
printf
```
```python
(
```
```python
"&a = %p, &b = %p, c = %p \n"
```
```python
, &a, &b, &c);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(07):01.Test.c+02.Run.c
内容概要:**指针运算的优先级**
```python
///01.Test.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
* p;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(p));
```
```python
//所有指针类型享有共同内存尺寸,只是区分编译器位数直接决定
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.Run.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.两个指针变量的减法说明:
```
```python
//  1.必需在同一个数组当中两个指针变量进行减法操作才具有实际意义!
```
```python
//  2.任意两个指针变量的减法结果推导!
```
```python
//      减法结果=((指针变量1的指针所属地址数值)-(指针变量2的指针所属地址数值))/sizeof(指针变量1的所属类型);
```
```python
//  注:编译器不会报错!但是实际开发过程当中严谨这样进行操作!
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
int
```
```python
* p = arr;
```
```python
int
```
```python
* p1 = &arr[
```
```python
4
```
```python
];
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, p1 - p);
```
```python
//相减等同于相差的数组元素个数
```
```python
//double * px = &arr[4];//2
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.内容概要:
```
```python
//  1.变量指针+常量指针
```
```python
//  2.指针减法=(指针1-指针2)/sizeof(*指针1);
```
```python
//03.指针变量的优先级和结合性:
```
```python
//  1.接触生效
```
```python
//  2.++的优先级高于*
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
int
```
```python
* p = arr;
```
```python
int
```
```python
* px = &arr[
```
```python
4
```
```python
];
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, px - p);
```
```python
char
```
```python
* px1 = arr +
```
```python
3
```
```python
;
```
```python
char
```
```python
* px2 = arr +
```
```python
4
```
```python
;
```
```python
//数组名arr的数据类型int * const p;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, px1 - px2);
```
```python
//4=(地址1-地址2)sizeof(char)
```
```python
*p++;
```
```python
//++的优先级比*的优先级高
```
```python
(*p)++;                                                                                                 
    ++*p;
```
```python
//优先级接触生效
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, arr[i]);
    }
    system(
```
```python
"pause "
```
```python
);
}
```
程序片段(08):01.Point.c
内容概要:**指针与数组**
```python
///01.Point.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.数组名+&数组名+*数组名:
```
```python
//  数组名:
```
```python
//      将所有数组看做为一维数组进行处理
```
```python
//      然后数组名就是指向该一维数组的常量指针
```
```python
//  &数组名:
```
```python
//      数组指针常量,是一个具有(地址+类型)意义的数值
```
```python
//  *数组名:
```
```python
//      根据数组名的特点进行区分
```
```python
//02.各种维度的指针区别:
```
```python
//  0维指针:指向一列
```
```python
//  1维指针:指向一行
```
```python
//  2维指针:指向一面
```
```python
//  3维指针:指向一体
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
};
```
```python
int
```
```python
intArrArr[
```
```python
3
```
```python
][
```
```python
4
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
,
```
```python
11
```
```python
,
```
```python
12
```
```python
};
```
```python
printf
```
```python
(
```
```python
"intArr = %p, &intArr = %p \n"
```
```python
, intArr, &intArr);
```
```python
printf
```
```python
(
```
```python
"intArr+1 = %p, &intArr + 1 = %p \n"
```
```python
, intArr +
```
```python
1
```
```python
, &intArr +
```
```python
1
```
```python
);
```
```python
//intArr作为一个常量指针,指向数组当中的首个元素
```
```python
//&intArr作为一个指针常量,指向整个数组
```
```python
prinrf(
```
```python
"intArrArr = %p, &intArrArr = %p, *intArrArr \n"
```
```python
, intArrArr, &intArrArr, *intArrArr);
```
```python
printf
```
```python
(
```
```python
"intArrArr+1 = %p, &intArrArr+1 = %p, *intArrArr+1 = %p \n"
```
```python
,intArrArr +
```
```python
1
```
```python
, &intArrArr +
```
```python
1
```
```python
, *intArrArr +
```
```python
1
```
```python
);
```
```python
//intArrArr作为一个常量指针,指向数组当中的首个元素(将所有数组当做为一维数组进行看待的处理结果)
```
```python
//&intArrArr作为一个指针常量,指向一个面儿
```
```python
//*intArrArr作为一个指针常量,指向一个列
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(09):01.P.cpp
内容概要:**指针数组与数组指针**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.指针数组与数组指针
```
```python
//  指针数组:
```
```python
//      1.是一个数组
```
```python
//      2.存储的都是变量指针
```
```python
//  数组指针:垂直指向
```
```python
//      1.是一个指针
```
```python
//      2.存储的是一维数组的首地址
```
```python
//  注:凡是对数组名进行取地址操作,所获取到的
```
```python
//      都是指针都是数组指针(指针常量)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
];
```
```python
int
```
```python
* pArr[
```
```python
10
```
```python
];
```
```python
//40-->指针数组:用于存储指针变量的数组
```
```python
int
```
```python
(*p)[
```
```python
10
```
```python
];
```
```python
//4-->数组指针:指向含有10个数组元素的的数组的指针!
```
```python
printf
```
```python
(
```
```python
"%d, %d \n"
```
```python
,
```
```python
sizeof
```
```python
(pArr),
```
```python
sizeof
```
```python
(p));
    system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
1
```
```python
;
}
```
```python
//0 9   2   8   3   7   4   5   5    10
```
```python
//0 9   2   8   3   7   4   6   10   5
```
```python
//10    9   2   8   3   7   4   6   1    5
```
```python
//02.指针数组的常见用途:
```
```python
//  1.批量管理指针(内存地址)
```
```python
//  2.便于分块数组模型的构建
```
```python
//注:指针数组所存储的指针类型通常都是(char*)类型
```
```python
//      因为便于进行内存检索!+字符串存储于代码区常量池
```
```python
//03.赋值运算符针对于指针变量不具备类型转换的特性
```
```python
//  通常只是具备地址层面意义的数值
```
```python
//04.比较指针变量所存储的指针所指向数据实体
```
```python
//      交换指针变量所存储的指针!-->防止修改原始存储数据顺序!
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
,
```
```python
9
```
```python
,
```
```python
2
```
```python
,
```
```python
8
```
```python
,
```
```python
3
```
```python
,
```
```python
7
```
```python
,
```
```python
4
```
```python
,
```
```python
6
```
```python
,
```
```python
5
```
```python
,
```
```python
10
```
```python
};
```
```python
int
```
```python
* pArr[
```
```python
10
```
```python
];
```
```python
//指针数组:该数组当中的每一个变量都是指针变量,用于批量管理内存地址[指针]
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        pArr[i] = arr + i;
```
```python
//变量指针存储常量指针的地址数值
```
```python
}
```
```python
//正向的冒泡排序算法
```
```python
//for (int i = 0; i < 10 - 1; ++i)
```
```python
//{
```
```python
//  for (int j = 0; j < 10 - 1 - i; ++j)
```
```python
//  {
```
```python
//      if (*pArr[j] < *pArr[j + 1])
```
```python
//      {
```
```python
//          int * pTemp = pArr[j];
```
```python
//          pArr[j] = pArr[j + 1];
```
```python
//          pArr[j + 1] = pTemp;
```
```python
//      }
```
```python
//  }
```
```python
//}
```
```python
//反向的冒泡排序算法
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
10
```
```python
-
```
```python
1
```
```python
; i >
```
```python
0
```
```python
; --i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
10
```
```python
-
```
```python
1
```
```python
; j >
```
```python
10
```
```python
-
```
```python
1
```
```python
- i; --j)
        {
```
```python
if
```
```python
(*pArr[j] < *pArr[j -
```
```python
1
```
```python
])
            {
```
```python
int
```
```python
* pTemp = pArr[j];
                pArr[j] = pArr[j -
```
```python
1
```
```python
];
                pArr[j -
```
```python
1
```
```python
] = pTemp;
            }
        }
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d, %d \n"
```
```python
, *pArr[i], arr[i]);
    }
    system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
1
```
```python
;
}
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
* p = arr; p < arr +
```
```python
10
```
```python
; ++p)
    {
```
```python
//指针遍历
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, *p);
    }
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, arr, &arr);
```
```python
printf
```
```python
(
```
```python
"%p , %p \n"
```
```python
, arr +
```
```python
1
```
```python
, &arr +
```
```python
1
```
```python
);
```
```python
int
```
```python
(*p)[
```
```python
10
```
```python
];
```
```python
//p-->p+1-->40//&一维数组名的本质
```
```python
p = &arr;
```
```python
int
```
```python
* px = arr;
```
```python
//px-->px+1-->4
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(10):01.批量挂.c
内容概要:**指针数组挂**
```python
#include <Windows.h>
```
```python
//01.通过指针数组实现批量处理指针变量:
```
```python
//  跨进程修改内存实体-->需要内存实体的所属地址!
```
```python
_declspec(dllexport) go()
{
```
```python
int
```
```python
* pArr[
```
```python
5
```
```python
];
    pArr[
```
```python
0
```
```python
] =
```
```python
0xadfc70
```
```python
;
    pArr[
```
```python
1
```
```python
] =
```
```python
0xae0720
```
```python
;
    pArr[
```
```python
2
```
```python
] =
```
```python
0xae0850
```
```python
;
    pArr[
```
```python
3
```
```python
] =
```
```python
0xae05f0
```
```python
;
    pArr[
```
```python
4
```
```python
] =
```
```python
0xae04c0
```
```python
;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
        {
```
```python
if
```
```python
(*pArr[i] <
```
```python
100
```
```python
)
            {
                *pArr[i] =
```
```python
101
```
```python
;
            }
        }
        Sleep(
```
```python
1000
```
```python
);
    }
}
```
程序片段(11):01.二维数组.c+02.二维数组轮询.c
内容概要:**指针与二维数组**
```python
///01.二维数组.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.关于线性存储的数组的解析方式:
```
```python
//  1.可以采用指针变量的遍历方式
```
```python
//  2.该指针变量直接从数组的首个数组元素开始进行遍历!
```
```python
//      线性遍历:遍历的指针尺寸是数组当中的不可分割的数据类型!
```
```python
//  3.线性数组的奥数操作方式!
```
```python
//      外层变化快+内层变化慢!
```
```python
//注:可以直接将二维数组当中的每个数组元素看做为单个列指针变量的
```
```python
//      指针所指向!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arrArr[
```
```python
3
```
```python
][
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
5
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%4d"
```
```python
, arrArr[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
* p = &arrArr[
```
```python
0
```
```python
][
```
```python
0
```
```python
]; p < *arrArr +
```
```python
15
```
```python
; ++p)
    {
```
```python
//线性排列-->线性遍历
```
```python
printf
```
```python
(
```
```python
"%4d, %p \n"
```
```python
, *p, p);
    }
```
```python
printf
```
```python
(
```
```python
"\n\n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
15
```
```python
; ++i)
    {
```
```python
//索引遍历-->性能优化
```
```python
printf
```
```python
(
```
```python
"%4d, %p \n"
```
```python
, arrArr[i /
```
```python
5
```
```python
][i %
```
```python
5
```
```python
], &arrArr[i /
```
```python
5
```
```python
][i %
```
```python
5
```
```python
]);
```
```python
//00 01 02 03 04
```
```python
//10 11 12 13 14
```
```python
//20 21 22 23 24
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.关于一维数组二维数组的概念区别:
```
```python
//  一维数组:int arr[5]
```
```python
//      arr:int * const-->常量指针-->有内存实体
```
```python
//      &arr:int (*pArr)[5]-->数组指针-->没有内存实体-->属于指针常量
```
```python
//      *arr:int-->零维指针-->有内存实体-->获取数值
```
```python
//  二维数组:int arrArr[4][5]
```
```python
//      arrArr:int (*pArr)[5]-->数组类型的常量指针-->行指针-->有内存实体
```
```python
//      &arrArr:int (*pArr)[4][5]-->数组类型的指针-->面指针-->没有内存实体-->属于指针常量
```
```python
//      *arrArr:int *-->普通变量的指针-->列指针-->有内存实体
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//int arr[5];
```
```python
int
```
```python
arrArr[
```
```python
3
```
```python
][
```
```python
5
```
```python
];
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, arrArr, arrArr +
```
```python
1
```
```python
);
```
```python
//20个字节
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, *arrArr, *arrArr +
```
```python
1
```
```python
);
```
```python
//4个字节
```
```python
//int ** p = arrArr;//数据类型不匹配
```
```python
int
```
```python
(*parrArr)[
```
```python
5
```
```python
] = arrArr +
```
```python
0
```
```python
;
```
```python
//二维数组名的本质:将二维数组看做为一维数组之后,指向其中每个元素的常量指针类型
```
```python
//arrArr = 1;//数组名一定是常量指针,绝对不可以进行改变
```
```python
int
```
```python
* px = *(arrArr +
```
```python
0
```
```python
);
```
```python
//*arrArr-->行指针转化为列指针(就是指向普通变量的一级一级指针)-->只是对内存数据的转换
```
```python
int
```
```python
(*py)[
```
```python
3
```
```python
][
```
```python
5
```
```python
] = &arrArr;
```
```python
//&a-->一个指向固定面积的二维数组的指着变量,二维数组指针
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.二维数组轮询.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.关于二维数组的指针操作方式:
```
```python
//  例如:int arrArr[3][4]
```
```python
//      arrArr:行指针
```
```python
//      arrArr+i<=>&arrArr[i]:行指针
```
```python
//      arrArr[i]+j<=>*(arrArr+i)+j;
```
```python
//      *(arrArr[i]+j)<=>*(*(arrArr+i)+j)
```
```python
//  注:
```
```python
//      数组名的本质:
```
```python
//          将数组看做为一维数组,数组名
```
```python
//          就是指向该一维数组的常量指针
```
```python
//      *行指针<=>列指针
```
```python
//      列指针的实质就是一级常量指针
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arrArr[
```
```python
3
```
```python
][
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
5
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%4d, %p"
```
```python
, arrArr[i][j], &arrArr[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"\n\n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"arrArr + %d = %p, %p \n"
```
```python
, i, arrArr + i, &arrArr[i]);
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
5
```
```python
; ++j)
    {
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, arrArr[
```
```python
0
```
```python
] + j, *(arrArr +
```
```python
0
```
```python
) + j);
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, *(arrArr[
```
```python
0
```
```python
] + j), *(*(arrArr +
```
```python
0
```
```python
) + j));
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(12):01.Show.c
内容概要:**WebShow二维数组**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"Content-Type:text/html \n\n"
```
```python
);
```
```python
//01.必须使用一个明显的空行(需要两个"\n\n")进行表示
```
```python
int
```
```python
arrArr[
```
```python
3
```
```python
][
```
```python
5
```
```python
];
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
5
```
```python
; ++j)
        {
            arrArr[i][j] = num;
            ++num;
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
,*(*(arrArr+i)+j));
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, arrArr[i][j] = ++num);
        }
```
```python
printf
```
```python
(
```
```python
"<br />"
```
```python
);
```
```python
//02.html换行标签,不能使用C语言的换行!
```
```python
}
```
```python
//system("pause");//03.不能使用系统函数
```
```python
}
```
程序片段(13):01.动态数组.c
内容概要:**动态数组**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.动态数组采用什么类型的指针变量进行接收:
```
```python
//  就表明动态数组名称属是什么类型!(变量指针|)
```
```python
//  简而言之:接收动态数组的指针变量就是动态数组名的本质!
```
```python
//注:严格区分变量指针和常量指针
```
```python
//02.区分释放内存和回收内存之间的区别:
```
```python
//  个人观点:释放内存+数据清除=回收内存
```
```python
//      仅仅的释放内存:不会自动发生数据清除操作!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//arr[N];
```
```python
int
```
```python
N;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &N);
```
```python
int
```
```python
* p;
    p = (
```
```python
int
```
```python
*)
```
```python
malloc
```
```python
(N *
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        p[i] = i;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, p[i]);
    }
```
```python
free
```
```python
(p);
```
```python
//回收内存
```
```python
//free(p);//释放内存,针对于同一片儿内存的指针,对该指针进行释放的操作不可重复进行!
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.在堆内存开辟模拟栈内存的二维数组的关键点在于:
```
```python
//  指针变量的类型-->决定对内存块儿的解析方式!
```
```python
//注:可以对动态数组的数组名执行类似于栈内存二维数组的操作!
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arrArr[
```
```python
3
```
```python
][
```
```python
10
```
```python
];
```
```python
//开辟堆内存动态数组模拟这个栈内存二维数组,关键在于指针
```
```python
int
```
```python
(*p)[
```
```python
10
```
```python
] =
```
```python
malloc
```
```python
(
```
```python
30
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
//p就是堆内存当中的动态数组数组名
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
10
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, p[i][j] = num++);
```
```python
//原理:p[i][j]<=>*(*(p+i)+j));
```
```python
}
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.关于动态内存分配的注意事项:
```
```python
//  1.参数按照无符号类型进行解析的!
```
```python
//      因此不能使用特殊值-1-->会解析为极大的数据
```
```python
//      无符号类型解析方式:内存二进制全部看做为补码进行逆向解析
```
```python
//  2.取特殊内存字节数0可以分配成功,但是并没有
```
```python
//      实际意义!
```
```python
//注:解析方式尤其重要!
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
//int * p = malloc(-1);//分配失败为0,-1补码-->所分配的内存空间比较大
```
```python
int
```
```python
* p =
```
```python
malloc
```
```python
(
```
```python
0
```
```python
);
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, p);
```
```python
//0能分配成功,但是没有实际意义!
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.动态内存开辟诀窍:
```
```python
//      数组首元素的指针!
```
```python
//  注:回收内存的操作只能执行一次,为了软件规范
```
```python
//      只要对指针变量当中所存储的指针执行了回收操作
```
```python
//      就应当置为空指针,防止重复回收内存错误!
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
N;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &N);
```
```python
int
```
```python
* p;
    p =
```
```python
malloc
```
```python
(N *
```
```python
sizeof
```
```python
(N));
```
```python
printf
```
```python
(
```
```python
"p = %p \n"
```
```python
, p);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        p[i] = i;
```
```python
printf
```
```python
(
```
```python
"%d"
```
```python
, p[i]);
    }
```
```python
free
```
```python
(p);
```
```python
//内存回收!
```
```python
printf
```
```python
(
```
```python
"p = %p \n"
```
```python
, p);
```
```python
//free(p);回收内存,回收内存的操作只能执行一次,不可以进行重复回收动作
```
```python
p = NULL;
```
```python
//被妹子回收了,为了防止迷途指针的产生,需要设定指针变量为空
```
```python
free
```
```python
(p);
```
```python
//回收空指针不会出错!
```
```python
//*p = 123;
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//05.一定要在存储指针的指针变量消亡之前
```
```python
//  执行指针所指向内存区块儿回收操作,否则会导致内存泄露
```
```python
void
```
```python
run()
{
```
```python
void
```
```python
* p =
```
```python
malloc
```
```python
(
```
```python
10
```
```python
);
```
```python
//指针变量p本身存储与栈内存
```
```python
//内存泄露,存储地址的指针消亡,就无法进行回收动作了
```
```python
free
```
```python
(p);
}
```
```python
//06.如何定义一个三维动态数组?
```
```python
//  采用面儿指针<=>指向二维数组的指针
```
```python
//注:定义N维数组需要(N-1)维的数组的指针
```
```python
//  任何N维数组都可以看做为一个一维数组,内部的(N-1)维数组只是一个元素!
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
(*p)[
```
```python
3
```
```python
][
```
```python
5
```
```python
] =
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
) *
```
```python
15
```
```python
*
```
```python
2
```
```python
);
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
z =
```
```python
0
```
```python
; z <
```
```python
2
```
```python
; ++z)
```
```python
//纵坐标-->控制面
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
x =
```
```python
0
```
```python
; x <
```
```python
3
```
```python
; ++x)
```
```python
//横坐标-->控制行
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
y =
```
```python
0
```
```python
; y <
```
```python
5
```
```python
; ++y)
```
```python
//纵坐标-->控制列
```
```python
{
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, p[z][x][y] = num++);
            }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
        }
```
```python
printf
```
```python
(
```
```python
"\n\n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(14):01.动态内存.c
内容概要:**动态内存**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.静态数组:
```
```python
//  位于栈内存:在编译时期就已经确定了该数组的所含有的元素个数
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
];
```
```python
//栈内存-->静态数组-->在编译时期就已经确定了数组的元素个数
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.动态数组:
```
```python
//  位于堆内存:在运行时期动态确定该数组所占有的内存尺寸!
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
n;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &n);
```
```python
int
```
```python
* p =
```
```python
malloc
```
```python
(n *
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
));
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < n; ++i)
    {
        p[i] = i;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, p[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.区分软访问与硬访问:
```
```python
//  软访问和硬访问的默认最小单位是字节
```
```python
//  软访问可以实现的极限最下单位是二进制位
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
void
```
```python
* p =
```
```python
malloc
```
```python
(
```
```python
1024
```
```python
*
```
```python
1024
```
```python
*
```
```python
10
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.使用动态内存的原因:
```
```python
//  静态内存(栈内存)使用尺寸过小!
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
//int a[1024 * 1024 * 1024];//栈内存的大小,不能太大,设置很大不但耗费CPU,还耗费内存
```
```python
int
```
```python
a;
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(15):main.c
内容概要:**Stack**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.内存地址的高低必须区分模式:
```
```python
//  模式:Debug+Release
```
```python
//02.不同的模式:
```
```python
//  栈内存的开口方向不一样
```
```python
// 程序优化程度不一样(例如:经常访问的变量会定义在栈口!)
```
```python
int
```
```python
main01()
{
```
```python
int
```
```python
a;
```
```python
int
```
```python
b;
```
```python
int
```
```python
c;
```
```python
printf
```
```python
(
```
```python
"a=%p\nb=%p\nc=%p"
```
```python
, &a, &b, &c);
        system(
```
```python
"pause"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
()
```

