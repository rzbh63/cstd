
# 20160221.CCPP体系详解(0031天) - 尹成的技术博客 - CSDN博客

置顶2016年03月15日 00:41:09[尹成](https://me.csdn.net/yincheng01)阅读数：3278个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)


程序片段(01):01.结构体静态数组.c+02.结构体动态数组.c
内容概要:**结构体数组**
```python
///01.结构体静态数组.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.C语言的结构体特点:
```
```python
//  1.C语言要求结构体或者共用体至少得有一个成员
```
```python
//      也就是说C语言并不允许空结构体或者空共用体的出现!
```
```python
//  2.严格区分采用结构体类型到底定义的是哪种具体变量:
```
```python
//      普通变量+指针变量+数组变量
```
```python
struct
```
```python
{
```
```python
//匿名结构体
```
```python
int
```
```python
num;
} *pStruct, structArr[
```
```python
10
```
```python
], structVar;
```
```python
//02.定义结构体的不同分类方式:
```
```python
//  1.按照声明类型和定义变量的时机不同:
```
```python
//      声明结构体类型的同时定义结构体变量
```
```python
//      声明结构体类型之后再定义结构体变量
```
```python
//  2.按照所属内存空间的不同:
```
```python
//      栈内存:
```
```python
//      堆内存:
```
```python
//      静态区:
```
```python
//注:结构体变量(普通+指针+数组)
```
```python
struct
```
```python
MyStruct01
{
```
```python
//标准结构体
```
```python
int
```
```python
id;
```
```python
char
```
```python
str[
```
```python
10
```
```python
];
} ms01[
```
```python
10
```
```python
];
```
```python
//03.结构体的两种常见分类:
```
```python
//  标准结构体:标准情况
```
```python
//  匿名结构体:锁定变量变量个数
```
```python
//注:要想锁定变量个数就不能使用指针变量:
```
```python
//  因为针对于结构体指针变量可以进行动态内存分配,于是就会
```
```python
//  导致结构体变量数目的不确定性
```
```python
//04.结构体初始化:
```
```python
//  1.位于栈内存的结构体可以采用如同数组一样的静态初始化方式
```
```python
//  2.可以采用静态默认初始化方式{0}来将整个结构体空间清空为0
```
```python
//  3.如果涉及到结构体数组的形式,那么最外层{}代表结构体数组整体
```
```python
//      内层的每一个{}代表一个结构体变量本身
```
```python
//  4.如果涉及到一维结构体数组的初始化操作,想要省略内部的{}
```
```python
//      就需要按照结构体变量一个一个按照类型一致,顺序对应的关系
```
```python
//      完成初始化操作
```
```python
//05.关于静态初始化:
```
```python
//  1.针对于所有复合类型:
```
```python
//  2.最外层{}代表整体:
```
```python
//      内层{}一般代表单个,也可代表子整体
```
```python
//注:任何位于栈内存的复合类型采用指针进行指向,都需要进行类型转换
```
```python
//     任何位于栈内存的复合类型都可以采用{0}进行整体数据清零操作,无论
```
```python
//          符合类型的嵌套级数-->复合类型快捷静态初始化操作!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct01 ms02[
```
```python
10
```
```python
];
```
```python
struct
```
```python
MyStruct01 * pMS01 = (
```
```python
struct
```
```python
MyStruct01[]) {
```
```python
0
```
```python
};
```
```python
//结构体静态初始化(默认形式)
```
```python
struct
```
```python
MyStruct01 ms03[] = { {
```
```python
10
```
```python
,
```
```python
"20"
```
```python
},{
```
```python
10
```
```python
,
```
```python
"20"
```
```python
},{
```
```python
10
```
```python
,
```
```python
"20"
```
```python
} };
```
```python
struct
```
```python
MyStruct01 * pMS02 = (
```
```python
struct
```
```python
MyStruct01[]) { {
```
```python
10
```
```python
,
```
```python
"20"
```
```python
}, {
```
```python
10
```
```python
,
```
```python
"20"
```
```python
}, {
```
```python
10
```
```python
,
```
```python
"20"
```
```python
} };
```
```python
struct
```
```python
MyStruct01 ms04[] = { {
```
```python
0
```
```python
}, {
```
```python
0
```
```python
} };
```
```python
struct
```
```python
MyStruct01 ms05[] = {
```
```python
0
```
```python
};
```
```python
struct
```
```python
MyStruct01 ms06[][
```
```python
10
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//复合类型整体初始化
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
struct
```
```python
CSDN01
{
```
```python
char
```
```python
name[
```
```python
100
```
```python
];
```
```python
char
```
```python
pass[
```
```python
100
```
```python
];
```
```python
char
```
```python
email[
```
```python
100
```
```python
];
} csdnData[
```
```python
10
```
```python
]
= {
    {
```
```python
"zdg"
```
```python
,
```
```python
"12344321"
```
```python
,
```
```python
"zdg@csdn.net"
```
```python
},
    {
```
```python
"LaoZheng"
```
```python
,
```
```python
"670203313747"
```
```python
,
```
```python
"chengming_zheng@163.com"
```
```python
},
    {
```
```python
"fstao"
```
```python
,
```
```python
"730413"
```
```python
,
```
```python
"fstao@tom.cn"
```
```python
}
}, *pCsdnStruct;
```
```python
//06.关于数组的类型以及指向数组的指针总结:
```
```python
//  1.所有数组(无论数组维度是多少),该数组的类型都是去掉最高维度数
```
```python
//  2.所有指向数组(无论数组维度是多少)类型的指针,都是将最高维度变为
```
```python
//      数组指针类型(*pArr)
```
```python
//07.成员选择:
```
```python
//  指针:箭头号
```
```python
//  对象:点儿号
```
```python
//注:严格注意运算符优先级特性
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    pCsdnStruct = (
```
```python
struct
```
```python
CSDN01[]) {
        {
```
```python
"zdg"
```
```python
,
```
```python
"12344321"
```
```python
,
```
```python
"zdg@csdn.net"
```
```python
},
        {
```
```python
"LaoZheng"
```
```python
,
```
```python
"670203313747"
```
```python
,
```
```python
"chengming_zheng@163.com"
```
```python
},
        {
```
```python
"fstao"
```
```python
,
```
```python
"730413"
```
```python
,
```
```python
"fstao@tom.com"
```
```python
}
    };
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
sizeof
```
```python
(csdnData) /
```
```python
sizeof
```
```python
(*(csdnData +
```
```python
0
```
```python
)); ++i)
    {
```
```python
//a.b       (&a)->b     (*p).b;
```
```python
//char * p = strstr(*(*(csdnData + i)).email, "chengming_zheng@163.com");
```
```python
//char * p = strstr((&csdnData[i])->email, "chengming_zheng@163.com");
```
```python
//char * p = strstr((*(pCsdnStruct + i)).email, "chengming_zheng@163.com");
```
```python
//char * p = strstr((pCsdnStruct + i)->email, "chengming_zheng@163.com");
```
```python
char
```
```python
* p =
```
```python
strstr
```
```python
((*(pCsdnStruct + i)).email,
```
```python
"chengming_zheng@163.com"
```
```python
);
```
```python
if
```
```python
(p)
        {
```
```python
puts
```
```python
((*(csdnData + i)).pass);
        }
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.结构体动态数组.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <malloc.h>
```
```python
#include <memory.h>
```
```python
struct
```
```python
CSDN01
{
```
```python
int
```
```python
id;
```
```python
int
```
```python
num;
};
```
```python
//01.静态开辟和动态回收:
```
```python
//  1.静态开辟:
```
```python
//      (1).内存尺寸编译指定
```
```python
//      (2).未使用内存分配函数
```
```python
//      (3).使用的是常量决定尺寸
```
```python
//      (4).只能使用数组类型作为类型转换(静态类型转换)
```
```python
//      (5).不可进行手动回收
```
```python
//  2.动态开辟:
```
```python
//      (1).内存尺寸运行决定
```
```python
//      (2).使用了内存分配函数
```
```python
//      (3).可以使用变量决定尺寸
```
```python
//      (4).只能使用指针类型作为类型转换(动态类型转换)
```
```python
//      (5).可以进行手动回收
```
```python
//02.内存清零函数:
```
```python
//  格式:memset(首地址, 数据, 字节数);
```
```python
//  注意:可以指定任意内存首地址,尤其注意所需参数的特点
```
```python
//      是地址层面的意义,不具备指针层面的意义
```
```python
//03.数组数据的两种访问方式:
```
```python
//  静态访问:中括号
```
```python
//  动态访问:点儿号
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &num);
```
```python
struct
```
```python
CSDN01 * pStruct01 = (
```
```python
struct
```
```python
CSDN01 *)alloca(num *
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
CSDN01));
```
```python
//栈内存
```
```python
struct
```
```python
CSDN01 * pStruct02 = (
```
```python
struct
```
```python
CSDN01 *)
```
```python
malloc
```
```python
(num *
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
CSDN01));
```
```python
//堆内存
```
```python
//内存清零函数:memset();
```
```python
memset
```
```python
(pStruct01,
```
```python
0
```
```python
,
```
```python
sizeof
```
```python
(num *
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
CSDN01)));
```
```python
memset
```
```python
(pStruct02,
```
```python
0
```
```python
,
```
```python
sizeof
```
```python
(num *
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
CSDN01)));
```
```python
//遍历动态数组[动态数组可以像静态数组那样的引用方式]
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < num; ++i)
    {
```
```python
//快速初始化:memset();手动初始化:赋值操作方式
```
```python
printf
```
```python
(
```
```python
"%d, %d\t%d, %d\n"
```
```python
, (*(pStruct01 + i)).id = i, (*(pStruct01 + i)).num = i, (*(pStruct02 + i)).id = i, (*(pStruct02 + i)).num = i);
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
//投票次数
```
```python
int
```
```python
id =
```
```python
0
```
```python
;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &id);
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j < num; ++j)
        {
```
```python
//具体投票
```
```python
if
```
```python
((*(pStruct01 + i)).id == id)
            {
                ++(*(pStruct01 + i)).num;
                ++(*(pStruct02 + i)).num;
```
```python
break
```
```python
;
            }
        }
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < num; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d, %d\t%d, %d \n"
```
```python
, (*(pStruct01 + i)).id, (*(pStruct01 + i)).num, (*(pStruct02 + i)).id, (*(pStruct02 + i)).num);
    }
```
```python
free
```
```python
(pStruct02);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
struct
```
```python
MyStruct01
{
```
```python
int
```
```python
id;
```
```python
char
```
```python
str[
```
```python
10
```
```python
];
};
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &num);
```
```python
struct
```
```python
CSDN01 * pCSDNStruct01 = (
```
```python
struct
```
```python
CSDN01 *)
```
```python
malloc
```
```python
(num *
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
CSDN01));
```
```python
struct
```
```python
CSDN01 * pCSDNStruct02 = (
```
```python
struct
```
```python
CSDN01[]) {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
};
```
```python
//静态分配
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (*(pCSDNStruct02 +
```
```python
1
```
```python
)).id);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (pCSDNStruct02 +
```
```python
1
```
```python
)->id);
```
```python
struct
```
```python
CSDN01 csdnx = {
```
```python
10
```
```python
,
```
```python
20
```
```python
};
```
```python
struct
```
```python
CSDN01 * pCSDNX = &csdnx;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (*(pCSDNX)).id);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, pCSDNX->id);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
CSDN01 csdnData[
```
```python
100
```
```python
];
```
```python
struct
```
```python
CSDN01 * pCSDNStruct = csdnData;
```
```python
struct
```
```python
CSDN01 csdnDataX[
```
```python
10
```
```python
][
```
```python
10
```
```python
];
```
```python
struct
```
```python
CSDN01(*pArr01)[
```
```python
10
```
```python
] = csdnDataX;
```
```python
struct
```
```python
CSDN01(*pArr02)[
```
```python
10
```
```python
] = (
```
```python
struct
```
```python
CSDN01(*)[
```
```python
10
```
```python
])
```
```python
malloc
```
```python
(
```
```python
50
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
CSDN01));
    pArr02[
```
```python
3
```
```python
][
```
```python
4
```
```python
];
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):结构体大小.c
内容概要:**结构体大小**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.关于结构体内存字节对齐的相关知识:
```
```python
//  1.明确基本数据类型:
```
```python
//      char short int long float double long long long double
```
```python
//      (通常情况之下:double和long long尺寸一样)
```
```python
//  2.结构体的内存尺寸一定是大于或者等于所有成员标准尺寸之和
```
```python
//  3.结构体内存字节准确判定方式:
```
```python
//      (1).确定基本对齐尺寸:
```
```python
//          编译器指定尺寸+基本数据类型最宽尺寸(两者取最短)
```
```python
//      (2).准确判定内存字节尺寸:
```
```python
//          方式一:
```
```python
//              结构体最终尺寸必须可以整除对齐尺寸
```
```python
//              结构体成员的首地址-结构体的首地址=偏移量(该偏移量必须是当前成员尺寸的整数倍)
```
```python
//              结构体对齐单元的末尾不足部分,会被默认填充
```
```python
//          方式二:
```
```python
//              所有结构体在内存当中的存储形式是矩形方式
```
```python
//              矩形的宽度为对齐内存尺寸
```
```python
//              放进矩形的的成员相对位置必须能够整除自身尺寸
```
```python
//  4.结构体如果只是存在单个成员的情况,根本就不存在结构体内存字节对齐问题:
```
```python
//      所以此时的结构体尺寸就是结构体当中的第一个成员的尺寸
```
```python
//  5.结构体内存字节对齐的优点:
```
```python
//      (1).便于快速寻址
```
```python
//      (2).便于节约内存
```
```python
//  6.结构体内存字节优化方式:
```
```python
//      1.首先确定基本数据类型最宽的成员:
```
```python
//          (包含结构体多层嵌套都生效的最宽基本成员)
```
```python
//      2.结构体矩形的形成顺序,务必按照从内到外,从前到
```
```python
//          后的顺序进行确定
```
```python
//      3.并且每个结构体矩形成员必须是独立矩形!
```
```python
//      4.再其次定义基本数据类型最宽的成员
```
```python
//          (按照不同结构体单元进行分类顺序考虑)
```
```python
//      5.再其次考虑各个结构体当中当中的数组数据类型和数据类型最宽的成员关系
```
```python
//          数组尺寸和对齐字节数之间的关系
```
```python
//      6.再逐个按照基本数据类型宽度尺寸递减的方式定义成员
```
```python
//    注意:每个独立的结构体都是按照矩形形式存储的!
```
```python
//      这个矩形的宽度就是所有结构体当中数据类型最宽的那个成员
```
```python
//      (嵌套结构体必须保证每个结构体自身先形成矩形,从内到外进行矩形确定)
```
```python
struct
```
```python
MyStruct01
{
```
```python
//默认顺序
```
```python
char
```
```python
chr1;
```
```python
//8
```
```python
double
```
```python
db2;
```
```python
//8
```
```python
int
```
```python
num3;
```
```python
//8
```
```python
char
```
```python
chr4;
```
```python
double
```
```python
db5;
```
```python
//8
```
```python
};
```
```python
struct
```
```python
MyStruct02
{
```
```python
//节省顺序
```
```python
double
```
```python
db2;
```
```python
//8
```
```python
double
```
```python
db5;
```
```python
//8
```
```python
int
```
```python
num3;
```
```python
//8
```
```python
char
```
```python
chr1;
```
```python
char
```
```python
chr4;
};
```
```python
struct
```
```python
MyStruct03
{
```
```python
//单成员结构体不存在结构体内存字节对齐问题
```
```python
char
```
```python
num1;
```
```python
//double num4;
```
```python
};
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct01 ms01;
```
```python
struct
```
```python
MyStruct02 ms02;
```
```python
printf
```
```python
(
```
```python
"sizeof(ms01) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(ms01));
```
```python
//32-->默认存储
```
```python
printf
```
```python
(
```
```python
"sizeof(ms02) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(ms02));
```
```python
//24-->节省存储
```
```python
printf
```
```python
(
```
```python
"&ms01 = %p \n"
```
```python
, &ms01);
```
```python
printf
```
```python
(
```
```python
"&ms01.chr1 = %p \n"
```
```python
, &ms01.db2);
```
```python
printf
```
```python
(
```
```python
"&ms01.db2 = %p \n"
```
```python
, &ms01.db2);
```
```python
printf
```
```python
(
```
```python
"&ms01.num3 = %p \n"
```
```python
, &ms01.num3);
```
```python
printf
```
```python
(
```
```python
"&ms01.chr4 = %p \n"
```
```python
,    &ms01.chr4);
```
```python
printf
```
```python
(
```
```python
"&ms01.db5 = %p \n"
```
```python
, &ms01.db5);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(03):01.Test.c+02.结构体结构体数组副本机制.c+03.指针与结构体.c
内容概要:**结构体成员与指针**
```python
///01.Test.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.结构体占用字节统计:
```
```python
//  1.确定内存字节对齐数:
```
```python
//      编译器指定+基本数据类型最宽成员(两者取较短那个)
```
```python
//      注:包括嵌套形式情况下的结构体数据类型最宽成员
```
```python
//  2.从外往内,从前往后分析结构体嵌套形式:
```
```python
//      注:任何一个独立的结构体本身一定是按照矩形结构存储的
```
```python
//          结构体嵌套结构体-->类似于宽度相同的矩形嵌套
```
```python
//  3.任何结构体成员的的起始位置减去相对矩形左外边的尺寸
```
```python
//      一定是当前结构体成员字节的整数倍-->如果当前矩形行能够
```
```python
//      存储下当前结构体成员,则存下,如果当前矩形行存储不下,则
```
```python
//      换下一个矩形行,当前矩形行的其余位置空置
```
```python
//02.结构体占用字节优化:
```
```python
//  1.确定内存字节对齐数:
```
```python
//      1.编译器指定+基本数据类型最宽成员(两者取较短那个)
```
```python
//      2.这个内存字节对齐数用于确定每个独立结构体的矩形宽度
```
```python
//      注:包括嵌套形式情况下的结构体基本数据类型最宽成员!
```
```python
//  2.从外往内,从前往后进行嵌套结构体的内存字节对齐优化:
```
```python
//  3.先安置与内存字节对齐数相同的基本数据类型成员
```
```python
//  4.再考虑结构体类型的成员安置情况
```
```python
//  5.再考虑数组类型的成员安置情况,这个需要与内存字节对齐数
```
```python
//      进行综合考虑
```
```python
//  6.在依次考虑基本数据类型当中从大到小的基本你数据类型安置
```
```python
struct
```
```python
{
```
```python
char
```
```python
chr1;
```
```python
//8--1--7
```
```python
double
```
```python
db2;
```
```python
//8--8--0
```
```python
int
```
```python
num3;
```
```python
//8--4--0
```
```python
char
```
```python
chr4;
```
```python
//0--1--0
```
```python
short
```
```python
num5;
```
```python
//0--2--1
```
```python
char
```
```python
chr6;
```
```python
//8--1--7
```
```python
long
```
```python
long
```
```python
num7;
```
```python
//8--8--0
```
```python
} anonymity01;
```
```python
//40=25+15
```
```python
struct
```
```python
{
```
```python
long
```
```python
long
```
```python
num7;
```
```python
//8-8-0
```
```python
double
```
```python
db2;
```
```python
//8-8-0
```
```python
int
```
```python
num3;
```
```python
//8-4-0
```
```python
short
```
```python
num5;
```
```python
//0--2--0
```
```python
char
```
```python
chr1;
```
```python
//0--1--0
```
```python
char
```
```python
chr4;
```
```python
//0--1--0
```
```python
char
```
```python
chr6;
```
```python
//8--1-7
```
```python
} anonymity02;
```
```python
//32=25+7
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"sizeof(anonymity01) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(anonymity01));
```
```python
printf
```
```python
(
```
```python
"sizeof(anonymity02) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(anonymity02));
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.结构体结构体数组副本机制.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
struct
```
```python
MyStruct01
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
];
```
```python
int
```
```python
len;
};
```
```python
void
```
```python
change(
```
```python
struct
```
```python
MyStruct01 ms01)
{
```
```python
printf
```
```python
(
```
```python
"change:ms01.arr = %p \n"
```
```python
, ms01.arr);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < ms01.len; ++i)
    {
        *((ms01.arr) + i) = i *
```
```python
3
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, *((ms01.arr) + i));
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
//01.符合类型都可以使用静态初始化方式:
```
```python
//  静态初始化方式-->大括号{}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct01 ms01 = { {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
},
```
```python
10
```
```python
};
    change(ms01);
```
```python
printf
```
```python
(
```
```python
"main:ms01.arr = %p \n"
```
```python
, ms01.arr);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < ms01.len; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, *(ms01.arr + i));
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.函数副本机制:
```
```python
//  1.函数的形参和返回值都具备副本机制
```
```python
//  2.只是该副本机制针对于数组类型进行了优化:
```
```python
//      函数副本机制唯一对数组特殊,采用的是退化指针的解决方案
```
```python
//03.关于各种取地址符运算的结果:
```
```python
//  1.对一维数组当中所存储的元素:
```
```python
//      获取的是列指针
```
```python
//  2.对一维数组整体(数组名称)
```
```python
//      获取的行指针
```
```python
//  3.对任意数组名称执行取地址运算符:
```
```python
//      获取的都是指向数组的指针(数组指针)
```
```python
//04.如何确定数组的类型以及指向数组的指针?
```
```python
//  1.所有数组的类型:
```
```python
//      去掉数组名+去掉最高维度系数
```
```python
//  2.指向数组的指针:
```
```python
//      替换数组名为(*pArr),pArr就是指向数组的指针
```
```python
//  3.如何确定数组名类型:
```
```python
//      去掉数组名+替换最高维度(包含中括号以及维度数)为(*),此时就是数组名的变量类型
```
```python
//注:严格区分数组名的变量类型和常量类型
```
```python
struct
```
```python
MyStruct01 testReturn()
{
```
```python
struct
```
```python
MyStruct01 ms01 = { {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
},
```
```python
10
```
```python
};
```
```python
printf
```
```python
(
```
```python
"testReturn:ms01.arr = %p;ms01.arr + 1 = %p \n"
```
```python
, ms01.arr, ms01.arr +
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"testReturn:&ms01.arr = %p;&ms01.arr + 1 = %p \n"
```
```python
, &ms01.arr, &ms01.arr +
```
```python
1
```
```python
);
```
```python
return
```
```python
ms01;
}
```
```python
//05.函数的返回值不能是数组类型:
```
```python
//  但可以是指向数组的指针类型
```
```python
typedef
```
```python
int
```
```python
* intP;
```
```python
//int类型的指针
```
```python
typedef
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
];
```
```python
//int类型的数组
```
```python
//int[] returnUnit()//数组类型-->错误
```
```python
//intArr returnUnit()//数组类型-->错误
```
```python
intP returnUnit(){}
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct01 ms01 = testReturn();
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < ms01.len; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, *(ms01.arr + i));
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
struct
```
```python
info
{
```
```python
char
```
```python
name[
```
```python
10
```
```python
];
```
```python
int
```
```python
age;
};
```
```python
struct
```
```python
info infos[
```
```python
3
```
```python
];
```
```python
struct
```
```python
info infos[];
```
```python
struct
```
```python
info * pInfo;
```
```python
void
```
```python
changeInfo(
```
```python
struct
```
```python
info * pInfo)
{
```
```python
//数组名作为函数形参将会退化和数组名相同的变量指针类型
```
```python
//pInfo = pInfo + 3;
```
```python
(*(pInfo +
```
```python
1
```
```python
)).age =
```
```python
88
```
```python
;
}
```
```python
//06.通过结构体来描述结构体动态数组:
```
```python
//  结构体可以用于描述任何数据类型
```
```python
struct
```
```python
data
{
```
```python
struct
```
```python
info * pArr;
```
```python
//数组首元素变量指针
```
```python
int
```
```python
len;
};
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
info infos[
```
```python
3
```
```python
] = { {
```
```python
"fang"
```
```python
,
```
```python
18
```
```python
}, {
```
```python
"hua"
```
```python
,
```
```python
19
```
```python
}, {
```
```python
"lin"
```
```python
,
```
```python
19
```
```python
} };
```
```python
//infos = infos;
```
```python
changeInfo(infos);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%s, %d \n"
```
```python
, (*(infos + i)).name, (*(infos + i)).age);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///03.指针与结构体.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <malloc.h>
```
```python
struct
```
```python
Data01
{
```
```python
int
```
```python
num;
};
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
//int intArr[3][4];//intArr:数组名的常量指针形式
```
```python
int
```
```python
(*intArr)[
```
```python
4
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//intArr:数组名的变量指针形式
```
```python
//int * [4];//指针数组形式
```
```python
printf
```
```python
(
```
```python
"intArr:%p, intArr+1:%p \n"
```
```python
, intArr, intArr +
```
```python
1
```
```python
);
```
```python
struct
```
```python
Data01(*pArr)[
```
```python
10
```
```python
] =
```
```python
malloc
```
```python
(
```
```python
90
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
Data01));
```
```python
//动态分配一个标准的二维结构体数组
```
```python
int
```
```python
k =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
9
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
10
```
```python
; ++j)
        {
```
```python
//printf("%3d", pArr[i][j].num = ++k);
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, (*(*(pArr + i) + j)).num = ++k);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main06(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
Data01 **pp;
```
```python
//结构体锯齿数组
```
```python
pp = (
```
```python
struct
```
```python
Data01 **)
```
```python
malloc
```
```python
(
```
```python
10
```
```python
*
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
Data01 *));
```
```python
int
```
```python
k =
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        *(pp + i) = (
```
```python
struct
```
```python
Data01 *)
```
```python
malloc
```
```python
((i) *
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
Data01));
```
```python
for
```
```python
(
```
```python
struct
```
```python
Data01 * pStruct = *(pp + i); pStruct <= *(pp + i) + i; ++pStruct)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, (*pStruct).num = k++);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main07(
```
```python
void
```
```python
)
{
```
```python
//struct Data01 * pStruct = (struct Data01 *)alloca(10 * sizeof(struct Data01));//栈内存-->动态分配
```
```python
struct
```
```python
Data01 * pStruct = (
```
```python
struct
```
```python
Data01 *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
Data01) *
```
```python
10
```
```python
);
```
```python
//堆内存-->动态分配
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
struct
```
```python
Data01 * pTemp = pStruct; pTemp < pStruct +
```
```python
10
```
```python
; ++pTemp)
    {
```
```python
printf
```
```python
(
```
```python
"%p, %d \n"
```
```python
, pTemp, (*pTemp).num = i++);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(04):位域.c
内容概要:**位域**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.位域:通过限定数据的存储位数,从而实现节省内存占用
```
```python
//      位域-->指定存储位数-->节省内存|显二进制位
```
```python
//02.在操作二进制位运算的过程当中,一定要注意到符号位的特点
```
```python
//  1.位域结构体有其自身的数据存储方式和解析方式
```
```python
//  2.可以进行数据的分批次存储
```
```python
struct
```
```python
MyStruct01
{
```
```python
unsigned
```
```python
int
```
```python
a :
```
```python
5
```
```python
;
```
```python
//00~31[2^5=32]
```
```python
unsigned
```
```python
int
```
```python
b :
```
```python
5
```
```python
;
```
```python
//00~12[2^4=16]
```
```python
unsigned
```
```python
int
```
```python
c :
```
```python
16
```
```python
;
```
```python
//0000[2^16]
```
```python
};
```
```python
//4
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"sizeof(struct MyStruct01) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
MyStruct01));
```
```python
struct
```
```python
MyStruct01 ms1, *pStruct;
    pStruct = &ms1;
    ms1.a =
```
```python
8
```
```python
;
```
```python
//位域-->压缩内存-->操作二进制位-->效率高
```
```python
ms1.b =
```
```python
11
```
```python
;
    ms1.c =
```
```python
1999
```
```python
;
```
```python
//存储数据都一样,解析方式不同
```
```python
printf
```
```python
(
```
```python
"%d ,%d, %d \n"
```
```python
, ms1.a, ms1.b, ms1.c);
```
```python
printf
```
```python
(
```
```python
"%d, %d ,%d \n"
```
```python
, pStruct->a, pStruct->b, pStruct->c);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
struct
```
```python
Data01
{
```
```python
unsigned
```
```python
short
```
```python
num1 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
short
```
```python
num2 :
```
```python
2
```
```python
;
};
```
```python
//2
```
```python
//03.位域结构体在进行数据的分批次存储的时候:
```
```python
//  1.注意有无符号的影响
```
```python
//  2.注意数据越界的情况:
```
```python
//      如果出现越界,就只会解析界限以内的数据
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"sizeof(struct Data01) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
Data01));
```
```python
struct
```
```python
Data01 data01;
    data01.num1 =
```
```python
2
```
```python
;
```
```python
//数据越界2-->二进制-->10-->显示0
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, data01.num1);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.只有位域才有可能出现按照数据类型进行合并的情况
```
```python
//  同类型+不越界=>内存压缩
```
```python
struct
```
```python
Data02
{
```
```python
unsigned
```
```python
int
```
```python
num1 :
```
```python
32
```
```python
;
```
```python
unsigned
```
```python
short
```
```python
num2 :
```
```python
1
```
```python
;
};
```
```python
//8
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
Data02));
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
isit()
{
```
```python
unsigned
```
```python
short
```
```python
num =
```
```python
1
```
```python
;
```
```python
//0000 000 0000 0001
```
```python
return
```
```python
(
```
```python
1
```
```python
== *(
```
```python
char
```
```python
*)&num);
```
```python
//接触原则
```
```python
}
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
short
```
```python
num =
```
```python
1
```
```python
;
```
```python
printf
```
```python
(
```
```python
"&num = %p \n"
```
```python
, &num);
```
```python
//低位在低字节,高位在高字节
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, isit());
```
```python
//0000 0000 0000 0001
```
```python
//逆序存储:1000 0000 0000 0000
```
```python
//顺序显示:0000 0000 0000 0001
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):显示整数.c
内容概要:**位域编程实战**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.关于二进制位与高低直接之间的关系:
```
```python
//  1.现代手机,电脑:
```
```python
//      低位在低字节:
```
```python
//  2.Unix服务器系列:
```
```python
//      低位在高字节:
```
```python
//注:关于两种不同存储方式的优缺点:
```
```python
//      低位在低字节:
```
```python
//          节省内存
```
```python
//      低位在高字节:
```
```python
//          快速检索
```
```python
//02.调试显示状态:
```
```python
//  低位在低字节的情况内存结构分析:
```
```python
//      1000 0000 0000 0000 0000 0000 0000 0000//逆序存储
```
```python
//      0000 0000 0000 0000 0000 0000 0000 0001//顺序显示
```
```python
//  解析特点:
```
```python
//      1000 0000:8个二进制位存储于低字节位置-->节省内存
```
```python
//注:逆序存储-->实现低位在低字节-->顺序显示(解析方式)
```
```python
//03.结构体与位域:
```
```python
//  1.位域所涉及的知识:
```
```python
//      结构体+位运算
```
```python
//  2.按照单字节解析二进制位的结构体:
```
```python
//      特殊结构体:位域
```
```python
//04.位域特点分析:
```
```python
//  1.位域的用处:
```
```python
//      (1).内存压缩
```
```python
//      (2).解析数据二进制位
```
```python
//  2.内存字节对齐特点:
```
```python
//      (1).基于标准结构体法则
```
```python
//      (2).基于内存合并法则
```
```python
//          相同类型,如果位数相加小于该类型字节数,则压缩存储
```
```python
//          相同类型,如果位数相加大于该类型字节数,则填位移字
```
```python
//      (3).特殊位域处理:
```
```python
//          如果位域当中的位域为空,则空置下一个此类型字节数
```
```python
//          如果位域当中的域名没有,则空置下一个此类型字节数
```
```python
//  3.快速识别位域:
```
```python
//      结构体+冒号
```
```python
//  4.位域组成特点分析:
```
```python
//      BitField:位域结构体名(整体)
```
```python
//      unsigned char:位域结构体成员类型
```
```python
//      chr:域名
```
```python
//      : :位域结构体标识
```
```python
//      1:位宽
```
```python
//05.采用位于结构体显示一个数据的二进制存储形式注意事项:
```
```python
//  1.采用指向位域结构体的指针来存储变量的地址!
```
```python
//  2.该位于结构体的指针是按照单字节进行内存解析的
```
```python
//      从低字节开始逐个进行解析
```
```python
//  3.逆序存储-->顺序显示:
```
```python
//      (1).逆序指针:先打印高字节
```
```python
//      (2).逆序域名:反转存储实质
```
```python
struct
```
```python
BitField
{
```
```python
unsigned
```
```python
char
```
```python
chr1 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
chr2 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
chr3 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
chr4 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
chr5 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
chr6 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
chr7 :
```
```python
1
```
```python
;
```
```python
unsigned
```
```python
char
```
```python
chr8 :
```
```python
1
```
```python
;
};
```
```python
//一个字节
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"sizeof(struct BitField) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
BitField));
```
```python
int
```
```python
data =
```
```python
1
```
```python
;
```
```python
//原始整数
```
```python
int
```
```python
bitLen =
```
```python
4
```
```python
;
```
```python
struct
```
```python
BitField * pBitField = &data;
```
```python
//将一个整数指针直接赋值给位域结构体变量
```
```python
//pBitField存储的是位域结构体数组方式存储的
```
```python
printf
```
```python
(
```
```python
"&data = %p \n"
```
```python
, &data);
```
```python
while
```
```python
(bitLen--)
```
```python
//存在-->获位
```
```python
{
```
```python
//每次解析一个字节-->从高字节开始进行解析-->一直解析到低字节
```
```python
printf
```
```python
(
```
```python
"%d%d%d%d %d%d%d%d \n"
```
```python
,
            (pBitField + bitLen)->chr8,
            (pBitField + bitLen)->chr7,
            (pBitField + bitLen)->chr6,
            (pBitField + bitLen)->chr5,
            (pBitField + bitLen)->chr4,
            (pBitField + bitLen)->chr3,
            (pBitField + bitLen)->chr2,
            (pBitField + bitLen)->chr1);
    }
```
```python
//1000 0000
```
```python
//0000 0000
```
```python
//0000 0000
```
```python
//0000 0000
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):Union.c
内容概要:**Union**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.结构体和共用体的相同点:
```
```python
//  1.既不允许空结构体的存在,也不允许空共用体的出现:
```
```python
//      也就是说结构体或共用体至少必须包含一个成员
```
```python
//  2.使用结构体类型或者共用体类型的时候都必须包含
```
```python
//      struct关键字
```
```python
union
```
```python
MyUnion01
{
```
```python
int
```
```python
num;
```
```python
double
```
```python
db;
};
```
```python
//02.共用体内容总结:
```
```python
//  1.共用体的内存尺寸等于最长的那个成员所占据的内存尺寸
```
```python
//      最长成员(包含复合类型)
```
```python
//  2.共用体的所有成员共享同一数据实质(内存形式一致)
```
```python
//      但是由于共用体的不同成员类型不一致,因此解析结果不一致
```
```python
//注:共用体的各个成员存储数据存储实质一样,但是解析方式却不一样
```
```python
//  区分存储实质和解析方式的不同所造成的差异
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//printf("sizeof(union MyUnion01) = %d \n", sizeof(union MyUnion01));//结构体内存尺寸等于最宽的那个成员
```
```python
union
```
```python
MyUnion01 mu01;
    mu01.num =
```
```python
3
```
```python
;
```
```python
//mu01.db = 111111111123.98776;
```
```python
printf
```
```python
(
```
```python
"%8d, %lf \n"
```
```python
, mu01.num, mu01.db);
```
```python
//存储实质一致,但是解析类型不一致
```
```python
mu01.num =
```
```python
0
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%8d, %lf \n"
```
```python
, mu01.num, mu01.db);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(07):Union.c
内容概要:**Union定义方式**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
union
```
```python
MyUnion01
{
```
```python
//标准形式
```
```python
int
```
```python
num;
```
```python
float
```
```python
fl;
} mu, arr[
```
```python
3
```
```python
], *p;
```
```python
//01.共用体定义方式:
```
```python
//  1.声明共用体类型的同时定义共用体变量
```
```python
//  2.先声明共用体类型,再定义共用体变量
```
```python
//  3.标准共用体和匿名共用体
```
```python
union
```
```python
{
```
```python
//匿名形式
```
```python
int
```
```python
num;
```
```python
float
```
```python
fl;
} mu1, arr1[
```
```python
3
```
```python
], *p1;
```
```python
//02.共用体的特点:
```
```python
//  1.所有成员共用同一个数据
```
```python
//  2.所有成员公用同一个地址
```
```python
//  3.只是由于成员的不同类型,因此导致对
```
```python
//      同一内存地址的同一个数据解析结果不同
```
```python
//注:所有变量使用同一地址,所有变量使用同一数据
```
```python
//  不同的成员只是决定不同的数据解析方式
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//printf("sizeof(mu1) = %d \n", sizeof(mu1));
```
```python
union
```
```python
MyUnion01 mu2, arr2[
```
```python
3
```
```python
], *p2;
    mu2.num =
```
```python
100
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d, %f \n"
```
```python
, mu2.num, mu2.fl);
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, &(mu2.num), &(mu2.fl));
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(08):对齐.c
内容概要:**内存对齐**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
struct
```
```python
MyStruct01
{
```
```python
char
```
```python
str[
```
```python
23
```
```python
];
```
```python
short
```
```python
num;
};
```
```python
//01.结构体嵌套的情况之下:
```
```python
//  内存字节对齐数就是所有基本类型成员当中
```
```python
//  占用内存字节数最宽的那个成员
```
```python
struct
```
```python
MyStruct02
{
```
```python
struct
```
```python
MyStruct01 ms01;
```
```python
char
```
```python
chr;
};
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//printf("sizeof(struct MyStruct01) = %d \n", sizeof(struct MyStruct01));
```
```python
printf
```
```python
(
```
```python
"sizeof(struct MyStruct02) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
MyStruct02));
    system(
```
```python
"pause"
```
```python
);
}
```
```python
union
```
```python
MyUnion01
{
```
```python
char
```
```python
str[
```
```python
13
```
```python
];
```
```python
int
```
```python
db;
};
```
```python
//02.共用体的内存尺寸特点:
```
```python
//  1.必须遵守内存字节对齐方式
```
```python
//  2.为占用内存尺寸最大的那个成员
```
```python
//      数组特点+对齐尺寸
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"sizeof(sruct MyUnion01) = %d \n"
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
union
```
```python
MyUnion01));
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(09):01.同与不同.c+02.TypeDef.c
内容概要:**结构体与共用体的不同**
```python
///01.同与不同.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
struct
```
```python
MyStruct01
{
```
```python
int
```
```python
num;
```
```python
double
```
```python
db;
};
```
```python
union
```
```python
MyUnion01
{
```
```python
int
```
```python
num;
```
```python
double
```
```python
db;
};
```
```python
//01.结构体和共用体各个成员的特点:
```
```python
//  结构体的各个成员内存地址独立,数据之间没有关系
```
```python
//  共用体的各个成员内存地址相同,数据也是完全相同
```
```python
//注:共用体的各个成员由于其数据类型的不用,因此对
```
```python
//  同样一块儿内存数据的解析结果就不一样
```
```python
//  (有无符号+补码解析+阶码解析)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStruct01 ms01, * ps01;
```
```python
union
```
```python
MyUnion01 mu01, *pu01;
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, &ms01.num, &ms01.db);
```
```python
//结构体各个成员内存地址不同
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, &mu01.num, &mu01.db);
```
```python
//共用体各个成员内存地址相同
```
```python
ps01 = &ms01;
    pu01 = &mu01;
    ms01.num;
    (&ms01)->num;
    (*&ms01).num;
    ps01->num;
    ps01->num;
    (*ps01).num;
    mu01.num;
    (&mu01)->num;
    (*(&mu01)).num;
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.TypeDef.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.typedef的特点:
```
```python
//  所有连续定义的变量名称都会成为数据类型的别名
```
```python
typedef
```
```python
struct
```
```python
MyStruct01
{
```
```python
int
```
```python
num;
```
```python
double
```
```python
db;
} ms01, ms02;
```
```python
typedef
```
```python
struct
```
```python
MyStruct01 MS;
```
```python
typedef
```
```python
union
```
```python
MyUnion01
{
```
```python
int
```
```python
num;
```
```python
double
```
```python
db;
} mu01, mu02;
```
```python
typedef
```
```python
union
```
```python
MyUnion01 MU;
```
```python
typedef
```
```python
unsigned
```
```python
int
```
```python
num1, num2, num3, num4;
```
```python
//num1,num2,num3,num4都是数据类型的别名
```
```python
//02.共用体赋值特点:
```
```python
//  1.共用体只能对其中一个成员进行初始化赋值操作
```
```python
//  2.共用体在经过多次赋值操作之后,其最终结果是最后一次赋值结果
```
```python
//03.结构体和共用体都可以采用指定成员初始化的方式:
```
```python
//  必须是静态初始化特点才可以采取指定成员初始化的方式
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    MS my01 = { .num =
```
```python
10
```
```python
,
```
```python
10.9
```
```python
};
    ms01 my02 = {
```
```python
11
```
```python
,
```
```python
11.9
```
```python
};
    MU myu01 = {
```
```python
10
```
```python
};
    mu01 myu02 = { .db =
```
```python
11.9
```
```python
};
    ms02 my3 = {
```
```python
12
```
```python
,
```
```python
129
```
```python
};
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(10):PC.c
内容概要:**共用体**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
struct
```
```python
MyStructX
{
```
```python
double
```
```python
db;
};
```
```python
union
```
```python
PC
{
```
```python
struct
```
```python
MyStructX;
```
```python
int
```
```python
num;
```
```python
char
```
```python
price[
```
```python
10
```
```python
];
```
```python
char
```
```python
* p;
} pc01 = { .num =
```
```python
10000
```
```python
};
```
```python
struct
```
```python
MyStruct
{
```
```python
union
```
```python
PC pc1;
};
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
union
```
```python
PC pc02;
    pc02.p = (
```
```python
char
```
```python
*)
```
```python
malloc
```
```python
(
```
```python
100
```
```python
);
```
```python
strcpy
```
```python
(pc02.p,
```
```python
"海华装的电脑,价格未知!"
```
```python
);
```
```python
union
```
```python
PC pc03 = pc02;
    pc03.p =
```
```python
malloc
```
```python
(
```
```python
100
```
```python
);
```
```python
strcpy
```
```python
(pc03.p, pc02.p);
```
```python
printf
```
```python
(
```
```python
"%s, %s \n"
```
```python
, pc02.p, pc03.p);
```
```python
free
```
```python
(pc02.p);
```
```python
printf
```
```python
(
```
```python
"%s, %s \n"
```
```python
, pc02.p, pc03.p);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.针对于结构体和共用体而言:
```
```python
//  1.都存在着浅拷贝和深拷贝问题
```
```python
//  2.变量名称可以和结构体的名称相同
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
union
```
```python
PC pc = {
```
```python
10000
```
```python
};
```
```python
union
```
```python
PC arr[
```
```python
3
```
```python
] = { {
```
```python
10000
```
```python
},{
```
```python
10000
```
```python
}, {
```
```python
10000
```
```python
} };
```
```python
union
```
```python
PC * p = (
```
```python
union
```
```python
PC []){ {
```
```python
10000
```
```python
},{
```
```python
10000
```
```python
},{
```
```python
10000
```
```python
} };
```
```python
//++pc;
```
```python
//arr = arr;
```
```python
pc.num++;
    ++pc.num;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, pc.num);

    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.采用共用体可以采用多种方式描述同一个事物:
```
```python
//  注:共用体当中所存储的成员一旦改变,就只能访问最后一个数据
```
```python
//      同一个地址,同一个数据(指针变量和普通变量存储的内容一致)
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
union
```
```python
PC pc;
    pc.p = (
```
```python
char
```
```python
*)
```
```python
malloc
```
```python
(
```
```python
100
```
```python
);
```
```python
strcpy
```
```python
(pc.p,
```
```python
"海华装的电脑,价格位置!"
```
```python
);
    pc.num =
```
```python
4000
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
, pc.p);
```
```python
free
```
```python
(pc.p);
```
```python
//严重错误
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(11):Data.c
内容概要:**数据管理编程**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
//01.如何"多行表示"一个"整体存储"的字符串?
```
```python
//  采用反斜杠"\"操作符作为多行表示字符串的结尾链接状态
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] =
```
```python
"521276402----hanlei@19940403 \
    286738260----WEIPEI559720 \
    501223616----feng66532008 \
    851400824----shuidongwo520 \
    1340382355----huang.512yang \
    1061817115----fz62wangyong1983 \
    347232860----20080811 \
    1028181591----7404850554 \
    120539543----0.0123456789 \
    754229005----460228214 \
    819781633----zmt1993826 \
    1319148052----YNU1500621032 \
    904972448----zhouxiaowen.520 \
    750134133----1292857988 \
    438905700----320675 \
    379644978----7758521tao \
    346083956----devl1017 \
    562193724----5361a749 \
    286124126----xuqiang1988 \
    4008167599----234567 \
    937350113----MAWENcxn1020 \
    873589635----qqco1341HUA \
    853249795----5385939d "
```
```python
;
```
```python
//02.创建类型为struct info的结构体类型
```
```python
//  1.用于描述单个用户的信息实体
```
```python
//  2.单个结构体对应于一个用户的信息
```
```python
struct
```
```python
info
{
```
```python
long
```
```python
long
```
```python
QQ;
```
```python
char
```
```python
pass[
```
```python
16
```
```python
];
};
```
```python
//03.采用结构体描述动态结构体数组:
```
```python
//  用户结构体动态数组用于描述多个用户信息实体
```
```python
//注:基于C语言的所有数据结构都依赖于结构体
```
```python
struct
```
```python
infos
{
```
```python
struct
```
```python
info * pInfo;
```
```python
int
```
```python
len;
} myInfos;
```
```python
int
```
```python
getRowNum(
```
```python
char
```
```python
* pStr)
{
```
```python
//根据每行字符串所共有的特征进行数据行的统计
```
```python
int
```
```python
rows =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
char
```
```python
* pTemp =
```
```python
strstr
```
```python
(pStr,
```
```python
"----"
```
```python
); NULL != pTemp; pTemp =
```
```python
strstr
```
```python
(pTemp +
```
```python
4
```
```python
,
```
```python
"----"
```
```python
))
    {
```
```python
//两面夹击统计法
```
```python
++rows;
    }
```
```python
return
```
```python
rows;
}
```
```python
void
```
```python
initMem()
{
```
```python
//采用结构体模拟动态结构体数组
```
```python
int
```
```python
len = getRowNum(str);
    myInfos.pInfo = (
```
```python
struct
```
```python
info *)
```
```python
malloc
```
```python
(len *
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
info));
    myInfos.len = len;
}
```
```python
void
```
```python
initData(
```
```python
char
```
```python
* pStr)
{
```
```python
int
```
```python
len =
```
```python
strlen
```
```python
(pStr);
```
```python
for
```
```python
(
```
```python
char
```
```python
* p = pStr; p < pStr + len; ++p)
    {
```
```python
//针对于原始数据的预处理操作
```
```python
if
```
```python
(
```
```python
' '
```
```python
== *p)
        {
            *p =
```
```python
'\0'
```
```python
;
        }
    }
```
```python
for
```
```python
(
```
```python
char
```
```python
* p = pStr, chr =
```
```python
0
```
```python
; p < pStr + len; ++p)
    {
```
```python
//根据字符串数据进行结构体数据拼装
```
```python
//printf("%p, %d \n", p, chr);
```
```python
char
```
```python
* pTmp = (
```
```python
char
```
```python
*)
```
```python
calloc
```
```python
(
```
```python
strlen
```
```python
(p) +
```
```python
1
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
char
```
```python
));
```
```python
strcpy
```
```python
(pTmp, p);
```
```python
//"521276402\0---hanlei@19940403"//pTmp-->pWei+4
```
```python
char
```
```python
* pWei =
```
```python
strstr
```
```python
(pTmp,
```
```python
"----"
```
```python
);
        *pWei =
```
```python
'\0'
```
```python
;
```
```python
sscanf
```
```python
(pTmp,
```
```python
"%lld"
```
```python
, &(*(myInfos.pInfo + chr)).QQ);
```
```python
sprintf
```
```python
((*(myInfos.pInfo + chr)).pass,
```
```python
"%s"
```
```python
, pWei +
```
```python
strlen
```
```python
(
```
```python
"----"
```
```python
));
        p +=
```
```python
strlen
```
```python
(p) +
```
```python
1
```
```python
;
    }
}
```
```python
void
```
```python
showAllData()
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < myInfos.len; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"QQ = %lld, pass = %s \n"
```
```python
, (*(myInfos.pInfo + i)).QQ, (*(myInfos.pInfo + i)).pass);
    }
}
```
```python
void
```
```python
showDataStatus()
{
```
```python
printf
```
```python
(
```
```python
"还有%d条数据! \n"
```
```python
, myInfos.len);
}
```
```python
void
```
```python
help()
{
```
```python
printf
```
```python
(
```
```python
"1.显示数据 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"2.删除数据 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"3.插入数据 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"4.修改数据 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"5.查找数据 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"6.显示全部数据 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"7.对于QQ排序 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"8.清屏 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"9.Helop \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
void
```
```python
deleteData(){}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    initMem();
    initData(str);
    help();
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
char
```
```python
chr = getch();
```
```python
//实时获取单个字符
```
```python
//char chr = '\0';
```
```python
//getchar(chr);
```
```python
//putchar(chr);
```
```python
switch
```
```python
(chr)
        {
```
```python
case
```
```python
'1'
```
```python
:
            showDataStatus();
```
```python
break
```
```python
;
```
```python
case
```
```python
'2'
```
```python
:
```
```python
break
```
```python
;
```
```python
case
```
```python
'3'
```
```python
:
```
```python
break
```
```python
;
```
```python
case
```
```python
'4'
```
```python
:
```
```python
break
```
```python
;
```
```python
case
```
```python
'5'
```
```python
:
```
```python
break
```
```python
;
```
```python
case
```
```python
'6'
```
```python
:
```
```python
break
```
```python
;
```
```python
case
```
```python
'7'
```
```python
:
```
```python
break
```
```python
;
```
```python
case
```
```python
'8'
```
```python
:
            system(
```
```python
"cls"
```
```python
);
```
```python
break
```
```python
;
```
```python
case
```
```python
'9'
```
```python
:
            help();
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
break
```
```python
;
        }
    }
    system(
```
```python
"pause"
```
```python
);
}
```

