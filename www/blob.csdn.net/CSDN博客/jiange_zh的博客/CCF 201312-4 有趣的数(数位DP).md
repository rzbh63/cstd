
# CCF 201312-4 有趣的数(数位DP) - jiange_zh的博客 - CSDN博客


2015年12月14日 21:18:04[jiange_zh](https://me.csdn.net/jiange_zh)阅读数：1057



## 一.问题描述
我们把一个数称为有趣的，当且仅当：
1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。
2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。
3. 最高位数字不为0。
因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。
请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。
输入格式
输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。
输出格式
输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。
样例输入
4
样例输出
3
二.思路
在不考虑条件1的情况下，共有六种合法状态：
0、只含2
1、只含2、0
2、只含2、3
3、只含2、0、1
4、只含2、0、3
5、含4种数字。
我们可以用dp[i][j]，j = 0,1,…,5，来表示长度为i的整数，满足上述状态j的个数。
于是得到状态转移方程：
1、dp[i][0]=1，位数为i且只含2的整数有且只有1个
2、dp[i][1]=2*dp[i-1][1]+dp[i-1][0]，位数为i且只含2、0的整数可以由位数为i-1的只含2、0的整数通过在末尾添加0或者2得到，也可以由位数为i-1的只含2的整数在末尾添加0得到。
3、dp[i][2]=dp[i-1][2]+dp[i-1][0]，位数为i且只含2、3的整数可以由位数为i-1的只含2、3的整数通过在末尾添加3得到，也可以由位数为i-1的只含2的整数在末尾添加3得到。
其余的状态转移方程以此类推。
三.解答
\#include<cstring>\#include<iostream>using namespace std;
typedeflonglongLL;\#define mod 1000000007LL dp[1001][6];voidsolve(intn)
{
    memset(dp,0,sizeof(dp));
    dp[1][0]=1;for(inti=2;i<=n;++i)
    {
        dp[i][0]=1;//只含2dp[i][1]=(2*dp[i-1][1]%mod+dp[i-1][0])%mod;//只含2、0  末尾0或2、末尾0dp[i][2]=(dp[i-1][2]+dp[i-1][0])%mod;//只含2、3 末尾3dp[i][3]=(2*dp[i-1][3]%mod+dp[i-1][1])%mod;//只含2、0、1 末尾2或1、末尾1dp[i][4]=((2*dp[i-1][4]%mod+dp[i-1][2])%mod+dp[i-1][1])%mod;//只含2、0、3 末尾1或3、末尾0、末尾3dp[i][5]=((2*dp[i-1][5]%mod+dp[i-1][4])%mod+dp[i-1][3])%mod;//含4个数字  末尾1或3}
}intmain()
{intn;
    cin>>n;
    solve(n);
    cout<<dp[n][5]<<endl;return0;
}

