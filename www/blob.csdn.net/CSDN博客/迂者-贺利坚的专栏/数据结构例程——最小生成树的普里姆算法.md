
# 数据结构例程——最小生成树的普里姆算法 - 迂者-贺利坚的专栏 - CSDN博客

2015年11月07日 10:29:37[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：4224


本文是[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]中第11课时[[最小生成树的普里姆算法](http://edu.csdn.net/course/detail/1595/24601)]的例程。
（程序中graph.h是图存储结构的“算法库”中的头文件，详情请[单击链接…](http://blog.csdn.net/sxhelijian/article/details/49591419)）
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
void
```
```python
Prim(MGraph g,
```
```python
int
```
```python
v)
{
```
```python
int
```
```python
lowcost[MAXV];
```
```python
//顶点i是否在U中
```
```python
int
```
```python
min;
```
```python
int
```
```python
closest[MAXV],i,j,k;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//给lowcost[]和closest[]置初值
```
```python
{
        lowcost[i]=g.edges[v][i];
        closest[i]=v;
    }
```
```python
for
```
```python
(i=
```
```python
1
```
```python
; i<g.n; i++)
```
```python
//找出n-1个顶点
```
```python
{
        min=INF;
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
```
```python
//在(V-U)中找出离U最近的顶点k
```
```python
if
```
```python
(lowcost[j]!=
```
```python
0
```
```python
&& lowcost[j]<min)
            {
                min=lowcost[j];
                k=j;
```
```python
//k记录最近顶点的编号
```
```python
}
```
```python
printf
```
```python
(
```
```python
" 边(%d,%d)权为:%d\n"
```
```python
,closest[k],k,min);
        lowcost[k]=
```
```python
0
```
```python
;
```
```python
//标记k已经加入U
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
```
```python
//修改数组lowcost和closest
```
```python
if
```
```python
(g.edges[k][j]!=
```
```python
0
```
```python
&& g.edges[k][j]<lowcost[j])
            {
                lowcost[j]=g.edges[k][j];
                closest[j]=k;
            }
    }
}
```
```python
int
```
```python
main()
{
    MGraph g;
```
```python
int
```
```python
A[
```
```python
6
```
```python
][
```
```python
6
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
6
```
```python
,
```
```python
1
```
```python
,
```
```python
5
```
```python
,INF,INF},
        {
```
```python
6
```
```python
,
```
```python
0
```
```python
,
```
```python
5
```
```python
,INF,
```
```python
3
```
```python
,INF},
        {
```
```python
1
```
```python
,
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
4
```
```python
},
        {
```
```python
5
```
```python
,INF,
```
```python
5
```
```python
,
```
```python
0
```
```python
,INF,
```
```python
2
```
```python
},
        {INF,
```
```python
3
```
```python
,
```
```python
6
```
```python
,INF,
```
```python
0
```
```python
,
```
```python
6
```
```python
},
        {INF,INF,
```
```python
4
```
```python
,
```
```python
2
```
```python
,
```
```python
6
```
```python
,
```
```python
0
```
```python
}
    };
    ArrayToMat(A[
```
```python
0
```
```python
],
```
```python
6
```
```python
, g);
```
```python
printf
```
```python
(
```
```python
"最小生成树构成:\n"
```
```python
);
    Prim(g,
```
```python
0
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
附：测试用图结构
![这里写图片描述](https://img-blog.csdn.net/20151107102859637)

