
# μC-OS-II的任务切换机理及中断调度优化 -  芝麻软件工作室的专栏 - CSDN博客


2016年07月13日 09:57:02[seven-soft](https://me.csdn.net/softn)阅读数：1163


文章讲了UCOS最核心的内容，可以说基本上是全部，这对于我们理解UCOS的工作原理很有意义，希望搞这方面的人可以消化消化，虽然内容有点老了，但是是很基础的东西，对于做更高层次的开发非常有好处！
引 言：在嵌入式操作系统领域，由Jean J. Labrosse开发的μC/OS，由于开放源代码和强大而稳定的功能，曾经一度在嵌入式系统领域引起强烈反响。而其本人也早已成为了嵌入式系统会议（美国）的顾问委员会的成员。
不管是对于初学者，还是有经验的工程师，μC/OS开放源代码的方式使其不但知其然，还知其所以然。通过对于系统内部结构的深入了解，能更加方便地进行开 发和调试；并且在这种条件下，完全可以按照设计要求进行合理的裁减、扩充、配置和移植。通常，购买RTOS往往需要一大笔资金，使得一般的学习者望而却 步；而μC/OS对于学校研究完全免费，只有在应用于盈利项目时才需要支付少量的版权费，特别适合一般使用者的学习、研究和开发。自1992第1版问世以 来，已有成千上万的开发者把它成功地应用于各种系统，安全性和稳定性已经得到认证，现已经通过美国FAA认证。
1 μC/OS-II的几大组成部分
μC/OS-II可以大致分成核心、任务处理、时间处理、任务同步与通信，CPU的移植等5个部分。
核心部分(OSCore.c) 是操作系统的处理核心，包括操作系统初始化、操作系统运行、中断进出的前导、时钟节拍、任务调度、事件处理等多部分。能够维持系统基本工作的部分都在这里。
任务处理部分(OSTask.c) 任务处理部分中的内容都是与任务的操作密切相关的。包括任务的建立、删除、挂起、恢复等等。因为μC/OS-II是以任务为基本单位调度的，所以这部分内容也相当重要。
时钟部分(OSTime.c) μC/OS-II中的最小时钟单位是timetick（时钟节拍）。任务延时等操作是在这里完成的。
任务同步和通信部分为事件处理部分，包括信号量、邮箱、邮箱队列、事件标志等部分；主要用于任务间的互相联系和对临界资源的访问。
与CPU的接口部分是指μC/OS-II针对所使用的CPU的移植部分。由于μC/OS-II是一个通用性的操作系统，所以对于关键问题上的实现，还 是需要根据具体CPU的具体内容和要求作相应的移植。这部分内容由于牵涉到SP等系统指针，所以通常用汇编语言编写。主要包括中断级任务切换的底层实现、 任务级任务切换的底层实现、时钟节拍的产生和处理、中断的相关处理部分等内容。
2 对于MSP430的中断处理
2.1 函数调用和中断调用的操作
MSP430最常使用的C编译器应该就是IAR Embedd-ed WorkBench。对于这一编译器来说，通过分析和研究，发现它有以下规律。
(1)函数调用
如果是函数级调用，编译器会在函数调用时先把当前函数PC压栈，然后调用函数，PC值改变。如果被调用的函数带有参数，那么，编译器按照以下的规则进行。
最左边的两个参数如果不是struct（结构体）或者union（联合体），将被赋值到寄存器，否则将被压栈。函数剩下的参数都将被压栈。根据最左边 的那两个参数的类型，分别赋值给R12（对于32位类型赋值给R12:R13）和R14(对于32位类型赋值给R14:R15)。
(2)中断调用
如果是在中断中调用中断服务子程序的话，编译器将把当前执行语句的PC压栈，同时再把SR压栈。接着，根据中断服务子程序的复杂程度，选择把R12~R15中的寄存器压栈。然后，执行中断服务子程序。中断处理结束后再把Rx寄存器出栈，SR出栈，PC出栈。把系统恢复到中断前的状态，使程序接着被中断的部分继续运行。
2.2 任务级和中断级的任务切换步骤和原理
(1)任务级的任务切换原理
μC/OS-II是一个多任务的操作系统，在没有用户自己定义的中断情况下，任务间的切换步骤是这样的：任务间的切换一般会调用OSSched()函数。函数的结构如下：
void OSSched(void)
{
关中断
如果(不是中断嵌套并且系统可以被调度)
{
确定优先级最高的任务
如果(最高级的任务不是当前的任务)
{
调用OSCtxSw0()
}
}
开中断
}
我们把这个函数称作任务调度的前导函数。它先判断要进行任务切换的条件，如果条件允许进行任务调度，则调用OSCtxSw()。这个函数 是真正实现任务调度的函数。由于期间要对堆栈进行操作，所以OSCtxSw()一般用汇编语言写成。它将正在运行的任务的CPU的SR寄存器推入堆栈，然 后把R4~R15压栈。接着把当前的SP保存在TCB->OSTCBStkPtr中，然后把最高优先级的TCB->OSTCBStkPtr的 值赋值给SP。这时候，SP就已经指到最高优先级任务的任务堆栈了。然后进行出栈工作，把R15~R4出栈。接着使用RETI返回，这样就把SR和PC出栈了。简单地说，μC/OS-II切换到最高优先级的任务，只是恢复最高优先级任务所有的寄存器并运行中断返回指令（RETI），实际上，所作的只是人为地模仿了一次中断。
(2)中断级的任务切换原理
μC/OS-II的中断服务子程序和一般前后台的操作有少许不同，往往需要这样操作：
保存全部CPU寄存器
调用OSIntEnter()或OSIntNesting++ 开放中断
执行用户代码 关闭中断
调用OSIntExit();
恢复所有CPU寄存器
RETI
OSIntEnter()就是将全局变量OSIntNesting加1。OSIntNesting是中断嵌套层数的变量。μC/OS-II通过它确保 在中断嵌套的时候，不进行任务调度。执行完用户的代码后，μC/OS-II调用OSIntExit()，一个与OSSched()很像的函数。在这个函数 中，系统首先把OSIntNesting减1，然后判断是否中断嵌套。如果不是的话，并且当前任务不是最高优先级的任务，那么找到优先级最高的任务，执行 OSIntCtxSw()这一出中断任务切换函数。因为，在这之前已经做好了压栈工作；在这个函数中，要进行R15~R4的出栈工作。而且，由于在之前调
 用函数的时候，可能已经有一些寄存器被压入了堆栈。所以要进行堆栈指针的调整，使得能够从正确的位置出栈。
3 使用μC/OS-II存在的问题和解决方法
由于μC/OS-II在应用的时候会占用单片机上的一些资源，如系统时钟、RAM、Flash或者ROM，从而减少了用户程序对资源的利用。对于 MSP430来说，RAM的占用是特别突出的问题。对于8、16位的单片机来说，片内的RAM容量都很小，MSP430也是如此（最大的片内RAM也只有 2KB，例如MSP430F149）。如果使用扩展内存，会大大增加设计难度。
通过对μC/OS-II的分析可以得知，μC/OS-II占用的RAM主要是用在每个任务的TCB、每个任务的堆栈等方面。通过进一步分析，发现任务 堆栈大的原因是因为MSP430的硬件设计中没有把中断堆栈和任务堆栈分开。这样就造成了在应用μC/OS-II的时候，考虑每个任务的任务堆栈大小时， 不单单需要计算任务中局部变量和函数嵌套层数，还需要考虑中断的最大嵌套层数。因为，对于μC/OS-II原始的中断处理的设计、中断处理过程中的中断嵌 套中所需要压栈的寄存器大小和局部变量的内存大小，都需要算在每个任务的任务堆栈中，则对于每一个任务都需要预留这一部分内存，所以大量的RAM被浪费。
 从这里可以看出，解决这一问题的直接方法就是把中断堆栈和每个任务自己的堆栈分开。这样，在计算每个任务堆栈的时候，就不需要把中断处理中（包括中断嵌套 过程中）的内存的占用计算到每个任务的任务堆栈中，只需要计算每个任务本身需要的内存大小，从而提高了RAM的利用率，可以缓解内存紧张的问题。
在这种设计方案中，中断堆栈区也就是利用原有的MSP430中的系统堆栈区。在前后台的设计形式中，中断中的压栈和出栈的操作都是在系统的堆栈区完成 的。基于μC/OS-II的任务切换的原理，我们对于任务堆栈的功能和系统堆栈的功能做了以下划分：任务在运行过程中产生中断和任务切换的时候，PC和 SR以及寄存器Rx都保存在各个任务自己的任务堆栈中；而中断嵌套产生的压栈和出栈的操作都是放在系统堆栈中进行的。这种划分方式是基于尽量将中断任务与 普通任务分开的思想设计的。
从前面对于IAR EW的默认操作分析来看，堆栈的结构可以有两种。一种是把μC/OS-II的任务堆栈设计成图1所示的形式。这种方法是把编译器默认的压栈操作放在前面， 然后再把剩下的寄存器进栈。但是，由于编译器在处理复杂程度不同的中断服务程序的时候，压入栈的寄存器的数量不定，所以会对以后其余寄存器的压栈和出栈操 作增加复杂度。这里，我们采用了图2所示的方式生成堆栈。在这种堆栈中，PC和SR压栈后，通过调整SP指针，使得R4~R15寄存器覆盖编译器默认压栈 的寄存器。这样，处理的难度会小一点。





对于这样的设计方式，CPU必须能够：
◆ 有相应的CPU寄存器能够模仿SP的一些功能，能使用相应的指令来完成类似SP的一些操作；
◆ 作为SP使用的寄存器在编译过程中最好不被编译器默认使用。在IAR的编译器中，有一个选项可以避免在编译过程中使用到R4、R5。
这两点MSP430都可以做到。
下面对一个正在运行的优先级为6的任务中断后，会发生的几种情况进行分析。
1）在中断的处理过程中没有更高优先级的中断产生，即不会产生中断嵌套。
图3所示为中断发生后对于任务优先级为6的任务堆栈所进行的操作。中断发生后，PC和SR被系统压栈②，对于IAR C编译器来说，会按照复杂度不同的中断服务程序的要求，默认地进行一些寄存器的压栈操作③。因为我们要求的堆栈格式是如图2所示的，我们要把SP调整到SR后面④，然后进行R4~R15的压栈操作，形成我们所要求的堆栈格式⑤。
进行任务堆栈的压栈工作以后，就可以调整SP的指针到系统堆栈了，如图4所示。压栈后的SP指向最后一个压栈内容①。我们把SP的值赋值给优先级6任务的TCB->OSTCBStkPtr，以便进行任务调度的时候出栈使用②。


接着，就把SP调整到系统堆栈处③。在中断处理过程中，可能会出现压栈的操作，那么这种情况下SP的指针会随之移动。由于现在是中断堆栈中，所以不会破坏任务堆栈的格式。
由于没有中断嵌套，在中断处理中没有别的中断发生，那么返回的步骤和上述的进栈操作正好相反。在中断处理完了以后，SP会自动回到图4中③的SP位 置。接着，系统会查询到优先级最高的任务，然后把SP的指针移到优先级最高的任务的任务堆栈，进行R15~R4的出栈工作，最后用RETI中断返回指令返 回到新的任务。因为我们把所有的任务堆栈都规定成相同的格式，所以它们之间不会产生问题。这里需要注意的是，因为系统在C编译器的中断处理中会对中断进入 时默认压栈的寄存器出栈，所以在设计出栈的程序时，要先把这些内容压栈，这样才能正确出栈。


2）在中断的处理过程中，有别的中断产生，产生中断嵌套。
如图5所示，由于在处理中断的时候，SP已经被移到系统堆栈去了，只有当中断退出的时候才可能把SP移到别的任务的任务堆栈中。所以在中断的时候进行 中断嵌套，那么对于中断的处理和第一次是一样的，所不同的是，这次保存在堆栈中的不是任务运行中的寄存器，而是中断处理中的寄存器，而且是保存在系统堆栈 中而不是任务堆栈中。从这里就可以看出优化内存的效果。所有的中断嵌套中的寄存器压栈都压在系统堆栈中，这样对于任务堆栈内存大小的要求大大降低。
因为μC/OS-II在进入中断中，会把全局变量OSIntNesting++；在退出中断的时候，又会把OSIntNesting--。在退出中断 进行任务切换之前，μC/OS-II会先判断OSIntNesting是否为0，是0才会进行任务调度。当第二中断运行结束以后，退出中断嵌套的时 候，OSIntNesting不为0，也就不会进行任务调度。因此，仍旧在系统堆栈出栈，那么系统会继续前面没有完成的中断服务程序。
接着退出中断的顺序和非中断嵌套的顺序是一样的。在中断处理完以后，SP会自动回到图4中③的SP位置。接着，系统会查询到优先级最高的任务，然后把SP的指针移到优先级最高的任务的任务堆栈。进行R15~R4的出栈工作，最后用RETI中断返回指令返回到新的任务。
中断的情况基本上就是上述两种。对于有些文献中提到的在中断中会调度到更高优先级的任务的情况，笔者觉得是不应该发生的。因为从上面的分析可以看出， 默认的（μC/OS-II的设计思路）中断处理会同时对全局变量OSIntNesting进行增减处理，以给出是否需要任务调度的条件。那么即使在中断服 务程序中把更高优先级的任务就绪，也会等到中断退出以后再进行调度，除非是在中断中直接调用更高优先级的任务函数。但这种方法应该是和μC/OS-II的 原则相违背的，沿用的是以前前后台设计的思路。
对于这样的设计方式，时钟节拍的处理方式必须和一般的中断处理方式是一样的。一般来说，MSP430使用WATCHDOG时钟中断作为时钟节拍的产生 源。从本质上来说，时钟节拍本身也是中断处理过程，所以对于时钟节拍的处理应该和其它的中断处理过程相同。实际上，在时钟节拍的处理过程中也可能会存在中 断嵌套的问题。
中断堆栈和任务堆栈分离设计的程序流程如图6所示。

4 几点建议
① 编写中断程序的时候，有条件尽量使用汇编语言。因为这样可以避免一些编译器自己进行的操作，减少指针调整的次数。
② 在用C编写中断服务的时候，因为有些功能必须调用汇编的函数才能实现。调用函数时，有些时候压栈的PC会破坏堆栈的结构。这个时候需要把堆栈进行适当的调整，保证堆栈格式的正确。
③ 中断处理过程中调用OSIntExit()的时候，由于 μC/OS-II的原始设计中SP指针有时是不调整的，所以在OSIntExit()返回了以后，还要判断一下是否中断嵌套。因为有的时候是需要切换任务的。













