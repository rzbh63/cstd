
# 数据结构实践——是否二叉排序树？ - 迂者-贺利坚的专栏 - CSDN博客

2015年11月23日 15:00:29[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2022


本文是[[数据结构基础系列(8)：查找](http://edu.csdn.net/course/detail/1669)]的实践项目参考。
【项目 - 是否二叉排序树？】
设计一个算法，判断给定的二叉树是否是二叉排序树。
[参考解答]
int JudgeBST()是设计的算法对应的实现。
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#define MaxSize 100
```
```python
typedef
```
```python
int
```
```python
KeyType;
```
```python
//定义关键字类型
```
```python
typedef
```
```python
char
```
```python
InfoType;
```
```python
typedef
```
```python
struct
```
```python
node
```
```python
//记录类型
```
```python
{
    KeyType key;
```
```python
//关键字项
```
```python
InfoType data;
```
```python
//其他数据域
```
```python
struct
```
```python
node *lchild,*rchild;
```
```python
//左右孩子指针
```
```python
} BSTNode;
```
```python
int
```
```python
path[MaxSize];
```
```python
//全局变量,用于存放路径
```
```python
void
```
```python
DispBST(BSTNode *b);
```
```python
//函数说明
```
```python
int
```
```python
InsertBST(BSTNode *&p,KeyType k)
```
```python
//在以*p为根节点的BST中插入一个关键字为k的节点
```
```python
{
```
```python
if
```
```python
(p==NULL)
```
```python
//原树为空, 新插入的记录为根节点
```
```python
{
        p=(BSTNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(BSTNode));
        p->key=k;
        p->lchild=p->rchild=NULL;
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
else
```
```python
if
```
```python
(k==p->key)
```
```python
return
```
```python
0
```
```python
;
```
```python
else
```
```python
if
```
```python
(k<p->key)
```
```python
return
```
```python
InsertBST(p->lchild,k);
```
```python
//插入到*p的左子树中
```
```python
else
```
```python
return
```
```python
InsertBST(p->rchild,k);
```
```python
//插入到*p的右子树中
```
```python
}
BSTNode *CreatBST(KeyType A[],
```
```python
int
```
```python
n)
```
```python
//由数组A中的关键字建立一棵二叉排序树
```
```python
{
    BSTNode *bt=NULL;
```
```python
//初始时bt为空树
```
```python
int
```
```python
i=
```
```python
0
```
```python
;
```
```python
while
```
```python
(i<n)
        InsertBST(bt,A[i++]);
```
```python
//将A[i]插入二叉排序树T中
```
```python
return
```
```python
bt;
```
```python
//返回建立的二叉排序树的根指针
```
```python
}
```
```python
void
```
```python
DispBST(BSTNode *bt)
```
```python
//以括号表示法输出二叉排序树bt
```
```python
{
```
```python
if
```
```python
(bt!=NULL)
    {
```
```python
printf
```
```python
(
```
```python
"%d"
```
```python
,bt->key);
```
```python
if
```
```python
(bt->lchild!=NULL || bt->rchild!=NULL)
        {
```
```python
printf
```
```python
(
```
```python
"("
```
```python
);
            DispBST(bt->lchild);
```
```python
if
```
```python
(bt->rchild!=NULL)
```
```python
printf
```
```python
(
```
```python
","
```
```python
);
            DispBST(bt->rchild);
```
```python
printf
```
```python
(
```
```python
")"
```
```python
);
        }
    }
}
```
```python
/*
int JudgeBST(BSTNode *bt)为判断一个树是否为排序二叉树设计的算法的实现
*/
```
```python
KeyType predt=-
```
```python
32767
```
```python
;
```
```python
//predt为全局变量,保存当前节点中序前趋的值,初值为-∞
```
```python
int
```
```python
JudgeBST(BSTNode *bt)
```
```python
//判断bt是否为BST
```
```python
{
```
```python
int
```
```python
b1,b2;
```
```python
if
```
```python
(bt==NULL)
```
```python
return
```
```python
1
```
```python
;
```
```python
//空二叉树是排序二叉树
```
```python
else
```
```python
{
        b1=JudgeBST(bt->lchild);
```
```python
//返回对左子树的判断，非排序二叉树返回0，否则返回1
```
```python
if
```
```python
(b1==
```
```python
0
```
```python
|| predt>=bt->key)
```
```python
//当左子树非排序二叉树，或中序前趋（全局变量）大于当前根结点时
```
```python
return
```
```python
0
```
```python
;
```
```python
//返回“不是排序二叉树”
```
```python
predt=bt->key;
```
```python
//记录当前根为右子树的中序前趋
```
```python
b2=JudgeBST(bt->rchild);
```
```python
//对右子树进行判断
```
```python
return
```
```python
b2;
    }
}
```
```python
int
```
```python
main()
{
    BSTNode *bt;
```
```python
int
```
```python
a[]= {
```
```python
43
```
```python
,
```
```python
91
```
```python
,
```
```python
10
```
```python
,
```
```python
18
```
```python
,
```
```python
82
```
```python
,
```
```python
65
```
```python
,
```
```python
33
```
```python
,
```
```python
59
```
```python
,
```
```python
27
```
```python
,
```
```python
73
```
```python
},n=
```
```python
10
```
```python
;
```
```python
printf
```
```python
(
```
```python
"创建排序二叉树:"
```
```python
);
    bt=CreatBST(a,n);
    DispBST(bt);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"bt%s\n"
```
```python
,(JudgeBST(bt)?
```
```python
"是一棵BST"
```
```python
:
```
```python
"不是一棵BST"
```
```python
));
    bt->lchild->rchild->key =
```
```python
30
```
```python
;
```
```python
//搞个破坏！
```
```python
printf
```
```python
(
```
```python
"修改后的二叉树:"
```
```python
);
    DispBST(bt);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"bt%s\n"
```
```python
,(JudgeBST(bt)?
```
```python
"是一棵BST"
```
```python
:
```
```python
"不是一棵BST"
```
```python
));
```
```python
return
```
```python
0
```
```python
;
}
```

