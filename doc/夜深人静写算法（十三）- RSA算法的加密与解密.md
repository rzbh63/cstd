# 夜深人静写算法（十三）- RSA算法的加密与解密

2018年04月25日 21:39:13

英雄哪里出来

阅读数：120058

更多

 								所属专栏： 																[夜深人静写算法](https://blog.csdn.net/column/details/21195.html) 																 							

 									







**目录**  



**一、概述**

​      **1、加密与解密**

​      **2、对称性加密与非对称性加密**

**二、RSA算法流程**

​      **1、算法原理**

​      **2、公钥和私钥的生成**

​      **3、RSA加密**

​      **4、RSA解密**

​      **5、快速幂取模**

**三、数论基础**

​      **1、同余**

​      **2、欧几里德算法**

​      **3、互素**

​      **4、扩展欧几里德算法**

​            **a、线性同余**

​            **b、逆元**

​      **5、算术基本定理**

​      **6、欧拉函数**

​      **7、欧拉定理**

​      **8、费马小定理**

**四、RSA算法证明**

​      **1、私钥解密证明**

​      **2、安全性证明**



**一、引例**

​       **1、加密与解密**

​       加密是以某种特定的算法，改变原有的数据信息，使得未授权的用户即使获得了加密后的数据，但因不知解密的方法（确切的说是不知道密钥），仍然无法了解其信息内容。而解密则是加密的逆过程。

​        我们称尚未加密的数据为明文，通过固定算法加密后的数据为密文。密钥是一种参数，它是在明文转换为密文或密文转换为明文时算法的输入参数。可以理解成密码的钥匙。

​       **2、对称性加密与非对称性加密**

​       常见的数字加密方式分为两类：对称加密和非对称加密。

​       对称加密算法中，数据发送方将明文和密钥一起经过特殊加密算法处理成密文后，将它发送出去。接收方收到密文后，若想解读原文，则需要使用加密用到的相同密钥及相同算法的逆算法对密文进行解密，才能使其恢复成原文。 它的最大优势是加/解密速度快，适用于大数据量进行加密，缺点是密钥管理困难。常见的对称加密算法有AES、DES、Blowfish等等。

​       非对称加密算法中，有两个密钥：公钥和私钥。它们是一对，如果用公钥进行加密，只有用对应的私钥才能解密；如果用私钥进行加密，只有用对应的公钥才能解密。非对称加密算法实现机密信息的交换过程为：甲方生成一对密钥并将其中一把作为公钥向其他方公开；得到该公钥的乙方使用该密钥对机密信息进行加密后发送给甲方；甲方再用自己的另一把专用密钥对加密后的信息进行解密。最有名的非对称加密算法当属RSA了，本文将对RSA算法的加/解密过程进行详细剖析。



**二、RSA算法流程**

​       **1、算法原理**

​       算法本身基于一个简单的数论知识：给出两个素数，很容易将它们相乘，然而给出它们的乘积，想得到这两个素数就显得尤为困难。如果能够解决大整数（比如几百位的整数）分解的快速方法，那么RSA算法将轻易被破解。

​       **2、公钥和私钥的生成**

​       RSA算法由两个密钥，即公钥和私钥组成。

​      1）准备两个非常大的素数p和q（转换成二进制后1024个二进制位或者更多，位数越多越难破解）；

​      2）计算p和q的乘积n=pq；

​      3）计算m=(p-1)(q-1)，这里的m为n的欧拉函数（欧拉函数的含义会在下文进行详细解释）；

​      4）找到一个数e（1 < e < m），满足gcd(m, e)=1（即e和m互素）；

​      5）计算e在模m域上的逆元d（满足ed mod m = 1，则称e和d在模m域上互为逆元）；

​      6）公钥和私钥生成完毕：(n, e)为公钥，(n, d)为私钥；

​      **3、RSA加密**

​      对于明文x，用公钥(n,e)对x加密的过程，就是将x转换成数字（字符串的话取其ASCII码或者unicode值），然后通过幂取模计算出y，其中y就是密文；

![img](https://img-blog.csdn.net/20180426093239394)

​      **4、RSA解密**

​      对于密文y，用私钥(n,d)对y进行解密的过程和加密类似，同样是计算幂取模，如下：

![img](https://img-blog.csdn.net/20180426093244813)

​      **5、快速幂取模**

​       由于e和d可能是非常大的数，所以这一步幂取模运算需要用二分进行加速。利用如下等式可以在O(logb)的时间内计算a的b次幂模上c的值，递归实现即可。

![img](https://img-blog.csdn.net/20180426093303243)

​       RSA算法的原理需要一些简单的数论基础做支撑，接下来的章节就介绍一些简单的数论知识，有助于帮助读者快速理解RSA的实现原理。实际阅读过程可以先跳过第三节，当第四节遇到相关概念的时候再来看第三节，会达到事半功倍的效果。



**三、数论基础**

​      **1、同余**

​       给定一个正整数n，以及任意两个整数a和b，满足a-b能被n整除，则称a与b模n同余（模上n后有相同的余数），记作：

![img](https://img-blog.csdn.net/20180426093310787)

​      **2、欧几里德算法**

​       欧几里德算法又称辗转相除法，是指利用递归或者迭代的方式计算两个整数a和b的最大公约数，计算方式如下：

![img](https://img-blog.csdn.net/20180426093316149)

​       证明如下：令a = kb+r，其中a与r模b同余，即r = a(mod b)；令d为a和b的公约数，则d整除a且d整除b，所以根据整除的组合性原则，有d整除(a-kb)；而(a-kb) = r = a(mod b)。

​       综上所述，如果d是a和b的公约数，那么也一定是b和(a mod b)的公约数，即两者公约数一致，所以最大公约数也必定相等。

​       C++代码实现如下：

```cpp
int gcd(int a, int b) {



    return b ? gcd(b, a%b) : a;



}
```

​        递归实现的欧几里德算法，透露出一个信息：任何非零整数和零的最大公约数是它本身。

​      **3、互素**

​       如果两个整数a和b的最大公约数为1，则称这两个数互素，也叫互质。

![img](https://img-blog.csdn.net/2018042609335251)

​      **4、扩展欧几里德算法**

​       对于不完全为0的整数a和b，必然存在整数对x，y，满足等式：

![img](https://img-blog.csdn.net/20180426093405886)

​       根据欧几里德算法以及一些同余性质，我们可以进行如下推导：

![img](https://img-blog.csdn.net/20180426093418960)

​       根据等式两边a和b的确定性，得到：

![img](https://img-blog.csdn.net/20180426093427360)

​       由于gcd(a,b)是一个递归的计算，所以在求解(x,y)时，(x',y')其实已经通过递归计算出来了，递归出口为b==0时，此时x0=1，y0=0。扩展欧几里德算法的C++实现代码如下：

```cpp
    #define LL __int64



    LL Extend_Euclid(LL a, LL b, LL &X, LL &Y) {



        LL q, temp;



          if( !b ) {



            X = 1; Y = 0; return a;



        }else {



            q = Extend_Euclid(b, a % b, X, Y);



            temp = X; X = Y; Y = temp - (a / b) * Y;



            return q;



        }



    }
```

​       **a、线性同余**

​       来看等式ax+by = c（a、b、c为常量，x、y为未知量），当x和y取值为全体实数时，这个方程表示的是一个二维空间中的直线。而当x和y取整数时，它代表了一类同余方程，可以将等式两边同时模上b，得到：

![img](https://img-blog.csdn.net/20180426093453664)

​       由于未知数x是一次（线性）的，所以这样的方程称为线性同余方程。

​       线性同余方程的求解是利用扩展欧几里德算法求解，分为以下几步：

​       i) 首先求出a和b的最大公约数d = gcd(a, b)，那么原方程可以转化成：

![img](https://img-blog.csdn.net/2018042609350651)

所以，如果c不是d=gcd(a,b)的倍数，方程必然无解，算法结束；否则进入ii)。

​       ii)  利用扩展欧几里德算法计算出方程ax+by=gcd(a,b)的解x0，则ax+by=c的解为：

![img](https://img-blog.csdn.net/20180426093514642)

需要注意的是，这里的解不止一个，而是有无限个解。举例说明：

![img](https://img-blog.csdn.net/20180426093535650)

利用扩展欧几里德算法得到初解(x0,y0)，那么对于c为gcd(6,8)的倍数的方程，必然有解：

![img](https://img-blog.csdn.net/20180426093543422)

​       **b、逆元**

​        对于之前的线性同余方程，当c=1的时，方程表示如下：

![img](https://img-blog.csdn.net/20180426093550843)

​        这种情况下，x为a在模b域下的逆元。逆元这个词在本文之前讲到的公钥和私钥的生成过程中略有提及，公钥中的e和私钥中的d互为逆元，即：

![img](https://img-blog.csdn.net/20180426093558713)

​        在已知e、m的情况下，我们就可以利用扩展欧几里德算法求出d的值了，这就是为什么要花这么长的篇幅介绍扩展欧几里德算法的原因。仅仅只是为了求一个逆元（囧）。

​       接下来要介绍的内容围绕欧拉函数展开，这是初等数论中非常重要的一个函数，也对RSA加密算法起了至关重要的作用。

​      **5、算术基本定理**

​        任何一个大于1的自然数n，必然可以表示成有限个素数的乘积，表示如下：

![img](https://img-blog.csdn.net/2018042609360744)

​      **6、欧拉函数**

​       对于正整数n，欧拉函数是小于等于n的正整数中与n互素的数的个数，记为φ(n)（显然，φ(1)=1）。

​       **1) 素数**

​       对于素数p而言，比p小的数必然与它互素，所以互素的数的个数为p-1。记为：

![img](https://img-blog.csdn.net/20180426093617966)

​       **2) 素数的幂**

​       当一个数n等于素数p的k次幂时，任何小于等于n且是p的倍数的数都与n有大于1的最大公约数，那么剩下的就是和n互素的数。那么有多少个p的倍数是小于等于p的k次幂的呢？我们可以一个一个列出来：

![img](https://img-blog.csdn.net/20180426093623650)

​       于是，肉眼就可以看出，和n = p^k不互素的数总共有p^(k-1)个，把这些数去掉就是互素的数了，这种情况下，欧拉函数表示如下：

![img](https://img-blog.csdn.net/20180426093631288)

​       **3) 互素数的乘积**

​       当n为两个互素的数p和q的乘积时，我们可以这么考虑：将1~n之间的数按照p行q列按顺序排列起来。

![img](https://img-blog.csdn.net/20180426093639982)

对于任意与q互素的数r满足1<=r<q，根据欧几里德算法，有：

![img](https://img-blog.csdn.net/20180426093645756)

这个公式的含义是：只要r和q互素，那么r所在的那一列必然全部和q互素。根据欧拉函数的定义，和q互素的列的总列数就是φ(q)列。

​       那么当gcd(q,r)=1时，我们取第r列来看，这一列的元素排列起来为：

![img](https://img-blog.csdn.net/2018042609365723)

​       以上任意两个数都不模p同余（反证法：如果两数模p同余，则相减必然是p的倍数），所以它们各自模p的余数必定不相同。总共p个数，这些数模p的余数必然是0~p-1的排列，那么其中和p互素的数的个数必然是φ(p)。所以得到小于等于pq并与之互素的数的个数为φ(q)φ(p)。

​       所以对于两个互素的数p和q，它们乘积的欧拉函数表示如下：

![img](https://img-blog.csdn.net/20180426093702857)

​       **4) 一般情况**

​       利用结论2)和3)，再套用算术基本定理，可以得出欧拉函数的一般式如下：

![img](https://img-blog.csdn.net/20180426093708943)

​      **7、欧拉定理**

​       n和a为正整数，且n,a互素，则：

![img](https://img-blog.csdn.net/20180426093719950)

​        证明过程如下：

​       1）令1~n中与n互素的数（总共φ(n)个）按顺序排列为：

![img](https://img-blog.csdn.net/20180426093729422)

​       2）将这些数分别乘上a，得到如下序列：

![img](https://img-blog.csdn.net/20180426093734467)

​       3）可知以上任意两个数yi都不模n同余。这点，可以利用反证法证明：假设某两个数模n同余，则有：

![img](https://img-blog.csdn.net/20180426093740163)

如若两个数模n同余，则它们相减必然是n的倍数，将它们的差记为kn（k为任意整数），则有如下等式：

![img](https://img-blog.csdn.net/20180426093745578)

由此可见，上式中ab是n的倍数，而a和n互素，所以只能b是n的倍数。但是b的绝对值小于n，所以b也不可能是n的倍数。从而推导出假设不成立。所以任意两个数都不模n同余。即φ(n)个数yi模n有φ(n)种余数。

​       4）任意的yi(mod n)必然与n互素，这个可以由欧几里得算法递归求最大公约数（辗转相除法）反推得出：

![img](https://img-blog.csdn.net/20180426093753715)

​       5）综合1）、3）和4），xi和yi(mod n)必然是一一映射。所以将所有的xi连乘，yi(mod n)连乘，两者必然相等。即：

![img](https://img-blog.csdn.net/20180426093759903)

由于任意的xi和n互素，所以等式两边的xi可以约去，得到欧拉定理的表示如下：

![img](https://img-blog.csdn.net/20180426093805221)

​       **8、费马小定理**

​        素数p的欧拉函数等于p-1，将它代入欧拉定理，直接得出（其中a<p）：

![img](https://img-blog.csdn.net/20180426093813514)

**四、RSA算法证明**

​       **1、私钥解密证明**

​       我们要做的就是证明密文经过私钥的幂取模的结果等于明文，即如下等式成立：

![img](https://img-blog.csdn.net/20180426093818487)

​        证明如下：根据加密算法得到的密文y满足：

![img](https://img-blog.csdn.net/20180426093826733)

​        等式两边同时取d次幂，再对n取模，等式变为同余式：

![img](https://img-blog.csdn.net/20180426093857662)

​        e和d在模m(m为n的欧拉函数)域上互为逆元，所以得到如下等式：

![img](https://img-blog.csdn.net/20180426093911655)

​        将它代入y的同余式，得到：

![img](https://img-blog.csdn.net/20180426093920361)

​        接下来分情况讨论即可：

​       1）x和n互素

​        直接代入欧拉定理即可，如下：

![img](https://img-blog.csdn.net/20180426093930754)

​       2）x和n不互素

​        由于n是p和q的乘积，如若x和n不互素，则gcd(x,n)=p或gcd(x,n)=q，这里只需要讨论其中一种情况，令x=tp。这里的t必然和q互素，否则x将会是n的倍数，加密结果将永远等于0且无法解密。所以gcd(x, q) =1，根据欧拉定理，有：

![img](https://img-blog.csdn.net/20180426093941307)

​       等式两边取kφ(p)次幂，得到等式：

![img](https://img-blog.csdn.net/20180426093948332)

​       将同余式写成等式的形式如下（其中g为任意整数）：

![img](https://img-blog.csdn.net/20180426093955952)

​       等式两边同时乘上x得到：

![img](https://img-blog.csdn.net/20180426094011133)

​       最后回到解密的同余式，将上式代入得到：

![img](https://img-blog.csdn.net/20180426094018594)

​       **2、安全性证明**

​       最后来看下RSA算法为何安全，全程六个数字：

![img](https://img-blog.csdn.net/20180426094023760)

​       而对于外界来说，知道的只有公钥(n, e)，如何通过这两个已知数得到明文？

​       1)   首先，明文需要密文的d次幂模上n来计算，所以首先要知道d；

​       2)  d为e对φ(n)的逆元，如果知道φ(n)，则能够通过扩展欧几里德算法计算出d；

​       3)  φ(n)=(p-1)(q-1)，其中p和q均为素数，只有得知p和q的值才能计算出φ(n)；

​       4)  n=pq，n已知，所以如果能够分解n，则p和q就能被计算出来。

​       综上所述，破解RSA的难点在于对n的因数分解，然而大整数的因数分解暂时没有高效的算法。