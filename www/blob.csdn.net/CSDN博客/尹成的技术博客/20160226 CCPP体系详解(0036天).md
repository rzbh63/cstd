
# 20160226.CCPP体系详解(0036天) - 尹成的技术博客 - CSDN博客

置顶2016年03月25日 13:59:24[尹成](https://me.csdn.net/yincheng01)阅读数：2739


程序片段(01):01.多线程.c+02.多线程操作.c
内容概要:**多线程**
```python
///01.多线程.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
//01.线程任务函数剖析:
```
```python
//  1."封装"线程任务代码
```
```python
//  2.MessageBox();作用:
```
```python
//      用于"阻塞"当前线程的继续执行状态
```
```python
//      也就是暂停线程任务代码的执行
```
```python
//02.MessageBox();带参宏的作用:
```
```python
//  1.弹出一个消息盒子
```
```python
//  2.该带参宏位于那条线程任务函数当中,就会在
```
```python
//      该线程之上产生同步效果,从而阻塞该条线程
```
```python
//注:MessageBox();带参宏和TEXT();带参宏结合可以
```
```python
//  解决字符集兼容性问题(让任何文字自动使用本地字符集)
```
```python
void
```
```python
thTaskFun(
```
```python
void
```
```python
* pArr)
{
    MessageBox(
```
```python
0
```
```python
, TEXT(
```
```python
"1"
```
```python
), TEXT(
```
```python
"1"
```
```python
),
```
```python
0
```
```python
);
}
```
```python
//03.关于开启线程函数(_beginthread();)函数的解析:
```
```python
//  1.头文件:process.h
```
```python
//  2.格式:_beginthread(arg1, arg2, arg3);
```
```python
//  3.参数:
```
```python
//      arg1:函数指针(表象)<->线程任务代码(实质)
```
```python
//      arg2:栈的尺寸,0表示默认情况(拷贝主线程栈尺寸作为新开启线程所占用的栈尺寸)
```
```python
//      arg3:开启线程之后,向线程任务函数所传递的参数(数据封装体的地址)
```
```python
//注:数据封装体的地址,便于跨函数访问多个参数!+提升效率
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    MessageBox(
```
```python
0
```
```python
,
```
```python
"2"
```
```python
,
```
```python
"2"
```
```python
,
```
```python
0
```
```python
);
```
```python
//此处将会阻塞主线程
```
```python
_beginthread(thTaskFun,
```
```python
0
```
```python
, NULL);
```
```python
//用于开启一条异步执行的线程
```
```python
_beginthread(thTaskFun,
```
```python
0
```
```python
, NULL);
    _beginthread(thTaskFun,
```
```python
0
```
```python
, NULL);
    _beginthread(thTaskFun,
```
```python
0
```
```python
, NULL);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.多线程操作.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
//01.线程状态管理:
```
```python
//  线程状态:冻结(暂停)+解冻(继续)
```
```python
//注:_beginthread();不太注重代码格式要求,CreateThread();注重代码格式要求
```
```python
void
```
```python
print(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, ++i);
        Sleep(
```
```python
1000
```
```python
);
    }
}
```
```python
//02.阻塞线程和阻塞进程:
```
```python
//  阻塞线程
```
```python
//      1.阻塞线程之后,只是当前线程的后续代码暂停执行状态
```
```python
//      2.任何情况之下都可以触发阻塞线程的状态
```
```python
// 阻塞进程:
```
```python
//      1.阻塞进程之后,进程之内的所有代码全部处于暂停执行执行状态
```
```python
//      2.CPU在为单个进程只开启单条线程的情况之下才能出现阻塞进程现象
```
```python
//注:Debug调试模式状态下,无论是单线程还是多线程,只要阻塞了主线程
```
```python
//      就会出现阻塞进程的现象,从而其它线程无法得到具体的执行
```
```python
//注:只有在多线程的情况之下才具备阻塞线程和阻塞进程之间的区别
```
```python
//      因为在单线程的情况之下阻塞线程就等同于阻塞进程
```
```python
//注:阻塞主线程的情况之下,才有可能阻塞进程,从而让其它所有的代码得不到
```
```python
//      继续执行的机会(当然,是在其他线程没有启动的情况之下)
```
```python
//注:冻结主线程的情况之下,在调试模式下等同于阻塞进程,在这种情况之下可以
```
```python
//      方便与实施对其他线程的状态切换操作
```
```python
//03.阻塞线程的两种常见方式:
```
```python
//      MessageBox();带参宏
```
```python
//      system("pause");
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    _beginthread(print,
```
```python
0
```
```python
, NULL);
    system(
```
```python
"pause"
```
```python
);
```
```python
//(Debug调试模式下)暂停主线程等同于暂停整个进程,便于对其它线程的状态切换操作
```
```python
system(
```
```python
"pause"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.线程状态:冻结(暂停)&解冻(继续)
```
```python
//02.线程休眠:Sleep();用于当前线程任务函数之中,休眠当前线程
```
```python
//03.异步线程:_beginthread(run,0,NULL);
```
```python
//  run:函数指针
```
```python
//      0:堆栈尺寸
```
```python
//  NULL:参数列表
```
```python
//04.阻塞线程:
```
```python
//  MessageBox();
```
```python
//  system("pause");
```
```python
//05.冻结&解冻[线程管理方面的重要概念]
```
```python
//  实质:在于是否存在于系统所控制的环形队列当中<=>是否处于等待CPU执行的状态
```
```python
//  特点:由于CPu存在的固定的CPU执行频率,因此CPU对环形队列当中的线程任务分配
```
```python
//      相应所需的时间片,按照顺序进行环形队列当中的线程任务函数内容切换
```
```python
//注:一条线程对应于一个环形队列,对应于一组线程任务序列
```
```python
//06.操作系统管理线程的特点:
```
```python
//  1.操作系统为每个程序的相应代码片段分配相应的时间片
```
```python
//  2.该时间片模型的本质就是一个环形队列(线程<->队列)
```
```python
//  3.CPU针对于每一个时间片进行切换访问
```
```python
//07.关于同步与异步的概念:
```
```python
//  1.单条线程根本不存在同步与异步的概念,只是会出现同步与异步的现象
```
```python
//  2.只有多线程的情况之下,才存在同步与异步的概念
```
```python
//注:严格区分概念和现象
```
```python
//08.如何进行线程冻结&解冻状态的演示?
```
```python
//  1.采用两条线程
```
```python
//  2.主线程的阻塞状态会导致副线程暂时无法获得CPU的执行权
```
```python
//  3.在主线程的阻塞状态之下进行副线程的线程状态管理演示[冻结&解冻]
```
```python
//09.测试多线程:多线程的常用操作
```
```python
//  例子-->细节-->通信-->队列
```
```python
//10.操作系统特点:
```
```python
//  1.操作系统:PC&Phone
```
```python
//  2.由于CPU存在CPU执行频率,所以操作系统分配给线程的任务代码时间片大小有限,
```
```python
//      也就是环形队列总时间片固定,只不过是循环进行执行,所以应用程序不会存在执
```
```python
//      行不到的情况[CPU刷新环形队列的频率]
```
```python
//  3.单核CPU一个时刻只会执行一条线程,根据概率进行切换
```
```python
//  4.关于多线程的假象问题:
```
```python
//      单核CPU只能出现多线程的假象情况,不会出现多多线程的真相情况
```
```python
//      也就是说某一时刻,单核CPU只会处理一条线程,多核CPU才能出现处理多线程情况
```
```python
//  5.操作系统通过线程环形队列实现对CPU随机切换动作的调度[随机性]
```
```python
//  6.所有的线程都放置在同一个操作系统所管理的环形队列当中,然后让操作系统对CPU进行随机调度执行
```
```python
//      CPU调度执行某条线程-->从而指向某条线程的任务代码
```
```python
//11.冻结&解冻:
```
```python
//  冻结:休眠&从环形队列当中退出
```
```python
//  解冻:运行&进入到环形队列当中-->等待执行(不一定立即得到CPU的执行权)
```
```python
//  执行权:CPU切换到线程的执行状态-->执行
```
程序片段(02):01._beginthread.c+02.CreateThread.c
内容概要:**多线程冲突问题**
```python
///01._beginthread.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <time.h>
```
```python
#include <process.h>
```
```python
//01.临界区:CRITICAL_SECTION
```
```python
//  1.解决多线程并发访问冲突问题
```
```python
//  2.所允许的多线程并发访问数64
```
```python
//  3.通常情况之下需要将临界区定义为全局变量:
```
```python
//      为的是让多条线程识别同一个临界区!(防止互锁)
```
```python
//注:临界区情况之下,如果并发访问数目大于64
```
```python
//  那么多线程并发访问效果将会失效
```
```python
//注:临界区的实质是一个结构体类型,它位于Windows.h
```
```python
//  头文件中进行的类型定义
```
```python
//注:C语言的全局变量不会进行自动初始化操作,CPP语言
```
```python
//      会进行默认的自动初始化操作
```
```python
static
```
```python
CRITICAL_SECTION cs;
```
```python
//02.全局变量:用于多线程之间的通信信息描述
```
```python
//  任何一个当前进程下的线程都可以访问这个全局变量
```
```python
//注:全局变量在默认的情况之下,如果被多条线程所并发
```
```python
//  访问,容易导致线程并发访问冲突问题!
```
```python
static
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
//03.多线程并发访问问题详细剖析:
```
```python
//  1.理论上:100条线程并发计算同一个数据之后的结果应当是
```
```python
//      100*100=10000,但是结果却是达不到10000
```
```python
//  2.原因是:多条线程同时读取到相同的数据,再进行数据写入
```
```python
//      的时候,写入相同的结果,因此导致计算次数-1,因此结果-1
```
```python
//注:使用临界区之后,多条线程在同一时刻的情况之下,只能由
```
```python
//      单条线程进行数据的访问(读取和写入)
```
```python
//注:使用临界区之后,将会有N多条线程处于运行状态下:
```
```python
//  其中,(N-1)条处于运行"等待"状态下-->
```
```python
//      全部都是处于"急切"等待状态下-->
```
```python
//      临界区一旦接触,就会随机抽取一条线程得到CPU的执行权
```
```python
//  其中,1条处于运行"执行"状态下
```
```python
//注:避免频繁的使用临界区可以加快数据的访问效率
```
```python
//  严格避免频发的加解锁情况发生(多线程效率提升与优化)
```
```python
static
```
```python
void
```
```python
myFun(
```
```python
void
```
```python
* p)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
    {
        EnterCriticalSection(&cs);
```
```python
//进入临界区
```
```python
++num;
        LeaveCriticalSection(&cs);
```
```python
//离开临界区
```
```python
Sleep(
```
```python
3
```
```python
);
```
```python
//不要讲时间操作放置于临界区当中(否则极度耗费时间)
```
```python
}
}
```
```python
//04.如何对程序进行计时操作?
```
```python
//  1.时间刻度
```
```python
//  2.记录开始
```
```python
//  3.记录结束
```
```python
//  4.时间差值
```
```python
//05.HANDLE类型解析:
```
```python
//  1.位于Windows.h头文件当中
```
```python
//  2.名为句柄,实质void *,也就是一个空类型的地址类型
```
```python
//      只是一个地址数值的类型定义,没有明确的解析方式
```
```python
//06.要想模拟多线程处理操作,必须等待所有线程执行完毕
```
```python
//      最终再进行多条线程的结果处理
```
```python
//07.等待多条线程执行状态的结束:
```
```python
//  格式:WaitForMutipleObjects(arg1, arg2, arg3, arg4);
```
```python
//  参数:arg1:线程个数+arg2:线程数组+arg3:单个|全部等待+arg4:等待时间
```
```python
//08.这儿处在两个冲突问题:
```
```python
//  1.同步执行:结果精确,耗费时间
```
```python
//  2.异步执行:时间精确,结果不正确
```
```python
//09.解决方式:
```
```python
//  临界区:实质就是加解锁的特点
```
```python
//      添加一把锁,必须等待当前线程执行状态完毕之后,再进行解锁,再让下一个
```
```python
//      线程执行临界区当中的代码块儿
```
```python
//  信号量:通过信号提示决定是否可以进行变量的访问
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    InitializeCriticalSection(&cs);
    time_t start, end;
    time(&start);
    HANDLE thArr[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
    {
```
```python
//这里需要等待所有线程执行结束并退出,所以需要使用线程句柄数组进行统一管理
```
```python
thArr[i] = _beginthread(myFun,
```
```python
0
```
```python
, NULL);
```
```python
//thArr[i] = CreateThread(NULL, 0, myFun, NULL, 0, NULL);
```
```python
//这儿如果是使用等待单条线程执行完毕之后,再让下一个线程执行,这样会导致等待时间较长
```
```python
//效率低下,等待一个一个的线程执行结束,如果修改成功,同步收取,一个一个的执行,防止竞争
```
```python
//关系的产生,造成最终的处理结果丢失
```
```python
}
    WaitForMultipleObjects(
```
```python
100
```
```python
, thArr, TRUE, INFINITE);
    time(&end);
```
```python
printf
```
```python
(
```
```python
"difftime = %lf \n"
```
```python
, difftime(end, start));
```
```python
printf
```
```python
(
```
```python
"num = %d \n"
```
```python
, num);
    DeleteCriticalSection(&cs);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.多线程问题:冻结&解冻之后
```
```python
//  1.通过队列,通过一些额外的方式对多线程进行一些额外的操作
```
```python
//  2.多线程冲突问题:开发中间经常遇到的问题
```
```python
//      多条线程同时访问一个全局变量,容易出现多线程并发访问问题
```
```python
//02.全局变量:
```
```python
//  任何一条线程都可以进行该变量的访问,所以多线程在访问的时候,非常容易出问题,所以在进行大数据处理
```
```python
//  的时候,将所有的数据全部加载进内存之后,如果采用多线程并发访问,就需要首要解决这个问题!
```
```python
//03.解决多线程并发访问问题:
```
```python
//  1.同步单条线程:缺点就是单条线程的操作时间过长!->效率低下,耗费时间
```
```python
//  2.因此需要使用临界区进行各条不同的线程之间的同一时刻的屏蔽操作
```
```python
//04.计时函数编程:
```
```python
//  1.#include <time.h>
```
```python
//  2.定义->起始(时刻)->终止(时刻)->差距->显示
```
```python
//      time_t start,end;
```
```python
//      time(&start);//记录起始
```
```python
//      time(&end);//记录结束
```
```python
//      difftime(end,start);//统计差距
```
```python
//      %lf//显示结果
```
```python
//05.定义临界区:
```
```python
//  1.修改后缀为.cpp
```
```python
//  2.定义步骤:
```
```python
//      声明临界区:
```
```python
//          CRITICAL_SECTION cs;//实质就是一个"结构体"
```
```python
//          解释:LONG LockCount;LONG RecursionCount;[Lock信号+方式]
```
```python
//          特点:该临界区既可以应用于C++同样也可以应用于C当中
```
```python
//          原则:一般情况之下,我们应用多线程都是采用CPP
```
```python
//      进入临界区:
```
```python
//          EnterCriticalSection(&cs);
```
```python
//      离开临界区:
```
```python
//          LeaveCriticalSection(&cs);
```
```python
//      删除临界区:
```
```python
//          特点:临界区不是一个变量,实质上是操作系统,让我们的这个线程进入到临界区锁定状态
```
```python
//              临界区位于Windows.h头文件当中(多线程最高级是由操作系统完成调度的)
```
```python
//          DeleteCriticalSection(&cs);
```
```python
//06.临界区原理:保证精确操作
```
```python
//  1.并行操作情况之下,效率提升,但是结果不精确-->推出临界区概念:
```
```python
//      临界区用于解决同步单条线程的效率低下问题,线程进入临界区之后,该条线程独享代码执行权
```
```python
//  2.临界区的概念:媒婆特点
```
```python
//07.CreateThread();与_beginthread();的区别
```
```python
//      CreateThread();使用的是HANDLE
```
```python
//      _beginthead();使用的是int
```
```python
//          属于process.h线程库当中的一个线程函数声明,这里只能给你发生互锁的情况,但是不能解决多线程的冲突问题,所以这儿需要使用
```
```python
//          CreateThead();线程访问的时候发生的冲突情况[只能加锁,弹出多线程访问异常]
```
```python
//08.代码调试的方式:
```
```python
//      逐步放开部分代码进行观察
```
```python
///02.CreateThread.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <time.h>
```
```python
//01.定义"临界区"为全局变量:
```
```python
//  原因:让多条线程识别同一个临界区
```
```python
CRITICAL_SECTION cs;
```
```python
//02.定义"多线程"的通信信息:
```
```python
//  多线程信息容易导致多线程并发访问冲突问题
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
//03._beginthread();线程任务函数格式
```
```python
//void myFun(void * p)
```
```python
//{
```
```python
//  for (int i = 0; i < 100; ++i)
```
```python
//  {
```
```python
//      EnterCriticalSection(&cs);
```
```python
//      ++num;
```
```python
//      LeaveCriticalSection(&cs);
```
```python
//  }
```
```python
//}
```
```python
//04.CreateThread();线程任务函数格式
```
```python
//  DWORD:unsigned long
```
```python
//  WINAPI:声明让操作系统来调度这条线程[操作系统调度标识]
```
```python
DWORD WINAPI myFun(
```
```python
void
```
```python
* p)
{
    EnterCriticalSection(&cs);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
    {
        ++num;
    }
    LeaveCriticalSection(&cs);
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    InitializeCriticalSection(&cs);
    time_t start, end;
    time(&start);
    HANDLE thArr[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
    {
        thArr[i] = CreateThread(NULL,
```
```python
0
```
```python
, myFun, NULL,
```
```python
0
```
```python
, NULL);
```
```python
//WaitForSingleObject(thArr[i], INFINITE);
```
```python
}
    WaitForMultipleObjects(
```
```python
100
```
```python
, thArr, TRUE, INFINITE);
    time(&end);
```
```python
printf
```
```python
(
```
```python
"difftime = %lf \n"
```
```python
, difftime(end, start));
```
```python
printf
```
```python
(
```
```python
"num = %d \n"
```
```python
, num);
    DeleteCriticalSection(&cs);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.临界区:
```
```python
//  CRITICAL_SECTION:处于"内核部位",它的实现是依赖于操作系统的"内核"
```
```python
//  所以这里创建线程的方式使用CreateThread();[系统特点&HANDLE]
```
```python
//02.由于CreateThread();函数来源于Windows内部,所以该函数的参数会很多,于是进行函数改良
```
```python
//  声明:DWORD WINAPI
```
```python
//  创建:CreateThread(NULL,0,myfun,NULL,0,NULL);
```
```python
//      NULL:附加信息,安全等级
```
```python
//      0:堆栈大小:
```
```python
//      myfun:函数指针
```
```python
//      NULL:参数列表
```
```python
//      0:优先等级
```
```python
//      NULL:线程编号
```
```python
//03.这儿的临界区还是存在一定的问题
```
程序片段(03):_beginthread.c
内容概要:**线程池**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
//01.创建线程的两种方式:
```
```python
//  实质:CreateThread();
```
```python
//  表象:_beginthread();
```
```python
//02.结束线程的三种方式:
```
```python
//  内部:
```
```python
//      endthread();
```
```python
//      exitthread();
```
```python
//  外部:
```
```python
//      terminate();
```
```python
//03.线程状态的两种控制方式:
```
```python
//  冻结:SuspendThread(hd);
```
```python
//  解冻:ResumeThread(hd);
```
```python
//04.CreateThread();创建线程所需线程函数格式:
```
```python
//  DWORD:unsigned long
```
```python
DWORD WINAPI myFun(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, i);
```
```python
if
```
```python
(i >
```
```python
8000
```
```python
)
            _endthread();
        Sleep(
```
```python
1000
```
```python
);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//05.主线程与辅助线程:
```
```python
//  1.主线程:处理主函数的线程
```
```python
//      在整个进程当中起到主导作用,管控整个进程内部的其它所有线程
```
```python
//  2.辅助线程:处理其它函数的线程
```
```python
//注:调试模式下,如果"断点"主线程,那么其它线程将会暂停运行状态
```
```python
//  暂停主线程就相当于占用了品目刷新线程,于是屏幕将不会发生变化
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    HANDLE th = CreateThread(NULL,
```
```python
0
```
```python
, myFun, NULL,
```
```python
0
```
```python
, NULL);
    system(
```
```python
"pause"
```
```python
);
    SuspendThread(th);
```
```python
//冻结
```
```python
system(
```
```python
"pause"
```
```python
);
    ResumeThread(th);
```
```python
//解冻
```
```python
system(
```
```python
"pause"
```
```python
);
```
```python
//ExitThread(0);//错误位置
```
```python
TerminateThread(th,
```
```python
0
```
```python
);
```
```python
//外部强行退出
```
```python
//_endthread();
```
```python
//system("pause");
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.操作线程:线程调度问题
```
```python
//      开启-->冻结-->解冻-->内部结束-->外部结束
```
```python
//02.重点内容:冻结&解冻
```
```python
//      操作单条线程
```
```python
//03.CreateThead();线程
```
```python
//  1.DWORD WINAPI&return 0;
```
```python
//  2.HANDLE hd=CreateThead(NULL,0,fun,NULL,0,NULL);
```
```python
//      NULL:安全等级
```
```python
//             0:堆栈大小,默认为0就是拷贝自身,每个线程的栈内存都是独立的,而非共享的
```
```python
//         fun:函数指针
```
```python
//     NULL:参数列表
```
```python
//            0:优先等级
```
```python
//    NULL:线程标识
```
```python
//04.管理调度线程池:
```
```python
//05.演示或者操作线程的时候,一般情况之下不要使用IDE进行演示:
```
```python
//  1.注意线程的优先等级
```
```python
//  2.关闭线程的特点[主线程与副线程的区别]
```
```python
//  3.进程依然存在:
```
```python
//      如果是程序自己结束就会自动结束所有线程并结束该进程,但是这个工具是应用
```
```python
//      底层操作系统内核驱动来完成的,所以它的操作方法比较高端,于是手动结束的时候
```
```python
//      线程挂掉,但是进程却没有退出
```
```python
//06.结束线程的三种方式:
```
```python
//  内部结束:_endthread();+exitthread();
```
```python
//  外部结束:terminatethread();
```
```python
//  全部结束:CloseThreadPool();//关闭线程池
```
```python
//07.冻结线程与解冻线程:
```
```python
//  SuspendThread();+ResumeThead();
```
```python
//08.强制结束一条线程:数据容易丢失
```
```python
//  自我结束语强行结束:return
```
```python
//  非强制:内部
```
```python
//      _endThread();//指定线程
```
```python
//      ExitThread(0);//默认参数
```
```python
//  强制:外部
```
```python
//      TerminateThead(hd,0):
```
```python
//          0代表退出的时候携带一个编号
```
```python
//09.线程内部的等待采用死循环进行实现
```
```python
//10.外部操作线程完毕
```
程序片段(04):01._beginthread.c+02.CreateThead.c
内容概要:**线程池**
```python
///01._beginthread.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <process.h>
```
```python
#include <Windows.h>
```
```python
//01.提取创建线程时期由创建函数传递给线程函数的参数:
```
```python
//  1.读取创建线程传递的参数列表,需要进行类型转换
```
```python
//  2.空类型的地址(干地址)-->强制类型转换-->获取数据
```
```python
void
```
```python
run(
```
```python
void
```
```python
* p)
{
```
```python
char
```
```python
str[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
};
```
```python
sprintf
```
```python
(str,
```
```python
"备胎%d"
```
```python
, *(
```
```python
int
```
```python
*)p);
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
, str);
}
```
```python
//02.防止多线程并发访问冲突的方式:
```
```python
//  1._beginthead(run,0,&a[i]);解释
```
```python
//      (1).多个线程不可以同时访问同一个地址,防止多线程访问冲突
```
```python
//      (2).参数列表说明:
```
```python
//          run:函数指针
```
```python
//              0:堆栈大小
```
```python
//        &a[i]:参数列表-->这儿的每条线程所访问到的数据都不一样
```
```python
//          独立访问而非并发访问
```
```python
//  2._beingthead();函数的返回值是int类型
```
```python
//      因此_beginthread();和CreateThread();所采取的控制多线程
```
```python
//      异步操作的方式不一样(一个是int类型的数组,一个是HANDLE类型的数组)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
int
```
```python
id = _beginthread(run,
```
```python
0
```
```python
, &arr[i]);
        WaitForSingleObject(id,
```
```python
300
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.CreateThead.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
DWORD WINAPI myFun01(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        printf(
```
```python
"%d \n"
```
```python
, i);
        Sleep(
```
```python
1000
```
```python
);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    HANDLE th = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, myFun01,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    system(
```
```python
"pause"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
DWORD WINAPI myFun02(
```
```python
void
```
```python
* p)
{
```
```python
char
```
```python
str[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
};
    sprintf(str,
```
```python
"备胎%d"
```
```python
, *(
```
```python
int
```
```python
*)p);
    MessageBoxA(
```
```python
0
```
```python
, str, str,
```
```python
0
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//01.CreateThread();方式创建线程详解:
```
```python
//  1.控制多条线程异步执行状态的所需数组:
```
```python
//      HANDLE类型的句柄数组
```
```python
//  2.创建线程所需的参数说明:
```
```python
//      NULL:安全属性集
```
```python
//             0:堆栈尺寸,默认拷贝主线程的栈大小,栈独立
```
```python
//      myfun:函数指针
```
```python
//          a+i:参数地址
```
```python
//              0:优先等级
```
```python
//      NULL:线程编号
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
arr[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
};
    HANDLE thArr[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        thArr[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, myFun02, thArr + i,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//WaitForSingleObject(thArr[i], INFINITE);
```
```python
}
    WaitForMultipleObjects(
```
```python
10
```
```python
, thArr,
```
```python
FALSE
```
```python
, INFINITE);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):多线程.c
内容概要:**操作一条线程**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
//01.创建一条线程的两种方式:
```
```python
//  底层方式:CreateThread();
```
```python
//  表象方式:_beginthread();
```
```python
//02.结束一条线程的三种方式:
```
```python
//  内部方式:_endthread();+ExitThread();
```
```python
//  外部方式:TerminateThread();
```
```python
//03.线程状态控制的两种方式:
```
```python
//  冻结:SuspendThread();
```
```python
//  解冻:ResumeThread();
```
```python
DWORD WINAPI myFun(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, i);
```
```python
while
```
```python
(++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, i);
```
```python
if
```
```python
(i >
```
```python
8000
```
```python
)
        {
```
```python
//_endthread();
```
```python
//ExitThread(0);
```
```python
}
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    HANDLE th = CreateThread(NULL,
```
```python
0
```
```python
, myFun, NULL,
```
```python
0
```
```python
, NULL);
    system(
```
```python
"pause"
```
```python
);
    SuspendThread(th);
    system(
```
```python
"pause"
```
```python
);
    ResumeThread(th);
    system(
```
```python
"pause"
```
```python
);
    TerminateThread(th,
```
```python
0
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):临界区.c
内容概要:**线程临界区解决线程冲突**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.临界区的使用与操作系统调度线程相关:
```
```python
//  所有线程的本质调度还是得依赖于操作系统本身
```
```python
//  #include <Windows.h>--->临界区结构体
```
```python
#define N 20
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
//02.临界区结构体变量:
```
```python
//  1.一个用于收钱,一个用于用钱
```
```python
//  2.定义为全局变量的原因是:
```
```python
//      为了让多条线程识别同一临界区
```
```python
CRITICAL_SECTION cs1;
CRITICAL_SECTION cs2;
```
```python
//03.对临界区的优化操作:
```
```python
//  减少频繁的进出临界区的次数;
```
```python
//  有利于提高多线程并发访问的效率
```
```python
DWORD WINAPI add(
```
```python
void
```
```python
* p)
{
    EnterCriticalSection(&cs1);
```
```python
//减少进出
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10000
```
```python
; ++i)
    {
```
```python
//EnterCriticalSection(&cs1);//频繁进出
```
```python
++num;
```
```python
//LeaveCriticalSection(&cs1);//效率低下
```
```python
}
    LeaveCriticalSection(&cs1);
```
```python
//效率提升
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//04.使用临界区的注意事项:
```
```python
//  1.临界区结构体变量必须是全局变量
```
```python
//  2.临界区结构体变量最好不要嵌套使用
```
```python
DWORD WINAPI sub(
```
```python
void
```
```python
* p)
{
    EnterCriticalSection(&cs2);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10000
```
```python
; ++i)
    {
        --num;
    }
    LeaveCriticalSection(&cs2);
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
//01.初始化临界区结构体变量
```
```python
InitializeCriticalSection(&cs1);
    InitializeCriticalSection(&cs2);
```
```python
//02.匿名代码块儿的使用方式:
```
```python
//  划分区域执行代码(复用代码)
```
```python
//03.要想多线程异步执行状态:
```
```python
//  需要使用多线程句柄数组
```
```python
{
        HANDLE thArr[N] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
        {
            thArr[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, add,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//WaitForSingleObject(thArr[i], INFINITE);
```
```python
}
        WaitForMultipleObjects(N, thArr,
```
```python
TRUE
```
```python
, INFINITE);
        printf(
```
```python
"num = %d \n"
```
```python
, num);
    }
    {
        HANDLE thArr[N] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
        {
            thArr[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, sub,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
        }
        WaitForMultipleObjects(N, thArr,
```
```python
TRUE
```
```python
, INFINITE);
        printf(
```
```python
"num = %d \n"
```
```python
, num);
    }
```
```python
//04.释放临界区结构体变量
```
```python
DeleteCriticalSection(&cs1);
    DeleteCriticalSection(&cs2);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.什么是临界区?
```
```python
//  1.临界区是用于解决多线程并发访问冲突问题的
```
```python
//  2.包括Cocos2dx当中的C++封装线程,基本上都是
```
```python
//      我们现在所使用的同步方式(这里的线程操作方式就是实质)
```
```python
//  3.临界区所支持的最大线程个数为64,Windows操作系统之上
```
```python
//      线程个数限制,但是服务器操作系统上面没有限制
```
```python
//  4.临界区的使用步骤:
```
```python
//      创建-->初始化-->进入-->离开-->删除
```
```python
//02.线程通信-->进程通信:
```
```python
//      并发访问错误:收钱特点,收不过来之后
```
```python
//03.防止多线程并发访问错误:
```
```python
//  1.WaitForSingleObject(hd[i]);等待单个线程逐个退出-->缺点:效率低下
```
```python
//  2.避免多线程并发访问问题,并且提高多线程操作效率的方式:
```
```python
//      临界区-->跑到最近的位置-->逐个给钱[以前的情况是一个一个的处理]
```
```python
//          临界区&互斥量
```
```python
//04.临界区的完整使用过程:
```
```python
//  创建临界区:全局声明
```
```python
//      CRITICAL_SECTION cs;
```
```python
//  初始化临界区:Main();
```
```python
//      InitializeCriticalSection(&cs);
```
```python
//  使用临界区:
```
```python
//      进入:EnterCriticalSection();
```
```python
//      退出:LeaveCriticalSection();
```
```python
//  释放临界区:DeleteCriticalSection();
```
```python
//      1.因为临界区结构体变量内部存在指针情况,会耗费内存,所以需要释放临界区
```
```python
//      2.还有原因就是因为我们这里申请的是操作系统调度(避免过度占用操作操作系统资源)
```
```python
//05.线程库的初始化特点:
```
```python
//  C语言不会自动进行初始化,C++会进行自动的初始化动作
```
```python
//06.解决多线程并发访问冲突的两种方式最大特点:
```
```python
//  同步方式:
```
```python
//      1.效率低下
```
```python
//      2.一次只有一条线程处于执行状态
```
```python
//  临界方式:
```
```python
//      1.效率优化
```
```python
//      2.一次拥有多条线程处于执行状态
```
```python
//注:临界方式一次有(N-1)条线程处于等待执行状态,但是总有一条是处于执行状态
```
```python
//注:同步方式和临界方式最大的区别就在于处于等待执行状态的线程数目不同
```
```python
//      同步方式:没有等待执行状态的线程
```
```python
//      临界方式:用于等待执行状态的线程
```
```python
//  相当于一个有预热状态,一个没有预热状态!
```
程序片段(07):01.事件.c+02.事件.c+03.事件.c
内容概要:**线程通信事件机制**
```python
///01.事件.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.事件:确定为3个
```
```python
HANDLE eventArrA[
```
```python
3
```
```python
] = {
```
```python
0
```
```python
};
HANDLE threadArrA[
```
```python
3
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//02.同步:两个线程-->三个线程-->多个线程
```
```python
DWORD WINAPI firstThread(
```
```python
void
```
```python
* p)
{
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"1"
```
```python
,
```
```python
"1"
```
```python
,
```
```python
0
```
```python
);
    printf(
```
```python
"第一个线程执行完毕! \n"
```
```python
);
    SetEvent(eventArrA[
```
```python
0
```
```python
]);
```
```python
//设置事件(发出Event通知)
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//03.事件用于多条线程之间的通信:
```
```python
//  可以用于控制多线程的情况之下,各条线程之间的执行顺序
```
```python
//注:设置事件相当于发出通知,等待事件相当于处理通知
```
```python
DWORD WINAPI secondThread(
```
```python
void
```
```python
* p)
{
```
```python
//等待一个事件执行完毕[等待Event信号的出现,再执行下一步操作]
```
```python
WaitForSingleObject(eventArrA[
```
```python
0
```
```python
], INFINITE);
```
```python
//处理事件(等待Event通知)
```
```python
MessageBoxA(
```
```python
0
```
```python
,
```
```python
"2"
```
```python
,
```
```python
"2"
```
```python
,
```
```python
0
```
```python
);
    printf(
```
```python
"第二个线程执行完毕! \n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
```python
//04.句柄类型:
```
```python
//  创建事件的方式+创建线程的方式
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//1.初始化事件参数:
```
```python
//  NULL:安全等级+TRUE:人为设定+FALSE:触发状态+NULL:事件名称
```
```python
eventArrA[
```
```python
0
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    eventArrA[
```
```python
1
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//2.两条线程并行弹出盒子,现在需要控制线程的执行顺序:
```
```python
threadArrA[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, firstThread,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArrA[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, secondThread,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//3.维持多线程异步执行状态:
```
```python
WaitForMultipleObjects(
```
```python
2
```
```python
, threadArrA,
```
```python
TRUE
```
```python
, INFINITE);
    printf(
```
```python
"全部等待完成! \n"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.线程同步的问题:
```
```python
//  1.服务器当中的多条线程:
```
```python
//      (1).将外部数据写入到本地文件
```
```python
//      (2).从本地文件读取数据到内存
```
```python
//  2.相关问题:
```
```python
//      (1).没有写入之前无法进行读取
```
```python
//      (2).但是这两条线程是同时开启的
```
```python
//  3.模型:
```
```python
//      (1).文本-->写入-->读取[配置文件特点]
```
```python
//      (2).先写入本地文件,再进行本地文件读取
```
```python
//      (3).同时开启的时候,就需要进行多线程通信,以确保线程的执行流程
```
```python
//02.线程通信:事件机制[用于管理线程通信]
```
```python
//  1.同时启动的两条线程,将会任意确定执行顺序,所以需要线程调度
```
```python
//  2.实现时间等待的特点(线程通信)
```
```python
//03.事件用作通知:CreateEvent();事件处理机制
```
```python
//  A:默认的安全设定0
```
```python
//  B:TRUE人工设定&FALSE自动设定
```
```python
//  C:是否进入到触发状态
```
```python
//  D:事件名称
```
```python
//04.执行流程:聊天儿系统[多事件处理]
```
```python
//  1.等待执行原理的使用
```
```python
//  2.创建事件,线程都是在主函数内完成
```
```python
//      (1).事件必须是全局变量(多条线程访问统一标识!)
```
```python
//      (2).线程必须是全局变量(任意函数都可以创建线程)
```
```python
//      (3)SetEvent(e);WaitForSingleObject(e);
```
```python
//          设置(触发)+等待(处理)<->发出通知+处理通知
```
```python
//05.聊天儿系统原理:
```
```python
//  1.多个时间连续
```
```python
//  2.多层嵌套问题
```
```python
///02.事件.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
HANDLE threadArrB[
```
```python
3
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//多线程处理
```
```python
HANDLE eventArrB[
```
```python
4
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//线程通信
```
```python
//01.全局变量:所有线程使用同一临界区标识
```
```python
//  用于解决全局的多线程并发访问冲突问题
```
```python
CRITICAL_SECTION csB;
```
```python
//线程互斥
```
```python
//02.全局变量:多线程之间的通信内容
```
```python
//  1.代表聊条儿内容的缓冲区
```
```python
//  2.memset(str, '\0', 1024);
```
```python
//      暂时用不到,三方通话机制需要使用
```
```python
//  3.三方通信原理:中介者设计模式
```
```python
//      海华和芳芳不会直接接触的特点;
```
```python
//      都是通过媒婆进行间接接触的特点
```
```python
char
```
```python
strB[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//通信内容
```
```python
//03.三方通信原理简介:
```
```python
//  海华-->媒婆(设置事件0)
```
```python
//      媒婆(处理事件0)
```
```python
//  媒婆-->芳芳(设置事件1)
```
```python
//      芳芳(处理事件0)
```
```python
//  芳芳-->媒婆(设置事件2)
```
```python
//      媒婆(处理事件2)
```
```python
//  媒婆-->海华(设置事件3)
```
```python
//      海华(处理事件3)
```
```python
DWORD WINAPI haiHuaB(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
    EnterCriticalSection(&csB);
    memset(strB,
```
```python
'\0'
```
```python
,
```
```python
1024
```
```python
);
```
```python
//防止并发访问冲突
```
```python
sprintf(strB,
```
```python
"haiHua第%d次说:i love you fangfang! \n"
```
```python
, i);
```
```python
//三方通信
```
```python
LeaveCriticalSection(&csB);
    Sleep(
```
```python
1000
```
```python
);
```
```python
//不会占用过多的互斥时间(模拟数据生成时间)
```
```python
SetEvent(eventArrB[
```
```python
0
```
```python
]);
```
```python
//发出通知
```
```python
//00:模拟第一次的数据设置(通信主动发出者:主动者)
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrB[
```
```python
3
```
```python
], INFINITE);
```
```python
//等待通知(必须等待)
```
```python
EnterCriticalSection(&csB);
        memset(strB,
```
```python
'\0'
```
```python
,
```
```python
1024
```
```python
);
```
```python
//内容清空
```
```python
sprintf(strB,
```
```python
"haiHua第%d次说:i love you fangfang! \n"
```
```python
, i);
        LeaveCriticalSection(&csB);
        Sleep(
```
```python
1000
```
```python
);
```
```python
//模拟现实
```
```python
SetEvent(eventArrB[
```
```python
0
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI ruiFuB(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrB[
```
```python
0
```
```python
], INFINITE);
        EnterCriticalSection(&csB);
        printf(
```
```python
"媒婆给HaiHua传递:%s \n"
```
```python
, strB);
        LeaveCriticalSection(&csB);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArrB[
```
```python
1
```
```python
]);
        WaitForSingleObject(eventArrB[
```
```python
2
```
```python
], INFINITE);
        EnterCriticalSection(&csB);
        printf(
```
```python
"媒婆传递FangFang:%s \n"
```
```python
, strB);
        LeaveCriticalSection(&csB);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArrB[
```
```python
3
```
```python
]);
    }
```
```python
//WaitForSingleObject(eventArrB[0], INFINITE);
```
```python
//printf("%s \n", strB);
```
```python
//SetEvent(eventArrB[1]);
```
```python
//WaitForSingleObject(eventArrB[2], INFINITE);
```
```python
//printf("%s \n", strB);
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI fangFangB(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArrB[
```
```python
1
```
```python
], INFINITE);
        EnterCriticalSection(&csB);
        memset(strB,
```
```python
'\0'
```
```python
,
```
```python
1024
```
```python
);
        sprintf(strB,
```
```python
"fangFang第%d次说:i love you haihua! \n"
```
```python
, i);
        LeaveCriticalSection(&csB);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArrB[
```
```python
2
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    InitializeCriticalSection(&csB);
    eventArrB[
```
```python
0
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    eventArrB[
```
```python
1
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    threadArrB[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, haiHuaB,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArrB[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, ruiFuB,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArrB[
```
```python
2
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, fangFangB,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    WaitForMultipleObjects(
```
```python
3
```
```python
, threadArrB,
```
```python
TRUE
```
```python
, INFINITE);
    printf(
```
```python
"over!!! \n"
```
```python
);
    DeleteCriticalSection(&csB);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.双方通信的原理:你发一条,我收一条,然后我再发送一条给你,你接收我一条
```
```python
//02.显示模块儿抽离出来之后,就是一个单独的函数,用于展示内容
```
```python
//  1.同时做两个检测,三个信号-->防止操作系统死锁
```
```python
//  2.说话的同时i需要进行通知,逐级进行通知
```
```python
//  3.原理:说话+通知[Show进行通知]-->三部曲
```
```python
//  4.大家都在等待Show-->中介者模式&媒婆模式
```
```python
//03.流程分析:
```
```python
//  haihua发送消息-->媒婆接收消息
```
```python
//  媒婆收到消息-->媒婆通知芳芳
```
```python
//04..中介者模式:
```
```python
//  1.haihua-->发出信号0
```
```python
//  2.zhongjiezhe-->等待信号0--发出信号1
```
```python
//  3.wangfang-->等待信号1--发出信号2
```
```python
//  4.zhongjiezhe-->等待信号2-->发出信号3
```
```python
//  5.haihua-->等待信号3--发出信号0
```
```python
//05.事件审批逐级审批原理
```
```python
//  用于多条线程之间的逐级通信
```
```python
///03.事件.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.HANDLE:操作系统提供的句柄标识,原始类型为(void *)
```
```python
HANDLE threadArr[
```
```python
3
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//线程句柄数组
```
```python
HANDLE eventArr[
```
```python
4
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//事件句柄数组
```
```python
//02.CRITICAL_SECTION:操作系统内核提供的临界区结构体变量
```
```python
CRITICAL_SECTION cs = {
```
```python
0
```
```python
};
```
```python
//临界区全局变量:整个多线程体系都能够识别的唯一标识
```
```python
char
```
```python
str[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//全局信息公告栏{代表聊天内容的缓冲区}
```
```python
//03.中介者设计模式原理:
```
```python
//  海华向媒婆 设置事件0
```
```python
//      媒婆从海华 等待事件0
```
```python
//  媒婆向芳芳 设置事件1
```
```python
//      芳芳从媒婆 等待事件1
```
```python
//  芳芳向媒婆 设置事件2
```
```python
//      媒婆从芳芳 等待事件2
```
```python
//  媒婆向海华 设置事件3
```
```python
//      海华从媒婆 等待事件3
```
```python
//  海华向媒婆 设置事件0
```
```python
DWORD WINAPI haiHua(
```
```python
void
```
```python
*p)
```
```python
//WINAPI:操作系统提供的待调度标识
```
```python
{
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
//标识海华主动发言
```
```python
EnterCriticalSection(&cs);
```
```python
//进入临界区
```
```python
memset(str,
```
```python
'\0'
```
```python
,
```
```python
1024
```
```python
);
```
```python
//内容清空
```
```python
sprintf(str,
```
```python
"haiHua第%d次说:i love you Fang! \n"
```
```python
, i);
```
```python
//发言内容
```
```python
LeaveCriticalSection(&cs);
```
```python
//离开临界区
```
```python
Sleep(
```
```python
1000
```
```python
);
```
```python
//模拟现实通信事件间隔
```
```python
SetEvent(eventArr[
```
```python
0
```
```python
]);
```
```python
//发出事件通知0
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArr[
```
```python
3
```
```python
], INFINITE);
```
```python
//等待事件通知3
```
```python
EnterCriticalSection(&cs);
        memset(str,
```
```python
'\0'
```
```python
,
```
```python
1024
```
```python
);
        sprintf(str,
```
```python
"\nhaiHua第%d次说:i love you Fang! \n"
```
```python
, i);
        LeaveCriticalSection(&cs);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArr[
```
```python
0
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI ruiFu(
```
```python
void
```
```python
*p)
{
```
```python
//中介者不断进行扫描等待线程通信信息
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
int
```
```python
flag =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
```
```python
if
```
```python
(!flag)
        {
```
```python
//判断通信内容发送方
```
```python
WaitForSingleObject(eventArr[
```
```python
0
```
```python
], INFINITE);
            EnterCriticalSection(&cs);
            printf(
```
```python
"媒婆传递%d次信息%s \n"
```
```python
, i, str);
            LeaveCriticalSection(&cs);
            Sleep(
```
```python
1000
```
```python
);
            SetEvent(eventArr[
```
```python
1
```
```python
]);
            flag =
```
```python
1
```
```python
;
```
```python
//发送方判定标识切换
```
```python
}
```
```python
else
```
```python
{
            WaitForSingleObject(eventArr[
```
```python
2
```
```python
], INFINITE);
            EnterCriticalSection(&cs);
            printf(
```
```python
"媒婆传递%d次信息%s \n"
```
```python
, i, str);
            LeaveCriticalSection(&cs);
            Sleep(
```
```python
1000
```
```python
);
            SetEvent(eventArr[
```
```python
3
```
```python
]);
            flag =
```
```python
0
```
```python
;
        }
    }
```
```python
return
```
```python
0
```
```python
;
}
DWORD WINAPI fangFang(
```
```python
void
```
```python
*p)
{
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(++i)
    {
        WaitForSingleObject(eventArr[
```
```python
1
```
```python
], INFINITE);
        EnterCriticalSection(&cs);
        memset(str,
```
```python
'\0'
```
```python
,
```
```python
1024
```
```python
);
        sprintf(str,
```
```python
"fangFang第%d次说:i love you too! \n"
```
```python
, i);
        LeaveCriticalSection(&cs);
        Sleep(
```
```python
1000
```
```python
);
        SetEvent(eventArr[
```
```python
2
```
```python
]);
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
main03()
{
```
```python
//01.初始化临界区结构体变量
```
```python
InitializeCriticalSection(&cs);
```
```python
//02.初始化事件句柄数组
```
```python
eventArr[
```
```python
0
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    eventArr[
```
```python
1
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    eventArr[
```
```python
2
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    eventArr[
```
```python
3
```
```python
] = CreateEvent(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//03.创建并执行多条异步线程
```
```python
threadArr[
```
```python
0
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, haiHua,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArr[
```
```python
2
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, ruiFu,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    threadArr[
```
```python
1
```
```python
] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, fangFang,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//04.等待除中介者之外其他的线程执行完毕之后,结束多线程状态
```
```python
WaitForMultipleObjects(
```
```python
2
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    printf(
```
```python
"over"
```
```python
);
```
```python
//05.释放临界区结构体变量:指针&操作系统调度
```
```python
DeleteCriticalSection(&cs);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(08):线程冲突.c
内容概要:**线程互相排斥**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.全局变量:表示多线程异步并发访问的通信内容
```
```python
//  极度容易导致多线程并发访问同一内容的冲突性
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
//02.互斥量:实质为(void *)类型的空类型地址变量
```
```python
//  1.同一个互斥量最多能够解决64个线程以内的多线程异步并发访问
```
```python
//      所导致的冲突问题(这个限制仅仅只是针对于Windows操作系统)
```
```python
//      (针对于服务器之上的多线程异步并发访问线程数没有限制)
```
```python
//  2.互斥量和临界区的作用相同:
```
```python
//      同是用于解决多线程异步并发访问所导致的冲突问题!
```
```python
HANDLE mutex =
```
```python
NULL
```
```python
;
DWORD WINAPI add(
```
```python
void
```
```python
* p)
{
    WaitForSingleObject(mutex, INFINITE);
```
```python
//添加互斥状态
```
```python
if
```
```python
(
```
```python
NULL
```
```python
== mutex)
    {
```
```python
//添加互斥出错
```
```python
printf(
```
```python
"添加线程互斥量失败! \n"
```
```python
);
        abort();
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10000
```
```python
; ++i)
    {
        ++num;
    }
    ReleaseMutex(mutex);
```
```python
//解除互斥状态
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    mutex = CreateMutex(
```
```python
NULL
```
```python
,
```
```python
FALSE
```
```python
,
```
```python
NULL
```
```python
);
    HANDLE threadArr[
```
```python
64
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
64
```
```python
; ++i)
    {
        threadArr[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, add,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
if
```
```python
(
```
```python
NULL
```
```python
== threadArr[i])
        {
            printf(
```
```python
"线程创建失败! \n"
```
```python
);
        }
    }
    WaitForMultipleObjects(
```
```python
64
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    printf(
```
```python
"num = %d \n"
```
```python
, num);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
64
```
```python
; ++i)
    {
        CloseHandle(threadArr[i]);
```
```python
//关闭每条线程所占用的资源
```
```python
}
    CloseHandle(mutex);
```
```python
//关闭互斥量所占用的资源
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.多线程互斥量问题:线程之间互相排斥
```
```python
//  1.临界区-->互斥量-->设计模式:队列传递强化
```
```python
//  2.互斥量:和临界区一个作用,用于解决线程冲突问题
```
```python
//注:临界区解决代码段儿互斥+互斥量解决共享资源互斥访问
```
```python
//02.互斥量的缺点:
```
```python
//  1.当我们所需操作的线程个数超过64个的时候就不行了
```
```python
//  2.所有的线程都有数量限制,你在一定数量之下都处于正常情况,
```
```python
//          一定数量之上就不会正常了[冲突临界的线程数目限制]
```
```python
//03.使用互斥量的步骤:
```
```python
//      声明互斥量:全局变量
```
```python
//          HANDLE mutex = NULL;
```
```python
//      初始化互斥量:
```
```python
//          mutex = CreateMutex(NULL,FALSE,NULL);
```
```python
//      使用互斥量:
```
```python
//          等待:WaitForSingleObject(mutex,INFINITE);//添加互斥状态
```
```python
//          释放:ReleaseMutex(mutex);//解除互斥状态
```
```python
//      关闭互斥量:
```
```python
//          CloseHandle(mutex);
```
程序片段(09):01.Run.c+02.原子变量与原子操作.c
内容概要:**原子变量与原子操作**
```python
///01.Run.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.关于调试(Debug)和发行(Release)状态特点:
```
```python
//  Debug:不会进行代码自动优化操作
```
```python
//  Release:会进行代码自动优化操作
```
```python
//02.关于register和volatile两个关键字:
```
```python
//  register:将内存变量移植为寄存器变量(寄存器变量标识)
```
```python
//  volatile:防止内存变量移植为寄存器变量(内存变量标识)
```
```python
//03.for(int i = 0; i < INT_MAX; ++i){}:
```
```python
//  当前这段儿代码在编译器Release发行模式之下,将会在
```
```python
//  内存变量第一次移植到寄存器之后,不在频繁读写内存变量
```
```python
//原因:一直使用同一内存变量+循环执行体没有操作该内存变量
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
for
```
```python
(
```
```python
volatile
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < INT_MAX; ++i) {}
    printf(
```
```python
"over"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.区分编译器的优化与非优化情况:
```
```python
//  1.早期编译器和近期编译器:
```
```python
//      早期编译器不会优化,近期编译器会涉及优化
```
```python
//  2.Debug模式和Release模式:
```
```python
//      Debug模式下会优化(操作寄存器),Release模式不会优化(操作内存)
```
```python
//注:根据地址访问数据相当于强制读取内存操作(volatile操作)
```
```python
volatile
```
```python
int
```
```python
num =
```
```python
20
```
```python
;
DWORD WINAPI rmsg(
```
```python
void
```
```python
* p)
{
```
```python
//多线程读取
```
```python
//int * px = p;
```
```python
int
```
```python
* px = (
```
```python
int
```
```python
*)p;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
//printf("%d \n", *px);//当心这儿的副本机制
```
```python
//int data = *px;//根据地址读取数据,相当于强制读取内存
```
```python
printf(
```
```python
"%d \n"
```
```python
, num);
        Sleep(
```
```python
1000
```
```python
);
    }
}
DWORD WINAPI  wmsg(
```
```python
void
```
```python
* p)
{
```
```python
//多线程写入
```
```python
int
```
```python
* px = (
```
```python
int
```
```python
*)p;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
        *px +=
```
```python
1
```
```python
;
        Sleep(
```
```python
1000
```
```python
);
    }
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, wmsg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, wmsg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, wmsg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, rmsg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.原子变量主要用于解决什么样儿的问题?
```
```python
//  还是一样的问题,多线程异步并发访问冲突问题(效率最高)
```
```python
//02.三方互相通信-->技术含量最高-->会使用到所有的多线程知识
```
```python
//      只是:临界区,互斥量,原子变量等等...
```
```python
//03.原子变量:Atomitic
```
```python
//      不可拆解的变量-->变量修改问题:两个变量同时访问一个
```
```python
//      第三方变量,造成最终的访问结果不正确(因此需要限定原子访问)
```
```python
//04.volatile:
```
```python
//      Debug模式:
```
```python
//      Release模式:代码优化作用,主要解决代码更快的效果
```
```python
//          代码优化:让你的代码更快,发现该变量在寄存器当中
```
```python
//          没有相应的操作,于是就直接读取内存当中的数据
```
```python
//05.Realese:实现无线等待的方式
```
```python
//06.操作系统操作所有的变量都是依赖于寄存器的:
```
```python
//      寄存器读取副本-->强制读取寄存器当中的数据
```
```python
//      寄存器当中的原始副本-->与内存当中的普通副本
```
```python
//      寄存器原始与副本[区分寄存器副本与内存副本]
```
```python
//07.当指针指向一个变量之后,操作指针就等同于操作原本
```
```python
//      注意副本机制
```
```python
//08.不同编译器的演示使用
```
```python
//      多线程现代编译器的优化特性
```
```python
//09.寄存器变量与内存变量:
```
```python
//  register + volatile
```
```python
//注:强制读写内存的情况之下等同于寄存器和内存状态实时对应!
```
```python
///02.原子变量与原子操作.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.全局变量:用于表示多线程异步并发访问之间的通信信息
```
```python
//  1.对于全局变量的访问分为两种(一种是写入,一种是读取):
```
```python
//      针对于写入操作,会发生多线程异步并发访问冲突问题
```
```python
//      针对于读取操作,不会发生多线程异步并发访问冲突 问题
```
```python
//  2.解决多线程异步执行并发访问操作的冲突问题:
```
```python
//      临界区:用于代码段儿
```
```python
//      互斥量:用于共享变量
```
```python
//      原子量:用于单独变量
```
```python
//注:事件通知是用于线程之间的通信,例如让多条线程按照指定
```
```python
//      的顺序进行代码段儿的执行
```
```python
//注:原子操作的速度要快于互斥量和临界区的操作
```
```python
//  1.因此,一般情况之下,如果多个线程同时访问一个变量,就建议
```
```python
//      采用原子变量
```
```python
//  2.简单的原理:
```
```python
//      int类型的变量操作-->其它类型的操作-->线程安全问题
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
//02.对于当前这个线程任务代码函数的剖析:
```
```python
//  1.这儿的++num翻译为汇编语言,以便于看清实质
```
```python
//  2.翻译为汇编语言之后,就不只是一条执行语句了:
```
```python
//      (1).先将该内存变量载入进寄存器当中,形成寄存器变量
```
```python
//      (2).接着调用完成执行++num;操作
```
```python
//      (3).再将运算完成之后的结果返回到内存当中
```
```python
//  3.因此++num;这条代码真实的运行操作其实是三条语句
```
```python
//      体现了非原子性,因此容易出现多线程异步并发访问问题
```
```python
//  4.由此,退出了原子变量的概念,相当于将这三个操作打包为
```
```python
//      一个整体操作,多线程情况之下的同一时刻,只能由一条线
```
```python
//      程进行访问操作!
```
```python
//  5.C和CPP包括游戏里面都提供了这种原子变量的操作机制:
```
```python
//      原子变量的操作方法
```
```python
//03.原子操作的方式分类:
```
```python
//  1.分"类型"进行处理
```
```python
//  2.分"写入"和"读取"进行处理
```
```python
//  3.分"增加"和"减少"进行处理
```
```python
//  4.分"原本"和"副本"进行分类
```
```python
//注:这里边需要一个volatile类型的指针,用于强制读写内存
```
```python
DWORD WINAPI runX(
```
```python
void
```
```python
* p)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10000
```
```python
; ++i)
    {
```
```python
//++num;
```
```python
//InterlockedIncrement(&num);//(++num) or (num++)
```
```python
//InterlockedIncrement(&num, 1);//可指明递增数
```
```python
//InterlockedExchange(&num);//可修改性
```
```python
//InterlocakedAdd(&num);//改变的是副本,原本不会发生改变
```
```python
InterlocakedExchangeAdd(&num,
```
```python
1
```
```python
);
```
```python
//原本会发生改变
```
```python
}
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    HANDLE threadArr[
```
```python
50
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
50
```
```python
; ++i)
    {
        threadArr[i] = CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, runX,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    }
    WaitForMultipleObjects(
```
```python
50
```
```python
, threadArr,
```
```python
TRUE
```
```python
, INFINITE);
    printf(
```
```python
"num = %d \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.原子变量与原子操作(C++概念)
```
```python
//  同样用于解决线程安全问题
```
```python
//02.原子变量主要解决什么样的问题?
```
```python
//  多个线程并发访问一个全局变量常常都会发生一定的问题
```
```python
//  所以需要进行解决(原子操作:不可分割的操作!)
```
```python
//03.C语言当中的0和NULL在数值方面是完全等价的
```
```python
//  只是一个具备地址层面的意义,一个不具有
```
```python
//04.为了精确控制全局变量的多线程并发访问问题:
```
```python
//  需要进行控制访问特性
```
```python
//5.什么是线程安全?
```
```python
//      纯C编写的-->C++编写-->多线程必须
```
程序片段(10):main.c
内容概要:**volatile**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <limits.h>
```
```python
#include <Windows.h>
```
```python
int
```
```python
num =
```
```python
1120
```
```python
;
```
```python
//现代编译器:自动优化内存变量为寄存器变量
```
```python
DWORD WINAPI rmsg(
```
```python
void
```
```python
*p)
{
```
```python
//读取
```
```python
int
```
```python
* px = (
```
```python
int
```
```python
*)p;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
//int data = *px;//等同于强制读内存
```
```python
printf(
```
```python
"\n%d"
```
```python
, num);
        Sleep(
```
```python
1000
```
```python
);
    }
}
DWORD WINAPI wmsg(
```
```python
void
```
```python
*p)
{
```
```python
//写入
```
```python
int
```
```python
* px = (
```
```python
int
```
```python
*)p;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
        *px +=
```
```python
1
```
```python
;
        Sleep(
```
```python
10000
```
```python
);
    }
}
```
```python
void
```
```python
main01()
{
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, msg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, msg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, msg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
    CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, cmsg, &num,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);

    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(11):Time.c
内容概要:**时间同步**
```python
#include
```
```python
<
```
```python
stdio
```
```python
.
```
```python
h
```
```python
>
```
```python
#include
```
```python
<
```
```python
stdlib
```
```python
.
```
```python
h
```
```python
>
```
```python
#include
```
```python
<
```
```python
Windows
```
```python
.
```
```python
h
```
```python
>
```
```python
//01.时间同步:定时器操作
```
```python
//  1.由于操作系统自带时间定时器,因此不用为程序独立创建时间定时器:
```
```python
//      利用已存在的资源,避免过多的占用资源
```
```python
//  2.定时器的实质还是一种事件通知机制:
```
```python
//      在定时器到达了某一个指定刻度之后,发出某个事件通知
```
```python
//注:需要检测定时器的创建成功和失败情况!
```
```python
//02.定时器编程特点剖析:
```
```python
//  1.定时器的精准性,精确到小数点儿之后的第7位
```
```python
//  2.由于一个联合体,因此能够进行时间精准度的设定
```
```python
//注:timer描述时间刻度非常精准
```
```python
int main01(
```
```python
void
```
```python
)
{
```
```python
HANDLE
```
```python
timer
```
```python
=
```
```python
CreateWaitableTimer(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
NULL
```
```python
);
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
timer)
    {
        printf(
```
```python
"定时器创建失败! \n"
```
```python
);
```
```python
abort
```
```python
();
    }
    LARGE_INTEGER time;
```
```python
//-5000 000 0 :毫秒-->微妙-->0.1微妙
```
```python
time
```
```python
.
```
```python
QuadPart
```
```python
=
```
```python
-
```
```python
20000000
```
```python
;
```
```python
//延迟2秒启动
```
```python
//10^-7方秒-->等待功能
```
```python
//设置定时器等待两秒
```
```python
SetWaitableTimer(timer,
```
```python
&
```
```python
time,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//设置时间
```
```python
//接收一个消息
```
```python
if
```
```python
(WAIT_OBJECT_0
```
```python
==
```
```python
WaitForSingleObject(timer, INFINITE))
    {
        printf(
```
```python
"等待成功! \n"
```
```python
);
    }
```
```python
else
```
```python
{
        printf(
```
```python
"等待失败! \n"
```
```python
);
    }
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
//01.单线程每隔两秒做一件事情,没机会做其他事情
```
```python
//  这个叫做线程占用
```
```python
//02.通过操作系统进行线程的管理,时间进行指定
```
```python
//  1.操作系统自动管理线程,通过时间进行检测
```
```python
//  2.时间同步是操作系统进行的管理
```
```python
//      操作系统原理:每打开一个窗口都一个地址
```
```python
//          (1)操作系统管理原理是通过链表进行管理
```
```python
//          (2)操作系统内部有一个死循环,不断的进行检测
```
```python
//      while(1)
```
```python
//      {读到:键盘,鼠标操作的信息}
```
```python
//      扫描信息-->消息传给窗口
```
```python
//      操作-->消息[线程管理]-->本质操作
```
```python
//03.时间统一的功能都交给了操作系统管理
```
```python
//      所以我们这里使用操作系统当中的时间同步原理
```
```python
printf(
```
```python
"fangfang \n"
```
```python
);
        Sleep(
```
```python
2000
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
HANDLE
```
```python
timer;
```
```python
//(1.声明定时器)
```
```python
DWORD WINAPI go1(
```
```python
void
```
```python
*
```
```python
p)
{
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"1"
```
```python
,
```
```python
"1"
```
```python
,
```
```python
0
```
```python
);
```
```python
//让go1执行完毕之后5秒再执行go2
```
```python
//(2.创建定时器)
```
```python
timer
```
```python
=
```
```python
CreateWaitableTimer(
```
```python
NULL
```
```python
,
```
```python
TRUE
```
```python
,
```
```python
NULL
```
```python
);
    LARGE_INTEGER time;
    time
```
```python
.
```
```python
QuadPart
```
```python
=
```
```python
-
```
```python
50000000
```
```python
;
```
```python
//5秒
```
```python
//10  -7秒  0.1微秒
```
```python
SetWaitableTimer(timer,
```
```python
&
```
```python
time,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//设置定时器等待 2聊
```
```python
}
DWORD WINAPI go2(
```
```python
void
```
```python
*
```
```python
p)
{
```
```python
//if (WaitForSingleObject(timer,INFINITE)==WAIT_OBJECT_0)
```
```python
//{
```
```python
WaitForSingleObject(timer, INFINITE);
    MessageBoxA(
```
```python
0
```
```python
,
```
```python
"2"
```
```python
,
```
```python
"2"
```
```python
,
```
```python
0
```
```python
);
    printf(
```
```python
"等待成功!"
```
```python
);
```
```python
//}
```
```python
//else
```
```python
//{
```
```python
//printf("等待失败!");
```
```python
//}
```
```python
}
```
```python
void
```
```python
main02()
{
```
```python
//通过主线程进行控制时间同步
```
```python
HANDLE
```
```python
hd
```
```python
=
```
```python
CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, go1,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
```
```python
//弊端:时间同步不能用于跨线程的同步
```
```python
//单独定时器:只能用于同步的通信,不能用于异步通信
```
```python
WaitForSingleObject(hd, INFINITE);
```
```python
if
```
```python
(WaitForSingleObject(timer,INFINITE)
```
```python
==
```
```python
WAIT_OBJECT_0)
    {
        CreateThread(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, go2,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
NULL
```
```python
);
        printf(
```
```python
"等待成功!"
```
```python
);
    }
```
```python
else
```
```python
{
        printf(
```
```python
"等待失败!"
```
```python
);
    }
    getchar();
}
```
```python
//01.根据时间进行同步:
```
```python
//  原理:确定的时间赶往同一个地点
```
```python
//02.时间同步:定时器原理[空间原理]
```
```python
//  定时的完成一件事情
```
```python
//03.定时器原理:
```
```python
//  1.主线程独立执行
```
```python
//  2.时间线程:每隔3秒提供一个函数指针
```
```python
//  3.接收到事情的时候就开始干活儿
```
```python
//04.时间锁定
```
```python
//05.时间同步可能只能执行于一个线程内部
```
程序片段(12):time.c
内容概要:**多线程实战**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <process.h>
```
```python
#include <Windows.h>
```
```python
int
```
```python
i =
```
```python
1
```
```python
;
```
```python
//全局变量:用于多线程通信
```
```python
void
```
```python
setTime(
```
```python
void
```
```python
* p)
{
```
```python
//定时器函数:
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
        Sleep(
```
```python
1000
```
```python
);
```
```python
char
```
```python
str[
```
```python
40
```
```python
] = {
```
```python
0
```
```python
};
```
```python
sprintf
```
```python
(str,
```
```python
"title 当前时间为第%3d的秒! \n"
```
```python
, i++);
        system(str);
    }
}
```
```python
void
```
```python
run(
```
```python
void
```
```python
* p)
{
```
```python
//主控制函数
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
if
```
```python
(
```
```python
3
```
```python
== i)
        {
            system(
```
```python
"calc"
```
```python
);
        }
```
```python
else
```
```python
if
```
```python
(
```
```python
10
```
```python
== i)
        {
            system(
```
```python
"notepad"
```
```python
);
            _endthread();
        }
```
```python
else
```
```python
if
```
```python
(
```
```python
19
```
```python
== i)
        {
            system(
```
```python
"tasklist & pause"
```
```python
);
        }
        Sleep(
```
```python
1000
```
```python
);
    }
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    system(
```
```python
"title China World! \n"
```
```python
);
    _beginthread(setTime,
```
```python
0
```
```python
, NULL);
```
```python
//开启定时器
```
```python
_beginthread(run,
```
```python
0
```
```python
, NULL);
```
```python
//主控制函数
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(13):main.c
内容概要:**多线程检索数组**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <process.h>
```
```python
//01.采用多线程处理:
```
```python
//  在数组当中只存在一个待查找数据的情况
```
```python
int
```
```python
isFind =
```
```python
0
```
```python
;
```
```python
//全局变量-->多线程通信内容
```
```python
int
```
```python
* pFind = NULL;
```
```python
//查找到的数据位置
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
arrLen;
```
```python
int
```
```python
findNum;
```
```python
int
```
```python
thID;
```
```python
int
```
```python
* intArr;
} thTaskInfo;
```
```python
void
```
```python
searchNum(
```
```python
void
```
```python
* p)
{
    thTaskInfo * pThTask = (thTaskInfo *)p;
```
```python
printf
```
```python
(
```
```python
"编号为%d的线程开始检索: \n"
```
```python
, pThTask->thID);
```
```python
for
```
```python
(
```
```python
int
```
```python
* pTmp = pThTask->intArr; pTmp < pThTask->intArr + pThTask->arrLen; ++pTmp)
    {
```
```python
if
```
```python
(
```
```python
1
```
```python
== isFind)
        {
```
```python
printf
```
```python
(
```
```python
"编号为%d的线程结束检索状态,其它线程已检索到指定数据! \n"
```
```python
, pThTask->thID);
            _endthread();
        }
```
```python
if
```
```python
(pThTask->findNum == *pTmp)
        {
            isFind =
```
```python
1
```
```python
;
            pFind = pTmp;
```
```python
printf
```
```python
(
```
```python
"编号为%d的线程已检索到指定数据%d,该数据的位置为:%p ! \n"
```
```python
, pThTask->thID, *pTmp, pTmp);
            _endthread();
        }
    }
```
```python
printf
```
```python
(
```
```python
"编号为%d的线程未检索到指定数据,结束检索状态! \n"
```
```python
, pThTask->thID);
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//理想情况之下
```
```python
int
```
```python
data[
```
```python
1000
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
999
```
```python
; i > -
```
```python
1
```
```python
; --i)
    {
        data[i] = i;
    }
    thTaskInfo thTaskArr[
```
```python
10
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        thTaskArr[i].intArr = data + i *
```
```python
100
```
```python
;
        thTaskArr[i].arrLen =
```
```python
100
```
```python
;
        thTaskArr[i].findNum =
```
```python
767
```
```python
;
        thTaskArr[i].thID = i;
        _beginthread(searchNum,
```
```python
0
```
```python
, &thTaskArr[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.多线程检索无规律数据的规则:
```
```python
//  1.采用N条线程执行检索任务
```
```python
//  2.其中(N-1)条线程所检索的数据量一致
```
```python
//      最后1条检索的数据量不一致
```
```python
//  3.其中(N-1)条线程所检索的数据量单元
```
```python
//      要大于最后一条线程所检索的数据量单元
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
data[
```
```python
1000
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
999
```
```python
; i > -
```
```python
1
```
```python
; --i)
    {
        data[i] = i;
    }
```
```python
int
```
```python
findNum =
```
```python
0
```
```python
;
```
```python
int
```
```python
thNum =
```
```python
0
```
```python
;
```
```python
scanf
```
```python
(
```
```python
"%d %d"
```
```python
, &findNum, &thNum);
```
```python
int
```
```python
quotient =
```
```python
1000
```
```python
/ thNum;
```
```python
int
```
```python
remainder =
```
```python
1000
```
```python
% thNum;
    thTaskInfo * pThTaskArr = (thTaskInfo *)
```
```python
malloc
```
```python
(thNum *
```
```python
sizeof
```
```python
(thTaskInfo));
```
```python
if
```
```python
(!remainder)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < thNum; ++i)
        {
            (pThTaskArr + i)->intArr = data + i * (
```
```python
1000
```
```python
/ thNum);
            (pThTaskArr + i)->arrLen =
```
```python
1000
```
```python
/ thNum;
            (pThTaskArr + i)->findNum = findNum;
            (pThTaskArr + i)->thID = i;
            _beginthread(searchNum,
```
```python
0
```
```python
, pThTaskArr + i);
        }
    }
```
```python
else
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < thNum -
```
```python
1
```
```python
; ++i)
        {
            (pThTaskArr + i)->intArr = data + i * (
```
```python
1000
```
```python
/ quotient);
            (pThTaskArr + i)->arrLen =
```
```python
1000
```
```python
/ quotient;
            (pThTaskArr + i)->findNum = findNum;
            (pThTaskArr + i)->thID = i;
            _beginthread(searchNum,
```
```python
0
```
```python
, pThTaskArr + i);
        }
```
```python
int
```
```python
endI = thNum -
```
```python
1
```
```python
;
        (pThTaskArr + endI)->intArr = data + quotient * (thNum -
```
```python
1
```
```python
);
        (pThTaskArr + endI)->arrLen = remainder;
        (pThTaskArr + endI)->findNum = findNum;
        (pThTaskArr + endI)->thID = endI;
        _beginthread(searchNum,
```
```python
0
```
```python
, pThTaskArr + endI);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(14):DualCircle.h+DualCircle.c
内容概要:**双环**
```python
///
```
```python
DualCircle.h
```
```python
#
```
```python
pragma
```
```python
once
```
```python
typedef
```
```python
struct
```
```python
node
{
```
```python
int
```
```python
data;
```
```python
struct
```
```python
node * pPre;
```
```python
struct
```
```python
node * pNext;
}Node;
typedef
```
```python
struct
```
```python
dualcircle
{
    Node * pHead;
    Node * pTail;
}DualCircle;
```
```python
void
```
```python
initNodeWithData(Node * pNode,
```
```python
int
```
```python
data);
```
```python
void
```
```python
initDualCircle(DualCircle * pDualCircle);
```
```python
void
```
```python
dualCircleHeadInsert(DualCircle * pDualCircle,
```
```python
int
```
```python
data);
```
```python
void
```
```python
dualCircleTailInsert(DualCircle * pDualCircle,
```
```python
int
```
```python
data);
Node * dualCircleSelectFirst(DualCircle * pDualCircle,
```
```python
int
```
```python
data);
```
```python
void
```
```python
dualCircleRandInsert(DualCircle * pDualCircle,
```
```python
int
```
```python
findData,
```
```python
int
```
```python
insertData);
```
```python
void
```
```python
showDualCircle(DualCircle * pDualCircle);
```
```python
void
```
```python
dualCircleDeleteFirst(DualCircle * pDualCircle,
```
```python
int
```
```python
data);
```
```python
void
```
```python
dualCircleUpdateFirst(DualCircle * pDualCircle,
```
```python
int
```
```python
oldData,
```
```python
int
```
```python
newData);
```
```python
///DualCircle.c
```
```python
#include
```
```python
"DualCircle.h"
```
```python
#include
```
```python
<
```
```python
Windows
```
```python
.
```
```python
h
```
```python
>
```
```python
void
```
```python
initNodeWithData(Node
```
```python
*
```
```python
pNode, int
```
```python
data
```
```python
)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pNode)
```
```python
abort
```
```python
();
    pNode
```
```python
->
```
```python
data
```
```python
=
```
```python
data
```
```python
;
    pNode
```
```python
->
```
```python
pPre
```
```python
=
```
```python
NULL
```
```python
;
    pNode
```
```python
->
```
```python
pNext
```
```python
=
```
```python
NULL
```
```python
;
}
```
```python
void
```
```python
initDualCircle(DualCircle
```
```python
*
```
```python
pDualCircle)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pDualCircle)
```
```python
abort
```
```python
();
    pDualCircle
```
```python
->
```
```python
pHead
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pTail
```
```python
=
```
```python
NULL
```
```python
;
}
```
```python
void
```
```python
dualCircleHeadInsert(DualCircle
```
```python
*
```
```python
pDualCircle, int
```
```python
data
```
```python
)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pDualCircle)
```
```python
abort
```
```python
();
    Node
```
```python
*
```
```python
pNew
```
```python
=
```
```python
(Node
```
```python
*
```
```python
)malloc(sizeof(Node));
    initNodeWithData(pNew,
```
```python
data
```
```python
);
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pDualCircle
```
```python
->
```
```python
pHead)
    {
```
```python
//空双环
```
```python
pNew
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pNew
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pNew;
        pDualCircle
```
```python
->
```
```python
pHead
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pTail
```
```python
=
```
```python
pNew;
```
```python
return
```
```python
;
    }
```
```python
if
```
```python
(pDualCircle
```
```python
->
```
```python
pHead
```
```python
==
```
```python
pDualCircle
```
```python
->
```
```python
pTail)
    {
```
```python
//单节点
```
```python
pNew
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pNew
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pHead;
        pDualCircle
```
```python
->
```
```python
pTail
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pTail
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pNew;
        pDualCircle
```
```python
->
```
```python
pHead
```
```python
=
```
```python
pNew;
```
```python
return
```
```python
;
    }
```
```python
//多节点
```
```python
pNew
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pTail;
    pNew
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pHead;
    pDualCircle
```
```python
->
```
```python
pHead
```
```python
=
```
```python
pNew;
    pDualCircle
```
```python
->
```
```python
pTail
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pNew;
}
```
```python
void
```
```python
dualCircleTailInsert(DualCircle
```
```python
*
```
```python
pDualCircle, int
```
```python
data
```
```python
){}
Node
```
```python
*
```
```python
dualCircleSelectFirst(DualCircle
```
```python
*
```
```python
pDualCircle, int
```
```python
data
```
```python
)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pDualCircle)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pDualCircle
```
```python
->
```
```python
pHead)
```
```python
abort
```
```python
();
    Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pHead;
```
```python
do
```
```python
{
```
```python
if
```
```python
(
```
```python
data
```
```python
==
```
```python
pTmp
```
```python
->
```
```python
data
```
```python
)
```
```python
return
```
```python
pTmp;
        pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext;
    }
```
```python
while
```
```python
(pDualCircle
```
```python
->
```
```python
pHead
```
```python
!=
```
```python
pTmp);
```
```python
return
```
```python
NULL
```
```python
;
}
```
```python
void
```
```python
dualCircleRandInsert(DualCircle
```
```python
*
```
```python
pDualCircle, int findData, int insertData)
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pDualCircle)
```
```python
abort
```
```python
();
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
pDualCircle
```
```python
->
```
```python
pHead)
```
```python
abort
```
```python
();
    int find
```
```python
=
```
```python
0
```
```python
;
    Node
```
```python
*
```
```python
pTmp
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pHead;
```
```python
do
```
```python
{
```
```python
if
```
```python
(findData
```
```python
==
```
```python
pTmp
```
```python
->
```
```python
data
```
```python
)
        {
            find
```
```python
=
```
```python
1
```
```python
;
            break;
        }
        pTmp
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext;
    }
```
```python
while
```
```python
(pDualCircle
```
```python
->
```
```python
pHead
```
```python
!=
```
```python
pTmp);
```
```python
if
```
```python
(
```
```python
!
```
```python
find)
```
```python
return
```
```python
;
    Node
```
```python
*
```
```python
pInsert
```
```python
=
```
```python
(Node
```
```python
*
```
```python
)malloc(sizeof(Node));
    initNodeWithData(pInsert, insertData);
```
```python
if
```
```python
(pDualCircle
```
```python
->
```
```python
pTail
```
```python
==
```
```python
pTmp)
    {
        pDualCircle
```
```python
->
```
```python
pTail
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pInsert;
        pInsert
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pTail;
        pInsert
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pDualCircle
```
```python
->
```
```python
pHead;
        pDualCircle
```
```python
->
```
```python
pHead
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pInsert;
        pDualCircle
```
```python
->
```
```python
pTail
```
```python
=
```
```python
pInsert;
```
```python
return
```
```python
;
    }
    pInsert
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pTmp;
    pInsert
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pTmp
```
```python
->
```
```python
pNext;
    pTmp
```
```python
->
```
```python
pNext
```
```python
=
```
```python
pInsert;
    pTmp
```
```python
->
```
```python
pNext
```
```python
->
```
```python
pPre
```
```python
=
```
```python
pInsert;
}
```
```python
//其它的没有写头,自己去想吧!
```

