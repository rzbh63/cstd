
# 20160207.CCPP体系详解(0017天) - 尹成的技术博客 - CSDN博客

置顶2016年02月18日 22:39:55[尹成](https://me.csdn.net/yincheng01)阅读数：4594个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)



程序片段:01.Point.c+02.进程.c+03.内存的栈和堆.c
内容概要:**内存32位和64位的区别**
```python
///01.Point.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.指针变量所占用的内存尺寸由编译器进行直接决定
```
```python
//      指针变量所占用的内存尺寸同时直接或间接与CPU-->操作系统-->编译器平台有关
```
```python
//          综合决定:CPU-->操作系统-->编译器平台
```
```python
//          直接决定:编译器平台
```
```python
//02.指针变量当中的指针就是内存寻址范围当中的地址(注意类型差别)
```
```python
//  32位操作系统的CPU寻址能力
```
```python
//      32位编译器:0x00000000~0xFFFFFFFF
```
```python
//          2^32=2^2*2^10*2^10*2^10=4*1024*1024*1024=4G
```
```python
//  64位操作系统的CPU寻址能力
```
```python
//      64位编译器:0x0000000000000000~0xFFFFFFFFFFFFFFFFF
```
```python
//          所能寻址的范围很大
```
```python
//03.CPU的不同位数所导致的能力差异:
```
```python
//  1.寻址能力不同:
```
```python
//      寻址范围非常的大
```
```python
//  2.运算能力不同:
```
```python
//      32位CPU只能做32位运算;
```
```python
//      64位CPU既能做32位运算,也能做64位运算
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
1
```
```python
;
```
```python
int
```
```python
* pNum = &num;
```
```python
printf
```
```python
(
```
```python
"%llu \n"
```
```python
,
```
```python
sizeof
```
```python
(pNum));
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.寄存器相关的特点分析:
```
```python
//  1.所有的运算操作都需要借助CPU的寄存器区域进行完成
```
```python
//  2.任何一个表达式都是位于CPU的寄存器区域(eax|rax)
```
```python
//      但是C语言不能直接对CPU的寄存器进行写入操作,除非内嵌汇编
```
```python
//      注:包括对任何一个变量名的取地址操作(&varName)
```
```python
//05.计算机在CPU的寄存器区域生成常量的过程:
```
```python
//      CPU-->寄存器-->代码区-->符号表-->读取常量-->寄存器生成常量
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
1
```
```python
;
```
```python
int
```
```python
data =
```
```python
0
```
```python
;
    data = num;
```
```python
//&(num+1);
```
```python
data = num +
```
```python
1
```
```python
;
    data = num +
```
```python
2
```
```python
;
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.进程.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
//01.单个进程处于不同编译器平台之下所支持的单进程内存尺寸不同:
```
```python
//  32位编译器平台情况之下,所支持的单进程最大内存尺寸为2GB
```
```python
//  64位编译器平台情况之下,所指吃的单进程最大内存尺寸为1024GB
```
```python
//  注:
```
```python
//      1.区分大小写B的区别
```
```python
//      2.该单进程内存尺寸指整个进程所占用的内存(包含:代码区+全局区+栈内存+堆内存)
```
```python
//      3.单个进程所占用的内存尺寸是由编译器平台的位数所直接决定的(间接因素:CPU->操作系统->编译器)
```
```python
//02.内存分配,内存释放,内存回收四个词语的意思:
```
```python
//  内存分配:操作系统为进程分配指定内存区域的访问权限(写入权限和读取权限)
```
```python
//  内存释放:操作系统从进程回收指定内存区域的访问权限
```
```python
//      只是收回权限,不会清空数据
```
```python
//  内存回收:清空内存的实际数据
```
```python
//      不仅收回权限,还会清空数据
```
```python
//03.关于软访问和硬访问的区别:
```
```python
//  软访问:所能访问的最小内存单位是二进制位(Bit)(补码)
```
```python
//      但是通常都是采取字节作为最小单位操作内存的
```
```python
//      除非是位运算就会操作到内存的最小单位
```
```python
//  硬访问:所能访问的最小硬盘单位是字节(Byte)
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
malloc
```
```python
(
```
```python
1024
```
```python
*
```
```python
1024
```
```python
*
```
```python
100
```
```python
);
```
```python
//不断的分配内存空间
```
```python
Sleep(
```
```python
100
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///03.内存的栈和堆.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
//01.最常用栈内存和堆内存耗费方式:
```
```python
//  栈耗费:auto int num
```
```python
//  对耗费:malloc(1024)
```
```python
//02.栈内存和堆内存的基本特点:
```
```python
//  数据结构的栈和堆:
```
```python
//      栈:先进后出的一种数据结构
```
```python
//      堆:一种二叉树形式的存储结构
```
```python
//  内存访问的栈内存和堆内存:
```
```python
//      栈内存:自动释放,自动回收
```
```python
//      堆内存:手动释放,手动回收
```
```python
//  注:栈内存由编译器进行维护,编译器控制自动释放和自动回收的时机,默认栈内存所占用的尺寸为1M,可以手动拓展编译器
```
```python
//      所操控的栈内存尺寸大小,通过项目配置修改栈内存所操纵的栈内存尺寸大小[配置属性-->链接器-->系统-->堆栈保留大小]
```
```python
//03.区分虚拟内存和物理内存:
```
```python
//  虚拟内存:硬盘内存
```
```python
//  物理内存:真实内存
```
```python
void
```
```python
stack
```
```python
(
```
```python
int
```
```python
numA)
```
```python
//int numA:作为形式参数,占用栈内存
```
```python
{
```
```python
int
```
```python
numB =
```
```python
10
```
```python
;
```
```python
//局部变量,占用栈内存
```
```python
printf
```
```python
(
```
```python
"%p, %p \n"
```
```python
, &numA, &numB);
    numA =
```
```python
1
```
```python
;
    numB =
```
```python
2
```
```python
;
    getchar();
```
```python
//某些情况之下如果不能进行断点调试,需要添加上这句无用的代码,以便插上断点进行断点调试
```
```python
}
```
```python
//04.关于编译器的自动优化特点解释:
```
```python
//  1.一个函数在调用完成之后,如果调用了其它函数,那么当前函数会被立即释放
```
```python
//  2.然而编译器检测到两次调用的是相同函数,只不过中间插入了一个无关紧要的函数,
```
```python
//      那么此时的编译器不会对两次重复调用的相同函数进行不同的栈内存开辟
```
```python
//05.静态数组分配的代码分析:
```
```python
//  int intArr[1024*1024];
```
```python
//      1.该数组占用栈内存字节数为4M
```
```python
//      2.该数组属于静态数组,需要在代码一旦加入进内存之后就决定该数组的内存尺寸
```
```python
//      3.该数组分配方式为静态分配,因此必须使用常量指明数组元素个数
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
//stack(1);
```
```python
//printf("\n\n\n");
```
```python
//stack(1);
```
```python
//printf("\n\n\n");
```
```python
//int intArr[1024 * 1024];
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//06.线程任务函数的标准格式
```
```python
void
```
```python
run(
```
```python
void
```
```python
* p)
{
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
int
```
```python
num[
```
```python
1024
```
```python
*
```
```python
1024
```
```python
];
```
```python
//自动释放回收栈内存
```
```python
}
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
malloc
```
```python
(
```
```python
1024
```
```python
*
```
```python
1024
```
```python
*
```
```python
10
```
```python
);
```
```python
//不断的进行堆内存的分配而没有进行释放,很容易造成内存溢出情况
```
```python
Sleep(
```
```python
1000
```
```python
);
```
```python
//堆内存膨胀-->导致整个进程的内存溢出,不是栈内存溢出
```
```python
}
}
```
```python
//07.32位编译器平台之下,由于编译器所编译的单个进程程序所支持的最大内存尺度为2GB(同时包含内存四区)大小
```
```python
//  全局区+代码区+栈内存+堆内存=2GB,因此堆内存所占用的尺寸极限必定小于2GB
```
```python
//08.关于多线程情况之下的单个进程的内存使用情况:
```
```python
//  1.多条线程共享同一个进程的堆内存
```
```python
//  2.各条线程独自占用一定的进程的栈内存
```
```python
//09.关于启动线程函数处理线程任务代码的特点分析:
```
```python
//  代码:_beginthread(taskFun, 0, NULL);
```
```python
//  参数说明:
```
```python
//          taskFun:线程待处理的任务函数
```
```python
//                     0:以跟主线程相同栈内存尺寸分配线程任务栈内存-->通常所说的堆栈保留大小其实就是主线程的堆栈保留大小
```
```python
//              NULL:传递给任务处理函数的实际参数
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
//void * p = malloc(1024 * 1024);//分配1M
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
8
```
```python
; ++i)
    {
        _beginthread(run,
```
```python
0
```
```python
, NULL);
```
```python
//多线程,每一个线程都有各自独立的栈内存
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):01.Heap.c
内容概要:**Heap**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include <process.h>
```
```python
void
```
```python
taskFun(
```
```python
void
```
```python
* p)
{
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
malloc
```
```python
(
```
```python
1024
```
```python
*
```
```python
1024
```
```python
*
```
```python
10
```
```python
);
        Sleep(
```
```python
100
```
```python
);
    }
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//taskFun(NULL);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
        _beginthread(taskFun,
```
```python
0
```
```python
, NULL);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(03):stack.h+stack.c+main.c
内容概要:**Stack**
```python
///stack.h
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
#define EN 100
```
```python
struct
```
```python
stack
```
```python
//单个结构体变量可以用于整合多个不同类型的变量
```
```python
{
```
```python
int
```
```python
data[EN];
```
```python
//栈内存空间
```
```python
int
```
```python
top;
```
```python
//栈顶标识
```
```python
};
```
```python
typedef
```
```python
struct
```
```python
stack
```
```python
Stack;
```
```python
//Stack别名
```
```python
void
```
```python
initStack(Stack * pStack);
```
```python
//初始化栈结构
```
```python
int
```
```python
isEmpty(Stack * pStack);
```
```python
//判断栈结构是否为空
```
```python
int
```
```python
isFull(Stack * pStack);
```
```python
//判断栈结构是否填满
```
```python
void
```
```python
pushStack(Stack * pStack,
```
```python
int
```
```python
value);
```
```python
//栈结构压入数据
```
```python
int
```
```python
popStack(Stack * pStack);
```
```python
//栈结构弹出数据
```
```python
int
```
```python
getTop(Stack * pStack);
```
```python
//获取栈顶数据
```
```python
void
```
```python
showStack(Stack * pStack);
```
```python
//栈结构显示
```
```python
///stack.c
```
```python
#include "stack.h"
```
```python
void
```
```python
initStack(Stack * pStack)
{
```
```python
memset
```
```python
(pStack->data,
```
```python
0
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
)*EN);
```
```python
//数据清零,模拟回收数据
```
```python
pStack->top = -
```
```python
1
```
```python
;
```
```python
//表示栈顶索引只要在0以上就表示栈结构当中存储有数据
```
```python
}
```
```python
int
```
```python
isEmpty(Stack * pStack)
{
```
```python
if
```
```python
(-
```
```python
1
```
```python
== pStack->top)
    {
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
isFull(Stack * pStack)
{
```
```python
if
```
```python
(EN -
```
```python
1
```
```python
== pStack->top)
    {
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
pushStack(Stack * pStack,
```
```python
int
```
```python
value)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== isFull(pStack))
    {
```
```python
return
```
```python
;
    }
    pStack->data[++pStack->top] = value;
}
```
```python
int
```
```python
popStack(Stack * pStack)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== isEmpty(pStack))
    {
```
```python
return
```
```python
;
    }
```
```python
return
```
```python
pStack->data[pStack->top--];
}
```
```python
int
```
```python
getTop(Stack * pStack)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== isFull(pStack))
    {
```
```python
return
```
```python
-
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
popStack(pStack);
}
```
```python
void
```
```python
showStack(Stack * pStack)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== isEmpty(pStack))
    {
```
```python
return
```
```python
;
    }
```
```python
printf
```
```python
(
```
```python
"栈结构的数据是: \n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <= pStack->top; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%4d \n"
```
```python
, pStack->data[i]);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
///main.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include "stack.h"
```
```python
//01.结构体类型与结构体变量:
```
```python
//  1.结构体类型:用于整合多个不同类型
```
```python
//  2.结构体变量:用于整合多个不同类型的变量
```
```python
//  3.结构体变量的成员访问方式:点访问符+指针访问符
```
```python
//      注:点号(".")操作符的优先级大于星号("*")操作符的优先级
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
struct
```
```python
MyStack
```
```python
//结构体类型用于整合多个不同类型
```
```python
{
```
```python
int
```
```python
data[
```
```python
10
```
```python
];
```
```python
int
```
```python
top;
    };
```
```python
//结构体变量意义:整合多个不同类型的变量
```
```python
struct
```
```python
MyStack my1 = { {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
},
```
```python
1
```
```python
};
```
```python
//结构体变量的静态初始化
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, my1.top);
```
```python
//访问结构体变量的成员变量
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (&my1)->top);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, my1.top);
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (*(&my1)).top);
```
```python
struct
```
```python
MyStack * my2 = &my1;
```
```python
//printf("%d \n", *my2.top);//星号("*")的优先级低于点号(".")
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, (*my2).top);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, my1.data[i]);
```
```python
//可以用点号(".")操作符进行访问
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//int intArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
```
```python
Stack myStack;
    initStack(&myStack);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        pushStack(&myStack, i);
    }
```
```python
while
```
```python
(!isEmpty(&myStack))
    {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, getTop(&myStack));
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
//int intArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
```
```python
Stack myStack;
    initStack(&myStack);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        pushStack(&myStack, i);
```
```python
//压栈一个
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, getTop(&myStack));
```
```python
//弹栈一个
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.如何求取一个整数的二进制形式?
```
```python
//  10      %2      5       0
```
```python
//    5     %2      2       1
```
```python
//    2     %2      1       0
```
```python
//    1     %2      0       1
```
```python
//    0     %2      0       0-->直到被除数为0,末尾添加一个0(被除数:0->取模数:0)
```
```python
void
```
```python
intHexToBin(
```
```python
int
```
```python
intHexNum)
{
```
```python
if
```
```python
(
```
```python
0
```
```python
== intHexNum)
```
```python
//表示最终的被除数为0的情况
```
```python
{
```
```python
putchar
```
```python
(
```
```python
'0'
```
```python
);
```
```python
//表明确实已经除到了最后一个数值-->意思:直到被除数为0,末尾添加了一个0
```
```python
}
```
```python
else
```
```python
{
        intHexToBin(intHexNum /
```
```python
2
```
```python
);
```
```python
putchar
```
```python
(
```
```python
'0'
```
```python
+ intHexNum %
```
```python
2
```
```python
);
```
```python
//十进制的整数类型转化为字符型的整数
```
```python
}
}
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intHexNum =
```
```python
0
```
```python
;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &intHexNum);
    intHexToBin(intHexNum);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//压入一个,弹出一个
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intNum;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &intNum);
    Stack myStack;
    initStack(&myStack);
```
```python
while
```
```python
(intNum)
    {
        pushStack(&myStack, intNum %
```
```python
2
```
```python
);
```
```python
putchar
```
```python
(
```
```python
'0'
```
```python
+ getTop(&myStack));
        intNum /=
```
```python
2
```
```python
;
    }
```
```python
putchar
```
```python
(
```
```python
'0'
```
```python
);
```
```python
//当被除数变为0的时候,也需要在末尾进行补零操作
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//压入全部,一次性逆序弹出
```
```python
int
```
```python
main06(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &num);
    Stack myStack;
    initStack(&myStack);
```
```python
while
```
```python
(num)
    {
        pushStack(&myStack, num %
```
```python
2
```
```python
);
        num /=
```
```python
2
```
```python
;
    }
    pushStack(&myStack,
```
```python
0
```
```python
);
```
```python
//当被除数为0的时候,需要补上一个存储0
```
```python
while
```
```python
(!isEmpty(&myStack))
    {
```
```python
putchar
```
```python
(
```
```python
'0'
```
```python
+ getTop(&myStack));
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(04):01.蟒蛇.c
内容概要:**蛇**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.蛇形行走:
```
```python
//  1.规律总结:
```
```python
//      (1).每次都是围绕"未走过"的"最外圈"棋盘
```
```python
//      (2).每一圈儿的行走起点都是该圈儿的最左上角
```
```python
//  2.必杀技巧:
```
```python
//      (1).二维数组模拟棋盘
```
```python
//      (2).采用循环变量控制圈儿数以及转向(四个方向)
```
```python
//  注:圈数采用变量模拟和控制
```
```python
//02.控制技巧:
```
```python
//  1.外层循环核心控制圈数
```
```python
//      (1).圈数必定大于等于1
```
```python
//      (2).圈数与行数之间的关系
```
```python
//          行数=1-->圈数=1
```
```python
//          行数=2-->圈数=1
```
```python
//          规律:(行数+1)/2-->圈数
```
```python
//  2.内部循环控制四周的转向操作
```
```python
//      在这里是顺时针的转向操作
```
```python
//  3.空置棋盘,填充规律数字
```
```python
#define N 10
```
```python
int
```
```python
intArrArr[N][N] = {
```
```python
0
```
```python
};
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
1
```
```python
;
```
```python
//规律数值生成器:初始化为1
```
```python
for
```
```python
(
```
```python
int
```
```python
q =
```
```python
0
```
```python
, x =
```
```python
0
```
```python
, y =
```
```python
0
```
```python
; q < (N +
```
```python
1
```
```python
) /
```
```python
2
```
```python
; ++q)
    {
```
```python
while
```
```python
(y < N - q)
```
```python
//控制横向列数
```
```python
{
            intArrArr[x][y] = num++;
            ++y;
        }
        --y;
```
```python
//回列
```
```python
++x;
```
```python
//走行
```
```python
while
```
```python
(x < N - q)
```
```python
//控制纵向行数
```
```python
{
            intArrArr[x][y] = num++;
            ++x;
        }
        --x;
```
```python
//回行
```
```python
--y;
```
```python
//走列
```
```python
while
```
```python
(y > q -
```
```python
1
```
```python
)
        {
            intArrArr[x][y] = num++;
            --y;
        }
        ++y;
```
```python
//回列
```
```python
--x;
```
```python
//走行
```
```python
while
```
```python
(x > q)
        {
            intArrArr[x][y] = num++;
            --x;
        }
        ++x;
```
```python
//回行
```
```python
++y;
```
```python
//走列
```
```python
}
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j < N; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%4d"
```
```python
, intArrArr[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):数组交集与并集.c
内容概要:**交集与并集**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//00.求交并集的首要条件是:
```
```python
//  去除各个集合当中重复的元素,防止重复存储
```
```python
#define M 15
```
```python
#define N 10
```
```python
//01.求交集规律总结:
```
```python
//  1.新建交集数组存储交集结果:
```
```python
//      交集数组的元素个数最多为较小待求交集的那个数组的元素个数
```
```python
//  2.以待求交集的那个数组的元素个数为外层循环遍历该数组
```
```python
//      然后用该数据与另外一个较大待求交集的那个数组元素进行比较
```
```python
//  3.如果较小数组元素和较大数组元素一样
```
```python
//      那就将该数组元素存入进交集数组当中,否则不用放入
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArrM[M] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
,
```
```python
11
```
```python
,
```
```python
12
```
```python
,
```
```python
13
```
```python
,
```
```python
14
```
```python
,
```
```python
15
```
```python
};
```
```python
int
```
```python
intArrN[N] = {
```
```python
11
```
```python
,
```
```python
12
```
```python
,
```
```python
13
```
```python
,
```
```python
14
```
```python
,
```
```python
15
```
```python
,
```
```python
16
```
```python
,
```
```python
17
```
```python
,
```
```python
18
```
```python
,
```
```python
19
```
```python
,
```
```python
20
```
```python
};
```
```python
int
```
```python
intArrJiao[N] = {
```
```python
0
```
```python
};
```
```python
//求交集
```
```python
int
```
```python
index
```
```python
=
```
```python
0
```
```python
;
```
```python
int
```
```python
flag =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
```
```python
//外层循环最少,能够达到最大的节省循环次数
```
```python
{
        flag =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j < M; ++j)
        {
```
```python
if
```
```python
(intArrN[i] == intArrM[j])
            {
                flag =
```
```python
1
```
```python
;
```
```python
break
```
```python
;
            }
        }
```
```python
if
```
```python
(
```
```python
1
```
```python
== flag)
        {
            intArrJiao[
```
```python
index
```
```python
++] = intArrN[i];
        }
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
```
```python
if
```
```python
(
```
```python
0
```
```python
== intArrJiao[i])
        {
```
```python
break
```
```python
;
        }
        printf(
```
```python
"%3d"
```
```python
, intArrJiao[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.求并集规律总结:
```
```python
//  1.新建并集数组存储并集结果:
```
```python
//      并集数组的元素个数最多为两个待求并集数组的元素个数总和
```
```python
//  2.并集数组拷贝:
```
```python
//      将待求并集数组当中元素最多的那个数组的元素全部拷贝到并集数组当中
```
```python
//      因为并集数组当中元素最少就是较大的那个数组当中的元素个数
```
```python
//  3.然后遍历较小的那个待求并集数组当中的每个元素
```
```python
//      再用该元素与较大的那个待求并集数组的元素进行比对
```
```python
//  4.如果较小数组元素和较大数组元素不一样
```
```python
//      那就将该数组元素存储进并集数组当中,否则不用进行存入
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArrM[M] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
,
```
```python
11
```
```python
,
```
```python
12
```
```python
,
```
```python
13
```
```python
,
```
```python
14
```
```python
,
```
```python
15
```
```python
};
```
```python
int
```
```python
intArrN[N] = {
```
```python
11
```
```python
,
```
```python
12
```
```python
,
```
```python
13
```
```python
,
```
```python
14
```
```python
,
```
```python
15
```
```python
,
```
```python
16
```
```python
,
```
```python
17
```
```python
,
```
```python
18
```
```python
,
```
```python
19
```
```python
,
```
```python
20
```
```python
};
```
```python
int
```
```python
intArrBing[M + N] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < M; ++i)
    {
        intArrBing[i] = intArrM[i];
    }
```
```python
int
```
```python
index
```
```python
= M;
```
```python
int
```
```python
flag =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        flag =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j < M; ++j)
        {
```
```python
if
```
```python
(intArrN[i] == intArrM[j])
            {
                flag =
```
```python
1
```
```python
;
```
```python
break
```
```python
;
            }
        }
```
```python
if
```
```python
(
```
```python
0
```
```python
== flag)
        {
            intArrBing[
```
```python
index
```
```python
++] = intArrN[i];
        }
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < M + N; ++i)
    {
```
```python
if
```
```python
(
```
```python
0
```
```python
== intArrBing[i])
        {
```
```python
break
```
```python
;
        }
        printf(
```
```python
"%3d"
```
```python
, intArrBing[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):01.破解密码.c
内容概要:**密码概率分布**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#define N 20
```
```python
int
```
```python
intArr[N] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
9
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
,
```
```python
11
```
```python
,
```
```python
12
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
,
```
```python
10
```
```python
,
```
```python
11
```
```python
,
```
```python
98
```
```python
};
typedef struct
{
```
```python
int
```
```python
value;
```
```python
//密码值
```
```python
int
```
```python
count
```
```python
;
```
```python
//次数
```
```python
} Pass;
Pass pass[N] = {
```
```python
0
```
```python
};
```
```python
//结构体数据清零
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
//对数组pass当中的元素进行排序
```
```python
int
```
```python
currentIndex =
```
```python
0
```
```python
;
```
```python
int
```
```python
currentValue =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i < N; ++i)
    {
        currentIndex = i;
        currentValue = intArr[i];
```
```python
while
```
```python
(currentIndex >
```
```python
0
```
```python
&& intArr[currentIndex -
```
```python
1
```
```python
] > currentValue)
        {
            intArr[currentIndex] = intArr[currentIndex -
```
```python
1
```
```python
];
            --currentIndex;
        }
        intArr[currentIndex] = currentValue;
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
        printf(
```
```python
"%3d"
```
```python
, intArr[i]);
    }
    printf(
```
```python
"\n\n"
```
```python
);
```
```python
int
```
```python
index
```
```python
=
```
```python
0
```
```python
;
```
```python
//代表结构体数组当中第一个结构体元素的索引
```
```python
int
```
```python
count
```
```python
=
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
```
```python
count
```
```python
=
```
```python
1
```
```python
;
        pass[
```
```python
index
```
```python
].value = intArr[i];
```
```python
for
```
```python
(
```
```python
int
```
```python
j = i; j < N -
```
```python
1
```
```python
; ++j)
        {
```
```python
if
```
```python
(intArr[j] == intArr[j +
```
```python
1
```
```python
])
            {
                ++
```
```python
count
```
```python
;
            }
```
```python
else
```
```python
{
                i = j;
```
```python
//最后一个相同值的所在位置
```
```python
break
```
```python
;
```
```python
//中断
```
```python
}
        }
        pass[
```
```python
index
```
```python
++].
```
```python
count
```
```python
=
```
```python
count
```
```python
;
    }
```
```python
//for (int i = 0; i < N; ++i)
```
```python
//{
```
```python
//  if (0 == pass[i].count)
```
```python
//  {
```
```python
//      break;
```
```python
//  }
```
```python
//  printf("%3d%3d \n",pass[i].value, pass[i].count);
```
```python
//}
```
```python
int
```
```python
end =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < N; ++i)
    {
```
```python
if
```
```python
(pass[i].
```
```python
count
```
```python
==
```
```python
0
```
```python
)
        {
            end = i;
```
```python
//等效于有效元素个数
```
```python
}
    }
```
```python
int
```
```python
maxIndex =
```
```python
0
```
```python
;
```
```python
int
```
```python
maxCount =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < end -
```
```python
1
```
```python
; ++i)
    {
        maxIndex = i;
        maxCount = pass[i].
```
```python
count
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
j = i +
```
```python
1
```
```python
; j < end; ++j)
        {
```
```python
if
```
```python
(maxCount < pass[j].
```
```python
count
```
```python
)
            {
                maxIndex = j;
                maxCount = pass[j].
```
```python
count
```
```python
;
            }
        }
```
```python
if
```
```python
(i != maxIndex)
        {
            pass[i].value = pass[i].value ^ pass[maxIndex].value;
            pass[maxIndex].value = pass[i].value ^ pass[maxIndex].value;
            pass[i].value = pass[i].value ^ pass[maxIndex].value;
            pass[i].
```
```python
count
```
```python
= pass[i].
```
```python
count
```
```python
^ pass[maxIndex].
```
```python
count
```
```python
;
            pass[maxIndex].
```
```python
count
```
```python
= pass[i].
```
```python
count
```
```python
^ pass[maxIndex].
```
```python
count
```
```python
;
            pass[i].
```
```python
count
```
```python
= pass[i].
```
```python
count
```
```python
^ pass[maxIndex].
```
```python
count
```
```python
;
        }
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < end; ++i)
    {
```
```python
if
```
```python
(
```
```python
0
```
```python
== pass[i].
```
```python
count
```
```python
)
        {
```
```python
break
```
```python
;
        }
        printf(
```
```python
"%3d%3d \n"
```
```python
, pass[i].value, pass[i].
```
```python
count
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(07):stack.h+stack.c+01.台阶.c
内容概要:**台阶问题**
```python
///stack.h
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
#define N 100
```
```python
struct
```
```python
stack
```
```python
{
```
```python
//[将结构体当中为一个整体进行看待]
```
```python
int
```
```python
data[N];
```
```python
int
```
```python
top;
```
```python
//标识栈顶
```
```python
};
```
```python
typedef
```
```python
struct
```
```python
stack
```
```python
Stack;
```
```python
//Stack作为该结构体的别名,相当于是对重新定义的一个数据类型进行更名识别
```
```python
//[对结构体当中的某个属性进行修改]
```
```python
void
```
```python
init(Stack *p);
```
```python
//初始化
```
```python
int
```
```python
isempty(Stack *p);
```
```python
//判断栈是否为空
```
```python
int
```
```python
isfull(Stack *p);
```
```python
//判断栈溢出
```
```python
int
```
```python
gettop(Stack *p);
```
```python
//获取栈顶
```
```python
void
```
```python
push(Stack *p);
```
```python
//插入数据
```
```python
void
```
```python
pop(Stack *p);
```
```python
//吐出栈顶数据
```
```python
void
```
```python
show(Stack *p);
```
```python
//显示栈结构数据
```
```python
///stack.c
```
```python
#include "stack.h"
```
```python
void
```
```python
init(Stack *p)
```
```python
//初始化栈结构
```
```python
{
```
```python
memset
```
```python
(p->data,
```
```python
0
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
)*N);
```
```python
//数据清零
```
```python
p->top = -
```
```python
1
```
```python
;
```
```python
//代表为空
```
```python
}
```
```python
int
```
```python
isempty(Stack *p)
```
```python
//判断栈结构是否为空
```
```python
{
```
```python
if
```
```python
(p->top=-
```
```python
1
```
```python
)
    {
```
```python
return
```
```python
1
```
```python
;
```
```python
//为空
```
```python
}
```
```python
else
```
```python
{
```
```python
return
```
```python
0
```
```python
;
```
```python
//不为空
```
```python
}
}
```
```python
int
```
```python
isfull(Stack *p)
```
```python
//判断栈溢出
```
```python
{
```
```python
if
```
```python
(p->top==N-
```
```python
1
```
```python
)
    {
```
```python
return
```
```python
1
```
```python
;
```
```python
//溢出
```
```python
}
```
```python
else
```
```python
{
```
```python
return
```
```python
0
```
```python
;
```
```python
//还能再喝点儿
```
```python
}
}
```
```python
int
```
```python
gettop(Stack *p)
```
```python
//获取栈顶数据
```
```python
{
```
```python
return
```
```python
p->data[p->top];
}
```
```python
void
```
```python
push(Stack *p,
```
```python
int
```
```python
key)
```
```python
//将数据压入栈头
```
```python
{
```
```python
if
```
```python
(isfull(p)==
```
```python
1
```
```python
)
    {
```
```python
return
```
```python
;
    }
```
```python
else
```
```python
{
        p->top +=
```
```python
1
```
```python
;
```
```python
//结构体指向下一个整体
```
```python
p->data[p->top] = key;
```
```python
//压入数据
```
```python
}
}
```
```python
void
```
```python
pop(Stack *p)
```
```python
//吐出
```
```python
{
```
```python
if
```
```python
(isempty(p)==
```
```python
1
```
```python
)
    {
```
```python
return
```
```python
; 
    }
```
```python
else
```
```python
{
        p->top -=
```
```python
1
```
```python
;
```
```python
//出栈
```
```python
}
}
```
```python
void
```
```python
show(Stack *p)
```
```python
//显示栈结构当中的所有数据
```
```python
{
```
```python
if
```
```python
(isempty(p)==
```
```python
1
```
```python
)
    {
```
```python
return
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"\n栈的数据时\n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <=p->top; i++)
        {
```
```python
printf
```
```python
(
```
```python
"%4d"
```
```python
, p->data[i]);
```
```python
//打印栈结构当中的数据
```
```python
}
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
///
```
```python
01.台阶.c
```
```python
#include "stack.h"
```
```python
#
```
```python
define
```
```python
STPES 10
```
```python
//01.三级台阶问题:
```
```python
//  1.1次只能走1步,2步,或者3步
```
```python
//  2.10级台阶有多少中走法?
```
```python
//  1       1
```
```python
//  2       2       11+2
```
```python
//  3       4       111+12+21+3
```
```python
//  4       7       1111    +112+121+211+13+31
```
```python
//  n=(n-3)+(n-2)+(n-1);//规律总结
```
```python
int
```
```python
stepMethods(
```
```python
int
```
```python
steps)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== steps)
    {
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
else
```
```python
if
```
```python
(
```
```python
2
```
```python
== steps)
    {
```
```python
return
```
```python
2
```
```python
;
    }
```
```python
else
```
```python
if
```
```python
(
```
```python
3
```
```python
== steps)
    {
```
```python
return
```
```python
4
```
```python
;
    }
```
```python
return
```
```python
stepMethods(steps -
```
```python
3
```
```python
) + stepMethods(steps -
```
```python
2
```
```python
) + stepMethods(steps -
```
```python
1
```
```python
);
}
```
```python
//01.通过数组栈来提升递归效率:
```
```python
//  递归-->加速-->循环+数组栈
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[STPES] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
4
```
```python
};
```
```python
//前3级台阶作为基础进行规律的建立
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
3
```
```python
; i < STPES; ++i)
    {
        intArr[i] = intArr[i -
```
```python
3
```
```python
] + intArr[i -
```
```python
2
```
```python
] + intArr[i -
```
```python
1
```
```python
];
    }
    printf(
```
```python
"stepMethods = %d, intArr[N - 1] = %d \n"
```
```python
, stepMethods(STPES), intArr[STPES -
```
```python
1
```
```python
]);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.直接循环结构
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
steps1 =
```
```python
1
```
```python
;
```
```python
int
```
```python
steps2 =
```
```python
2
```
```python
;
```
```python
int
```
```python
steps3 =
```
```python
4
```
```python
;
```
```python
int
```
```python
stepsN =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
3
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        stepsN = steps1 + steps2 + steps3;
        steps1 = steps2;
        steps2 = steps3;
        steps3 = stepsN;
    }
    printf(
```
```python
"stepsN = %d \n"
```
```python
, stepsN);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(08):queue.h+queue.c+01.队列.c
内容概要:**队列**
```python
///queue.h
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <memory.h>
```
```python
#define N 100
```
```python
//队列结构的元素实体个数
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
data[N];
```
```python
//队列结构的内存存储空间
```
```python
int
```
```python
head;
```
```python
//标识队列结构的头部位置
```
```python
int
```
```python
back;
```
```python
//标识队列结构的尾部位置
```
```python
} Queue;
```
```python
void
```
```python
initQueue(Queue * pQueue);
```
```python
//初始化队列结构
```
```python
int
```
```python
isEmpty(Queue * pQueue);
```
```python
//判定队列结构是否为空
```
```python
int
```
```python
isFull(Queue * pQueue);
```
```python
//判定队列结构是否已满
```
```python
void
```
```python
enQueue(Queue * pQueue,
```
```python
int
```
```python
value);
```
```python
//为队列结构添加一个数据元素
```
```python
void
```
```python
deQueue(Queue * pQueue);
```
```python
//出队
```
```python
int
```
```python
getLast(Queue * pQueue);
```
```python
//获取队列尾部数据实体
```
```python
void
```
```python
showQueue(Queue * pQueue);
```
```python
//展示队列状态
```
```python
///
```
```python
queue.c
```
```python
#include "queue.h"
```
```python
//01.队列结构的开头位置是固定死的
```
```python
void
```
```python
initQueue(Queue * pQueue)
{
    (*pQueue).head = (*pQueue).back =
```
```python
0
```
```python
;
```
```python
//标识队列结构为空
```
```python
memset(pQueue,
```
```python
0
```
```python
,
```
```python
sizeof
```
```python
(
```
```python
int
```
```python
)*N);
```
```python
//只是针对于内存空间的数据清零操作
```
```python
}
```
```python
int
```
```python
isEmpty(Queue * pQueue)
{
```
```python
if
```
```python
((*pQueue).head == (*pQueue).back)
    {
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
isFull(Queue * pQueue)
{
```
```python
if
```
```python
(pQueue->back == N -
```
```python
1
```
```python
)
    {
```
```python
return
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
0
```
```python
;
}
```
```python
void
```
```python
enQueue(Queue * pQueue,
```
```python
int
```
```python
value
```
```python
)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== isFull(pQueue))
    {
```
```python
return
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== isEmpty(pQueue))
        {
            (*pQueue).data[
```
```python
0
```
```python
] =
```
```python
value
```
```python
;
            ++((*pQueue).back);
        }
```
```python
else
```
```python
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i = (*pQueue).back; i >
```
```python
0
```
```python
; --i)
            {
                (*pQueue).data[i] = (*pQueue).data[i -
```
```python
1
```
```python
];
            }
            (*pQueue).data[
```
```python
0
```
```python
] =
```
```python
value
```
```python
;
            ++((*pQueue).back);
        }
    }
}
```
```python
int
```
```python
getLast(Queue * pQueue)
```
```python
//只是查询效果
```
```python
{
```
```python
return
```
```python
(*pQueue).data[(*pQueue).back -
```
```python
1
```
```python
];
}
```
```python
void
```
```python
deQueue(Queue * pQueue)
{
```
```python
if
```
```python
(isEmpty(pQueue))
    {
```
```python
return
```
```python
;
    }
    --((*pQueue).back);
}
```
```python
void
```
```python
showQueue(Queue * pQueue)
{
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < (*pQueue).back; ++i)
    {
        printf(
```
```python
"%4d"
```
```python
, (*pQueue).data[i]);
    }
    printf(
```
```python
"\n\n"
```
```python
);
}
```
```python
///01.队列.c
```
```python
#include "queue.h"
```
```python
#include "Windows.h"
```
```python
#include "process.h"
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    Queue myQueue;
    initQueue(&myQueue);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
99
```
```python
; i <
```
```python
108
```
```python
; ++i)
    {
        enQueue(&myQueue, i);
        showQueue(&myQueue);
    }
```
```python
while
```
```python
(!isEmpty(&myQueue))
    {
        printf(
```
```python
"%4d \n"
```
```python
, getLast(&myQueue));
        deQueue(&myQueue);
        showQueue(&myQueue);
    }
    system(
```
```python
"pause"
```
```python
);
}
Queue myQueue;
```
```python
void
```
```python
run(
```
```python
void
```
```python
* p)
{
```
```python
int
```
```python
* px = p;
    printf(
```
```python
"线程编号是%d \n"
```
```python
, *px);
    enQueue(&myQueue, *px);
}
```
```python
//int intArr[10]-- > int * p = intArr;
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    initQueue(&myQueue);
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
HANDLE
```
```python
hd = _beginthread(run,
```
```python
0
```
```python
, &intArr[i]);
        WaitForSingleObject(hd, INFINITE);
```
```python
//WaitForMultipleObjects();
```
```python
}
    system(
```
```python
"pause"
```
```python
);
```
```python
//防止主线程提前结束
```
```python
showQueue(&myQueue);
    system(
```
```python
"pause"
```
```python
);
}
```

