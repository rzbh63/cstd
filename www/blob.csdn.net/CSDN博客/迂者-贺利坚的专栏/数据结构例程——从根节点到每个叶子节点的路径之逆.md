
# 数据结构例程——从根节点到每个叶子节点的路径之逆 - 迂者-贺利坚的专栏 - CSDN博客

2015年10月19日 22:07:20[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：4203


本文是[数据结构基础系列(6)：树和二叉树](http://edu.csdn.net/course/detail/1553)中第11课时[二叉树遍历非递归算法](http://edu.csdn.net/course/detail/1553/24076)和第12课时[层次遍历算法](http://edu.csdn.net/course/detail/1553/24077)的例程。
问题：设计算法输出从根节点到每个叶子节点的路径之逆。
解法1：利用二叉树[后序遍历非递归算法](http://edu.csdn.net/course/detail/1553/24076)中，每一个叶子节点出现时，栈中从栈顶到栈底，正好是叶子节点到根节点的逆序的性质编写。
［参考解答］（btreee.h见[算法库](http://blog.csdn.net/sxhelijian/article/details/49250581)）
```python
#include <stdio.h>
```
```python
#include "btree.h"
```
```python
void
```
```python
AllPath1(BTNode *b)
{
    BTNode *St[MaxSize];
    BTNode *p;
```
```python
int
```
```python
flag,i,top=-
```
```python
1
```
```python
;
```
```python
//栈指针置初值
```
```python
if
```
```python
(b!=NULL)
    {
```
```python
do
```
```python
{
```
```python
while
```
```python
(b!=NULL)
```
```python
//将*b的所有左节点进栈
```
```python
{
                top++;
                St[top]=b;
                b=b->lchild;
            }
            p=NULL;
            flag=
```
```python
1
```
```python
;
```
```python
while
```
```python
(top!=-
```
```python
1
```
```python
&& flag)
            {
                b=St[top];
```
```python
//取出当前的栈顶元素
```
```python
if
```
```python
(b->rchild==p)
                {
```
```python
if
```
```python
(b->lchild==NULL && b->rchild==NULL)
                    {
```
```python
//若为叶子节点,输出栈中所有节点值
```
```python
for
```
```python
(i=top; i>
```
```python
0
```
```python
; i--)
```
```python
printf
```
```python
(
```
```python
"%c->"
```
```python
,St[i]->data);
```
```python
printf
```
```python
(
```
```python
"%c\n"
```
```python
,St[
```
```python
0
```
```python
]->data);
                    }
                    top--;
                    p=b;
```
```python
//p指向刚访问过的节点
```
```python
}
```
```python
else
```
```python
{
                    b=b->rchild;
```
```python
//b指向右孩子节点
```
```python
flag=
```
```python
0
```
```python
;
                }
            }
        }
```
```python
while
```
```python
(top!=-
```
```python
1
```
```python
);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
int
```
```python
main()
{
    BTNode *b;
    CreateBTNode(b,
```
```python
"A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"二叉树b: "
```
```python
);
    DispBTNode(b);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"从根节点到每个叶子节点的路径之逆:\n"
```
```python
);
    AllPath1(b);
    DestroyBTNode(b);
```
```python
return
```
```python
0
```
```python
;
}
```
解法2：利用二叉树[层次遍历算法](http://edu.csdn.net/course/detail/1553/24077)的思路解决。
采用非环形顺序队列qu
层次遍历二叉树
将所有已访问过的节点指针进队，并在队列中保存双亲节点的位置。
当找到一个叶子节点时，在队列中通过双亲节点的位置输出根节点到该叶子节点的路径之逆。
［参考解答］（btreee.h见[算法库](http://blog.csdn.net/sxhelijian/article/details/49250581)）
```python
#include <stdio.h>
```
```python
#include "btree.h"
```
```python
void
```
```python
AllPath2(BTNode *b)
{
```
```python
struct
```
```python
snode
    {
        BTNode *node;
```
```python
//存放当前节点指针
```
```python
int
```
```python
parent;
```
```python
//存放双亲节点在队列中的位置
```
```python
} qu[MaxSize];
```
```python
//定义非环形队列
```
```python
BTNode *q;
```
```python
int
```
```python
front,rear,p;
```
```python
//定义队头和队尾指针
```
```python
front=rear=-
```
```python
1
```
```python
;
```
```python
//置队列为空队列
```
```python
rear++;
    qu[rear].node=b;
```
```python
//根节点指针进入队列
```
```python
qu[rear].parent=-
```
```python
1
```
```python
;
```
```python
//根节点没有双亲节点
```
```python
while
```
```python
(front!=rear)
```
```python
//队列不为空
```
```python
{
        front++;
```
```python
//front是当前节点*q在qu中的位置
```
```python
q=qu[front].node;
```
```python
//队头出队列,该节点指针仍在qu中
```
```python
if
```
```python
(q->lchild==NULL && q->rchild==NULL)
        {
            p=front;
```
```python
//输出*q到根节点的路径序列
```
```python
while
```
```python
(qu[p].parent!=-
```
```python
1
```
```python
)
            {
```
```python
printf
```
```python
(
```
```python
"%c->"
```
```python
,qu[p].node->data);
                p=qu[p].parent;
            }
```
```python
printf
```
```python
(
```
```python
"%c\n"
```
```python
,qu[p].node->data);
        }
```
```python
if
```
```python
(q->lchild!=NULL)
```
```python
//*q节点有左孩子时将其进列
```
```python
{
            rear++;
            qu[rear].node=q->lchild;
            qu[rear].parent=front;
```
```python
//*q的双亲位置为front
```
```python
}
```
```python
if
```
```python
(q->rchild!=NULL)
```
```python
//*q节点有右孩子时将其进列
```
```python
{
            rear++;
            qu[rear].node=q->rchild;
            qu[rear].parent=front;
```
```python
//*q的双亲位置为front
```
```python
}
    }
}
```
```python
int
```
```python
main()
{
    BTNode *b;
    CreateBTNode(b,
```
```python
"A(B(D,E(H(J,K(L,M(,N))))),C(F,G(,I)))"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"二叉树b: "
```
```python
);
    DispBTNode(b);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"从根节点到每个叶子节点的路径之逆:\n"
```
```python
);
    AllPath2(b);
    DestroyBTNode(b);
```
```python
return
```
```python
0
```
```python
;
}
```
注：在main函数中，创建的用于测试的二叉树如下——
![这里写图片描述](https://img-blog.csdn.net/20151019153602522)

