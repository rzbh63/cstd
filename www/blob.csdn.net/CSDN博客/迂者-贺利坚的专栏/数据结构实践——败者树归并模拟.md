
# 数据结构实践——败者树归并模拟 - 迂者-贺利坚的专栏 - CSDN博客

2015年12月09日 21:31:26[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：2503


本文是针对[[数据结构基础系列(10)：外部排序](http://edu.csdn.net/course/detail/1765)]中的实践项目。
【项目】败者树归并模拟
编写程序，模拟改者树实现5路归并算法的过程。
设有5个文件，其中的记录的关键字如下：
F0:{17,21,∞}　F1:{5,44,∞}　F2:{10,12,∞}F3: {29,32,∞} F4: {15,56,∞}
要求将其归并为一个有序段并输出。
假设这些输入文件数据保存在内存中，输出结果也不必输出到文件，而是在屏幕上输出即可。
[参考解答]()
```python
#include <stdio.h>
```
```python
#define MaxSize 20
```
```python
//每个文件中最多记录
```
```python
#define K 5
```
```python
//5路平衡归并
```
```python
#define MAXKEY 32767
```
```python
//最大关键字值∞
```
```python
#define MINKEY -32768
```
```python
//最小关键字值-∞
```
```python
typedef
```
```python
int
```
```python
InfoType;
```
```python
typedef
```
```python
int
```
```python
KeyType;
```
```python
typedef
```
```python
struct
```
```python
//记录类型
```
```python
{
    KeyType key;
```
```python
//关键字项
```
```python
InfoType otherinfo;
```
```python
//其他数据项,具体类型在主程中定义
```
```python
} RecType;
```
```python
typedef
```
```python
struct
```
```python
{
    RecType recs[MaxSize];
```
```python
int
```
```python
currec;
} FileType;
```
```python
//文件类型
```
```python
typedef
```
```python
int
```
```python
LoserTree[K];
```
```python
//败者树是完全二叉树且不含叶子
```
```python
RecType b[K];
```
```python
//b中存放各段中取出的当前记录
```
```python
FileType F[K];
```
```python
//存放文件记录的数组
```
```python
void
```
```python
initial()
{
```
```python
int
```
```python
i;
```
```python
//5个初始文件,当前读记录号为-1
```
```python
F[
```
```python
0
```
```python
].recs[
```
```python
0
```
```python
].key=
```
```python
17
```
```python
;
    F[
```
```python
0
```
```python
].recs[
```
```python
1
```
```python
].key=
```
```python
21
```
```python
;
    F[
```
```python
0
```
```python
].recs[
```
```python
2
```
```python
].key=MAXKEY;
    F[
```
```python
1
```
```python
].recs[
```
```python
0
```
```python
].key=
```
```python
5
```
```python
;
    F[
```
```python
1
```
```python
].recs[
```
```python
1
```
```python
].key=
```
```python
44
```
```python
;
    F[
```
```python
1
```
```python
].recs[
```
```python
2
```
```python
].key=MAXKEY;
    F[
```
```python
2
```
```python
].recs[
```
```python
0
```
```python
].key=
```
```python
10
```
```python
;
    F[
```
```python
2
```
```python
].recs[
```
```python
1
```
```python
].key=
```
```python
12
```
```python
;
    F[
```
```python
2
```
```python
].recs[
```
```python
2
```
```python
].key=MAXKEY;
    F[
```
```python
3
```
```python
].recs[
```
```python
0
```
```python
].key=
```
```python
29
```
```python
;
    F[
```
```python
3
```
```python
].recs[
```
```python
1
```
```python
].key=
```
```python
32
```
```python
;
    F[
```
```python
3
```
```python
].recs[
```
```python
2
```
```python
].key=MAXKEY;
    F[
```
```python
4
```
```python
].recs[
```
```python
0
```
```python
].key=
```
```python
15
```
```python
;
    F[
```
```python
4
```
```python
].recs[
```
```python
1
```
```python
].key=
```
```python
56
```
```python
;
    F[
```
```python
4
```
```python
].recs[
```
```python
2
```
```python
].key=MAXKEY;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
;i<K;i++)
        F[i].currec=-
```
```python
1
```
```python
;
}
```
```python
void
```
```python
input(
```
```python
int
```
```python
i,
```
```python
int
```
```python
&key)
```
```python
//从F[i]文件中读一个记录到b[i]中
```
```python
{
    F[i].currec++;
    key=F[i].recs[F[i].currec].key;
}
```
```python
void
```
```python
output(
```
```python
int
```
```python
q)
```
```python
//输出F[q]中的当前记录
```
```python
{
```
```python
printf
```
```python
(
```
```python
"输出F[%d]的关键字%d\n"
```
```python
,q,F[q].recs[F[q].currec].key);
}
```
```python
void
```
```python
Adjust(LoserTree ls,
```
```python
int
```
```python
s)
```
```python
//沿从叶子节点b[s]到根节点ls[0]的路径调整败者树
```
```python
{
```
```python
int
```
```python
i,t;
    t=(s+K)/
```
```python
2
```
```python
;
```
```python
//ls[t]是b[s]的双亲节点
```
```python
while
```
```python
(t>
```
```python
0
```
```python
)
    {
```
```python
if
```
```python
(b[s].key>b[ls[t]].key)
        {
            i=s;
            s=ls[t];
```
```python
//s指示新的胜者
```
```python
ls[t]=i;
        }
        t=t/
```
```python
2
```
```python
;
    }
    ls[
```
```python
0
```
```python
]=s;
}
```
```python
void
```
```python
display(LoserTree ls)
```
```python
//输出败者树
```
```python
{
```
```python
int
```
```python
i;
```
```python
printf
```
```python
(
```
```python
"败者树:"
```
```python
);
```
```python
for
```
```python
(i=
```
```python
0
```
```python
;i<K;i++)
```
```python
if
```
```python
(b[ls[i]].key==MAXKEY)
```
```python
printf
```
```python
(
```
```python
"%d(∞) "
```
```python
,ls[i]);
```
```python
else
```
```python
if
```
```python
(b[ls[i]].key==MINKEY)
```
```python
printf
```
```python
(
```
```python
"%d(-∞) "
```
```python
,ls[i]);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"%d(%d) "
```
```python
,ls[i],b[ls[i]].key);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
}
```
```python
void
```
```python
CreateLoserTree(LoserTree ls)
```
```python
//建立败者树
```
```python
{
```
```python
int
```
```python
i;
    b[K].key=MINKEY;
```
```python
//b[K]置为最小关键字
```
```python
for
```
```python
(i=
```
```python
0
```
```python
;i<K;i++)
        ls[i]=K;
```
```python
//设置ls中“败者”的初值,全部为最小关键字段号
```
```python
for
```
```python
(i=K-
```
```python
1
```
```python
;i>=
```
```python
0
```
```python
;--i)
```
```python
//依次从b[K-1]，b[K-2]，…，b[0]出发调整败者
```
```python
Adjust(ls,i);
}
```
```python
void
```
```python
K_Merge(LoserTree ls)
```
```python
//利用败者树ls将进行K路归并到输出
```
```python
{
```
```python
int
```
```python
i,q;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
;i<K;++i)
```
```python
//分别从k个输入归并段读入该段当前第一个记录的关键字到b
```
```python
input(i,b[i].key);
    CreateLoserTree(ls);
```
```python
//建败者树ls,选得最小关键字为b[ls[0]].key
```
```python
display(ls);
```
```python
while
```
```python
(b[ls[
```
```python
0
```
```python
]].key!=MAXKEY)
    {
        q=ls[
```
```python
0
```
```python
];
```
```python
//q指示当前最小关键字所在归并段
```
```python
output(q);
```
```python
//将编号为q的归并段中当前（关键字为b[q].key）的记录输出
```
```python
input(q,b[q].key);
```
```python
//从编号为q的输入归并段中读人下一个记录的关键字
```
```python
if
```
```python
(b[q].key==MAXKEY)
```
```python
printf
```
```python
(
```
```python
"从F[%d]中添加关键字∞并调整\n"
```
```python
,q);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"从F[%d]中添加关键字%d并调整\n"
```
```python
,q,b[q].key);
        Adjust(ls,q);
```
```python
//调整败者树，选择新的最小关键字
```
```python
display(ls);
    }
}
```
```python
int
```
```python
main()
{
    LoserTree ls;
    initial();
    K_Merge(ls);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```

