#  数据库函数依赖和范式理论学习总结

2016年08月31日 22:42:49 [国服第l帅](https://me.csdn.net/wu020708) 阅读数：2429



 版权声明：本文为博主原创文章，未经博主允许不得转载。	https://blog.csdn.net/wu020708/article/details/52389816

## 平凡函数依赖：

如果X→Y(x函数确定y或者y函数依赖x)，但Y函数不确定X（Y不确定<不属于符号不能保存>x），则称X→Y是非平凡的函数依赖；

若X→Y，但Y 属于 X,   则称X→Y是平凡的函数依赖。

在关系SC(Sno, Cno, Grade)【学号，课程号，成绩】中，

**非平凡函数依赖**： (Sno, Cno) → Grade

**平凡函数依赖**：     (Sno, Cno) →Sno

​                    (Sno, Cno) → Cno

对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明，我们总是讨论非平凡函数依赖。

函数定义：

在关系模式R(U)中，如果X→Y，并且对于X的任何一个真子集X`，都有X`-/->Y, 则称Y完全函数依赖于X，记作X-F->Y  (full)。

  若X→Y，但Y不完全函数依赖于X，则称Y部分函数依赖于X，记作XX-P->Y (partial dependency)。

**完全函数依赖**：

在关系SC(Sno, Cno, Grade)学号、课程号、课程得分中，

 由于：单独Sno不能确定Grade，单独Cno不能确定Grade，

 因此：(Sno, Cno)-F->Grade

Grade完全依赖于sno,cno

**部分函数依赖**：

在关系S(Sno, Sname, Ssex, Sage,Sdept)中

​      由于Sno →Ssex

​      因此(Sno,Sname)→p Ssex

**直接函数依赖与传递函数依赖**：

在关系模式R(U)中，如果X→Y，Y→Z，且Y不确定X，Y→Z且Z不确定Y，则称Z传递函数依赖于X。

注: 如果Y→X， 即X←→Y，则Z直接依赖于X。

例: 在关系Std(Sno, Sdept, Mname)学号，专业号，专业主任姓名中，有：

​        Sno → Sdept，Sdept → Mname

​       Mname传递函数依赖于Sno

范式理论

**第1范式**：

如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。

不满足第一范式的数据库模式不能称为关系数据库。

**第2范式**：

若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的任何一个候选码<可以保证每行记录是唯一的标示属性，可以是多个>，则R∈2NF。

关系模式 S(Sno, Sdept, MName,Cno, Grade)

函数依赖包括：

(Sno, Cno) Grade

   Sno → Sdept (Sno,Cno)Sdept

   Sno → Mname (Sno,Cno) Mname

 

非主属性Sdept和MName部分函数依赖于码(Sno, Cno)

产生的问题：

(1) 插入异常

​       假设Sno＝’95102’，Sdept＝’软件’的学生还未选课，因课程号是主属性，因此该学生的信息无法插入数据库。

(2) 删除异常

  假定某个学生本来只选修了3号课程这一门课。现在因身体不适，他连3号课程也不选修了。因课程号是主属性，此操作将导致该学生信息的整个元组都要删除。 

(3) 数据冗余度大

   如果一个学生选修了10门课程，那么他的Sdept和MName值就重复存储了10次。

(4) 修改复杂

例如学生转系，在修改此学生元组的Sdept值的同时，还可能需要修改系主任姓名（MName）。如果这个学生选修了K门课，则必须无遗漏地修改K个元组中全部Sdept、MName信息。

函数依赖关系：

 

用垂直分解法将S分解为两个关系模式，以消除这些部分函数依赖：

采用垂直分解法将一个1NF的关系分解为多个2NF的关系，可以在一定程度上减轻原1NF关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题，但并不能完全消除关系模式中的各种异常情况和数据冗余。

采用垂直分解法，把SM分解为两个关系模式，以消除传递函数依赖：

​      SD（Sno， Sdept）   DL（Sno，Sdept， MName）

   其中：SD的码为Sno， DL的码为Sno。

第3范式：

关系模式R<U，F> 中若不存在这样的码X，属性组Y及非主属性Z（Y不属于Z）, 使得X→Y，Y不确定 X，Y→Z，成立，则称R<U，F> ∈ 3NF。

若R∈3NF，则R的每一个非主属性既不部分函数依赖于码也不传递函数依赖于码。

而对于DL，存在传递函数依赖sno->sdept->mname，需要继续分解。

关系模式S(Sno, Sdept, MName,Cno, Grade)，最后分解为三个关系模式：

​          SC（Sno， Cno， Grade）

​          SD（Sno， Sdept）   DL（Sdept， MNane）

基本消除了数据冗余、插入异常和删除异常

BCNF又称为修正的或者扩充的第三范式:

在第三范式的基础上，如果关系模式是第一范式，且每个属性都不传递依赖于模式的候选键。

仓库管理表（仓库号，存储物品编号，管理员编号，数量）满足如下关系：

（仓库号，存储物品编号）——>（管理员编号，数量）

（管理员编号，存储物品编号）——>（仓库号，数量）

所以，（仓库号，存储物品编号）、（管理员编号，数量）都是该表的候选码，表中的唯一非关键字段为数量，符合第三范式。但是由于存在如下关系：

（仓库号）->（管理员号）

（管理员号）->（仓库号）

即关键字段决定关键字段的问题，因此不符合BCNF。分解：

仓库管理表（仓库号，管理员号）

仓库表（仓库号，存储物品号，数量）

消除了删除异常、插入异常、更新异常

N4范式：

R是一个关系模式，D是R上的多值依赖集合，如果D中存在凡多值依赖X->Y时，X必定是R的超键，则称R是第四范式。

职工表（职工号，职工孩子号，职工授课程号），存在多值事实，不符合N4.

改为：

职工表（职工号，孩子号）

授课表（职工号，授课号）

两个表都只有一个多值 事实，所以符合N4.

 