
# 利用Boost.Python实现Python C-C++混合编程 - 机器学习的小学生 - CSDN博客


2017年04月28日 10:34:06[机器学习的小学生](https://me.csdn.net/xuluhui123)阅读数：12691


学习中如果碰到问题，参考官网例子：
```python
D:
```
```python
\boost
```
```python
_1_61_0
```
```python
\libs
```
```python
\python
```
```python
\test
```
参考：Boost.Python 中英文文档。
利用Boost.Python实现Python C/C++混合编程
## 导出函数
```python
#include<string>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
char
```
```python
const
```
```python
* greet()
{
```
```python
return
```
```python
"hello,world"
```
```python
;
}
BOOST_PYTHON_MODULE(hello_ext)
{
    def(
```
```python
"greet"
```
```python
, greet);
}
```
python:
```python
import
```
```python
hello_ext
```
```python
print
```
```python
hello_ext.greet()
```
## 导出类：
### 导出默认构造的函数的类
**c++**
```python
#include<string>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
World
{
```
```python
void
```
```python
set
```
```python
(
```
```python
string
```
```python
msg) {
```
```python
this
```
```python
->msg = msg; }
```
```python
string
```
```python
greet() {
```
```python
return
```
```python
msg; }
```
```python
string
```
```python
msg;
};
BOOST_PYTHON_MODULE(hello)
```
```python
//导出的module 名字
```
```python
{
    class_<World>(
```
```python
"World"
```
```python
)
        .def(
```
```python
"greet"
```
```python
, &World::greet)
        .def(
```
```python
"set"
```
```python
, &World::
```
```python
set
```
```python
);
}
```
**python:**
```python
import hello 
planet = hello
```
```python
.World
```
```python
()
```
```python
# 调用默认构造函数，产生类对象
```
```python
planet
```
```python
.set
```
```python
(
```
```python
"howdy"
```
```python
)
```
```python
# 调用对象的方法
```
```python
print planet
```
```python
.greet
```
```python
()
```
```python
# 调用对象的方法
```
### 构造函数的导出：
```python
#include<string>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
World
{
    World(
```
```python
string
```
```python
msg):msg(msg){}
```
```python
//增加构造函数
```
```python
World(
```
```python
double
```
```python
a,
```
```python
double
```
```python
b):a(a),b(b) {}
```
```python
//另外一个构造函数
```
```python
void
```
```python
set
```
```python
(
```
```python
string
```
```python
msg) {
```
```python
this
```
```python
->msg = msg; }
```
```python
string
```
```python
greet() {
```
```python
return
```
```python
msg; }
```
```python
double
```
```python
sum_s() {
```
```python
return
```
```python
a + b; }
```
```python
string
```
```python
msg;
```
```python
double
```
```python
a;
```
```python
double
```
```python
b;
};
BOOST_PYTHON_MODULE(hello)
```
```python
//导出的module 名字
```
```python
{
    class_<World>(
```
```python
"World"
```
```python
,init<
```
```python
string
```
```python
>()) 
        .def(init<
```
```python
double
```
```python
,
```
```python
double
```
```python
>())
```
```python
// expose another construct
```
```python
.def(
```
```python
"greet"
```
```python
, &World::greet)
        .def(
```
```python
"set"
```
```python
, &World::
```
```python
set
```
```python
)
        .def(
```
```python
"sum_s"
```
```python
, &World::sum_s);
}
```
**python 测试调用：**
```python
import hello
planet = hello
```
```python
.World
```
```python
(
```
```python
5
```
```python
,
```
```python
6
```
```python
)
planet2 = hello
```
```python
.World
```
```python
(
```
```python
"hollo world"
```
```python
)
print planet
```
```python
.sum
```
```python
_s()
print planet2
```
```python
.greet
```
```python
()
```
如果不想导出任何构造函数，则使用`no_init`:
```python
class
```
```python
_
```
```python
<
```
```python
Abstract
```
```python
>(
```
```python
"Abstract"
```
```python
,no_init)
```
### 类的数据成员
```python
#include<string>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
Var
{
    Var(
```
```python
string
```
```python
name):name(name),value(){}
```
```python
string
```
```python
const
```
```python
name;
```
```python
float
```
```python
value;
};
BOOST_PYTHON_MODULE(hello_var)
{
    class_<Var>(
```
```python
"Var"
```
```python
, init<
```
```python
string
```
```python
>())
        .def_readonly(
```
```python
"name"
```
```python
, &Var::name)
```
```python
//只读
```
```python
.def_readwrite(
```
```python
"value"
```
```python
, &Var::value);
```
```python
//读写
```
```python
}
```
python调用:
```python
import
```
```python
hello_var
```
```python
var
```
```python
= hello_var.Var(
```
```python
"hello_var"
```
```python
)
```
```python
var
```
```python
.value =
```
```python
3.14
```
```python
#
```
```python
var
```
```python
.name =
```
```python
'hello'
```
```python
# error
```
```python
print
```
```python
var
```
```python
.name
```
C++类对象导出为Python的类对象，注意var.name不能赋值。
### 类的属性
```python
// 类的属性
```
```python
#include<string>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
Num
{
    Num(){}
```
```python
float
```
```python
get()
```
```python
const
```
```python
{
```
```python
return
```
```python
val; }
```
```python
void
```
```python
set
```
```python
(
```
```python
float
```
```python
val) {
```
```python
this
```
```python
->val = val; }
```
```python
float
```
```python
val;
};
BOOST_PYTHON_MODULE(hello_num)
{
    class_<Num>(
```
```python
"Num"
```
```python
)
        .add_property(
```
```python
"rovalue"
```
```python
, &Num::get)
```
```python
// 对外：只读
```
```python
.add_property(
```
```python
"value"
```
```python
, &Num::get, &Num::
```
```python
set
```
```python
);
```
```python
// 对外读写 .value值会改变.rovalue值，存储着同样的数据。
```
```python
}
```
python:
```python
import hello_num
```
```python
num
```
```python
= hello_num.Num()
```
```python
num
```
```python
.
```
```python
value
```
```python
=
```
```python
10
```
```python
print
```
```python
num
```
```python
.rovalue
```
```python
#  result: 10
```
### 继承
```python
// 类的继承
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
Base {
```
```python
virtual
```
```python
~Base() {};
```
```python
virtual
```
```python
string
```
```python
getName() {
```
```python
return
```
```python
"Base"
```
```python
; }
```
```python
string
```
```python
str;
};
```
```python
struct
```
```python
Derived : Base {
```
```python
string
```
```python
getName() {
```
```python
return
```
```python
"Derived"
```
```python
; }
};
```
```python
void
```
```python
b(Base *base) {
```
```python
cout
```
```python
<< base->getName() << endl; };
```
```python
void
```
```python
d(Derived *derived) {
```
```python
cout
```
```python
<< derived->getName() << endl; };
Base * factory() {
```
```python
return
```
```python
new
```
```python
Derived; }
```
```python
/*
    下面的额外的代码如果去掉会报错。
    解决地址：http://stackoverflow.com/questions/38261530/unresolved-external-symbols-since-visual-studio-2015-update-3-boost-python-link/38291152#38291152
*/
```
```python
namespace
```
```python
boost
{
```
```python
template
```
```python
<>
    Base
```
```python
const
```
```python
volatile
```
```python
* get_pointer<
```
```python
class
```
```python
Base
```
```python
const
```
```python
volatile
```
```python
>(
```
```python
class
```
```python
Base
```
```python
const
```
```python
volatile
```
```python
*c)
    {
```
```python
return
```
```python
c;
    }
}

BOOST_PYTHON_MODULE(hello_derived)
{
    class_<Base>(
```
```python
"Base"
```
```python
)
        .def(
```
```python
"getName"
```
```python
, &Base::getName)
        .def_readwrite(
```
```python
"str"
```
```python
, &Base::str);

    class_<Derived, bases<Base> >(
```
```python
"Derived"
```
```python
)
        .def(
```
```python
"getName"
```
```python
, &Derived::getName)
        .def_readwrite(
```
```python
"str"
```
```python
, &Derived::str);

    def(
```
```python
"b"
```
```python
, b);
    def(
```
```python
"d"
```
```python
, d);
    def(
```
```python
"factory"
```
```python
, factory,
        return_value_policy<manage_new_object>());
```
```python
//
```
```python
}
```
python:
```python
import hello_derived
derive = hello_derived
```
```python
.factory
```
```python
()
hello_derived
```
```python
.d
```
```python
(derive)
```
### 类的虚函数：
```python
/*
 类的虚函数，实现的功能是：可以编写Python类，来继承C++类
*/
```
```python
#include<boost/python.hpp>
```
```python
#include<boost/python/wrapper.hpp>
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
struct
```
```python
Base
{
```
```python
virtual
```
```python
~Base() {}
```
```python
virtual
```
```python
int
```
```python
f() {
```
```python
return
```
```python
0
```
```python
; };
};
```
```python
struct
```
```python
BaseWrap : Base, wrapper<Base>
{
```
```python
int
```
```python
f()
    {
```
```python
if
```
```python
(override f =
```
```python
this
```
```python
->get_override(
```
```python
"f"
```
```python
))
```
```python
return
```
```python
f();
```
```python
//如果函数进行重载了，则返回重载的
```
```python
return
```
```python
Base::f();
```
```python
//否则返回基类
```
```python
}
```
```python
int
```
```python
default_f() {
```
```python
return
```
```python
this
```
```python
->Base::f(); }
};
BOOST_PYTHON_MODULE(hello_virtual)
{
    class_<BaseWrap, boost::noncopyable>(
```
```python
"Base"
```
```python
)
        .def(
```
```python
"f"
```
```python
, &Base::f, &BaseWrap::default_f);

}
```
python：
```python
import
```
```python
hello_virtual 

base = hello_virtual.Base()
```
```python
# 定义派生类，继承C++类
```
```python
class
```
```python
Derived
```
```python
(hello_virtual.Base)
```
```python
:
```
```python
def
```
```python
f
```
```python
(self)
```
```python
:
```
```python
return
```
```python
42
```
```python
derived = Derived()
```
```python
print
```
```python
base.f()
```
```python
print
```
```python
derived.f()
```
### 类的运算符/特殊函数
```python
// 类的运算符/特殊函数
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
// #include<boost/python.hpp> 如果仅包含该头文件，会出错
```
```python
#include <boost/python/operators.hpp>
```
```python
#include <boost/python/class.hpp>
```
```python
#include <boost/python/module.hpp>
```
```python
#include <boost/python/def.hpp>
```
```python
#include <boost/operators.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
class
```
```python
FilePos
{
```
```python
public
```
```python
:
    FilePos() :len(
```
```python
0
```
```python
) {}
```
```python
operator
```
```python
double
```
```python
()
```
```python
const
```
```python
{
```
```python
return
```
```python
len; };
```
```python
//重载类型转换符
```
```python
int
```
```python
len;
};
```
```python
// operator 方法
```
```python
FilePos
```
```python
operator
```
```python
+(FilePos pos,
```
```python
int
```
```python
a)
{
    pos.len = pos.len + a;
```
```python
return
```
```python
pos;
```
```python
//返回的是副本
```
```python
}
FilePos
```
```python
operator
```
```python
+(
```
```python
int
```
```python
a, FilePos pos)
{
    pos.len = pos.len + a;
```
```python
return
```
```python
pos;
```
```python
//返回的是副本
```
```python
}
```
```python
int
```
```python
operator
```
```python
-(FilePos pos1, FilePos pos2)
{
```
```python
return
```
```python
(pos1.len - pos2.len);
}
FilePos
```
```python
operator
```
```python
-(FilePos pos,
```
```python
int
```
```python
a)
{
    pos.len = pos.len - a;
```
```python
return
```
```python
pos;
}
FilePos &
```
```python
operator
```
```python
+=(FilePos & pos,
```
```python
int
```
```python
a)
{
    pos.len = pos.len + a;
```
```python
return
```
```python
pos;
}
FilePos &
```
```python
operator
```
```python
-=(FilePos & pos,
```
```python
int
```
```python
a)
{
    pos.len = pos.len - a;
```
```python
return
```
```python
pos;
}
```
```python
bool
```
```python
operator
```
```python
<(FilePos  pos1, FilePos pos2)
{
```
```python
if
```
```python
(pos1.len < pos2.len)
```
```python
return
```
```python
true
```
```python
;
```
```python
return
```
```python
false
```
```python
;
}
```
```python
//特殊的方法
```
```python
FilePos
```
```python
pow
```
```python
(FilePos pos1, FilePos pos2)
{
    FilePos res;
    res.len =
```
```python
std
```
```python
::
```
```python
pow
```
```python
(pos1.len, pos2.len);
```
```python
return
```
```python
res;
}
FilePos
```
```python
abs
```
```python
(FilePos pos)
{
    FilePos res;
    res.len =
```
```python
std
```
```python
::
```
```python
abs
```
```python
(pos.len);
```
```python
return
```
```python
res;
}
ostream&
```
```python
operator
```
```python
<<(ostream& out, FilePos pos)
{
    out << pos.len;
```
```python
return
```
```python
out;
}
BOOST_PYTHON_MODULE(hello_operator)
{
    class_<FilePos>(
```
```python
"FilePos"
```
```python
)
        .def_readwrite(
```
```python
"len"
```
```python
,&FilePos::len)
        .def(self +
```
```python
int
```
```python
())
        .def(
```
```python
int
```
```python
() + self)
        .def(self - self)
        .def(self -
```
```python
int
```
```python
())
        .def(self +=
```
```python
int
```
```python
())
        .def(self -= other<
```
```python
int
```
```python
>())
        .def(self < self)
        .def(float_(self))
```
```python
//特殊方法 ,     __float__
```
```python
.def(
```
```python
pow
```
```python
(self, other<FilePos>()))
```
```python
// __pow__
```
```python
.def(
```
```python
abs
```
```python
(self))
```
```python
//  __abs__
```
```python
.def(str(self));
```
```python
//  __str__ for ostream
```
```python
}
```
注意上面的：`.def(pow(self, other<FilePos>()))`模板后面要加上括号。也要注意头文件的包含，否则会引发错误。
python:
```python
import hello_operator
filepos1 = hello_operator
```
```python
.FilePos
```
```python
()
filepos1
```
```python
.len
```
```python
=
```
```python
10
```
```python
filepos2 = hello_operator
```
```python
.FilePos
```
```python
()
filepos2
```
```python
.len
```
```python
=
```
```python
20
```
```python
;
```
```python
print filepos1 - filepos2
```
## 函数
### 函数的调用策略。
```python
// 函数的调用策略
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
X
{
```
```python
string
```
```python
str;
};
```
```python
struct
```
```python
Z
{
```
```python
int
```
```python
value;
};
```
```python
struct
```
```python
Y
{
    X x;
    Z *z;
```
```python
int
```
```python
z_value() {
```
```python
return
```
```python
z->value; }
};
X & f(Y &y, Z*z)
{
    y.z = z;
```
```python
return
```
```python
y.x;
```
```python
//因为x是y的数据成员，x的声明周期与y进行了绑定。因为我们的目的是：Python接口应尽可能的反映C++接口
```
```python
}

BOOST_PYTHON_MODULE(hello_call_policy)
{
    class_<Y>(
```
```python
"Y"
```
```python
)
        .def_readwrite(
```
```python
"x"
```
```python
, &Y::x)
        .def_readwrite(
```
```python
"z"
```
```python
, &Y::z)
        .def(
```
```python
"z_value"
```
```python
, &Y::z_value);
    class_<X>(
```
```python
"X"
```
```python
)
        .def_readwrite(
```
```python
"str"
```
```python
, &X::str);
    class_<Z>(
```
```python
"Z"
```
```python
)
        .def_readwrite(
```
```python
"value"
```
```python
, &Z::value);
```
```python
// return_internal_reference<1 表示返回的值与第一个参数有关系：即第一个参数是返回对象的拥有者（y和x都是引用的形式)。
```
```python
// with_custodian_and_ward<1, 2> 表示第二个参数的生命周期依赖于第一个参数的生命周期。
```
```python
def(
```
```python
"f"
```
```python
, f, return_internal_reference<
```
```python
1
```
```python
, with_custodian_and_ward<
```
```python
1
```
```python
,
```
```python
2
```
```python
> >());
}
```
### 函数重载
```python
// overloading
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
X
{
```
```python
bool
```
```python
f(
```
```python
int
```
```python
a)
    {
```
```python
return
```
```python
true
```
```python
;
    }
```
```python
bool
```
```python
f(
```
```python
int
```
```python
a,
```
```python
double
```
```python
b)
    {
```
```python
return
```
```python
true
```
```python
;
    }
```
```python
bool
```
```python
f(
```
```python
int
```
```python
a,
```
```python
double
```
```python
b,
```
```python
char
```
```python
c)
    {
```
```python
return
```
```python
true
```
```python
;
    }
```
```python
int
```
```python
f(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b,
```
```python
int
```
```python
c)
    {
```
```python
return
```
```python
a + b + c;
    }
};
```
```python
bool
```
```python
(X::*fx1)(
```
```python
int
```
```python
) = &X::f;
```
```python
bool
```
```python
(X::*fx2)(
```
```python
int
```
```python
,
```
```python
double
```
```python
) = &X::f;
```
```python
bool
```
```python
(X::*fx3)(
```
```python
int
```
```python
,
```
```python
double
```
```python
,
```
```python
char
```
```python
) = &X::f;
```
```python
int
```
```python
(X::*fx4)(
```
```python
int
```
```python
,
```
```python
int
```
```python
,
```
```python
int
```
```python
) = &X::f;
BOOST_PYTHON_MODULE(hello_overloaded)
{
    class_<X>(
```
```python
"X"
```
```python
)
        .def(
```
```python
"f"
```
```python
, fx1)
        .def(
```
```python
"f"
```
```python
, fx2)
        .def(
```
```python
"f"
```
```python
, fx3)
        .def(
```
```python
"f"
```
```python
, fx4);
}
```
**python:**
```python
import
```
```python
hello_overloaded
x = hello_overloaded.X() # create a
```
```python
new
```
```python
object
```
```python
print
```
```python
x.f
```
```python
(1
```
```python
)  #
```
```python
default
```
```python
int
```
```python
type
```
```python
print
```
```python
x.f
```
```python
(2
```
```python
,double
```
```python
(3
```
```python
))
```
```python
print
```
```python
x.f
```
```python
(4
```
```python
,double
```
```python
(5
```
```python
),chr
```
```python
(6
```
```python
))  # chr
```
```python
(6
```
```python
) convert * to char
```
```python
print
```
```python
x.f
```
```python
(7
```
```python
,8
```
```python
,9
```
```python
)
```
### 默认参数
#### 普通函数的默认参数：
然而通过上面的方式对重载函数进行封装时，就丢失了默认参数的信息。当然我们可以通过一般形式的封装，如下：
```python
int
```
```python
f(
```
```python
int
```
```python
,
```
```python
double
```
```python
=
```
```python
3.14
```
```python
,
```
```python
char
```
```python
const
```
```python
* =
```
```python
"hello"
```
```python
);
```
```python
int
```
```python
f1(
```
```python
int
```
```python
x){
```
```python
return
```
```python
f(x);}
```
```python
int
```
```python
f2(
```
```python
int
```
```python
x,
```
```python
double
```
```python
y){
```
```python
return
```
```python
f(x,y)}
```
```python
//int module init
```
```python
def(
```
```python
"f"
```
```python
,f);
```
```python
// 所有参数
```
```python
def(
```
```python
"f"
```
```python
,f2);
```
```python
//两个参数
```
```python
def(
```
```python
"f"
```
```python
,f1);
```
```python
//一个参数
```
但是通过上面的形式封装很麻烦。我们可以通过宏的形式，为我们批量完成上面的功能。
**C++:**
```python
// BOOST_PYTHON_FUNCTION_OVERLOADS
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
void
```
```python
foo(
```
```python
int
```
```python
a,
```
```python
char
```
```python
b =
```
```python
1
```
```python
,
```
```python
unsigned
```
```python
c =
```
```python
2
```
```python
,
```
```python
double
```
```python
d =
```
```python
3
```
```python
)
{
```
```python
return
```
```python
;
}
BOOST_PYTHON_FUNCTION_OVERLOADS(foo_overloads, foo,
```
```python
1
```
```python
,
```
```python
4
```
```python
);
```
```python
// 参数个数的最小为1，最大为4
```
```python
BOOST_PYTHON_MODULE(hello_overloaded)
{
    def(
```
```python
"foo"
```
```python
, foo, foo_overloads());
```
```python
//实现导出带有默认参数的函数
```
```python
}
```
**python:**
```python
import hello_overloaded

hello_overloaded
```
```python
.foo
```
```python
(
```
```python
1
```
```python
)
hello_overloaded
```
```python
.foo
```
```python
(
```
```python
1
```
```python
,chr(
```
```python
2
```
```python
))
hello_overloaded
```
```python
.foo
```
```python
(
```
```python
1
```
```python
,chr(
```
```python
2
```
```python
),
```
```python
3
```
```python
)
```
```python
# 3对应的C++为unsigned int
```
```python
hello_overloaded
```
```python
.foo
```
```python
(
```
```python
1
```
```python
,chr(
```
```python
2
```
```python
),
```
```python
3
```
```python
,double(
```
```python
4
```
```python
))
```
#### 成员函数的默认参数：
```python
//使用BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS 宏，完成成员函数默认参数的接口
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
george
{
```
```python
void
```
```python
wack_em(
```
```python
int
```
```python
a,
```
```python
int
```
```python
b =
```
```python
0
```
```python
,
```
```python
char
```
```python
c =
```
```python
'x'
```
```python
)
    {
```
```python
return
```
```python
;
    }
};

BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(george_overloads, wack_em,
```
```python
1
```
```python
,
```
```python
3
```
```python
);
```
```python
// 参数个数的最小为1，最大为3
```
```python
BOOST_PYTHON_MODULE(hello_member_overloaded)
{
    class_<george>(
```
```python
"george"
```
```python
)
        .def(
```
```python
"wack_em"
```
```python
, &george::wack_em, george_overloads());
}
```
**python:**
```python
import hello_member_overloaded
c = hello_member_overloaded
```
```python
.george
```
```python
()
c
```
```python
.wack
```
```python
_em(
```
```python
1
```
```python
)
c
```
```python
.wack
```
```python
_em(
```
```python
1
```
```python
,
```
```python
2
```
```python
)
c
```
```python
.wack
```
```python
_em(
```
```python
1
```
```python
,
```
```python
2
```
```python
,chr(
```
```python
3
```
```python
))
```
**利用init和optional实现构造函数的重载。**
使用方法如下：
```python
// init  optional
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
#include<boost/python.hpp>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
struct
```
```python
X
{
    X(
```
```python
int
```
```python
a,
```
```python
char
```
```python
b =
```
```python
'D'
```
```python
,
```
```python
string
```
```python
c =
```
```python
"constructor"
```
```python
,
```
```python
double
```
```python
b =
```
```python
0.0
```
```python
) {}
};
BOOST_PYTHON_MODULE(hello_construct_overloaded)
{
    class_<X>(
```
```python
"X"
```
```python
)
        .def(init<
```
```python
int
```
```python
, optional<
```
```python
char
```
```python
,
```
```python
string
```
```python
,
```
```python
double
```
```python
> >());
```
```python
// init 和 optional
```
```python
}
```
## 对象接口
Python 是动态类型的语言，C++是静态类型的。Python变量可能是：integer,float ,list ,dict,tuple,str,long,等等，还有其他类型。从Boost.Python和C++的观点来看，Python中的变量是类object的实例，在本节，我们看一下如何处理Python对象。
### 基本接口
```python
// init  optional
```
```python
#include<string>
```
```python
#include<iostream>
```
```python
#include<boost/python.hpp>
```
```python
#include <numpy/arrayobject.h>
```
```python
using
```
```python
namespace
```
```python
std
```
```python
;
```
```python
using
```
```python
namespace
```
```python
boost::python;
```
```python
namespace
```
```python
bp = boost::python;
```
```python
void
```
```python
f(object x)
{
```
```python
int
```
```python
y = extract<
```
```python
int
```
```python
>(x);
```
```python
// retrieve an int from x
```
```python
}
```
```python
int
```
```python
g(object x)
{
    extract<
```
```python
int
```
```python
> get_int(x);
```
```python
if
```
```python
(get_int.check())
```
```python
return
```
```python
get_int();
```
```python
else
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
test(object &x)
{
    dict d = extract<dict>(x.attr(
```
```python
"__dict__"
```
```python
));
    d[
```
```python
"whatever"
```
```python
] =
```
```python
4
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
int
```
```python
test2(dict & d)
{
    d[
```
```python
"helloworld"
```
```python
] =
```
```python
3
```
```python
;
```
```python
return
```
```python
0
```
```python
;
}
```
```python
class
```
```python
A {
```
```python
public
```
```python
:
```
```python
list
```
```python
lst;
```
```python
void
```
```python
listOperation(
```
```python
list
```
```python
&lst) {};
};
```
```python
// 传入np.array数组对象，让C++进行处理
```
```python
int
```
```python
add_arr_1(object & data_obj, object rows_obj, object cols_obj)
{
    PyArrayObject* data_arr =
```
```python
reinterpret_cast
```
```python
<PyArrayObject*>(data_obj.ptr());
```
```python
float
```
```python
* data =
```
```python
static_cast
```
```python
<
```
```python
float
```
```python
*>(PyArray_DATA(data_arr));
```
```python
// using data
```
```python
int
```
```python
rows = extract<
```
```python
int
```
```python
>(rows_obj);
```
```python
int
```
```python
cols = extract<
```
```python
int
```
```python
>(cols_obj);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < rows*cols; i++)
    {
        data[i] +=
```
```python
1
```
```python
;
    }
```
```python
return
```
```python
0
```
```python
;
}
BOOST_PYTHON_MODULE(hello_object)
{
    def(
```
```python
"test"
```
```python
, test);
    def(
```
```python
"test2"
```
```python
, test2);
    def(
```
```python
"add_arr_1"
```
```python
, add_arr_1);
}
```
**python 调用：**
```python
import
```
```python
hello_object
dic1 = {
```
```python
"whatever"
```
```python
:1
```
```python
}
hello_object.test2(dic1)
arr = np.array(
```
```python
[1
```
```python
,2
```
```python
,3
```
```python
],dtype =
```
```python
float32
```
```python
)
```
```python
print
```
```python
arr.dtype
```
```python
print
```
```python
arr
hello_object.add_arr_1(arr
```
```python
,1
```
```python
,3
```
```python
)
```
```python
print
```
```python
arr
```

