
# UDT 最新源码分析（五） -- 网络数据收发 - 老雍的博客 - CSDN博客


2019年01月29日 16:56:59[老雍](https://me.csdn.net/yongkai0214)阅读数：73标签：[UDT																](https://so.csdn.net/so/search/s.do?q=UDT&t=blog)[UDP																](https://so.csdn.net/so/search/s.do?q=UDP&t=blog)[网络																](https://so.csdn.net/so/search/s.do?q=网络&t=blog)[源码分析																](https://so.csdn.net/so/search/s.do?q=源码分析&t=blog)[
							](https://so.csdn.net/so/search/s.do?q=网络&t=blog)[
																					](https://so.csdn.net/so/search/s.do?q=UDP&t=blog)个人分类：[计算机网络																](https://blog.csdn.net/yongkai0214/article/category/7826133)
[
																								](https://so.csdn.net/so/search/s.do?q=UDP&t=blog)
[
				](https://so.csdn.net/so/search/s.do?q=UDT&t=blog)
[
			](https://so.csdn.net/so/search/s.do?q=UDT&t=blog)


### UDT 最新源码分析 -- 网络数据收发
[从接口实现看 UDT 网络收发](#_UDT__4)
[UDT 发送 send / sendmsg / sendfile](#UDT__send__sendmsg__sendfile_8)
[UDT 接收 recv /recvmsg /recvfile](#UDT__recv_recvmsg_recvfile_50)
[从内部实现看 UDT 网络收发](#_UDT__77)
[UDT 发送工作线程](#UDT__116)
[UDT 接收工作线程](#UDT__483)

# 从接口实现看 UDT 网络收发
从对外的接口实现方法来看，网络收发过程实际上是对 m_pSndBuffer 和 m_pRcvBuffer 进行操作，而实际的网络收发涉及到系统调度，算法实现等问题。简单来看看代码。
## UDT 发送 send / sendmsg / sendfile
以 send 为例，外部接口调用send 其实并不是直接发送到网络，而是将数据加入发送的 buffer 中，后续再通过调度将数据发送到网络中去。send 仅仅针对流传输模式而言，其他模式不可调用此函数。对于数据包模式，应该调用 sendmsg。
CUDT::send(UDTSOCKET u, const char* buf, int len, int)
->   CUDT::send(const char* data, int len)
```python
int
```
```python
CUDT
```
```python
::
```
```python
send
```
```python
(
```
```python
const
```
```python
char
```
```python
*
```
```python
data
```
```python
,
```
```python
int
```
```python
len
```
```python
)
```
```python
{
```
```python
.
```
```python
.
```
```python
.
```
```python
if
```
```python
(
```
```python
m_iSndBufSize
```
```python
<=
```
```python
m_pSndBuffer
```
```python
-
```
```python
>
```
```python
getCurrBufSize
```
```python
(
```
```python
)
```
```python
)
```
```python
//buffer 已满
```
```python
{
```
```python
// 检查buffer状态，等待满足条件被触发。
```
```python
// 检查网络连接状态，以及UDT 是否关闭等状态。
```
```python
}
```
```python
int
```
```python
size
```
```python
=
```
```python
(
```
```python
m_iSndBufSize
```
```python
-
```
```python
m_pSndBuffer
```
```python
-
```
```python
>
```
```python
getCurrBufSize
```
```python
(
```
```python
)
```
```python
)
```
```python
*
```
```python
m_iPayloadSize
```
```python
;
```
```python
//最大可用
```
```python
if
```
```python
(
```
```python
size
```
```python
>
```
```python
len
```
```python
)
```
```python
size
```
```python
=
```
```python
len
```
```python
;
```
```python
//size 为本次需要填充的字节，最大为可用容量
```
```python
// record total time used for sending
```
```python
if
```
```python
(
```
```python
0
```
```python
==
```
```python
m_pSndBuffer
```
```python
-
```
```python
>
```
```python
getCurrBufSize
```
```python
(
```
```python
)
```
```python
)
```
```python
m_llSndDurationCounter
```
```python
=
```
```python
CTimer
```
```python
::
```
```python
getTime
```
```python
(
```
```python
)
```
```python
;
```
```python
// insert the user buffer into the sending list
```
```python
m_pSndBuffer
```
```python
-
```
```python
>
```
```python
addBuffer
```
```python
(
```
```python
data
```
```python
,
```
```python
size
```
```python
)
```
```python
;
```
```python
//重点代码，发送过程其实只是放入buffer
```
```python
// insert this socket to snd list if it is not on the list yet
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
update
```
```python
(
```
```python
this
```
```python
,
```
```python
false
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_iSndBufSize
```
```python
<=
```
```python
m_pSndBuffer
```
```python
-
```
```python
>
```
```python
getCurrBufSize
```
```python
(
```
```python
)
```
```python
)
```
```python
{
```
```python
// write is not available any more
```
```python
s_UDTUnited
```
```python
.
```
```python
m_EPoll
```
```python
.
```
```python
update_events
```
```python
(
```
```python
m_SocketID
```
```python
,
```
```python
m_sPollID
```
```python
,
```
```python
UDT_EPOLL_OUT
```
```python
,
```
```python
false
```
```python
)
```
```python
;
```
```python
}
```
```python
return
```
```python
size
```
```python
;
```
```python
}
```
sendmsg 与 send 函数有非常多代码一致，核心代码基本上没有变化。sendfile 中 addbuffer 变成 addBufferFromFile，其余基本没变化。
## UDT 接收 recv /recvmsg /recvfile
从接口调用 recv 实际上只是从接收缓冲中取出数据，在获取数据会检查当前是否流模式，如果没数据，或启动条件唤醒和定时等待等，也会检查网络连接是否正常。
```python
int
```
```python
CUDT
```
```python
::
```
```python
recv
```
```python
(
```
```python
char
```
```python
*
```
```python
data
```
```python
,
```
```python
int
```
```python
len
```
```python
)
```
```python
{
```
```python
.
```
```python
.
```
```python
.
```
```python
if
```
```python
(
```
```python
0
```
```python
==
```
```python
m_pRcvBuffer
```
```python
-
```
```python
>
```
```python
getRcvDataSize
```
```python
(
```
```python
)
```
```python
)
```
```python
// buffer 为空
```
```python
{
```
```python
.
```
```python
.
```
```python
.
```
```python
//等待条件满足或者超时
```
```python
}
```
```python
int
```
```python
res
```
```python
=
```
```python
m_pRcvBuffer
```
```python
-
```
```python
>
```
```python
readBuffer
```
```python
(
```
```python
data
```
```python
,
```
```python
len
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
m_pRcvBuffer
```
```python
-
```
```python
>
```
```python
getRcvDataSize
```
```python
(
```
```python
)
```
```python
<=
```
```python
0
```
```python
)
```
```python
{
```
```python
// read is not available any more
```
```python
s_UDTUnited
```
```python
.
```
```python
m_EPoll
```
```python
.
```
```python
update_events
```
```python
(
```
```python
m_SocketID
```
```python
,
```
```python
m_sPollID
```
```python
,
```
```python
UDT_EPOLL_IN
```
```python
,
```
```python
false
```
```python
)
```
```python
;
```
```python
//删除
```
```python
}
```
```python
if
```
```python
(
```
```python
(
```
```python
res
```
```python
<=
```
```python
0
```
```python
)
```
```python
&&
```
```python
(
```
```python
m_iRcvTimeOut
```
```python
>=
```
```python
0
```
```python
)
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
6
```
```python
,
```
```python
3
```
```python
,
```
```python
0
```
```python
)
```
```python
;
```
```python
return
```
```python
res
```
```python
;
```
```python
}
```
# 从内部实现看 UDT 网络收发
从接口上可以看到，发送接收仅仅是将数据与buffer进行交互，看不到数据真正进行发送接收的地方。那么在内部究竟如何实现的呢？在以前的文章分析中已经提到过发送接收工作线程的概念，在这里再次看看，代码参考 queue.cpp。
初始化的地方如下，通过调用 m_pSndQueue 和 m_pRcvQueue 调用 init 实现 worker 线程创建：
```python
void
```
```python
CUDTUnited
```
```python
::
```
```python
updateMux
```
```python
(
```
```python
CUDTSocket
```
```python
*
```
```python
s
```
```python
,
```
```python
const
```
```python
sockaddr
```
```python
*
```
```python
addr
```
```python
,
```
```python
const
```
```python
UDPSOCKET
```
```python
*
```
```python
udpsock
```
```python
)
```
```python
{
```
```python
.
```
```python
.
```
```python
.
```
```python
CMultiplexer m
```
```python
;
```
```python
m
```
```python
.
```
```python
m_iID
```
```python
=
```
```python
s
```
```python
-
```
```python
>
```
```python
m_SocketID
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
=
```
```python
new
```
```python
CChannel
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iIPversion
```
```python
)
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
setSndBufSize
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iUDPSndBufSize
```
```python
)
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
setRcvBufSize
```
```python
(
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iUDPRcvBufSize
```
```python
)
```
```python
;
```
```python
try
```
```python
{
```
```python
if
```
```python
(
```
```python
NULL
```
```python
!=
```
```python
udpsock
```
```python
)
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
open
```
```python
(
```
```python
*
```
```python
udpsock
```
```python
)
```
```python
;
```
```python
else
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
open
```
```python
(
```
```python
addr
```
```python
)
```
```python
;
```
```python
}
```
```python
catch
```
```python
(
```
```python
CUDTException
```
```python
&
```
```python
e
```
```python
)
```
```python
{
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
close
```
```python
(
```
```python
)
```
```python
;
```
```python
delete
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
;
```
```python
throw
```
```python
e
```
```python
;
```
```python
}
```
```python
m
```
```python
.
```
```python
m_pTimer
```
```python
=
```
```python
new
```
```python
CTimer
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pSndQueue
```
```python
=
```
```python
new
```
```python
CSndQueue
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pSndQueue
```
```python
-
```
```python
>
```
```python
init
```
```python
(
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
,
```
```python
m
```
```python
.
```
```python
m_pTimer
```
```python
)
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pRcvQueue
```
```python
=
```
```python
new
```
```python
CRcvQueue
```
```python
;
```
```python
m
```
```python
.
```
```python
m_pRcvQueue
```
```python
-
```
```python
>
```
```python
init
```
```python
(
```
```python
32
```
```python
,
```
```python
s
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
-
```
```python
>
```
```python
m_iPayloadSize
```
```python
,
```
```python
m
```
```python
.
```
```python
m_iIPversion
```
```python
,
```
```python
1024
```
```python
,
```
```python
m
```
```python
.
```
```python
m_pChannel
```
```python
,
```
```python
m
```
```python
.
```
```python
m_pTimer
```
```python
)
```
```python
;
```
```python
m_mMultiplexer
```
```python
[
```
```python
m
```
```python
.
```
```python
m_iID
```
```python
]
```
```python
=
```
```python
m
```
```python
;
```
```python
}
```
## UDT 发送工作线程
发送线程中主要的变量有 m_pSndUList， m_pChannel， m_pTimer。线程的工作就是不停的检查 m_pSndUList 中的UDT 实例，取出包，通过 m_pChannel 发送出去。如果取出的包时发现未到发送时间，则通过 m_pTimer sleep 剩余的时间再发送。
创建线程如下所示：
```python
void
```
```python
CSndQueue
```
```python
::
```
```python
init
```
```python
(
```
```python
CChannel
```
```python
*
```
```python
c
```
```python
,
```
```python
CTimer
```
```python
*
```
```python
t
```
```python
)
```
```python
{
```
```python
m_pChannel
```
```python
=
```
```python
c
```
```python
;
```
```python
m_pTimer
```
```python
=
```
```python
t
```
```python
;
```
```python
m_pSndUList
```
```python
=
```
```python
new
```
```python
CSndUList
```
```python
;
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_pWindowLock
```
```python
=
```
```python
&
```
```python
m_WindowLock
```
```python
;
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_pWindowCond
```
```python
=
```
```python
&
```
```python
m_WindowCond
```
```python
;
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_pTimer
```
```python
=
```
```python
m_pTimer
```
```python
;
```
```python
#
```
```python
ifndef
```
```python
WIN32
```
```python
if
```
```python
(
```
```python
0
```
```python
!=
```
```python
pthread_create
```
```python
(
```
```python
&
```
```python
m_WorkerThread
```
```python
,
```
```python
NULL
```
```python
,
```
```python
CSndQueue
```
```python
::
```
```python
worker
```
```python
,
```
```python
this
```
```python
)
```
```python
)
```
```python
{
```
```python
m_WorkerThread
```
```python
=
```
```python
0
```
```python
;
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
3
```
```python
,
```
```python
1
```
```python
)
```
```python
;
```
```python
}
```
```python
#
```
```python
else
```
```python
DWORD threadID
```
```python
;
```
```python
m_WorkerThread
```
```python
=
```
```python
CreateThread
```
```python
(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
,
```
```python
CSndQueue
```
```python
::
```
```python
worker
```
```python
,
```
```python
this
```
```python
,
```
```python
0
```
```python
,
```
```python
&
```
```python
threadID
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
NULL
```
```python
==
```
```python
m_WorkerThread
```
```python
)
```
```python
throw
```
```python
CUDTException
```
```python
(
```
```python
3
```
```python
,
```
```python
1
```
```python
)
```
```python
;
```
```python
#
```
```python
endif
```
```python
}
```
根据前面的描述，接下来理解发送工作线程运行过程。getNextProcTime 实际上就是获取 m_pHeap[0] 的 m_llTimeStamp。这个时间就是即将要发送的数据的时间。sleepto 等待时间到达。pop 则是初始化 CPacket，然后再发送。如果 ts <= 0，代表当前并无数据需要发送，需要继续等待。
```python
#
```
```python
ifndef
```
```python
WIN32
```
```python
void
```
```python
*
```
```python
CSndQueue
```
```python
::
```
```python
worker
```
```python
(
```
```python
void
```
```python
*
```
```python
param
```
```python
)
```
```python
#
```
```python
else
```
```python
DWORD WINAPI CSndQueue
```
```python
::
```
```python
worker
```
```python
(
```
```python
LPVOID param
```
```python
)
```
```python
#
```
```python
endif
```
```python
{
```
```python
CSndQueue
```
```python
*
```
```python
self
```
```python
=
```
```python
(
```
```python
CSndQueue
```
```python
*
```
```python
)
```
```python
param
```
```python
;
```
```python
while
```
```python
(
```
```python
!
```
```python
self
```
```python
-
```
```python
>
```
```python
m_bClosing
```
```python
)
```
```python
{
```
```python
uint64_t
```
```python
ts
```
```python
=
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
getNextProcTime
```
```python
(
```
```python
)
```
```python
;
```
```python
//获取下一次发送时间
```
```python
if
```
```python
(
```
```python
ts
```
```python
>
```
```python
0
```
```python
)
```
```python
{
```
```python
// wait until next processing time of the first socket on the list
```
```python
uint64_t
```
```python
currtime
```
```python
;
```
```python
CTimer
```
```python
::
```
```python
rdtsc
```
```python
(
```
```python
currtime
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
currtime
```
```python
<
```
```python
ts
```
```python
)
```
```python
//时间未到
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pTimer
```
```python
-
```
```python
>
```
```python
sleepto
```
```python
(
```
```python
ts
```
```python
)
```
```python
;
```
```python
//sleep, 控制包与包之间的发送间隔
```
```python
// it is time to send the next pkt
```
```python
sockaddr
```
```python
*
```
```python
addr
```
```python
;
```
```python
CPacket pkt
```
```python
;
```
```python
if
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
pop
```
```python
(
```
```python
addr
```
```python
,
```
```python
pkt
```
```python
)
```
```python
<
```
```python
0
```
```python
)
```
```python
continue
```
```python
;
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pChannel
```
```python
-
```
```python
>
```
```python
sendto
```
```python
(
```
```python
addr
```
```python
,
```
```python
pkt
```
```python
)
```
```python
;
```
```python
}
```
```python
else
```
```python
{
```
```python
// wait here if there is no sockets with data to be sent
```
```python
#
```
```python
ifndef
```
```python
WIN32
```
```python
pthread_mutex_lock
```
```python
(
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
self
```
```python
-
```
```python
>
```
```python
m_bClosing
```
```python
&&
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_pSndUList
```
```python
-
```
```python
>
```
```python
m_iLastEntry
```
```python
<
```
```python
0
```
```python
)
```
```python
)
```
```python
pthread_cond_wait
```
```python
(
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowCond
```
```python
,
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowLock
```
```python
)
```
```python
;
```
```python
pthread_mutex_unlock
```
```python
(
```
```python
&
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowLock
```
```python
)
```
```python
;
```
```python
#
```
```python
else
```
```python
WaitForSingleObject
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_WindowCond
```
```python
,
```
```python
INFINITE
```
```python
)
```
```python
;
```
```python
#
```
```python
endif
```
```python
}
```
```python
}
```
```python
#
```
```python
ifndef
```
```python
WIN32
```
```python
return
```
```python
NULL
```
```python
;
```
```python
#
```
```python
else
```
```python
SetEvent
```
```python
(
```
```python
self
```
```python
-
```
```python
>
```
```python
m_ExitCond
```
```python
)
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
#
```
```python
endif
```
```python
}
```
Retrieve the next packet and peer address from the first entry, and reschedule it in the queue.
在线程循环块内，出现了 pop 方法。这个方法取出 m_pHeap 中的根节点，检查时间戳，若时间已到，在堆中删除该节点，进入 packData。
```python
int
```
```python
CSndUList
```
```python
::
```
```python
pop
```
```python
(
```
```python
sockaddr
```
```python
*
```
```python
&
```
```python
addr
```
```python
,
```
```python
CPacket
```
```python
&
```
```python
pkt
```
```python
)
```
```python
{
```
```python
CGuard
```
```python
listguard
```
```python
(
```
```python
m_ListLock
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
-
```
```python
1
```
```python
==
```
```python
m_iLastEntry
```
```python
)
```
```python
//m_pHeap中为空
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
// no pop until the next schedulled time
```
```python
uint64_t
```
```python
ts
```
```python
;
```
```python
CTimer
```
```python
::
```
```python
rdtsc
```
```python
(
```
```python
ts
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
ts
```
```python
<
```
```python
m_pHeap
```
```python
[
```
```python
0
```
```python
]
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
CUDT
```
```python
*
```
```python
u
```
```python
=
```
```python
m_pHeap
```
```python
[
```
```python
0
```
```python
]
```
```python
-
```
```python
>
```
```python
m_pUDT
```
```python
;
```
```python
remove_
```
```python
(
```
```python
u
```
```python
)
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
u
```
```python
-
```
```python
>
```
```python
m_bConnected
```
```python
||
```
```python
u
```
```python
-
```
```python
>
```
```python
m_bBroken
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
// pack a packet from the socket
```
```python
if
```
```python
(
```
```python
u
```
```python
-
```
```python
>
```
```python
packData
```
```python
(
```
```python
pkt
```
```python
,
```
```python
ts
```
```python
)
```
```python
<=
```
```python
0
```
```python
)
```
```python
return
```
```python
-
```
```python
1
```
```python
;
```
```python
addr
```
```python
=
```
```python
u
```
```python
-
```
```python
>
```
```python
m_pPeerAddr
```
```python
;
```
```python
// insert a new entry, ts is the next processing time
```
```python
if
```
```python
(
```
```python
ts
```
```python
>
```
```python
0
```
```python
)
```
```python
insert_
```
```python
(
```
```python
ts
```
```python
,
```
```python
u
```
```python
)
```
```python
;
```
```python
return
```
```python
1
```
```python
;
```
```python
}
```
m_pHeap 是一个以节点时间为参考建立的最小堆。所有的插入与删除操作均为堆的操作，需要注意的是，孩子节点与根节点的对应关系。对于根节点 q 来说，左孩子序号为 2 * q + 1， 右孩子为 2 * q + 2，这也是代码中的 p 节点值。
首先看删除某节点的操作：
```python
void
```
```python
CSndUList
```
```python
::
```
```python
remove_
```
```python
(
```
```python
const
```
```python
CUDT
```
```python
*
```
```python
u
```
```python
)
```
```python
{
```
```python
CSNode
```
```python
*
```
```python
n
```
```python
=
```
```python
u
```
```python
-
```
```python
>
```
```python
m_pSNode
```
```python
;
```
```python
if
```
```python
(
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
>=
```
```python
0
```
```python
)
```
```python
{
```
```python
// remove the node from heap 最后节点与被删节点交换
```
```python
m_pHeap
```
```python
[
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
]
```
```python
=
```
```python
m_pHeap
```
```python
[
```
```python
m_iLastEntry
```
```python
]
```
```python
;
```
```python
m_iLastEntry
```
```python
--
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
]
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
=
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
;
```
```python
int
```
```python
q
```
```python
=
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
;
```
```python
//被删位置上新节点
```
```python
int
```
```python
p
```
```python
=
```
```python
q
```
```python
*
```
```python
2
```
```python
+
```
```python
1
```
```python
;
```
```python
//左孩子序号
```
```python
while
```
```python
(
```
```python
p
```
```python
<=
```
```python
m_iLastEntry
```
```python
)
```
```python
// 存在左孩子节点
```
```python
{
```
```python
// 存在右孩子，且左孩子时间戳大于右孩子时间戳，则修改当前孩子为右孩子
```
```python
if
```
```python
(
```
```python
(
```
```python
p
```
```python
+
```
```python
1
```
```python
<=
```
```python
m_iLastEntry
```
```python
)
```
```python
&&
```
```python
(
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
>
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
+
```
```python
1
```
```python
]
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
)
```
```python
)
```
```python
p
```
```python
++
```
```python
;
```
```python
// 如果根节点时间戳大于孩子中最小时间戳节点，则交换，并置当前节点为新的根节点的左孩子
```
```python
if
```
```python
(
```
```python
m_pHeap
```
```python
[
```
```python
q
```
```python
]
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
>
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
)
```
```python
{
```
```python
CSNode
```
```python
*
```
```python
t
```
```python
=
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
=
```
```python
m_pHeap
```
```python
[
```
```python
q
```
```python
]
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
=
```
```python
p
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
q
```
```python
]
```
```python
=
```
```python
t
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
q
```
```python
]
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
=
```
```python
q
```
```python
;
```
```python
q
```
```python
=
```
```python
p
```
```python
;
```
```python
p
```
```python
=
```
```python
q
```
```python
*
```
```python
2
```
```python
+
```
```python
1
```
```python
;
```
```python
}
```
```python
else
```
```python
break
```
```python
;
```
```python
}
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
=
```
```python
-
```
```python
1
```
```python
;
```
```python
}
```
```python
// the only event has been deleted, wake up immediately
```
```python
if
```
```python
(
```
```python
0
```
```python
==
```
```python
m_iLastEntry
```
```python
)
```
```python
m_pTimer
```
```python
-
```
```python
>
```
```python
interrupt
```
```python
(
```
```python
)
```
```python
;
```
```python
}
```
对于插入操作，只要记住节点序号关系，就很容易看明白了。父节点 p 为孩子节点 (q-1)/2。 如果还不明白，只能去复习一下堆的数据结构相关知识。
```python
void
```
```python
CSndUList
```
```python
::
```
```python
insert_
```
```python
(
```
```python
int64_t
```
```python
ts
```
```python
,
```
```python
const
```
```python
CUDT
```
```python
*
```
```python
u
```
```python
)
```
```python
{
```
```python
CSNode
```
```python
*
```
```python
n
```
```python
=
```
```python
u
```
```python
-
```
```python
>
```
```python
m_pSNode
```
```python
;
```
```python
// do not insert repeated node
```
```python
if
```
```python
(
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
>=
```
```python
0
```
```python
)
```
```python
return
```
```python
;
```
```python
//插入增加到最后节点
```
```python
m_iLastEntry
```
```python
++
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
m_iLastEntry
```
```python
]
```
```python
=
```
```python
n
```
```python
;
```
```python
n
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
=
```
```python
ts
```
```python
;
```
```python
//开始调整
```
```python
int
```
```python
q
```
```python
=
```
```python
m_iLastEntry
```
```python
;
```
```python
int
```
```python
p
```
```python
=
```
```python
q
```
```python
;
```
```python
while
```
```python
(
```
```python
p
```
```python
!=
```
```python
0
```
```python
)
```
```python
{
```
```python
p
```
```python
=
```
```python
(
```
```python
q
```
```python
-
```
```python
1
```
```python
)
```
```python
>>
```
```python
1
```
```python
;
```
```python
//父节点
```
```python
if
```
```python
(
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
>
```
```python
m_pHeap
```
```python
[
```
```python
q
```
```python
]
```
```python
-
```
```python
>
```
```python
m_llTimeStamp
```
```python
)
```
```python
{
```
```python
CSNode
```
```python
*
```
```python
t
```
```python
=
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
p
```
```python
]
```
```python
=
```
```python
m_pHeap
```
```python
[
```
```python
q
```
```python
]
```
```python
;
```
```python
m_pHeap
```
```python
[
```
```python
q
```
```python
]
```
```python
=
```
```python
t
```
```python
;
```
```python
t
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
=
```
```python
q
```
```python
;
```
```python
q
```
```python
=
```
```python
p
```
```python
;
```
```python
}
```
```python
else
```
```python
break
```
```python
;
```
```python
}
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
=
```
```python
q
```
```python
;
```
```python
// an earlier event has been inserted, wake up sending worker
```
```python
if
```
```python
(
```
```python
n
```
```python
-
```
```python
>
```
```python
m_iHeapLoc
```
```python
==
```
```python
0
```
```python
)
```
```python
m_pTimer
```
```python
-
```
```python
>
```
```python
interrupt
```
```python
(
```
```python
)
```
```python
;
```
```python
// first entry, activate the sending queue
```
```python
if
```
```python
(
```
```python
0
```
```python
==
```
```python
m_iLastEntry
```
```python
)
```
```python
{
```
```python
#
```
```python
ifndef
```
```python
WIN32
```
```python
pthread_mutex_lock
```
```python
(
```
```python
m_pWindowLock
```
```python
)
```
```python
;
```
```python
pthread_cond_signal
```
```python
(
```
```python
m_pWindowCond
```
```python
)
```
```python
;
```
```python
//唤醒线程
```
```python
pthread_mutex_unlock
```
```python
(
```
```python
m_pWindowLock
```
```python
)
```
```python
;
```
```python
#
```
```python
else
```
```python
SetEvent
```
```python
(
```
```python
*
```
```python
m_pWindowCond
```
```python
)
```
```python
;
```
```python
#
```
```python
endif
```
```python
}
```
```python
}
```
在发送线程中还有一个 packData 方法，处理了两类 packet 的读取，一是丢失的 packet，二是正常的顺序传输的包。处理过程：
获取 entertime， 更新 m_ullTimeDiff， 即记录当前发包对应目标时间的差值，会影响到下一次发包的目标时间。UDT 以此使得发包的时间间隔始终控制在算法之中。
在 UDT 中，在开始的时候会初始化一个发包时间间隔 m_ullInterval ，这个值表示期望的发送时间间隔。初始化如下所示：
m_ullInterval = (uint64_t)(m_pCC->m_dPktSndPeriod * m_ullCPUFrequency);
m_ullInterval 并不是一个固定的值，而是根据网络状态进行调整。比如在 processCtrl 中 收到包类型为 4 时，就会改变。但是查找代码可以发现，当前udt 版本不再执行 sendCtrl(4)，代码详见包类型为6 时，代码已经被注释。但是无用代码并未删除，如下所示。
// One way packet delay is increasing, so decrease the sending rate
m_ullInterval = (uint64_t)ceil(m_ullInterval * 1.125);在拥塞控制中 CCUpdate 改变 m_ullInterva 值：
m_ullInterval = (uint64_t) (m_pCC->m_dPktSndPeriod * m_ullCPUFrequency);
m_dCongestionWindow = m_pCC->m_dCWndSize;
if (m_llMaxBW <= 0)
return;
const double minSP = 1000000.0 / (double(m_llMaxBW) / m_iMSS) * m_ullCPUFrequency;
if (m_ullInterval < minSP)
m_ullInterval = minSP;
在UDT中，包发送会有一个随着网络状况调整的一个发送周期，也就是 m_ullInterva 值。在每一次发送包时，都会根据 m_ullInterval值计算下一次包发送的理想时间间隔，并修改 m_ullTargetTime 值。
检查是否丢包。
如果丢包，就将 packet.m_iSeqNo 赋值为丢包的序号值。然后计算 offset。m_iSndLastDataAck 是在接收到最后一个 ack 时更新的序号，之前的所有包都被确认。如果 offset < 0, 表示上次确认序号大于丢包序号，即有包未收到但是被确认，可能出现错误。读取数据如果失败，就会发送丢弃请求，并更新 m_iSndCurrSeqNo。
如果没有丢包，则发送一个新包。根据流窗口与拥塞窗口更新 cwnd 值。若发送包序号在窗口范围内，则 readData 并且更新本地和 ccc中 m_iSndCurrSeqNo，更新 m_iSeqNo，检查是否需要发送包对探测。
更新 packet 与 cc，更新 ts, m_ullTargetTime。包将在 worker 中被发送

intCUDT::packData(CPacket&packet,uint64_t&ts){intpayload=0;boolprobe=false;uint64_tentertime;CTimer::rdtsc(entertime);if((0!=m_ullTargetTime)&&(entertime>m_ullTargetTime))m_ullTimeDiff+=entertime-m_ullTargetTime;// Loss retransmission always has higher priority.if((packet.m_iSeqNo=m_pSndLossList->getLostSeq())>=0)//发现丢包，可能超时或者 NACK回应消息{// protect m_iSndLastDataAck from updating by ACK processingCGuardackguard(m_AckLock);intoffset=CSeqNo::seqoff(m_iSndLastDataAck,packet.m_iSeqNo);if(offset<0)return0;intmsglen;//重新取数据payload=m_pSndBuffer->readData(&(packet.m_pcData),offset,packet.m_iMsgNo,msglen);if(-1==payload){int32_tseqpair[2];seqpair[0]=packet.m_iSeqNo;seqpair[1]=CSeqNo::incseq(seqpair[0],msglen);sendCtrl(7,&packet.m_iMsgNo,seqpair,8);// only one msg drop request is necessarym_pSndLossList->remove(seqpair[1]);// skip all dropped packetsif(CSeqNo::seqcmp(m_iSndCurrSeqNo,CSeqNo::incseq(seqpair[1]))<0)m_iSndCurrSeqNo=CSeqNo::incseq(seqpair[1]);return0;}elseif(0==payload)return0;++m_iTraceRetrans;++m_iRetransTotal;}else{// If no loss, pack a new packet.// check congestion/flow window limitintcwnd=(m_iFlowWindowSize<(int)m_dCongestionWindow)?m_iFlowWindowSize:(int)m_dCongestionWindow;if(cwnd>=CSeqNo::seqlen(m_iSndLastAck,CSeqNo::incseq(m_iSndCurrSeqNo))){if(0!=(payload=m_pSndBuffer->readData(&(packet.m_pcData),packet.m_iMsgNo))){m_iSndCurrSeqNo=CSeqNo::incseq(m_iSndCurrSeqNo);m_pCC->setSndCurrSeqNo(m_iSndCurrSeqNo);packet.m_iSeqNo=m_iSndCurrSeqNo;// every 16 (0xF) packets, a packet pair is sentif(0==(packet.m_iSeqNo&0xF))probe=true;}else{m_ullTargetTime=0;m_ullTimeDiff=0;ts=0;return0;}}else{m_ullTargetTime=0;m_ullTimeDiff=0;ts=0;return0;}}packet.m_iTimeStamp=int(CTimer::getTime()-m_StartTime);packet.m_iID=m_PeerID;packet.setLength(payload);m_pCC->onPktSent(&packet);//m_pSndTimeWindow->onPktSent(packet.m_iTimeStamp);++m_llTraceSent;++m_llSentTotal;if(probe){// sends out probing packet pairts=entertime;probe=false;}else{\#ifndefNO_BUSY_WAITINGts=entertime+m_ullInterval;\#elseif(m_ullTimeDiff>=m_ullInterval){ts=entertime;m_ullTimeDiff-=m_ullInterval;}else{ts=entertime+m_ullInterval-m_ullTimeDiff;m_ullTimeDiff=0;}\#endif}m_ullTargetTime=ts;returnpayload;}UDT 接收工作线程
接收工作线程的主要工作同样在 while 循环中完成。首先检查是否有新的 socket 到来，如果有，则不断加入 m_pRcvUList，同时添加到 m_pHash 中。然后再 m_UnitQueue 中查找是否存在可用的存储块，在此过程中如果发现已经数量太多会自动扩容。不断的通过 recvfrom 接收包。
如果是连接请求， 将被送给 listening socket 或者 rendezvous sockets，对应将进入 listen 或者 connect 操作。否则， 根据 getFlag 判断，进入 processData 或者 processCtrl。这也是接收数据被处理的核心函数。最后将这个 UDT实例 放入 m_pRcvUList 最后。
\#ifndefWIN32void*CRcvQueue::worker(void*param)\#elseDWORD WINAPI CRcvQueue::worker(LPVOID param)\#endif{CRcvQueue*self=(CRcvQueue*)param;sockaddr*addr=(AF_INET==self->m_UnitQueue.m_iIPversion)?(sockaddr*)newsockaddr_in:(sockaddr*)newsockaddr_in6;CUDT*u=NULL;int32_tid;while(!self->m_bClosing){\#ifdefNO_BUSY_WAITINGself->m_pTimer->tick();\#endif// check waiting list, if new socket, insert it to the listwhile(self->ifNewEntry()){CUDT*ne=self->getNewEntry();if(NULL!=ne){self->m_pRcvUList->insert(ne);self->m_pHash->insert(ne->m_SocketID,ne);}}// find next available slot for incoming packetCUnit*unit=self->m_UnitQueue.getNextAvailUnit();if(NULL==unit){// no space, skip this packetCPacket temp;temp.m_pcData=newchar[self->m_iPayloadSize];temp.setLength(self->m_iPayloadSize);self->m_pChannel->recvfrom(addr,temp);delete[]temp.m_pcData;gotoTIMER_CHECK;}unit->m_Packet.setLength(self->m_iPayloadSize);// reading next incoming packet, recvfrom returns -1 is nothing has been receivedif(self->m_pChannel->recvfrom(addr,unit->m_Packet)<0)gotoTIMER_CHECK;id=unit->m_Packet.m_iID;// ID 0 is for connection request, which should be passed to the listening socket or rendezvous socketsif(0==id){if(NULL!=self->m_pListener)self->m_pListener->listen(addr,unit->m_Packet);elseif(NULL!=(u=self->m_pRendezvousQueue->retrieve(addr,id))){// asynchronous connect: call connect here// otherwise wait for the UDT socket to retrieve this packetif(!u->m_bSynRecving)u->connect(unit->m_Packet);elseself->storePkt(id,unit->m_Packet.clone());}}elseif(id>0){if(NULL!=(u=self->m_pHash->lookup(id))){if(CIPAddress::ipcmp(addr,u->m_pPeerAddr,u->m_iIPversion)){if(u->m_bConnected&&!u->m_bBroken&&!u->m_bClosing){if(0==unit->m_Packet.getFlag())u->processData(unit);elseu->processCtrl(unit->m_Packet);u->checkTimers();self->m_pRcvUList->update(u);}}}elseif(NULL!=(u=self->m_pRendezvousQueue->retrieve(addr,id))){if(!u->m_bSynRecving)u->connect(unit->m_Packet);elseself->storePkt(id,unit->m_Packet.clone());}}TIMER_CHECK:// take care of the timing event for all UDT socketsuint64_tcurrtime;CTimer::rdtsc(currtime);CRNode*ul=self->m_pRcvUList->m_pUList;uint64_tctime=currtime-100000*CTimer::getCPUFrequency();while((NULL!=ul)&&(ul->m_llTimeStamp<ctime)){CUDT*u=ul->m_pUDT;if(u->m_bConnected&&!u->m_bBroken&&!u->m_bClosing){u->checkTimers();self->m_pRcvUList->update(u);}else{// the socket must be removed from Hash table first, then RcvUListself->m_pHash->remove(u->m_SocketID);self->m_pRcvUList->remove(u);u->m_pRNode->m_bOnList=false;}ul=self->m_pRcvUList->m_pUList;}// Check connection requests status for all sockets in the RendezvousQueue.self->m_pRendezvousQueue->updateConnStatus();}if(AF_INET==self->m_UnitQueue.m_iIPversion)delete(sockaddr_in*)addr;elsedelete(sockaddr_in6*)addr;\#ifndefWIN32returnNULL;\#elseSetEvent(self->m_ExitCond);return0;\#endif}checkTimers 会更新 cc 参数，并发送 ack 包，检查连接是否中断。在代码中，NAK 定时器不再生效，仅仅依靠发送方的超时机制。检测如果16个超时 且 总时间达到阈值才会认为连接挂掉。超时也会导致拥塞控制算法进行调整。
voidCUDT::checkTimers(){// update CC parametersCCUpdate();//更新发包时间间隔和拥塞窗口uint64_tcurrtime;CTimer::rdtsc(currtime);if((currtime>m_ullNextACKTime)||((m_pCC->m_iACKInterval>0)&&(m_pCC->m_iACKInterval<=m_iPktCount))){// ACK timer expired or ACK interval is reachedsendCtrl(2);//ackCTimer::rdtsc(currtime);if(m_pCC->m_iACKPeriod>0)//更新 m_ullNextACKTimem_ullNextACKTime=currtime+m_pCC->m_iACKPeriod*m_ullCPUFrequency;elsem_ullNextACKTime=currtime+m_ullACKInt;m_iPktCount=0;m_iLightACKCount=1;}elseif(m_iSelfClockInterval*m_iLightACKCount<=m_iPktCount){//send a "light" ACKsendCtrl(2,NULL,NULL,4);++m_iLightACKCount;}// we are not sending back repeated NAK anymore and rely on the sender's EXP for retransmission//if ((m_pRcvLossList->getLossLength() > 0) && (currtime > m_ullNextNAKTime))//{//   // NAK timer expired, and there is loss to be reported.//   sendCtrl(3);////   CTimer::rdtsc(currtime);//   m_ullNextNAKTime = currtime + m_ullNAKInt;//} //不再触发 NAK 定时器，仅仅依靠发送方的重传超时，应该是为了减少误丢包识别。uint64_tnext_exp_time;if(m_pCC->m_bUserDefinedRTO)next_exp_time=m_ullLastRspTime+m_pCC->m_iRTO*m_ullCPUFrequency;else{uint64_texp_int=(m_iEXPCount*(m_iRTT+4*m_iRTTVar)+m_iSYNInterval)*m_ullCPUFrequency;if(exp_int<m_iEXPCount*m_ullMinExpInt)exp_int=m_iEXPCount*m_ullMinExpInt;next_exp_time=m_ullLastRspTime+exp_int;}if(currtime>next_exp_time){// Haven't receive any information from the peer, is it dead?!// timeout: at least 16 expirations and must be greater than 10 secondsif((m_iEXPCount>16)&&(currtime-m_ullLastRspTime>5000000*m_ullCPUFrequency)){// Connection is broken.// UDT does not signal any information about this instead of to stop quietly.// Application will detect this when it calls any UDT methods next time.m_bClosing=true;m_bBroken=true;m_iBrokenCounter=30;// update snd U list to remove this socketm_pSndQueue->m_pSndUList->update(this);releaseSynch();// app can call any UDT API to learn the connection_broken errors_UDTUnited.m_EPoll.update_events(m_SocketID,m_sPollID,UDT_EPOLL_IN|UDT_EPOLL_OUT|UDT_EPOLL_ERR,true);CTimer::triggerEvent();return;}// sender: Insert all the packets sent after last received acknowledgement into the sender loss list.// recver: Send out a keep-alive packetif(m_pSndBuffer->getCurrBufSize()>0){if((CSeqNo::incseq(m_iSndCurrSeqNo)!=m_iSndLastAck)&&(m_pSndLossList->getLossLength()==0)){// resend all unacknowledged packets on timeout, but only if there is no packet in the loss listint32_tcsn=m_iSndCurrSeqNo;intnum=m_pSndLossList->insert(m_iSndLastAck,csn);m_iTraceSndLoss+=num;m_iSndLossTotal+=num;}m_pCC->onTimeout();CCUpdate();// immediately restart transmissionm_pSndQueue->m_pSndUList->update(this);}else{sendCtrl(1);//keep-live 包}++m_iEXPCount;//增加，如果到达16 次，进入超时处理，如果收到确认，则重置为0。// Reset last response time since we just sent a heart-beat.m_ullLastRspTime=currtime;}}再回头看数据处理部分 processData 。
intCUDT::processData(CUnit*unit){CPacket&packet=unit->m_Packet;// Just heard from the peer, reset the expiration count.m_iEXPCount=1;//有收到数据，重置 EXPuint64_tcurrtime;CTimer::rdtsc(currtime);m_ullLastRspTime=currtime;//更新 m_ullLastRspTimem_pCC->onPktReceived(&packet);//未找到函数的实现++m_iPktCount;// update time information, 记录包到达的时间以及上一包时间m_pRcvTimeWindow->onPktArrival();//记录的目的用于计算包的到达速率，然后将计算的速率通过ACK反馈回去// check if it is probing packet pair, 用于估计链路容量，将计算的容量通过ACK反馈回去if(0==(packet.m_iSeqNo&0xF))//检查是否为包对m_pRcvTimeWindow->probe1Arrival();//记录包对中第一个包的到达时间elseif(1==(packet.m_iSeqNo&0xF))m_pRcvTimeWindow->probe2Arrival();// 记录探测包对的时间间隔++m_llTraceRecv;++m_llRecvTotal;int32_toffset=CSeqNo::seqoff(m_iRcvLastAck,packet.m_iSeqNo);if((offset<0)||(offset>=m_pRcvBuffer->getAvailBufSize()))return-1;if(m_pRcvBuffer->addData(unit,offset)<0)//将数据包加入到 m_pRcvBufferreturn-1;// Loss detection.if(CSeqNo::seqcmp(packet.m_iSeqNo,CSeqNo::incseq(m_iRcvCurrSeqNo))>0){// If loss found, insert them to the receiver loss listm_pRcvLossList->insert(CSeqNo::incseq(m_iRcvCurrSeqNo),CSeqNo::decseq(packet.m_iSeqNo));// pack loss list for NAKint32_tlossdata[2];lossdata[0]=CSeqNo::incseq(m_iRcvCurrSeqNo)|0x80000000;lossdata[1]=CSeqNo::decseq(packet.m_iSeqNo);// Generate loss report immediately.sendCtrl(3,NULL,lossdata,(CSeqNo::incseq(m_iRcvCurrSeqNo)==CSeqNo::decseq(packet.m_iSeqNo))?1:2);intloss=CSeqNo::seqlen(m_iRcvCurrSeqNo,packet.m_iSeqNo)-2;m_iTraceRcvLoss+=loss;m_iRcvLossTotal+=loss;}// This is not a regular fixed size packet...//an irregular sized packet usually indicates the end of a message, so send an ACK immediatelyif(packet.getLength()!=m_iPayloadSize)CTimer::rdtsc(m_ullNextACKTime);// Update the current largest sequence number that has been received.// Or it is a retransmitted packet, remove it from receiver loss list.if(CSeqNo::seqcmp(packet.m_iSeqNo,m_iRcvCurrSeqNo)>0)m_iRcvCurrSeqNo=packet.m_iSeqNo;elsem_pRcvLossList->remove(packet.m_iSeqNo);return0;}接下来看控制消息的处理。这部分的内容可以参考[UDT 最新协议分析](https://blog.csdn.net/yongkai0214/article/details/85322548).
ACK 处理
如果是一个轻量级 ACK，更新 m_iFlowWindowSize 和 m_iSndLastAck， 终止处理。
否则：使用相同的 ACK 序号返回一个 ACK2 作为确认的确认。更新 m_ullSndLastAck2Time， m_iFlowWindowSize， m_iSndLastDataAck 和 m_iSndLastAck。\
更新发送丢失链表，移除已经被确认的所有包序号。\
更新RTT与RTTVar。更新ACK和NAK周期为 4 * RTT + RTTVar + SYN。\
更新发送端缓冲，释放已经被确认的缓冲。\
更新包到达速率为：A = (A * 7 + a) / 8，其中a为ACK中携带的相应值。更新链路容量估计值：B = (B * 7 + b) / 8，其中b为ACK中携带的相应值。
更新发包间隔 m_ullInterval。
voidCUDT::processCtrl(CPacket&ctrlpkt){...case2://010 - Acknowledgement{int32_tack;// process a lite ACKif(4==ctrlpkt.getLength()){ack=*(int32_t*)ctrlpkt.m_pcData;if(CSeqNo::seqcmp(ack,m_iSndLastAck)>=0){m_iFlowWindowSize-=CSeqNo::seqoff(m_iSndLastAck,ack);//更新 m_iFlowWindowSizem_iSndLastAck=ack;}break;}// read ACK seq. no.ack=ctrlpkt.getAckSeqNo();// send ACK acknowledgement// number of ACK2 can be much less than number of ACKuint64_tnow=CTimer::getTime();if((currtime-m_ullSndLastAck2Time>(uint64_t)m_iSYNInterval)||(ack==m_iSndLastAck2)){sendCtrl(6,&ack);// ack of ack, 对确认包的二次确认m_iSndLastAck2=ack;m_ullSndLastAck2Time=now;}// Got data ACKack=*(int32_t*)ctrlpkt.m_pcData;// check the validation of the ackif(CSeqNo::seqcmp(ack,CSeqNo::incseq(m_iSndCurrSeqNo))>0){//this should not happen: attack or bug . 不应该大于最大发送序号m_bBroken=true;m_iBrokenCounter=0;break;}if(CSeqNo::seqcmp(ack,m_iSndLastAck)>=0)//新的数据的 ack{// Update Flow Window Size, must update before and together with m_iSndLastAckm_iFlowWindowSize=*((int32_t*)ctrlpkt.m_pcData+3);m_iSndLastAck=ack;}// protect packet retransmissionCGuard::enterCS(m_AckLock);intoffset=CSeqNo::seqoff(m_iSndLastDataAck,ack);if(offset<=0){// discard it if it is a repeated ACKCGuard::leaveCS(m_AckLock);break;}// acknowledge the sending bufferm_pSndBuffer->ackData(offset);//仅修改 m_pFirstBlock 指针 和 m_iCount// record total time used for sendingm_llSndDuration+=currtime-m_llSndDurationCounter;m_llSndDurationTotal+=currtime-m_llSndDurationCounter;m_llSndDurationCounter=currtime;// update sending variablesm_iSndLastDataAck=ack;m_pSndLossList->remove(CSeqNo::decseq(m_iSndLastDataAck));//重点函数，后续介绍CGuard::leaveCS(m_AckLock);\#ifndefWIN32pthread_mutex_lock(&m_SendBlockLock);if(m_bSynSending)pthread_cond_signal(&m_SendBlockCond);pthread_mutex_unlock(&m_SendBlockLock);\#elseif(m_bSynSending)SetEvent(m_SendBlockCond);\#endif// acknowledde any waiting epolls to writes_UDTUnited.m_EPoll.update_events(m_SocketID,m_sPollID,UDT_EPOLL_OUT,true);// insert this socket to snd list if it is not on the list yetm_pSndQueue->m_pSndUList->update(this,false);// Update RTT//m_iRTT = *((int32_t *)ctrlpkt.m_pcData + 1);//m_iRTTVar = *((int32_t *)ctrlpkt.m_pcData + 2);intrtt=*((int32_t*)ctrlpkt.m_pcData+1);m_iRTTVar=(m_iRTTVar*3+abs(rtt-m_iRTT))>>2;m_iRTT=(m_iRTT*7+rtt)>>3;m_pCC->setRTT(m_iRTT);//更新cc m_iRTTif(ctrlpkt.getLength()>16){// Update Estimated Bandwidth and packet delivery rateif(*((int32_t*)ctrlpkt.m_pcData+4)>0)m_iDeliveryRate=(m_iDeliveryRate*7+*((int32_t*)ctrlpkt.m_pcData+4))>>3;if(*((int32_t*)ctrlpkt.m_pcData+5)>0)m_iBandwidth=(m_iBandwidth*7+*((int32_t*)ctrlpkt.m_pcData+5))>>3;m_pCC->setRcvRate(m_iDeliveryRate);//更新cc m_iRcvRatem_pCC->setBandwidth(m_iBandwidth);//更新cc m_iBandwidth}m_pCC->onACK(ack);//更新cc m_dPktSndPeriod，进一步影响发包间隔计算 m_ullIntervalCCUpdate();//重新计算 m_ullInterval++m_iRecvACK;++m_iRecvACKTotal;break;}...}ACK2 处理
acknowledge 根据ACK2中的ACK序号，在ACK历史窗口中找到关联的ACK，根据ACK2到达时间和ACK离开时间，计算rtt。
计算新的 RTT = (RTT * 7 + rtt) / 8，更新RTTVar = (RTTVar * 3 + abs(RTT - rtt)) / 4，更新cc中 rtt。
更新被确认的最大ACK序号。
voidCUDT::processCtrl(CPacket&ctrlpkt){case6://110 - Acknowledgement of Acknowledgement{int32_tack;intrtt=-1;// update RTTrtt=m_pACKWindow->acknowledge(ctrlpkt.getAckSeqNo(),ack);if(rtt<=0)break;//if increasing delay detected...//   sendCtrl(4);// RTT EWMAm_iRTTVar=(m_iRTTVar*3+abs(rtt-m_iRTT))>>2;m_iRTT=(m_iRTT*7+rtt)>>3;m_pCC->setRTT(m_iRTT);// update last ACK that has been received by the senderif(CSeqNo::seqcmp(ack,m_iRcvLastAckAck)>0)m_iRcvLastAckAck=ack;break;}}NAK 处理
将 NAK 中携带的所有序号添加到发送丢失链表中。通过码率控制更新 SND 周期。重置 EXP 时间变量。更新 m_pSndUList，等待重传。
voidCUDT::processCtrl(CPacket&ctrlpkt){case3://011 - Loss Report{int32_t*losslist=(int32_t*)(ctrlpkt.m_pcData);m_pCC->onLoss(losslist,ctrlpkt.getLength()/4);//拥塞控制丢包处理，比如停止慢启动，更新参数。CCUpdate();boolsecure=true;// decode loss list message and insert loss into the sender loss listfor(inti=0,n=(int)(ctrlpkt.getLength()/4);i<n;++i){if(0!=(losslist[i]&0x80000000)){if((CSeqNo::seqcmp(losslist[i]&0x7FFFFFFF,losslist[i+1])>0)||(CSeqNo::seqcmp(losslist[i+1],m_iSndCurrSeqNo)>0)){// seq_a must not be greater than seq_b; seq_b must not be greater than the most recent sent seqsecure=false;break;}intnum=0;if(CSeqNo::seqcmp(losslist[i]&0x7FFFFFFF,m_iSndLastAck)>=0)num=m_pSndLossList->insert(losslist[i]&0x7FFFFFFF,losslist[i+1]);elseif(CSeqNo::seqcmp(losslist[i+1],m_iSndLastAck)>=0)num=m_pSndLossList->insert(m_iSndLastAck,losslist[i+1]);m_iTraceSndLoss+=num;m_iSndLossTotal+=num;++i;}elseif(CSeqNo::seqcmp(losslist[i],m_iSndLastAck)>=0){if(CSeqNo::seqcmp(losslist[i],m_iSndCurrSeqNo)>0){//seq_a must not be greater than the most recent sent seqsecure=false;break;}intnum=m_pSndLossList->insert(losslist[i],losslist[i]);m_iTraceSndLoss+=num;m_iSndLossTotal+=num;}}if(!secure){//this should not happen: attack or bugm_bBroken=true;m_iBrokenCounter=0;break;}// the lost packet (retransmission) should be sent out immediatelym_pSndQueue->m_pSndUList->update(this);++m_iRecvNAK;++m_iRecvNAKTotal;break;}}Handshake 处理
case0://000 - Handshake{CHandShake req;req.deserialize(ctrlpkt.m_pcData,ctrlpkt.getLength());if((req.m_iReqType>0)||(m_bRendezvous&&(req.m_iReqType!=-2))){// The peer side has not received the handshake message, so it keeps querying// resend the handshake packetCHandShake initdata;initdata.m_iISN=m_iISN;initdata.m_iMSS=m_iMSS;initdata.m_iFlightFlagSize=m_iFlightFlagSize;initdata.m_iReqType=(!m_bRendezvous)?-1:-2;initdata.m_iID=m_SocketID;char*hs=newchar[m_iPayloadSize];inths_size=m_iPayloadSize;initdata.serialize(hs,hs_size);sendCtrl(0,NULL,hs,hs_size);delete[]hs;}break;}}Msg drop request 处理
在接收缓冲中标记所有属于同一个消息的包，使得不再可读。 在接收丢失链表中移除所有对应的包。
case7://111 - Msg drop requestm_pRcvBuffer->dropMsg(ctrlpkt.getMsgSeq());m_pRcvLossList->remove(*(int32_t*)ctrlpkt.m_pcData,*(int32_t*)(ctrlpkt.m_pcData+4));// move forward with current recv seq no.if((CSeqNo::seqcmp(*(int32_t*)ctrlpkt.m_pcData,CSeqNo::incseq(m_iRcvCurrSeqNo))<=0)&&(CSeqNo::seqcmp(*(int32_t*)(ctrlpkt.m_pcData+4),m_iRcvCurrSeqNo)>0)){m_iRcvCurrSeqNo=*(int32_t*)(ctrlpkt.m_pcData+4);}break;}

