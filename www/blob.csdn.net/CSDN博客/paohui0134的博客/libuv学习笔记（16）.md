
# libuv学习笔记（16） - paohui0134的博客 - CSDN博客


2016年06月23日 22:48:59[paohui0134](https://me.csdn.net/paohui0134)阅读数：1742


# libuv学习笔记（16）
## uv_udp_t数据结构与相关函数
### 数据结构
```python
typedef
```
```python
struct
```
```python
uv_udp_s uv_udp_t;
```
```python
struct
```
```python
uv_udp_s {
  UV_HANDLE_FIELDS
```
```python
//uv_handt_t的成员
```
```python
//目前等待发送的数据
```
```python
size_t send_queue_size;
```
```python
//等待处理的发送请求
```
```python
size_t send_queue_count;
```
```python
//UV_UDP_PRIVATE_FIELDS展开如下：
```
```python
SOCKET socket;
```
```python
unsigned
```
```python
int
```
```python
reqs_pending;
```
```python
int
```
```python
activecnt;                                                              
  uv_req_t recv_req;
```
```python
//接收请求
```
```python
uv_buf_t recv_buffer;
```
```python
//接收的数据
```
```python
struct
```
```python
sockaddr_storage recv_from;
```
```python
//数据来源的地址信息
```
```python
int
```
```python
recv_from_len;                                                          
  uv_udp_recv_cb recv_cb;                                                     
  uv_alloc_cb alloc_cb;                                                       
  LPFN_WSARECV func_wsarecv;
```
```python
//异步函数指针
```
```python
LPFN_WSARECVFROM func_wsarecvfrom;
```
```python
//异步函数指针
```
```python
};
```
### 相关函数
#### 初始化，导出函数，uv.h中声明，udp.c中定义
```python
int uv_udp_init_ex(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_udp_t
```
```python
*
```
```python
handle
```
```python
, unsigned int flags) {
  int domain;
```
```python
//只是用低八位
```
```python
domain
```
```python
=
```
```python
flags
```
```python
&
```
```python
0xFF
```
```python
;
```
```python
if
```
```python
(domain
```
```python
!=
```
```python
AF_INET
```
```python
&&
```
```python
domain
```
```python
!=
```
```python
AF_INET6
```
```python
&&
```
```python
domain
```
```python
!=
```
```python
AF_UNSPEC)
```
```python
return
```
```python
UV_EINVAL;
```
```python
if
```
```python
(flags
```
```python
&
```
```python
~
```
```python
0xFF
```
```python
)
```
```python
return
```
```python
UV_EINVAL;
```
```python
//初始化handle，将handle添加到loop的handle队列
```
```python
uv__handle_init(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
, UV_UDP);
```
```python
handle
```
```python
->
```
```python
socket
```
```python
=
```
```python
INVALID_SOCKET;
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
=
```
```python
0
```
```python
;
```
```python
handle
```
```python
->
```
```python
activecnt
```
```python
=
```
```python
0
```
```python
;
```
```python
handle
```
```python
->
```
```python
func_wsarecv
```
```python
=
```
```python
WSARecv;
```
```python
handle
```
```python
->
```
```python
func_wsarecvfrom
```
```python
=
```
```python
WSARecvFrom;
```
```python
handle
```
```python
->
```
```python
send_queue_size
```
```python
=
```
```python
0
```
```python
;
```
```python
handle
```
```python
->
```
```python
send_queue_count
```
```python
=
```
```python
0
```
```python
;
  uv_req_init(
```
```python
loop
```
```python
, (uv_req_t
```
```python
*
```
```python
)
```
```python
&
```
```python
(
```
```python
handle
```
```python
->
```
```python
recv_req));
```
```python
//初始化接收请求
```
```python
handle
```
```python
->
```
```python
recv_req
```
```python
.
```
```python
type
```
```python
=
```
```python
UV_UDP_RECV;
```
```python
handle
```
```python
->
```
```python
recv_req
```
```python
.
```
```python
data
```
```python
=
```
```python
handle
```
```python
;
```
```python
//如果有错误，移除loophandle队列中的本handle
```
```python
if
```
```python
(domain
```
```python
!=
```
```python
AF_UNSPEC) {
```
```python
//不支持AF_UNSPEC
```
```python
SOCKET sock;
    DWORD err;
    sock
```
```python
=
```
```python
socket(domain, SOCK_DGRAM,
```
```python
0
```
```python
);
```
```python
//获取一个socket
```
```python
if
```
```python
(sock
```
```python
==
```
```python
INVALID_SOCKET) {
      err
```
```python
=
```
```python
WSAGetLastError();
      QUEUE_REMOVE(
```
```python
&
```
```python
handle
```
```python
->
```
```python
handle_queue);
```
```python
return
```
```python
uv_translate_sys_error(err);
    }
    err
```
```python
=
```
```python
uv_udp_set_socket(
```
```python
handle
```
```python
->
```
```python
loop
```
```python
,
```
```python
handle
```
```python
, sock, domain);
```
```python
if
```
```python
(err) {
      closesocket(sock);
      QUEUE_REMOVE(
```
```python
&
```
```python
handle
```
```python
->
```
```python
handle_queue);
```
```python
return
```
```python
uv_translate_sys_error(err);
    }
  }
```
```python
return
```
```python
0
```
```python
;
}
```
#### 打开一个socket作为uv_udp_t，导出函数，uv.h中声明，udp.c中定义
```python
int
```
```python
uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {
  WSAPROTOCOL_INFOW protocol_info;
```
```python
int
```
```python
opt_len;
```
```python
int
```
```python
err;
```
```python
//获取socket地址类型
```
```python
opt_len = (
```
```python
int
```
```python
)
```
```python
sizeof
```
```python
protocol_info;
```
```python
//获取协议详细信息
```
```python
if
```
```python
(getsockopt(sock,
                 SOL_SOCKET,
                 SO_PROTOCOL_INFOW,
                 (
```
```python
char
```
```python
*) &protocol_info,
                 &opt_len) == SOCKET_ERROR) {
```
```python
return
```
```python
uv_translate_sys_error(GetLastError());
  }
```
```python
//将socket与uv_udp_t联系起来
```
```python
err = uv_udp_set_socket(handle->loop,
                          handle,
                          sock,
                          protocol_info.iAddressFamily);
```
```python
return
```
```python
uv_translate_sys_error(err);
}
```
```python
static
```
```python
int
```
```python
uv_udp_set_socket(uv_loop_t* loop, uv_udp_t* handle, SOCKET socket,
```
```python
int
```
```python
family) {
  DWORD yes =
```
```python
1
```
```python
;
  WSAPROTOCOL_INFOW info;
```
```python
int
```
```python
opt_len;
```
```python
if
```
```python
(handle->socket != INVALID_SOCKET)
```
```python
return
```
```python
UV_EBUSY;
```
```python
//socket设置为非阻塞模式
```
```python
if
```
```python
(ioctlsocket(socket, FIONBIO, &yes) == SOCKET_ERROR) {
```
```python
return
```
```python
WSAGetLastError();
  }
```
```python
if
```
```python
(!SetHandleInformation((HANDLE)socket, HANDLE_FLAG_INHERIT,
```
```python
0
```
```python
)) {
```
```python
return
```
```python
GetLastError();
  }
```
```python
//与iocp端口联系起来
```
```python
if
```
```python
(CreateIoCompletionPort((HANDLE)socket,
                             loop->iocp,
                             (ULONG_PTR)socket,
```
```python
0
```
```python
) == NULL) {
```
```python
return
```
```python
GetLastError();
  }
```
```python
if
```
```python
(pSetFileCompletionNotificationModes) {
```
```python
//只能在原生的udp socket上使用SetFileCompletionNotificationModes函数
```
```python
opt_len = (
```
```python
int
```
```python
)
```
```python
sizeof
```
```python
info;
```
```python
if
```
```python
(getsockopt(socket,
                   SOL_SOCKET,
                   SO_PROTOCOL_INFOW,
                   (
```
```python
char
```
```python
*) &info,
                   &opt_len) == SOCKET_ERROR) {
```
```python
return
```
```python
GetLastError();
    }
```
```python
if
```
```python
(info.ProtocolChain.ChainLen ==
```
```python
1
```
```python
) {
```
```python
//lsp链长度为1
```
```python
if
```
```python
(pSetFileCompletionNotificationModes((HANDLE)socket,
          FILE_SKIP_SET_EVENT_ON_HANDLE |
```
```python
//并不会改变socket句柄的状态（signal）
```
```python
FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)) {
```
```python
//不要将以同步方式完成的异步请求添加到与设
```
```python
//备相关联的完成端口中。
```
```python
handle->flags |= UV_HANDLE_SYNC_BYPASS_IOCP;
        handle->func_wsarecv = uv_wsarecv_workaround;
        handle->func_wsarecvfrom = uv_wsarecvfrom_workaround;
      }
```
```python
else
```
```python
if
```
```python
(GetLastError() != ERROR_INVALID_FUNCTION) {
```
```python
return
```
```python
GetLastError();
      }
    }
  }
  handle->socket = socket;
```
```python
//与uv_udp_t联系起来
```
```python
if
```
```python
(family == AF_INET6) {
    handle->flags |= UV_HANDLE_IPV6;
  }
```
```python
else
```
```python
{
    assert(!(handle->flags & UV_HANDLE_IPV6));
  }
```
```python
return
```
```python
0
```
```python
;
}
```
#### 绑定，导出函数，uv.h中声明，udp.c中定义
```python
int
```
```python
uv_udp_bind(uv_udp_t* handle,
```
```python
const
```
```python
struct
```
```python
sockaddr* addr,
```
```python
unsigned
```
```python
int
```
```python
flags) {
```
```python
unsigned
```
```python
int
```
```python
addrlen;
```
```python
if
```
```python
(handle->type != UV_UDP)
```
```python
return
```
```python
UV_EINVAL;
```
```python
if
```
```python
(addr->sa_family == AF_INET)
    addrlen =
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
sockaddr_in);
```
```python
else
```
```python
if
```
```python
(addr->sa_family == AF_INET6)
    addrlen =
```
```python
sizeof
```
```python
(
```
```python
struct
```
```python
sockaddr_in6);
```
```python
else
```
```python
return
```
```python
UV_EINVAL;
```
```python
//调用内部函数处理
```
```python
return
```
```python
uv__udp_bind(handle, addr, addrlen, flags);
}
```
uv__udp_bind调用uv_udp_maybe_bind
```python
static
```
```python
int
```
```python
uv_udp_maybe_bind(uv_udp_t* handle,
```
```python
const
```
```python
struct
```
```python
sockaddr* addr,
```
```python
unsigned
```
```python
int
```
```python
addrlen,
```
```python
unsigned
```
```python
int
```
```python
flags) {
```
```python
int
```
```python
r;
```
```python
int
```
```python
err;
  DWORD no =
```
```python
0
```
```python
;
```
```python
if
```
```python
(handle->flags & UV_HANDLE_BOUND)
```
```python
return
```
```python
0
```
```python
;
```
```python
if
```
```python
((flags & UV_UDP_IPV6ONLY) && addr->sa_family != AF_INET6) {
```
```python
//地址类型错误
```
```python
return
```
```python
ERROR_INVALID_PARAMETER;
  }
```
```python
if
```
```python
(handle->socket == INVALID_SOCKET) {
```
```python
//没有socket就创建
```
```python
SOCKET sock = socket(addr->sa_family, SOCK_DGRAM,
```
```python
0
```
```python
);
```
```python
if
```
```python
(sock == INVALID_SOCKET) {
```
```python
return
```
```python
WSAGetLastError();
    }
```
```python
//socket与handle以及iocp端口联系起来
```
```python
err = uv_udp_set_socket(handle->loop, handle, sock, addr->sa_family);
```
```python
if
```
```python
(err) {
      closesocket(sock);
```
```python
return
```
```python
err;
    }
  }
```
```python
if
```
```python
(flags & UV_UDP_REUSEADDR) {
    DWORD yes =
```
```python
1
```
```python
;
```
```python
/* Set SO_REUSEADDR on the socket. */
```
```python
if
```
```python
(setsockopt(handle->socket,
                   SOL_SOCKET,
                   SO_REUSEADDR,
```
```python
//允许重复绑定
```
```python
(
```
```python
char
```
```python
*) &yes,
```
```python
sizeof
```
```python
yes) == SOCKET_ERROR) {
      err = WSAGetLastError();
```
```python
return
```
```python
err;
    }
  }
```
```python
if
```
```python
(addr->sa_family == AF_INET6)
    handle->flags |= UV_HANDLE_IPV6;
```
```python
if
```
```python
(addr->sa_family == AF_INET6 && !(flags & UV_UDP_IPV6ONLY)) {
    setsockopt(handle->socket,
               IPPROTO_IPV6,
               IPV6_V6ONLY,
               (
```
```python
char
```
```python
*) &no,
```
```python
sizeof
```
```python
no);
  }
  /绑定
  r = bind(handle->socket, addr, addrlen);
```
```python
if
```
```python
(r == SOCKET_ERROR) {
```
```python
return
```
```python
WSAGetLastError();
  }
  handle->flags |= UV_HANDLE_BOUND;
```
```python
return
```
```python
0
```
```python
;
}
```
#### 发送数据
```python
int
```
```python
uv__udp_send(uv_udp_send_t* req,
                 uv_udp_t* handle,
```
```python
const
```
```python
uv_buf_t bufs[],
```
```python
unsigned
```
```python
int
```
```python
nbufs,
```
```python
const
```
```python
struct
```
```python
sockaddr* addr,
```
```python
unsigned
```
```python
int
```
```python
addrlen,
                 uv_udp_send_cb send_cb) {
```
```python
const
```
```python
struct
```
```python
sockaddr* bind_addr;
```
```python
int
```
```python
err;
```
```python
if
```
```python
(!(handle->flags & UV_HANDLE_BOUND)) {
```
```python
//未绑定，绑定默认地址
```
```python
if
```
```python
(addrlen ==
```
```python
sizeof
```
```python
(uv_addr_ip4_any_)) {
      bind_addr = (
```
```python
const
```
```python
struct
```
```python
sockaddr*) &uv_addr_ip4_any_;
    }
```
```python
else
```
```python
if
```
```python
(addrlen ==
```
```python
sizeof
```
```python
(uv_addr_ip6_any_)) {
      bind_addr = (
```
```python
const
```
```python
struct
```
```python
sockaddr*) &uv_addr_ip6_any_;
    }
```
```python
else
```
```python
{
```
```python
abort
```
```python
();
    }
    err = uv_udp_maybe_bind(handle, bind_addr, addrlen,
```
```python
0
```
```python
);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
uv_translate_sys_error(err);
  }
  err = uv__send(req, handle, bufs, nbufs, addr, addrlen, send_cb);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
uv_translate_sys_error(err);
```
```python
return
```
```python
0
```
```python
;
}
```
发送的内部处理函数
```python
static
```
```python
int
```
```python
uv__send(uv_udp_send_t* req,
                    uv_udp_t* handle,
```
```python
const
```
```python
uv_buf_t bufs[],
                    unsigned
```
```python
int
```
```python
nbufs,
```
```python
const
```
```python
struct
```
```python
sockaddr* addr,
                    unsigned
```
```python
int
```
```python
addrlen,
                    uv_udp_send_cb cb) {
  uv_loop_t*
```
```python
loop
```
```python
= handle->
```
```python
loop
```
```python
;
  DWORD result, bytes;
```
```python
//初始化发送请求
```
```python
uv_req_init(
```
```python
loop
```
```python
, (uv_req_t*) req);
  req->
```
```python
type
```
```python
= UV_UDP_SEND;
  req->handle = handle;
  req->cb = cb;
  memset(&req->u.io.overlapped,
```
```python
0
```
```python
, sizeof(req->u.io.overlapped));
```
```python
//异步发送
```
```python
result = WSASendTo(handle->socket,
                     (WSABUF*)bufs,
                     nbufs,
                     &bytes,
```
```python
0
```
```python
,
                     addr,
                     addrlen,
                     &req->u.io.overlapped,
                     NULL);
```
```python
if
```
```python
(UV_SUCCEEDED_WITHOUT_IOCP(result ==
```
```python
0
```
```python
)) {
```
```python
//不使用iocp，直接将请求添加到loop的请求列表
```
```python
req->u.io.queued_bytes =
```
```python
0
```
```python
;
    handle->reqs_pending++;
    handle->send_queue_size += req->u.io.queued_bytes;
    handle->send_queue_count++;
    REGISTER_HANDLE_REQ(
```
```python
loop
```
```python
, handle, req);
    uv_insert_pending_req(
```
```python
loop
```
```python
, (uv_req_t*)req);
  }
```
```python
else
```
```python
if
```
```python
(UV_SUCCEEDED_WITH_IOCP(result ==
```
```python
0
```
```python
)) {
```
```python
//使用iocp
```
```python
req->u.io.queued_bytes = uv__count_bufs(bufs, nbufs);
```
```python
//本次发送的数据
```
```python
handle->reqs_pending++;
    handle->send_queue_size += req->u.io.queued_bytes;
```
```python
//等待发送的数据
```
```python
handle->send_queue_count++;
```
```python
//等待处理的发送请求
```
```python
REGISTER_HANDLE_REQ(
```
```python
loop
```
```python
, handle, req);
```
```python
//注册请求
```
```python
}
```
```python
else
```
```python
{
```
```python
return
```
```python
WSAGetLastError();
  }
```
```python
return
```
```python
0
```
```python
;
}
```
对发送请求的处理：
```python
void
```
```python
uv_process_udp_send_req(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_udp_t
```
```python
*
```
```python
handle
```
```python
,
    uv_udp_send_t
```
```python
*
```
```python
req) {
  int err;
  assert(
```
```python
handle
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_UDP);
  assert(
```
```python
handle
```
```python
->
```
```python
send_queue_size
```
```python
>=
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
queued_bytes);
  assert(
```
```python
handle
```
```python
->
```
```python
send_queue_count
```
```python
>=
```
```python
1
```
```python
);
```
```python
handle
```
```python
->
```
```python
send_queue_size
```
```python
-=
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
queued_bytes;
```
```python
//等待发送的数据
```
```python
handle
```
```python
->
```
```python
send_queue_count
```
```python
--
```
```python
;
```
```python
//等待处理的请求
```
```python
UNREGISTER_HANDLE_REQ(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
, req);
```
```python
//取消请求的注册
```
```python
if
```
```python
(req
```
```python
->
```
```python
cb) {
    err
```
```python
=
```
```python
0
```
```python
;
```
```python
if
```
```python
(
```
```python
!
```
```python
REQ_SUCCESS(req)) {
      err
```
```python
=
```
```python
GET_REQ_SOCK_ERROR(req);
    }
    req
```
```python
->
```
```python
cb(req, uv_translate_sys_error(err));
```
```python
//回调函数
```
```python
}
  DECREASE_PENDING_REQ_COUNT(
```
```python
handle
```
```python
);
```
```python
//handle活动请求递减，如果处于closing状态且活动请求为0，关闭handle
```
```python
}
```
#### 开始读取
内部调用uv__udp_recv_start
```python
int uv__udp_recv_start(uv_udp_t
```
```python
*
```
```python
handle
```
```python
, uv_alloc_cb alloc_cb,
    uv_udp_recv_cb recv_cb) {
  uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
  int err;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING) {
```
```python
return
```
```python
WSAEALREADY;
  }
```
```python
//没绑定就绑定默认的地址
```
```python
err
```
```python
=
```
```python
uv_udp_maybe_bind(
```
```python
handle
```
```python
,
                          (const struct sockaddr
```
```python
*
```
```python
)
```
```python
&
```
```python
uv_addr_ip4_any_,
                          sizeof(uv_addr_ip4_any_),
```
```python
0
```
```python
);
```
```python
if
```
```python
(err)
```
```python
return
```
```python
err;
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_READING;
  INCREASE_ACTIVE_COUNT(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
loop
```
```python
->
```
```python
active_udp_streams
```
```python
++
```
```python
;
```
```python
handle
```
```python
->
```
```python
recv_cb
```
```python
=
```
```python
recv_cb;
```
```python
handle
```
```python
->
```
```python
alloc_cb
```
```python
=
```
```python
alloc_cb;
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READ_PENDING))
    uv_udp_queue_recv(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
//投递接收数据的请求
```
```python
return
```
```python
0
```
```python
;
}
```
投递请求
```python
static
```
```python
void
```
```python
uv_udp_queue_recv(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_udp_t
```
```python
*
```
```python
handle
```
```python
) {
  uv_req_t
```
```python
*
```
```python
req;
  uv_buf_t buf;
  DWORD
```
```python
bytes
```
```python
, flags;
  int result;
  assert(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING);
  assert(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READ_PENDING));
  req
```
```python
=
```
```python
&
```
```python
handle
```
```python
->
```
```python
recv_req;
  memset(
```
```python
&
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped,
```
```python
0
```
```python
, sizeof(req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped));
```
```python
//uv_active_udp_streams_threshold为0，不再需要预分配了
```
```python
if
```
```python
(
```
```python
loop
```
```python
->
```
```python
active_udp_streams
```
```python
<
```
```python
uv_active_udp_streams_threshold) {
```
```python
...
```
```python
}
```
```python
else
```
```python
{
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_ZERO_READ;
    buf
```
```python
.
```
```python
base
```
```python
=
```
```python
(char
```
```python
*
```
```python
) uv_zero_;
    buf
```
```python
.
```
```python
len
```
```python
=
```
```python
0
```
```python
;
    flags
```
```python
=
```
```python
MSG_PEEK;
    result
```
```python
=
```
```python
handle
```
```python
->
```
```python
func_wsarecv(
```
```python
handle
```
```python
->
```
```python
socket,
                                  (WSABUF
```
```python
*
```
```python
)
```
```python
&
```
```python
buf,
```
```python
1
```
```python
,
```
```python
&
```
```python
bytes
```
```python
,
```
```python
&
```
```python
flags,
```
```python
&
```
```python
req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped,
```
```python
NULL
```
```python
);
```
```python
if
```
```python
(UV_SUCCEEDED_WITHOUT_IOCP(result
```
```python
==
```
```python
0
```
```python
)) {
```
```python
//不使用iocp
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_READ_PENDING;
      req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped
```
```python
.
```
```python
InternalHigh
```
```python
=
```
```python
bytes
```
```python
;
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
      uv_insert_pending_req(
```
```python
loop
```
```python
, req);
    }
```
```python
else
```
```python
if
```
```python
(UV_SUCCEEDED_WITH_IOCP(result
```
```python
==
```
```python
0
```
```python
)) {
```
```python
//使用iocp
```
```python
handle
```
```python
->
```
```python
flags
```
```python
|=
```
```python
UV_HANDLE_READ_PENDING;
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
    }
```
```python
else
```
```python
{
```
```python
//出错
```
```python
SET_REQ_ERROR(req, WSAGetLastError());
      uv_insert_pending_req(
```
```python
loop
```
```python
, req);
```
```python
handle
```
```python
->
```
```python
reqs_pending
```
```python
++
```
```python
;
    }
  }
}
```
对读取请求的处理
```python
void
```
```python
uv_process_udp_recv_req(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_udp_t
```
```python
*
```
```python
handle
```
```python
,
    uv_req_t
```
```python
*
```
```python
req) {
  uv_buf_t buf;
  int partial;
  assert(
```
```python
handle
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_UDP);
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_READ_PENDING;
```
```python
if
```
```python
(
```
```python
!
```
```python
REQ_SUCCESS(req)) {
```
```python
//未成功读取
```
```python
DWORD err
```
```python
=
```
```python
GET_REQ_SOCK_ERROR(req);
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAEMSGSIZE) {
```
```python
//包数据比缓存大
```
```python
}
```
```python
else
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAECONNRESET
```
```python
||
```
```python
err
```
```python
==
```
```python
WSAENETRESET) {
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_ZERO_READ)) {
        goto done;
      }
    }
```
```python
else
```
```python
{
```
```python
//真正的错误
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING) {
        uv_udp_recv_stop(
```
```python
handle
```
```python
);
```
```python
//停止接受
```
```python
buf
```
```python
=
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_ZERO_READ)
```
```python
?
```
```python
uv_buf_init(
```
```python
NULL
```
```python
,
```
```python
0
```
```python
) :
```
```python
handle
```
```python
->
```
```python
recv_buffer;
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
, uv_translate_sys_error(err),
```
```python
&
```
```python
buf,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
);
      }
      goto done;
    }
  }
```
```python
if
```
```python
(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_ZERO_READ)) {
```
```python
//成功读取
```
```python
partial
```
```python
=
```
```python
!
```
```python
REQ_SUCCESS(req);
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
,
                    req
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped
```
```python
.
```
```python
InternalHigh,
```
```python
&
```
```python
handle
```
```python
->
```
```python
recv_buffer,
                    (const struct sockaddr
```
```python
*
```
```python
)
```
```python
&
```
```python
handle
```
```python
->
```
```python
recv_from,
                    partial
```
```python
?
```
```python
UV_UDP_PARTIAL :
```
```python
0
```
```python
);
  }
```
```python
else
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING) {
    DWORD
```
```python
bytes
```
```python
, err, flags;
    struct sockaddr_storage from;
    int from_len;
```
```python
handle
```
```python
->
```
```python
alloc_cb((uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
,
```
```python
65536
```
```python
,
```
```python
&
```
```python
buf);
```
```python
if
```
```python
(buf
```
```python
.
```
```python
len
```
```python
==
```
```python
0
```
```python
) {
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
, UV_ENOBUFS,
```
```python
&
```
```python
buf,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
);
      goto done;
    }
    assert(buf
```
```python
.
```
```python
base
```
```python
!=
```
```python
NULL
```
```python
);
    memset(
```
```python
&
```
```python
from,
```
```python
0
```
```python
, sizeof from);
    from_len
```
```python
=
```
```python
sizeof from;
    flags
```
```python
=
```
```python
0
```
```python
;
```
```python
if
```
```python
(WSARecvFrom(
```
```python
handle
```
```python
->
```
```python
socket,
                    (WSABUF
```
```python
*
```
```python
)
```
```python
&
```
```python
buf,
```
```python
1
```
```python
,
```
```python
&
```
```python
bytes
```
```python
,
```
```python
&
```
```python
flags,
                    (struct sockaddr
```
```python
*
```
```python
)
```
```python
&
```
```python
from,
```
```python
&
```
```python
from_len,
```
```python
NULL
```
```python
,
```
```python
NULL
```
```python
)
```
```python
!=
```
```python
SOCKET_ERROR) {
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
,
```
```python
bytes
```
```python
,
```
```python
&
```
```python
buf, (const struct sockaddr
```
```python
*
```
```python
)
```
```python
&
```
```python
from,
```
```python
0
```
```python
);
    }
```
```python
else
```
```python
{
      err
```
```python
=
```
```python
WSAGetLastError();
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAEMSGSIZE) {
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
,
```
```python
bytes
```
```python
,
```
```python
&
```
```python
buf,
                        (const struct sockaddr
```
```python
*
```
```python
)
```
```python
&
```
```python
from,
                        UV_UDP_PARTIAL);
      }
```
```python
else
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAEWOULDBLOCK) {
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
,
```
```python
0
```
```python
,
```
```python
&
```
```python
buf,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
);
      }
```
```python
else
```
```python
if
```
```python
(err
```
```python
==
```
```python
WSAECONNRESET
```
```python
||
```
```python
err
```
```python
==
```
```python
WSAENETRESET) {
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
,
```
```python
0
```
```python
,
```
```python
&
```
```python
buf,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
);
      }
```
```python
else
```
```python
{
        uv_udp_recv_stop(
```
```python
handle
```
```python
);
```
```python
handle
```
```python
->
```
```python
recv_cb(
```
```python
handle
```
```python
, uv_translate_sys_error(err),
```
```python
&
```
```python
buf,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
);
      }
    }
  }
done:
```
```python
/* Post another read if still reading and not closing. */
```
```python
if
```
```python
((
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING)
```
```python
&&
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READ_PENDING)) {
    uv_udp_queue_recv(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
```
```python
//继续投递读取请求
```
```python
}
  DECREASE_PENDING_REQ_COUNT(
```
```python
handle
```
```python
);
}
```
#### 停止读取
内部调用uv__udp_recv_stop
```python
int uv__udp_recv_stop(uv_udp_t
```
```python
*
```
```python
handle
```
```python
) {
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_READING) {
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&=
```
```python
~UV_HANDLE_READING;
```
```python
//取消接受标记
```
```python
handle
```
```python
->
```
```python
loop
```
```python
->
```
```python
active_udp_streams
```
```python
--
```
```python
;
    DECREASE_ACTIVE_COUNT(
```
```python
loop
```
```python
,
```
```python
handle
```
```python
);
  }
```
```python
return
```
```python
0
```
```python
;
}
```
libuv还提供了一些组播相关的API，可以参考以下文章：
[http://blog.csdn.net/langeldep/article/details/6167137](http://blog.csdn.net/langeldep/article/details/6167137)

