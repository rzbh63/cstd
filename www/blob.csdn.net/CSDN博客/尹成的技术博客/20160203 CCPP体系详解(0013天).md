
# 20160203.CCPP体系详解(0013天) - 尹成的技术博客 - CSDN博客

置顶2016年02月16日 21:50:20[尹成](https://me.csdn.net/yincheng01)阅读数：1250个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)


程序片段(01):数组.c+02.数组初始化语法.c
内容概要:**数组**
```python
///01.数组.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.采用容器结构存储数据的要点:
```
```python
//  1.必须为每个数据分配独立的存储空间
```
```python
//  2.必须为每个数据分配独立的标识符(变量名称)
```
```python
//02.C语言之C99语法的特点:
```
```python
//  针对于VC编译器:
```
```python
//      1.VC编译器分配数组的时候必须静态分配
```
```python
//          静态分配:在编译时期确定数组所占据的内存尺寸(字节数)大小
```
```python
//      2.数组长度必须为真常量(或常量表达式)
```
```python
//          明确的数组元素个数
```
```python
//  针对于GCC编译器:
```
```python
//      1.GCC编译器分配数组的时候采用动态分配
```
```python
//          动态分配:在执行时期确定数组所占据的内存尺寸
```
```python
//      2.数组长度可以为伪常量(或变量)
```
```python
//          不确定的数组元素个数(程序执行时期知道)
```
```python
//03.伪常量的声明方式:
```
```python
//  在原始变量的前面添加一个伪常量标识前缀("const")
```
```python
//04.关于常量的透彻分析:
```
```python
//  伪常量:const int num = 1;
```
```python
//      1.具备内存实体:
```
```python
//          不允许直接进行修改,但允许间接进行修改
```
```python
//      2.静态分配:
```
```python
//          在编译时期确定伪常量的值
```
```python
//  真常量:#define NUM 1
```
```python
//      1.不具备内存实体:
```
```python
//          既不允许直接修改,也不允许间接修改
```
```python
//      2.预编译决定:
```
```python
//          在预编译时期就已经决定了将宏名为了常量(整型,实型,字符型,字符串型)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
const
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
//常量表达式{但是该常量表达式的常量值可以经过间接改变,所以是伪常量}-->有内存实体
```
```python
#define NUM 1
```
```python
//真常量{一旦确定了真常量的值,就不允许修改真常量的数据}-->无内存实体
```
```python
//int a[num];//编译的时候确定大小,静态分配,VC不支持
```
```python
int
```
```python
a[NUM];
```
```python
//VC必须静态分配,GCC可以动态分配
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//05.关于数组使用的要点总结:
```
```python
//  1.静态数组分配方式:
```
```python
//      (1).int a[5] = {1, 2, 3, 4, 5};//数组元素的类型:int;数组整体的名称:a;数组元素的个数:5;
```
```python
//          数组元素的具体数据:1, 2, 3, 4, 5
```
```python
//      (2),静态分配:在编译时期就已经确定了数组所占用的内存地址以及内存尺寸(首地址+尺寸)
```
```python
//  2.分配方式组成分析:
```
```python
//      (1).int:表明数组当中所存储的每个元素的类型
```
```python
//      (2).a:表示数组整体的名称(数组名)
```
```python
//          数组名的本质是一个常量指针(伪常量)
```
```python
//      (3).{}:代码块儿分配方式,只能用于声明数组的同时进行使用(既可以局部初始化也可以全部初始化)
```
```python
//  3.sizeof:
```
```python
//      (1).是一个关键字,而不是一个函数
```
```python
//      (2).如果传递的是数组名,那么求取的内存尺寸是数组整体所占用的内存尺寸(区分数组整体和数组元素)
```
```python
//  4.%p和%d的使用意义:
```
```python
//      (1).所以数据在内存当中的存储实质都一样,都是二进制数据
```
```python
//      (2).格式控制符只是决定了不同的解析方式:
```
```python
//          %d:内存数据按照有符号十进制(signed int)类型进行解析
```
```python
//          %p:内存数据按照指针意义进行解析
```
```python
//  5.数组元素以及数组元素的地址:
```
```python
//      a[i]:a[i]表示数组元素的名称,直接写数组元素的名称,相当于访问该数组元素本身(数据)
```
```python
//          好比叫一个人的名字,目的就是为了这个人知道
```
```python
//      &a[i]:&表示根据变量的名称(内存实体)获取该变量的地址
```
```python
//          变量的名称:其实就是内存实体的别名(区分:(变量:内存实体)-->(变量名称:变量别名))
```
```python
//          统称:变量(统一)-->具称:变量别名(唯一)
```
```python
//      说明:中括号"[]"的优先级高于取内存实体地址符"&"的优先级
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//0,1,2,3,4
```
```python
int
```
```python
a[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
//a:数组名称,a代表该数组的内存首地址
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(a));
```
```python
//sizeof(a):用于获取数组所占用的真实内存尺寸(字节大小)
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, a);
```
```python
//数组的内存首地址
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; i++)
    {
```
```python
printf
```
```python
(
```
```python
"%d, %p \n"
```
```python
, a[i], &a[i]);
```
```python
//i:索引;&:符号表示获取变量的内存首地址
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//06.数组元素本身(内存实体)和数组元素地址(内存实体地址)
```
```python
//  1.数组元素地址(内存实体地址)
```
```python
//      &a[i],a+i:数组默认从第0个开始进行索引划分(数组元素(内存实体)的标识符:索引)
```
```python
//  2.数组元素本身(内存实体):
```
```python
//      a[i],*(&a[i]),*(a+i)
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
//数组声明语法:double a[10];数组元素的类型 数组整体的名称[数组元素的个数];
```
```python
double
```
```python
a[
```
```python
10
```
```python
] = {
```
```python
1.0
```
```python
,
```
```python
2.0
```
```python
,
```
```python
3.0
```
```python
,
```
```python
4.0
```
```python
,
```
```python
5.0
```
```python
,
```
```python
6.0
```
```python
,
```
```python
7.0
```
```python
,
```
```python
8.0
```
```python
,
```
```python
9.0
```
```python
,
```
```python
10.0
```
```python
};
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(a));
```
```python
//10*8=80
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; i++)
    {
```
```python
//&a[i], a + i;//代表数组第i个元素的内存实体地址,等价关系a+i(与类型密切相关)//以0作为开头
```
```python
//a + (i - 1)*sizeof(double);//以1作为开头
```
```python
//*号表示根据内存实体的地址获取内存实体本身(数据内容)
```
```python
//a[i], *(&a[i]), *(a + i);//效果等价
```
```python
printf
```
```python
(
```
```python
"%lf, %lf, %lf, %p, %p \n"
```
```python
, a[i], *(&a[i]), *(a + i), &a[i], a + i);
```
```python
//下标,索引
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.数组初始化语法.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.数组的初始化方式:
```
```python
//  标准方式:
```
```python
//      int a[5] = {1, 2, 3, 4, 5};
```
```python
//      数组元素的类型 数组整体的名称[数组元素的指明个数] = {静态初始化的静态数据};
```
```python
//  简化方式:
```
```python
//      itn a[] = {1, 2, 3, 4, 5};
```
```python
//  注意事项:
```
```python
//      1.C/C++当中的静态数组必须进行静态初始化才能进行使用,Java当中的静态数组会进行默认初始化
```
```python
//          大括号:{}就是表明静态初始化
```
```python
//      2.数组的声明必须明确两点:数组元素的数据类型+数组元素的元素个数-->才能确定数组整体尺寸(内存字节数)
```
```python
//      3.赋值特点:
```
```python
//          (1).大括号这种静态初始化方式,只能适用于声明数组的状态下(声明并定义的情况之下)
```
```python
//          (2).统一赋值与指明赋值特点:
```
```python
//              统一赋值:{0}
```
```python
//              指明赋值:
```
```python
//                  完全赋值:
```
```python
//                      {1, 2, 3, 4, 5}
```
```python
//                  前置局部:
```
```python
//                      {1, 2, 3}-->后面默认被编译器初始化为0,只有当前面进行了指明初始化的情况,后面才会进行默认初始化为0的操作
```
```python
//      4.访问特点:
```
```python
//          访问数组整体的内部某个元素本身(内存实体本身),不会出错
```
```python
//          访问数组整体的外部某个元素本身(内存实体本身),可能出错,可能不出错(关键是看系统是否为该内存实体分配了使用权限)
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
```
```python
//int a[10] = { 0 };//C/C++当中的数组必须进行初始化
```
```python
//int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//明确数组初始化元素个数,可以省略数组元素个数的声明
```
```python
//int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 };//数组初始化不允许越界
```
```python
//int a[10] = { 1, 2, 3, 4 };//默认没有初始化值的数组元素都将会被默认的初始化为0
```
```python
int
```
```python
a[
```
```python
5
```
```python
] = {
```
```python
0
```
```python
};
```
```python
//数组必须明确其元素个数
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; i++)
    {
```
```python
//注意不存在长度部分的数据将会是无法预料的值,5之后的数据可能会出现问题
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, a[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.数组名称的操作:
```
```python
//  1.任何指针进行加法,乘法,除法都没有任何实际意义
```
```python
//  2.在同一个数组当中的不同内存实体的内存地址进行
```
```python
//      减法运算具备实际意义,用于获取两个数组元素之间的元素个数差值
```
```python
//  3.C语言的常规数组不能进行整体操作,元素本身(内存实体)可以进行整体操作
```
```python
//  4.C语言的特殊素组(字符数组),如果以'\0'结尾,那么就是一个正常的字符串模拟
```
```python
//      字符串结尾标识符必须是'\0'(字符\0)-->0或者'\0'都一样
```
```python
//      字符:'\0'-->ASCII:0-->以及关键字NULL
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
int
```
```python
b[
```
```python
5
```
```python
] = {
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
};
```
```python
//a = b;//数组名称:标识数组整体的内存空间,数组名称是一个常量指针,不可以直接进行修改
```
```python
//a[1];//访问整体数组a当中的第1个元素所对应的内存实体(数据本身)
```
```python
//a + b;//C语言当中的普通数组不可以进行批量草最,只能针对于某一个元素进行批量操作
```
```python
//a < b;
```
```python
char
```
```python
str[
```
```python
5
```
```python
] = {
```
```python
'c'
```
```python
,
```
```python
'a'
```
```python
,
```
```python
'l'
```
```python
,
```
```python
'c'
```
```python
, NULL };
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
, str);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):01.数组.c+02.数组实战.c
内容概要:**数组实战**
```python
///01.数组.c
```
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <time.h>
```
```python
//01.数组越界问题分析;
```
```python
//  1.采用数组名称访问内存实体的时候:
```
```python
//      如果该内存实体位于数组整体当中的某个部分,那么访问正确
```
```python
//      如果该内存实体位于数组整体外部的某个部分,那么访问出错
```
```python
//          因为操作系统并没有为当前程序当中的数组分配该整体数组外部的内存实体的访问权限
```
```python
//  2.C语言编译器的特点所导致:
```
```python
//      数组不越界一定不会出错,数组越界可能会出错(编译通过但是运行不一定通过)
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//数组越界不一定出错,但是不越界一定不会发生内存访问冲突
```
```python
int
```
```python
a[
```
```python
5
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, a[i]);
```
```python
//存在越界的情况,但是C语言的编译器不一定会进行报错
```
```python
}
```
```python
//当采用数组方式访问到别处内存地址所对应的内存实体(数据本身)的时候,可能会出现报错的情况:
```
```python
//  因为该内存地址在赋值之前就已经具备了一定内存实体(数据本身),不允许紧急性数组操作
```
```python
//  因为操作系统并没有为本程序分配该内存地址的使用权限
```
```python
a[
```
```python
102389898
```
```python
] =
```
```python
1
```
```python
;
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a[
```
```python
10
```
```python
] = {
```
```python
10
```
```python
,
```
```python
9
```
```python
,
```
```python
8
```
```python
,
```
```python
7
```
```python
,
```
```python
6
```
```python
,
```
```python
5
```
```python
,
```
```python
4
```
```python
,
```
```python
3
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
9
```
```python
; i > -
```
```python
1
```
```python
; --i)
    {
```
```python
//逆序输出数组内存实体(数据本身)
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, a[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a[
```
```python
100
```
```python
] = {
```
```python
0
```
```python
};
    time_t te =
```
```python
0
```
```python
;
```
```python
//unsigned int seed = (unsigned int)(time(&te));//获取随机数种子
```
```python
//srand(seed);//种植随机数种子
```
```python
srand((
```
```python
unsigned
```
```python
int
```
```python
)(time(&te)));
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; i++)
    {
```
```python
//循环初始化方式(随机数)
```
```python
a[i] = rand() %
```
```python
300
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, a[i]);
    }
```
```python
int
```
```python
num =
```
```python
0
```
```python
;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
, &num);
```
```python
int
```
```python
flag =
```
```python
0
```
```python
;
```
```python
//假定找不到-->标识多数情况
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
100
```
```python
; ++i)
```
```python
if
```
```python
(a[num] == num)
    {
        flag =
```
```python
1
```
```python
;
```
```python
//标识找到-->只要存在情况
```
```python
break
```
```python
;
    }
```
```python
if
```
```python
(flag)
```
```python
printf
```
```python
(
```
```python
"找到! \n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"找不到! \n"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///02.数组实战.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <time.h>
```
```python
//01.最简单,最无效率的极值获取方式:
```
```python
//  打擂算法:极值获取以及极值在数组当中所对应的索引
```
```python
int
```
```python
main04(
```
```python
void
```
```python
)
{
    time_t te =
```
```python
0
```
```python
;
    srand((
```
```python
unsigned
```
```python
int
```
```python
)(time(&te)));
```
```python
//获取并终止随机数种子
```
```python
int
```
```python
a[
```
```python
20
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
20
```
```python
; ++i)
    {
        a[i] = rand() %
```
```python
300
```
```python
;
```
```python
//通过随机数进行数组的赋值
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, a[i]);
    }
```
```python
int
```
```python
minValue = a[
```
```python
0
```
```python
];
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i <
```
```python
20
```
```python
; ++i)
```
```python
//打擂算法:获取极小值
```
```python
if
```
```python
(minValue > a[i])
            minValue = a[i];
```
```python
int
```
```python
maxValue = a[
```
```python
0
```
```python
];
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i <
```
```python
20
```
```python
; i++)
```
```python
//打擂算法:获取极大值
```
```python
if
```
```python
(maxValue < a[i])
            maxValue = a[i];
```
```python
int
```
```python
minIndex1 =
```
```python
0
```
```python
;
```
```python
int
```
```python
minValue1 = a[
```
```python
0
```
```python
];
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i <
```
```python
20
```
```python
; i++)
```
```python
//打累算法:获取极小值以及极小值在数组当中所对应的索引
```
```python
if
```
```python
(minValue1 > a[i])
        {
            minIndex1 = i;
            minValue1 = a[i];
        }
```
```python
printf
```
```python
(
```
```python
"minIndex1 = %d, minValue1 = %d \n"
```
```python
, minIndex1, minValue1);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.最简单的排序算法:
```
```python
//  1.选择排序算法
```
```python
//  2.时空复杂度分析:
```
```python
//      时间复杂度:n平方
```
```python
//      空间复杂度:1
```
```python
#define EN 20
```
```python
int
```
```python
a[EN];
```
```python
//C语言全局变量默认被初始化为0
```
```python
int
```
```python
main05(
```
```python
void
```
```python
)
{
    time_t te =
```
```python
0
```
```python
;
    srand((
```
```python
unsigned
```
```python
int
```
```python
)(time(&te)));
```
```python
//获取并种植随机数种子
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
20
```
```python
; ++i)
    {
        a[i] = rand() %
```
```python
300
```
```python
;
```
```python
//给数组进行进行随机数赋值
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, a[i]);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
int
```
```python
gtIndex =
```
```python
0
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < EN -
```
```python
1
```
```python
; ++i)
    {
        gtIndex = i;
```
```python
for
```
```python
(
```
```python
int
```
```python
j = i +
```
```python
1
```
```python
; j < EN; ++j)
```
```python
if
```
```python
(a[gtIndex] < a[j])
                gtIndex = j;
```
```python
if
```
```python
(i != gtIndex)
        {
            a[i] = a[i] ^ a[gtIndex];
            a[gtIndex] = a[i] ^ a[gtIndex];
            a[i] = a[i] ^ a[gtIndex];
        }
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
20
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, a[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(03):main.c
内容概要:**GccArray**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
num=
```
```python
10
```
```python
;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
,&num);
```
```python
int
```
```python
a[num];
```
```python
//GCC支持动态分配数组:因此数组的元素个数指定可以采取变量,伪常量,真常量
```
```python
//动态分配，运行的时候
```
```python
return
```
```python
0
```
```python
;
}
```
程序片段(04):冒泡排序.c
内容概要:**冒泡排序法**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
3
```
```python
,
```
```python
5
```
```python
,
```
```python
18
```
```python
,
```
```python
9
```
```python
,
```
```python
23
```
```python
,
```
```python
5
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
-
```
```python
1
```
```python
; ++i)
    {
```
```python
//冒泡法求最大值:两两临近的数据进行比较
```
```python
if
```
```python
(intArr[i] > intArr[i +
```
```python
1
```
```python
])
        {
            intArr[i] = intArr[i] ^ intArr[i +
```
```python
1
```
```python
];
            intArr[i +
```
```python
1
```
```python
] = intArr[i] ^ intArr[i +
```
```python
1
```
```python
];
            intArr[i] = intArr[i] ^ intArr[i +
```
```python
1
```
```python
];
        }
    }
```
```python
printf
```
```python
(
```
```python
"maxValue = %d \n"
```
```python
, intArr[
```
```python
9
```
```python
]);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
3
```
```python
,
```
```python
5
```
```python
,
```
```python
18
```
```python
,
```
```python
9
```
```python
,
```
```python
23
```
```python
,
```
```python
5
```
```python
,
```
```python
2
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
-
```
```python
1
```
```python
; ++i)
```
```python
//外层循环,每完成一次循环,就有一个最值沉底
```
```python
{
```
```python
//冒泡法实现排序:重复进行相邻的两个数据比较
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
10
```
```python
-
```
```python
1
```
```python
- i; ++j)
```
```python
//沉底的次数,决定冒到了那里
```
```python
{
```
```python
if
```
```python
(intArr[j] > intArr[j +
```
```python
1
```
```python
])
```
```python
//沉底
```
```python
{
                intArr[j] = intArr[j] ^ intArr[j +
```
```python
1
```
```python
];
                intArr[j +
```
```python
1
```
```python
] = intArr[j] ^ intArr[j +
```
```python
1
```
```python
];
                intArr[j] = intArr[j] ^ intArr[j +
```
```python
1
```
```python
];
            }
        }
    }
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, intArr[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):斐波那契.c
内容概要:**斐波那契数组法**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.斐波那契数列:
```
```python
//  1.循环实现
```
```python
//  2.递归实现
```
```python
//  3.(循环+栈)实现
```
```python
//02.数组的使用特点:
```
```python
//  模拟栈这种数据结构
```
```python
//      先进后出
```
```python
//  模拟队列这种数据结构
```
```python
//      先进先出
```
```python
//03.如何进行递归加速?
```
```python
//  递归-->循环+栈:可以实现递归加速
```
```python
//04.三种实现斐波那契数列方式的速度问题:
```
```python
//      (循环+栈)>循环>递归
```
```python
int
```
```python
fibonacciLoop(
```
```python
int
```
```python
nItem)
{
```
```python
//循环实现:
```
```python
if
```
```python
(
```
```python
1
```
```python
== nItem ||
```
```python
2
```
```python
== nItem)
```
```python
return
```
```python
1
```
```python
;
```
```python
int
```
```python
temp1 =
```
```python
1
```
```python
;
```
```python
int
```
```python
temp2 =
```
```python
1
```
```python
;
```
```python
int
```
```python
nItemValue =
```
```python
0
```
```python
;
```
```python
//初始化一个常数,效率更高
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
2
```
```python
; i < nItem; ++i)
    {
        nItemValue = temp1 + temp2;
```
```python
//存储推理结果
```
```python
temp1 = temp2;
```
```python
//数据往前推进
```
```python
temp2 = nItemValue;
    }
```
```python
return
```
```python
nItemValue;
}
```
```python
int
```
```python
fibonacciRecursion(
```
```python
int
```
```python
nItem)
{
```
```python
//递归实现:
```
```python
if
```
```python
(
```
```python
1
```
```python
== nItem ||
```
```python
2
```
```python
== nItem)
```
```python
return
```
```python
1
```
```python
;
```
```python
return
```
```python
fibonacciRecursion(nItem -
```
```python
1
```
```python
) + fibonacciRecursion(nItem -
```
```python
2
```
```python
);
```
```python
//关系表达式
```
```python
}
```
```python
int
```
```python
fibonacciLoopStack(
```
```python
int
```
```python
nItem)
{
```
```python
//(循环+栈)实现:
```
```python
int
```
```python
intArr[
```
```python
64
```
```python
] = {
```
```python
0
```
```python
};
    intArr[
```
```python
0
```
```python
] =
```
```python
1
```
```python
;
    intArr[
```
```python
1
```
```python
] =
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
2
```
```python
; i < nItem; ++i)
```
```python
//注意数组存储特点
```
```python
{
        intArr[i] = intArr[i -
```
```python
1
```
```python
] + intArr[i -
```
```python
2
```
```python
];
    }
```
```python
return
```
```python
intArr[nItem -
```
```python
1
```
```python
];
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"loopResult = %d \n"
```
```python
, fibonacciLoop(
```
```python
40
```
```python
));
```
```python
printf
```
```python
(
```
```python
"recursionResult = %d \n"
```
```python
, fibonacciRecursion(
```
```python
40
```
```python
));
```
```python
printf
```
```python
(
```
```python
"loopStackResult = %d \n"
```
```python
, fibonacciLoopStack(
```
```python
40
```
```python
));
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):迷宫1.c
内容概要:**迷宫模拟**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
void
```
```python
showIntArr(
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
][
```
```python
10
```
```python
])
{
```
```python
//显示二维数组
```
```python
printf
```
```python
(
```
```python
"------------------------------ \n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
10
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, intArr[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"------------------------------ \n"
```
```python
);
}
```
```python
//01.数组数据的存储特点:
```
```python
//  1.所有数组的数据在内存当中的存储方式都是线性的
```
```python
//  2.显式的结果不同是由于不同维度的数组对内存当中的数据的解析方式不同
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
][
```
```python
10
```
```python
] = {
```
```python
//二维数组的图形化初始化方式:将二维数组当做一维数组进行看待,该一维数组当中的每个元素就是一行的数据信息
```
```python
{
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
}
    };
    showIntArr(intArr);
```
```python
int
```
```python
px =
```
```python
0
```
```python
, py =
```
```python
0
```
```python
;
```
```python
//点坐标(默认:左上角(0,0)点)
```
```python
intArr[px][py] =
```
```python
1
```
```python
;
```
```python
//根据点坐标修改棋盘上对应点坐标的数据实体(二维平面的数据实体修改为0)
```
```python
showIntArr(intArr);
```
```python
char
```
```python
ch =
```
```python
'\0'
```
```python
;
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
        ch = getchar();
        getchar();
```
```python
//吸收Enter键-->'\n'-->'\r\n':Win解析
```
```python
switch
```
```python
(ch)
        {
```
```python
case
```
```python
'w'
```
```python
:
```
```python
//按键控制
```
```python
if
```
```python
(px -
```
```python
1
```
```python
>=
```
```python
0
```
```python
&& intArr[px][py] !=
```
```python
2
```
```python
)
            {
                intArr[px][py] = intArr[px][py] ^ intArr[px -
```
```python
1
```
```python
][py];
                intArr[px -
```
```python
1
```
```python
][py] = intArr[px][py] ^ intArr[px -
```
```python
1
```
```python
][py];
                intArr[px][py] = intArr[px][py] ^ intArr[px -
```
```python
1
```
```python
][py];
                --px;
            }
```
```python
break
```
```python
;
```
```python
case
```
```python
's'
```
```python
:
```
```python
if
```
```python
(px +
```
```python
1
```
```python
<=
```
```python
9
```
```python
&& intArr[px +
```
```python
1
```
```python
][py] !=
```
```python
2
```
```python
)
            {
                intArr[px][py] = intArr[px][py] ^ intArr[px +
```
```python
1
```
```python
][py];
                intArr[px +
```
```python
1
```
```python
][py] = intArr[px][py] ^ intArr[px +
```
```python
1
```
```python
][py];
                intArr[px][py] = intArr[px][py] ^ intArr[px +
```
```python
1
```
```python
][py];
                ++px;
            }
```
```python
break
```
```python
;
```
```python
case
```
```python
'a'
```
```python
:
```
```python
if
```
```python
(
```
```python
0
```
```python
<= py -
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= intArr[px][py -
```
```python
1
```
```python
])
            {
                intArr[px][py] = intArr[px][py] ^ intArr[px][py -
```
```python
1
```
```python
];
                intArr[px][py -
```
```python
1
```
```python
] = intArr[px][py] ^ intArr[px][py -
```
```python
1
```
```python
];
                intArr[px][py] = intArr[px][py] ^ intArr[px][py -
```
```python
1
```
```python
];
                --py;
            }
```
```python
break
```
```python
;
```
```python
case
```
```python
'd'
```
```python
:
```
```python
if
```
```python
(
```
```python
9
```
```python
>= intArr[px][py +
```
```python
1
```
```python
] &&
```
```python
2
```
```python
!= intArr[px][py +
```
```python
1
```
```python
])
            {
                intArr[px][py] = intArr[px][py] ^ intArr[px][py +
```
```python
1
```
```python
];
                intArr[px][py +
```
```python
1
```
```python
] = intArr[px][py] ^ intArr[px][py +
```
```python
1
```
```python
];
                intArr[px][py] = intArr[px][py] ^ intArr[px][py +
```
```python
1
```
```python
];
                ++py;
            }
```
```python
break
```
```python
;
        }
        showIntArr(intArr);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(07):二分查找法.c
内容概要:**二分查找法以及拉格朗日插值查找**
```python
#
```
```python
define
```
```python
_CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.二分查找法以及二分查找法的变形:
```
```python
//  1.前提条件:待查找的数组当中的数据必须有序
```
```python
//      最好是顺序排列的(从小到大进行排列)
```
```python
//  2.二分查找以及拉格朗日查找:
```
```python
//      拉格朗日查找用于二分查找的加速模式
```
```python
#
```
```python
define
```
```python
N 1024
```
```python
int
```
```python
binarySearch(
```
```python
int
```
```python
intArr[N],
```
```python
int
```
```python
value
```
```python
)
{
```
```python
//二分查找法
```
```python
int
```
```python
minIndex =
```
```python
0
```
```python
;
```
```python
int
```
```python
maxIndex = N -
```
```python
1
```
```python
;
```
```python
int
```
```python
midIndex =
```
```python
0
```
```python
;
```
```python
while
```
```python
(minIndex <= maxIndex)
    {
        midIndex = (minIndex + maxIndex) /
```
```python
2
```
```python
;
```
```python
if
```
```python
(
```
```python
value
```
```python
== intArr[midIndex])
```
```python
return
```
```python
midIndex;
```
```python
else
```
```python
if
```
```python
(
```
```python
value
```
```python
< intArr[midIndex])
            maxIndex = --midIndex;
```
```python
else
```
```python
minIndex = ++minIndex;
    }
```
```python
return
```
```python
-
```
```python
1
```
```python
;
}
```
```python
int
```
```python
lagrangeSearch(
```
```python
int
```
```python
intArr[N],
```
```python
int
```
```python
value
```
```python
)
{
```
```python
//拉格朗日查找法
```
```python
int
```
```python
minIndex =
```
```python
0
```
```python
;
```
```python
int
```
```python
maxIndex = N -
```
```python
1
```
```python
;
```
```python
//int midIndex = 0;
```
```python
int
```
```python
tempIndex =
```
```python
0
```
```python
;
```
```python
while
```
```python
(minIndex <= maxIndex)
    {
```
```python
//midIndex = (minIndex + maxIndex) / 2;
```
```python
//midIndex = minIndex + (maxIndex - minIndex) / 2;
```
```python
tempIndex = minIndex + (
```
```python
value
```
```python
- intArr[minIndex]) / (intArr[maxIndex] - intArr[minIndex]);
```
```python
//二分查找加速
```
```python
if
```
```python
(
```
```python
value
```
```python
== intArr[tempIndex])
```
```python
return
```
```python
tempIndex;
```
```python
else
```
```python
if
```
```python
(
```
```python
value
```
```python
< intArr[tempIndex])
            maxIndex = --tempIndex;
```
```python
else
```
```python
minIndex = ++tempIndex;
    }
```
```python
return
```
```python
-
```
```python
1
```
```python
;
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
1024
```
```python
; ++i)
        intArr[i] = i;
```
```python
int
```
```python
value
```
```python
=
```
```python
0
```
```python
;
    scanf(
```
```python
"%d"
```
```python
, &
```
```python
value
```
```python
);
    printf(
```
```python
"valueIndex = %d \n"
```
```python
, binarySearch(intArr,
```
```python
value
```
```python
));
    printf(
```
```python
"valueIndex = %d \n"
```
```python
, lagrangeSearch(intArr,
```
```python
value
```
```python
));
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(08):插入排序法.c
内容概要:**插入排序法**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//插值法也要求数据必须有序
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
,
```
```python
5
```
```python
};
```
```python
int
```
```python
tempIndex =
```
```python
9
```
```python
;
```
```python
int
```
```python
tempValue = intArr[
```
```python
9
```
```python
];
```
```python
while
```
```python
(tempIndex >
```
```python
0
```
```python
&& intArr[tempIndex -
```
```python
1
```
```python
] > tempValue)
```
```python
//从后往前进行插值
```
```python
{
```
```python
//tempIndex>0:由于要让索引-1,但是索引-1之后必须>=0因此索引必须>=1
```
```python
//当此循环退出的时候,退出时所在的索引其实就是刚好需要进行插值的索引位置
```
```python
intArr[tempIndex] = intArr[tempIndex -
```
```python
1
```
```python
];
        --tempIndex;
    }
    intArr[tempIndex] = tempValue;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, intArr[i]);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
#define EN 10
```
```python
void
```
```python
insertSort(
```
```python
int
```
```python
intArr[EN])
{
```
```python
int
```
```python
tempIndex =
```
```python
0
```
```python
;
```
```python
int
```
```python
tempValue =
```
```python
0
```
```python
;
```
```python
//01.插值排序法说明:
```
```python
//  int i = 1:
```
```python
//      当元素个数为1的时候,不需要插值排序算法
```
```python
//      从1开始才能便于进行插值操作intArr[index-1]=intArr[index]
```
```python
//  i < 10:
```
```python
//      从第一个元素开始,到最后一个元素都需要进行插值排序检测
```
```python
//      注:忽略掉单个元素的数组,因为单个元素不存在插值排序
```
```python
// tempIndex > 0:(可能插值移位的最大范围)
```
```python
//      能够进行插值移位的前提
```
```python
//  intArr[tempIndex - 1] > tempValue:(可能插值移位的最小范围)
```
```python
//      只要当前索引的前一个索引所对应的值大于待插入的值
```
```python
//      就有必要执行插入操作
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
1
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
        tempIndex = i;
        tempValue = intArr[i];
```
```python
while
```
```python
(tempIndex >
```
```python
0
```
```python
&& intArr[tempIndex -
```
```python
1
```
```python
] > tempValue)
        {
            intArr[tempIndex] = intArr[tempIndex -
```
```python
1
```
```python
];
            --tempIndex;
        }
        intArr[tempIndex] = tempValue;
    }
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[EN] = {
```
```python
1
```
```python
,
```
```python
3
```
```python
,
```
```python
5
```
```python
,
```
```python
7
```
```python
,
```
```python
9
```
```python
,
```
```python
2
```
```python
,
```
```python
4
```
```python
,
```
```python
6
```
```python
,
```
```python
8
```
```python
,
```
```python
10
```
```python
};
    insertSort(intArr);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i < EN; ++i)
    {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, intArr[i]);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(09):开房.c
内容概要:**开房数据检索-硬盘模式**
```python
#define _CRT_SECURE_NO_WARNINGS
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <string.h>
```
```python
#include <time.h>
```
```python
char
```
```python
resourcesPath[
```
```python
256
```
```python
] =
```
```python
"D:\\Resource\\TestData\\DB\\KaiFang.txt"
```
```python
;
```
```python
char
```
```python
targetWritePath[
```
```python
256
```
```python
] = {
```
```python
0
```
```python
};
```
```python
void
```
```python
selectResultWriteToTargetFile(
```
```python
char
```
```python
nameStr[
```
```python
256
```
```python
])
{
```
```python
sprintf
```
```python
(targetWritePath,
```
```python
"D:\\Resource\\TestData\\Test\\%s.txt"
```
```python
, nameStr);
    FILE *frp = fopen(resourcesPath,
```
```python
"r"
```
```python
);
```
```python
//以读取模式打开一个文件(硬盘直接读取模式)
```
```python
FILE *fwp = fopen(targetWritePath,
```
```python
"w"
```
```python
);
```
```python
//以写入模式打开一个文件(硬盘直接写入模式)
```
```python
if
```
```python
(NULL == frp && NULL == fwp)
    {
```
```python
printf
```
```python
(
```
```python
"建立文件指针失败! \n"
```
```python
);
```
```python
return
```
```python
;
    }
```
```python
while
```
```python
(!feof(frp))
```
```python
//feof();到了文件读取的末尾返回真,没有到文件读取的末尾返回假
```
```python
{
```
```python
//只要没有到达文件读取的末尾,就继续进行硬盘文件读取操作
```
```python
char
```
```python
readStr[
```
```python
1024
```
```python
] = {
```
```python
0
```
```python
};
        fgets(readStr,
```
```python
1024
```
```python
, frp);
```
```python
//硬盘模式读取一行数据(以换行符作为读取模式结束,并且长度仅限为1024)读取条件限制
```
```python
char
```
```python
*tempStr =
```
```python
strstr
```
```python
(readStr, nameStr);
```
```python
if
```
```python
(NULL != tempStr)
        {
```
```python
puts
```
```python
(readStr);
```
```python
//打印检索到的数据行
```
```python
fputs
```
```python
(readStr, fwp);
```
```python
//硬盘模式写入到指定文件
```
```python
}
    }
    fclose(fwp);
```
```python
//关闭文件写入流
```
```python
fclose(frp);
```
```python
//关闭文件读取流
```
```python
}
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
char
```
```python
nameStr[
```
```python
256
```
```python
] = {
```
```python
0
```
```python
};
```
```python
scanf
```
```python
(
```
```python
"%s"
```
```python
, nameStr);
```
```python
printf
```
```python
(
```
```python
"您要查询人的姓名是:%s \n"
```
```python
, nameStr);
    time_t start =
```
```python
0
```
```python
, end =
```
```python
0
```
```python
;
    time(&start);
    selectResultWriteToTargetFile(nameStr);
    time(&end);
```
```python
printf
```
```python
(
```
```python
"查询总计话费了%lf秒 \n"
```
```python
, difftime(end, start));
    system(targetWritePath);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(10):二维数组.c
内容概要:**二维数组**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.二维数组:
```
```python
//  1.二维数组的内存存储原理:
```
```python
//      所有数组,无论一维数组,二维数组,多维数组,在内存当中的
```
```python
//      存储实质都是采取的连续存储方式
```
```python
//  2.二维数组的规律赋值方式:
```
```python
//      先进行行遍历,在进行列遍历,再逐个进行逐个数组元素的具体赋值操作
```
```python
//  3.如何求取任何数组的内存尺寸?
```
```python
//      都是采用sizeof();关键字进行的求取
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
a[
```
```python
5
```
```python
][
```
```python
5
```
```python
];
```
```python
//1, 2, 3, 4, 5, 6, 7, 8, 9, 10:总共25个数组元素
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
,
```
```python
sizeof
```
```python
(a));
```
```python
//sizeof(数组名);-->求取数组整体的内存尺寸5*5*4
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, a);
```
```python
int
```
```python
num =
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
5
```
```python
; ++j)
        {
```
```python
//a[i][j] = num;
```
```python
//++num;
```
```python
//printf("%4d", a[i][j]);
```
```python
printf
```
```python
(
```
```python
"%4d"
```
```python
, a[i][j] = num++);
```
```python
//复合语句
```
```python
}
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.二维数组知识详解:
```
```python
//  1.初始化方式:
```
```python
//      统一初始化:
```
```python
//          int a[5][4] = {0};-->巧用0
```
```python
//      前置初始化:
```
```python
//          int a[5][4] = {1}-->特用除0以外的数字
```
```python
//      注:
```
```python
//      1.统一初始化方式的实质还是前置初始化方式,由于采用特殊的数字
```
```python
//          0进行初始化,所以整体被统一的初始化为了0
```
```python
//      2.所有数组的初始化方式特点:
```
```python
//          只要数组当中前置元素有数字前置初始化,那么后面的数组元素
```
```python
//              本身都会被默认的初始化为0
```
```python
//  2.多维数组的特殊初始化方式:
```
```python
//      多维数组转化为低维数组进行初始化
```
```python
//      int a[5][4] = {
```
```python
//          {1, 2},
```
```python
//          {1, 2, 3}
```
```python
//      };
```
```python
//  3.确定数组内存尺寸的两大要素:
```
```python
//      数组元素个数+数组元素尺寸
```
```python
//   注:维度的省略情况分析:自动推演
```
```python
//      一维数组的一维可以省略
```
```python
//      二维数组的一维不可以省略
```
```python
//      三维数组的二维不可以省略
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//int a[5][4] = { 1 };//全部初始化为0
```
```python
//printf("%p \n", a);
```
```python
//int a[5][4] = { 1, 2, 3, 4, 5 };//数组的前面赋值,后面赋值为0,默认是一行一行的进行赋值操作
```
```python
//int a[5][4] = { {1, 2, 3, 4}, {1, 2} };//二维数组的初始化方式
```
```python
//int a[5][4] = {0};//全部初始化为0
```
```python
int
```
```python
a[
```
```python
5
```
```python
][
```
```python
4
```
```python
];
```
```python
//解释:5个一维数组,每个一维数组当中存储有4个数组元素
```
```python
int
```
```python
b[
```
```python
2
```
```python
][
```
```python
4
```
```python
] = { {
```
```python
1
```
```python
,
```
```python
2
```
```python
},{
```
```python
3
```
```python
,
```
```python
4
```
```python
} };
```
```python
//第一个名曲有几个一维数组,可以进行忽略
```
```python
//行坐标可以进行忽略,但是列坐标不可以进行忽略
```
```python
int
```
```python
num =
```
```python
1
```
```python
;
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
2
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
            b[i][j] = num++;
        }
    }
```
```python
printf
```
```python
(
```
```python
"\n\n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
2
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%4d"
```
```python
, b[i][j]);
        }
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.二维数组的线性初始化方式:
```
```python
//  奥数规律方式
```
```python
//      元素个数+求模(变化慢)+求余(变化快)+被除数是(列数)
```
```python
int
```
```python
mai03n(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArrArr[
```
```python
3
```
```python
][
```
```python
4
```
```python
];
```
```python
//规律初始化方式:
```
```python
//  00 0        01 1         02 2       03 3
```
```python
//  10 4        11 5         12 6       13 7
```
```python
//  20 8        21 9         22 10  23 11
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
12
```
```python
; ++i)
```
```python
//i:决定元素个数
```
```python
{
        intArrArr[i /
```
```python
4
```
```python
][i %
```
```python
4
```
```python
] = i;
```
```python
//行:变化慢;列:变化快
```
```python
}
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
3
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
4
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, intArrArr[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(11):迷宫初步.c+迷宫进阶.c
内容概要:**迷宫AI**
```python
///迷宫初步.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.关于维度与数组的联系:
```
```python
//  零维度:点
```
```python
//      1.数组元素
```
```python
//      2.没有方向
```
```python
//  一维度:线
```
```python
//      1.一维数组
```
```python
//      2.向右方向
```
```python
// 二维度:面
```
```python
//      1.二维数组
```
```python
//      2.上下左右
```
```python
//  三维度:立体
```
```python
//      1.三维数组
```
```python
//      2.上下左右前后
```
```python
//  多维度:慢慢想
```
```python
//      1.高维数组
```
```python
//      2.慢慢想
```
```python
//      注:时间(变化)+空间(三维)
```
```python
//02.所有数组的内存存储特点:
```
```python
//  都是采取线性的初始方式,也就是连续存储的方式
```
```python
//  只是由于计算机对于数组的解析方式的不同,所以产生了不同的维度效果
```
```python
//03.迷宫矩阵的组成特点分析:
```
```python
//  1.二维平面的迷宫矩阵由二维整型数组进行模拟
```
```python
//  2.该二微整型数组的组成元素特点分析:
```
```python
//      数字0:代表通道
```
```python
//      数字2:代表墙壁
```
```python
//      数字1:代表位置
```
```python
//  3.移动点和结束点模拟移动:
```
```python
//      移动点:(startPointX, startPointY);
```
```python
//      结束点:(endPointX, endPointY);
```
```python
int
```
```python
intArrArrMaze[
```
```python
5
```
```python
][
```
```python
5
```
```python
] = {
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
};
```
```python
int
```
```python
endPointX =
```
```python
4
```
```python
, endPointY =
```
```python
4
```
```python
;
```
```python
//终止点
```
```python
int
```
```python
visitMaze(
```
```python
int
```
```python
startPointX,
```
```python
int
```
```python
startPointY);
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
printf
```
```python
(
```
```python
"显示迷宫 \n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"-------------------------------------- \n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
5
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
, intArrArrMaze[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
int
```
```python
startPointX =
```
```python
0
```
```python
, startPointY =
```
```python
0
```
```python
;
```
```python
//起始点
```
```python
if
```
```python
(
```
```python
0
```
```python
== visitMaze(startPointX, startPointY))
    {
```
```python
printf
```
```python
(
```
```python
"迷宫没有出口 \n"
```
```python
);
    }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"显示路径 \n"
```
```python
);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
        {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
5
```
```python
; ++j)
            {
```
```python
if
```
```python
(
```
```python
2
```
```python
== intArrArrMaze[i][j])
```
```python
printf
```
```python
(
```
```python
"█"
```
```python
);
```
```python
else
```
```python
if
```
```python
(
```
```python
1
```
```python
== intArrArrMaze[i][j])
```
```python
printf
```
```python
(
```
```python
"◇"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"  "
```
```python
);
            }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
        }
    }
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//04.该函数的作用功能作用分析:
```
```python
//  1.函数整体作用:
```
```python
//      通过递归调用方式判定迷宫是否有出口?
```
```python
//          如果走到终点,那么就含有出口;如果没能走到出口,那么就没有出口!
```
```python
//  2.函数局部作用:
```
```python
//      每走动一次,都需要判定是否到达迷宫终点
```
```python
//  3.参数说明:
```
```python
//      形参值:
```
```python
//          整体意义:起始点
```
```python
//          局部意义:将要走动的点-->试探点
```
```python
//      返回值:
```
```python
//          整体意义:是否能够走出迷宫
```
```python
//          局部意义:判断是否完成了一条路线
```
```python
int
```
```python
visitMaze(
```
```python
int
```
```python
startPointX,
```
```python
int
```
```python
startPointY)
{
```
```python
int
```
```python
success =
```
```python
0
```
```python
;
```
```python
//标识迷宫是否完成走出状态
```
```python
int
```
```python
movePointX = startPointX;
```
```python
//通过起始点初始化移动点
```
```python
int
```
```python
movePointY = startPointY;
    intArrArrMaze[movePointX][movePointY] =
```
```python
3
```
```python
;
```
```python
//标识该点的起始状态:
```
```python
if
```
```python
(endPointX == movePointX && endPointY == movePointY)
```
```python
return
```
```python
success =
```
```python
1
```
```python
;
```
```python
//标识成功的走出状态
```
```python
if
```
```python
(
```
```python
1
```
```python
!= success &&
```
```python
5
```
```python
> movePointY +
```
```python
1
```
```python
&&
```
```python
2
```
```python
> intArrArrMaze[movePointX][movePointY +
```
```python
1
```
```python
]) visitMaze(movePointX, movePointY +
```
```python
1
```
```python
);
```
```python
if
```
```python
(
```
```python
1
```
```python
!= success &&
```
```python
5
```
```python
> movePointX +
```
```python
1
```
```python
&&
```
```python
2
```
```python
> intArrArrMaze[movePointX +
```
```python
1
```
```python
][movePointY]) visitMaze(movePointX +
```
```python
1
```
```python
, movePointY);
```
```python
if
```
```python
(
```
```python
1
```
```python
!= success && -
```
```python
1
```
```python
< movePointY -
```
```python
1
```
```python
&&
```
```python
2
```
```python
> intArrArrMaze[movePointX][movePointY -
```
```python
1
```
```python
]) visitMaze(movePointX, movePointY -
```
```python
1
```
```python
);
```
```python
if
```
```python
(
```
```python
1
```
```python
!= success && -
```
```python
1
```
```python
< movePointY -
```
```python
1
```
```python
&&
```
```python
2
```
```python
>  intArrArrMaze[movePointX -
```
```python
1
```
```python
][movePointY]) visitMaze(movePointX-
```
```python
1
```
```python
, movePointY);
```
```python
if
```
```python
(
```
```python
1
```
```python
!= success)
```
```python
//标识改点的回溯状态:该点走过,但是没有走成功,因此将该点重新值置为0
```
```python
intArrArrMaze[movePointX][movePointY] =
```
```python
0
```
```python
;
```
```python
return
```
```python
success;
}
```
```python
///迷宫进阶.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//数据层(Data):存储数据
```
```python
int
```
```python
intArrArrMazeY[
```
```python
10
```
```python
][
```
```python
10
```
```python
] = {
```
```python
//原始迷宫
```
```python
{
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
}
};
```
```python
int
```
```python
intArrArrMazeC[
```
```python
10
```
```python
][
```
```python
10
```
```python
] = {
```
```python
//测试迷宫
```
```python
{
```
```python
1
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
},
    {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
2
```
```python
,
```
```python
2
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
}
};
```
```python
int
```
```python
endPointX =
```
```python
9
```
```python
, endPointY =
```
```python
9
```
```python
;
```
```python
int
```
```python
countCiNum =
```
```python
1
```
```python
;
```
```python
//视图层(View):显示数据
```
```python
void
```
```python
showMaze(
```
```python
int
```
```python
intArrArrMaze[
```
```python
10
```
```python
][
```
```python
10
```
```python
])
{
```
```python
printf
```
```python
(
```
```python
"%d------------------------------ \n"
```
```python
, countCiNum++);
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
; ++i)
    {
```
```python
for
```
```python
(
```
```python
int
```
```python
j =
```
```python
0
```
```python
; j <
```
```python
10
```
```python
; ++j)
        {
```
```python
printf
```
```python
(
```
```python
"%2d"
```
```python
, intArrArrMaze[i][j]);
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
//控制层(Controller):数据操作
```
```python
void
```
```python
operateMaze(
```
```python
char
```
```python
direction,
```
```python
int
```
```python
startPointX,
```
```python
int
```
```python
startPointY)
{
```
```python
switch
```
```python
(direction)
    {
```
```python
case
```
```python
'w'
```
```python
:
```
```python
if
```
```python
(-
```
```python
1
```
```python
< startPointX -
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= intArrArrMazeC[startPointX -
```
```python
1
```
```python
][startPointY])
        {
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX -
```
```python
1
```
```python
][startPointY];
            intArrArrMazeC[startPointX -
```
```python
1
```
```python
][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX -
```
```python
1
```
```python
][startPointY];
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX -
```
```python
1
```
```python
][startPointY];
        }
```
```python
break
```
```python
;
```
```python
case
```
```python
's'
```
```python
:
```
```python
if
```
```python
(
```
```python
10
```
```python
> startPointX +
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= intArrArrMazeC[startPointX +
```
```python
1
```
```python
][startPointY])
        {
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX +
```
```python
1
```
```python
][startPointY];
            intArrArrMazeC[startPointX +
```
```python
1
```
```python
][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX +
```
```python
1
```
```python
][startPointY];
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX +
```
```python
1
```
```python
][startPointY];
        }
```
```python
break
```
```python
;
```
```python
case
```
```python
'a'
```
```python
:
```
```python
if
```
```python
(-
```
```python
1
```
```python
< startPointY -
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= intArrArrMazeC[startPointX][startPointY -
```
```python
1
```
```python
])
        {
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX][startPointY -
```
```python
1
```
```python
];
            intArrArrMazeC[startPointX][startPointY -
```
```python
1
```
```python
] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX][startPointY -
```
```python
1
```
```python
];
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX][startPointY -
```
```python
1
```
```python
];
        }
```
```python
break
```
```python
;
```
```python
case
```
```python
'd'
```
```python
:
```
```python
if
```
```python
(
```
```python
10
```
```python
> startPointY +
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= intArrArrMazeC[startPointX][startPointY +
```
```python
1
```
```python
])
        {
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX][startPointY +
```
```python
1
```
```python
];
            intArrArrMazeC[startPointX][startPointY +
```
```python
1
```
```python
] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX][startPointY +
```
```python
1
```
```python
];
            intArrArrMazeC[startPointX][startPointY] = intArrArrMazeC[startPointX][startPointY] ^ intArrArrMazeC[startPointX][startPointY +
```
```python
1
```
```python
];
        }
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
break
```
```python
;
    }
    showMaze(intArrArrMazeC);
}
```
```python
//业务层(Service/AI层):人工智能
```
```python
//  组成特点分析:
```
```python
//      返回值:int
```
```python
//          整体意义:迷宫是否能够走通
```
```python
//          局部意义:没有完成一条通路,就继续往下走
```
```python
//              不断的进行压栈,压到树状递归的底部
```
```python
//              如果不行:如果该路不通,就进行回溯释放函数所占用的栈内存(返回值无意义)
```
```python
//              如果能行:如果该路畅通,就进行回溯释放函数做占用的栈内存(返回值有意义)
```
```python
//      形参值:
```
```python
//          int intArrArrMaze[10][10]:
```
```python
//              整体意义:待测试的迷宫数据
```
```python
//              局部意义:每次迷宫的下一步,所依赖的上一步迷宫数据布局
```
```python
//          int startPointX, int startPointY:
```
```python
//              整体意义:就是迷宫的起始点
```
```python
//              局部意义:就是迷宫每次要试探的下一点
```
```python
int
```
```python
mazeAI(
```
```python
int
```
```python
intArrArrMaze[
```
```python
10
```
```python
][
```
```python
10
```
```python
],
```
```python
int
```
```python
startPointX,
```
```python
int
```
```python
startPointY)
{
```
```python
int
```
```python
successFlag =
```
```python
0
```
```python
;
```
```python
int
```
```python
movePointX = startPointX;
```
```python
//测试假定起始点的正确性
```
```python
int
```
```python
movePointY = startPointY;
    intArrArrMaze[startPointX][startPointY] =
```
```python
3
```
```python
;
```
```python
//试探迷宫走步(测试点成功走出)-->假定起点成功
```
```python
if
```
```python
(endPointX == movePointX && endPointY == movePointY)
```
```python
//当前待移动的点所在的位置
```
```python
{
```
```python
printf
```
```python
(
```
```python
"小伙子恭喜走出来了! \n"
```
```python
);
```
```python
return
```
```python
successFlag =
```
```python
1
```
```python
;
    }
```
```python
//右下左上
```
```python
//  1 != successFlag:
```
```python
//      这条语句表明还没有形成完整的通路,因此急需寻找,最终寻找到的通路
```
```python
//      一定是每一个递归函数都返回1的情况
```
```python
//  2 > intArrArrMaze[movePointX][movePointY + 1]:
```
```python
//      这条语句的作用既可以排除掉墙壁点,也可以排除走过点
```
```python
if
```
```python
(
```
```python
1
```
```python
!= successFlag &&
```
```python
10
```
```python
> movePointY +
```
```python
1
```
```python
&&
```
```python
2
```
```python
> intArrArrMaze[movePointX][movePointY +
```
```python
1
```
```python
])  mazeAI(intArrArrMaze, movePointX, movePointY +
```
```python
1
```
```python
);
```
```python
if
```
```python
(
```
```python
1
```
```python
!= successFlag &&
```
```python
10
```
```python
> movePointX +
```
```python
1
```
```python
&&
```
```python
2
```
```python
> intArrArrMaze[movePointX +
```
```python
1
```
```python
][movePointY])  mazeAI(intArrArrMaze, movePointX +
```
```python
1
```
```python
, movePointY);
```
```python
if
```
```python
(
```
```python
1
```
```python
!= successFlag && -
```
```python
1
```
```python
< movePointY -
```
```python
1
```
```python
&&
```
```python
2
```
```python
> intArrArrMaze[movePointX][movePointY -
```
```python
1
```
```python
]) mazeAI(intArrArrMaze, movePointX, movePointY -
```
```python
1
```
```python
);
```
```python
if
```
```python
(
```
```python
1
```
```python
!= successFlag && -
```
```python
1
```
```python
< movePointX -
```
```python
1
```
```python
&&
```
```python
2
```
```python
> intArrArrMaze[movePointX -
```
```python
1
```
```python
][movePointY]) mazeAI(intArrArrMaze, movePointX -
```
```python
1
```
```python
, movePointY);
```
```python
if
```
```python
(
```
```python
0
```
```python
== successFlag)
```
```python
//根据树状递归,递归到树状的根部返回情况决定当前路线是否通路(畅通|不畅通)-->完整路线
```
```python
intArrArrMaze[startPointX][startPointY] =
```
```python
0
```
```python
;
```
```python
//试探迷宫回溯(测试点失败走回)-->假定起点失败
```
```python
return
```
```python
successFlag;
}
```
```python
void
```
```python
AIUnitTest(
```
```python
int
```
```python
intArrArrMaze[
```
```python
10
```
```python
][
```
```python
10
```
```python
],
```
```python
int
```
```python
startPointX,
```
```python
int
```
```python
startPointY)
{
```
```python
int
```
```python
movePointX = startPointX;
```
```python
int
```
```python
movePointY = startPointY;
```
```python
while
```
```python
(endPointX != movePointX || endPointY != movePointY)
    {
```
```python
if
```
```python
(
```
```python
10
```
```python
> movePointY +
```
```python
1
```
```python
&&
```
```python
3
```
```python
== intArrArrMaze[movePointX][movePointY +
```
```python
1
```
```python
])
        {
            intArrArrMaze[movePointX][movePointY +
```
```python
1
```
```python
] =
```
```python
0
```
```python
;
            operateMaze(
```
```python
'd'
```
```python
, movePointX, movePointY +
```
```python
1
```
```python
);
        }
```
```python
if
```
```python
(
```
```python
10
```
```python
> movePointX +
```
```python
1
```
```python
&&
```
```python
3
```
```python
== intArrArrMaze[movePointX +
```
```python
1
```
```python
][movePointY])
        {
            intArrArrMaze[movePointX +
```
```python
1
```
```python
][movePointY] =
```
```python
0
```
```python
;
            operateMaze(
```
```python
's'
```
```python
, movePointX +
```
```python
1
```
```python
, movePointY);
        }
```
```python
if
```
```python
(-
```
```python
1
```
```python
< movePointY -
```
```python
1
```
```python
&&
```
```python
3
```
```python
== intArrArrMaze[movePointX][movePointY -
```
```python
1
```
```python
])
        {
            intArrArrMaze[movePointX][movePointY -
```
```python
1
```
```python
] =
```
```python
0
```
```python
;
            operateMaze(
```
```python
'a'
```
```python
, movePointX, movePointY -
```
```python
1
```
```python
);
        }
```
```python
if
```
```python
(-
```
```python
1
```
```python
< movePointX -
```
```python
1
```
```python
&&
```
```python
3
```
```python
== intArrArrMaze[movePointX -
```
```python
1
```
```python
][movePointY])
        {
            intArrArrMaze[movePointX -
```
```python
1
```
```python
][movePointY] =
```
```python
0
```
```python
;
            operateMaze(
```
```python
'd'
```
```python
, movePointX -
```
```python
1
```
```python
, movePointY);
        }
    }
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
//showMaze(intArrArrMazeY);
```
```python
int
```
```python
successFlag = mazeAI(intArrArrMazeC,
```
```python
0
```
```python
,
```
```python
0
```
```python
);
```
```python
if
```
```python
(successFlag)
    {
```
```python
printf
```
```python
(
```
```python
"可以走出! \n"
```
```python
);
        intArrArrMazeY[
```
```python
0
```
```python
][
```
```python
0
```
```python
] =
```
```python
1
```
```python
;
        showMaze(intArrArrMazeY);
    }
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"不可以走出! \n"
```
```python
);
    }
    system(
```
```python
"pause"
```
```python
);
}
```

