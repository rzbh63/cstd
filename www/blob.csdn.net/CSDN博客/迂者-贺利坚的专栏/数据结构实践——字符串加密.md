
# 数据结构实践——字符串加密 - 迂者-贺利坚的专栏 - CSDN博客

2015年10月10日 22:29:13[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：3565


本文针对[数据结构基础系列网络课程(4)：串](http://edu.csdn.net/course/detail/1434)实践项目。
【项目-字符串加密】
一个文本串可用事先编制好的字符映射表进行加密。例如，设字符映射表为：
```python
abcdefghijklmnopqrstuvwxyz
ngzqtcobmuhelkpdawxfyivrsj
```
则字符串“lao he jiao shu ju jie gou”被加密为“enp bt umnp xby uy umt opy”。
设计一个程序，实现加密、解密算法，将输入的文本进行加密后输出，然后进行解密并输出。
[参考解答]（头文件sqstring.h见[顺序串算法库](http://blog.csdn.net/sxhelijian/article/details/48573133)）
```python
#include <stdio.h>
```
```python
#include "sqString.h"
```
```python
SqString A,B;
```
```python
//用于存储字符映射表
```
```python
SqString EnCrypt(SqString p)
{
    int i=
```
```python
0
```
```python
,j;
    SqString q;
```
```python
while
```
```python
(i<p.
```
```python
length
```
```python
)
    {
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; p.data[i]!=A.data[j]&&j<A.
```
```python
length
```
```python
; j++);
```
```python
if
```
```python
(j>=A.
```
```python
length
```
```python
)
```
```python
//在A串中未找到p.data[i]字母
```
```python
q.data[i]=p.data[i];
```
```python
else
```
```python
//在A串中找到p.data[i]字母
```
```python
q.data[i]=B.data[j];
        i++;
    }
    q.
```
```python
length
```
```python
=p.
```
```python
length
```
```python
;
```
```python
return
```
```python
q;
}
SqString UnEncrypt(SqString q)
{
    int i=
```
```python
0
```
```python
,j;
    SqString p;
```
```python
while
```
```python
(i<q.
```
```python
length
```
```python
)
    {
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; q.data[i]!=B.data[j]&&j<B.
```
```python
length
```
```python
; j++);
```
```python
if
```
```python
(j>=B.
```
```python
length
```
```python
)
```
```python
//在B串中未找到q.data[i]字母
```
```python
p.data[i]=q.data[i];
```
```python
else
```
```python
//在B串中找到q.data[i]字母
```
```python
p.data[i]=A.data[j];
        i++;
    }
    p.
```
```python
length
```
```python
=q.
```
```python
length
```
```python
;
```
```python
return
```
```python
p;
}
int main()
{
    SqString p,q;
    StrAssign(A,
```
```python
"abcdefghijklmnopqrstuvwxyz"
```
```python
);
```
```python
//建立A串
```
```python
StrAssign(B,
```
```python
"ngzqtcobmuhelkpdawxfyivrsj"
```
```python
);
```
```python
//建立B串
```
```python
char str[MaxSize];
```
```python
printf
```
```python
(
```
```python
"输入原文串:"
```
```python
);
    gets(str);
```
```python
//获取用户输入的原文串
```
```python
StrAssign(p,str);
```
```python
//建立p串
```
```python
printf
```
```python
(
```
```python
"加密解密如下:\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"  原文串:"
```
```python
);
    DispStr(p);
    q=EnCrypt(p);
```
```python
//p串加密产生q串
```
```python
printf
```
```python
(
```
```python
"  加密串:"
```
```python
);
    DispStr(q);
    p=UnEncrypt(q);
```
```python
//q串解密产生p串
```
```python
printf
```
```python
(
```
```python
"  解密串:"
```
```python
);
    DispStr(p);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
下面的解决有bug，如一楼徐群壮同学所言，以及[巩凯强的博文](http://blog.csdn.net/gkq_comeon/article/details/49404223)所指。出错原因在于，for循环中的比较，没有考虑找不到时会越界（见注释）。
考虑不周害死猫。编程，认真；认真，编程！
```python
#include <stdio.h>
```
```python
#include "sqString.h"
```
```python
SqString A,B;
```
```python
//用于存储字符映射表
```
```python
SqString EnCrypt(SqString p)
{
    int i=
```
```python
0
```
```python
,j;
    SqString q;
```
```python
while
```
```python
(i<p.
```
```python
length
```
```python
)
    {
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; p.data[i]!=A.data[j]; j++);
```
```python
//循环条件少加了&&j<A.length
```
```python
if
```
```python
(j>=p.
```
```python
length
```
```python
)
```
```python
//在A串中未找到p.data[i]字母
```
```python
q.data[i]=p.data[i];
```
```python
else
```
```python
//在A串中找到p.data[i]字母
```
```python
q.data[i]=B.data[j];
        i++;
    }
    q.
```
```python
length
```
```python
=p.
```
```python
length
```
```python
;
```
```python
return
```
```python
q;
}
SqString UnEncrypt(SqString q)
{
    int i=
```
```python
0
```
```python
,j;
    SqString p;
```
```python
while
```
```python
(i<q.
```
```python
length
```
```python
)
    {
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; q.data[i]!=B.data[j]; j++);
```
```python
//循环条件少加了&&j<B.length
```
```python
if
```
```python
(j>=q.
```
```python
length
```
```python
)
```
```python
//在B串中未找到q.data[i]字母
```
```python
p.data[i]=q.data[i];
```
```python
else
```
```python
//在B串中找到q.data[i]字母
```
```python
p.data[i]=A.data[j];
        i++;
    }
    p.
```
```python
length
```
```python
=q.
```
```python
length
```
```python
;
```
```python
return
```
```python
p;
}
int main()
{
    SqString p,q;
    StrAssign(A,
```
```python
"abcdefghijklmnopqrstuvwxyz"
```
```python
);
```
```python
//建立A串
```
```python
StrAssign(B,
```
```python
"ngzqtcobmuhelkpdawxfyivrsj"
```
```python
);
```
```python
//建立B串
```
```python
char str[MaxSize];
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"输入原文串:"
```
```python
);
    gets(str);
```
```python
//获取用户输入的原文串
```
```python
StrAssign(p,str);
```
```python
//建立p串
```
```python
printf
```
```python
(
```
```python
"加密解密如下:\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"  原文串:"
```
```python
);
    DispStr(p);
    q=EnCrypt(p);
```
```python
//p串加密产生q串
```
```python
printf
```
```python
(
```
```python
"  加密串:"
```
```python
);
    DispStr(q);
    p=UnEncrypt(q);
```
```python
//q串解密产生p串
```
```python
printf
```
```python
(
```
```python
"  解密串:"
```
```python
);
    DispStr(p);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```

