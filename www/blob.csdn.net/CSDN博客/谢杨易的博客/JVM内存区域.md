
# JVM内存区域 - 谢杨易的博客 - CSDN博客

2016年07月12日 16:22:16[谢杨易](https://me.csdn.net/u013510838)阅读数：1151


运行时数据区
![这里写图片描述](http://i2.piimg.com/567571/7eadb7bba8024602.png)
---a. 程序计数器 pc
		i. 比较小，当前线程执行字节码的位置。分支，循环，异常处理，跳转，线程恢复都需要它
		ii. 线程私有，故线程间互不干扰。
		iii. 不会OOM，不需要GC
	b. Java栈
![这里写图片描述](http://i2.piimg.com/567571/2ef70275a6c9e873.png)
---i. 线程私有，线程间不会干扰
		ii. 存放Java方法的局部变量，入参等。
			1) 每个方法都有一个栈帧，用来存放方法的局部变量表，操作数栈，动态链接，方法出口等信息。
			2) 方法调用对应着栈帧入栈，方法返回对应栈帧出栈。
			3) 相邻的两个栈帧之间会有部分内存重合，一般是上一个方法的操作数栈和下一个方法的局部变量表。这样，就不需要copy入参了。
![这里写图片描述](http://i1.piimg.com/567571/d4f19f38dc3f69e8.png)
---iii. 编译阶段就可以确定局部变量表所需的内存空间，运行阶段不会改变它的大小。
			1) Java栈帧随方法退出而回收，Java栈随线程退出而回收。无需GC
			2) 栈无需GC，并且JIT编译优化时经常将它放到CPU的cache上，故速度比堆快很多。
		iv. 不需要GC，但可能会OOM。
			1) 线程请求栈深度超过JVM允许的深度，发生StackOverFlowError
			2) 栈扩展时无法申请到足够内存，会抛出OutOfMemoryError
	c. Native栈
		i. 线程私有，线程间不干扰
		ii. 存放本地方法，如C，C++的局部变量，入参等
		iii. 编译期可知道大小，无需GC。
	d. Java堆
		i. 线程共享，要注意同步问题
		ii. 存放Java对象实例，数组。JIT编译优化的存在，如栈上分配对象，使得所有的对象和数组都分配在堆上，不是那么绝对了。
		iii. 需要动态分配和GC回收，速度比较慢。
	e. 方法区
		i. 线程共享
		ii. 存储JVM加载后的类信息，final，类static字段，即使编译器（JIT）编译后的代码。
		iii. 方法区垃圾较少，但也不是没有。如不和任何引用关联的final，无用的类信息等。
		iv. JVM回收这个区域性价比不是很高，因为这个区域垃圾较少。对它的回收集中在常量池的回收和类型的卸载。
		v. 常量池：
			1) 存放编译期生成的各种字面量和符号引用。符号引用指类名，方法名，字段名等。
	f. 直接内存
		i. 不是JVM管理的区域
		ii. 使用native方法直接分配的内存，通过Java堆中的DirectByteBuffer对象来引用它。
		iii. 直接内存不受Java堆大小分配限制，但仍可能会OOM

---对象的创建，HotSpot虚拟机

---a. 遇到new关键字时，先检查是否能在常量池中找到这个类的符号引用。如果找不到，说明类还没有被加载
	b. 检查符号引用代表的类是否被解析和初始化过。
	c. 如果类没有被加载，则需要先执行类的加载过程：加载，验证，准备，解析，初始化。
	d. 为新对象分配内存。类加载后就可以完全确定对象的大小了。
		i. 分配方法：
			1) 指针碰撞法：内存完全规整，无碎片。每次分配时，只需要在空闲内存区，将指针向后移动一个距离即可。这个距离就是对象的大小。
			2) 空闲列表法：内存杂乱，有碎片。需要维护一个空闲内存表，在表上遍历，找到能够容纳对象的一块空闲内存。分配慢，且容易产生碎片。
		ii. 同步：
			1) 原因：正在分配一个对象内存时，可能会切换到另外一个线程，分配另外一个对象的内存。这样会导致第一个对象内存被覆盖一部分。故内存分配需要同步
			2) 方法：
				a) 对分配内存的动作做同步处理，采用CAS配上失败重试的策略保证更新操作的原子性
				b) 本地线程分配缓冲法（TLAB）：每个线程在Java堆中预分配一小块内存。
	e. 将分配的内存区域清零（不包括对象头）。故堆上变量有默认初值的，比如boolean为false，int为0，引用为null。但是栈上变量没有这个过程，故他们的初值是杂乱和随机的。
	f. 对对象做必要的设置。比如对象是属于哪个类的，对象hashcode，对象GC分代年龄等。这些信息都放在对象头里。
	g. 执行<init>方法，这个方法是JVM自动加入到字节码中的。init方法会先给对象属性赋初值，然后执行static代码块。

---对象的内存布局

---a. 对象头
		i. 标志位（32bit JVM为4B，64bit JVM上为8B）：对象自身运行时数据，比如hashCode，线程锁，锁状态标志，GC分代年龄等
		ii. 类型指针，即对象指向它的类元数据的指针。
	b. 实例数据：
		i. 父类中继承的，和子类中定义的，都会出现在这个区域。父类定义的变量在前
	c. 对齐填充
		i. 不一定存在，仅仅是作为占位符。Hotspot JVM规定对象的起始地址必须是8的整数倍。

---对象的访问定位：如何由引用找到实际对象

---a. 句柄池：引用和实例的map放到句柄池中，每次去池中查找
	b. 直接内存法：引用存储的就是对象的实际逻辑地址。
		i. 直接内存法不需要查找，速度快。但每次GC后，由于整理内存碎片时，对象地址会改变，故引用也需要发生改变。
		ii. Hotspot JVM采用直接内存法。


