
# 数据结构实践——归并排序算法的改进 - 迂者-贺利坚的专栏 - CSDN博客

2015年12月01日 15:36:31[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：3293


本文是针对[[数据结构基础系列(9)：排序](http://edu.csdn.net/course/detail/1710)]的项目。
【项目 - 归并排序算法的改进】
采用归并排序、快速排序等高效算法进行排序，当数据元素较少时(如n≤64)，经常直接使用直接插入排序算法等高复杂度的算法。这样做，会带来一定的好处，例如归并排序减少分配、回收临时存储区域的频次，快速排序减少递归层次等。
试按上面的思路，重新实现归并排序算法。
[参考解答]
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include <stdlib.h>
```
```python
#include <time.h>
```
```python
#define MinLength 64
```
```python
//最短分段长度
```
```python
typedef
```
```python
int
```
```python
KeyType;
```
```python
//定义关键字类型
```
```python
typedef
```
```python
char
```
```python
InfoType[
```
```python
10
```
```python
];
```
```python
typedef
```
```python
struct
```
```python
//记录类型
```
```python
{
    KeyType key;
```
```python
//关键字项
```
```python
InfoType data;
```
```python
//其他数据项,类型为InfoType
```
```python
} RecType;
```
```python
//排序的记录类型定义
```
```python
void
```
```python
GetData(RecType *&R,
```
```python
int
```
```python
n)
{
    srand(time(
```
```python
0
```
```python
));
    R=(RecType*)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(RecType)*n);
```
```python
for
```
```python
(
```
```python
int
```
```python
i=
```
```python
0
```
```python
; i<n; i++)
        R[i].key= rand();
```
```python
printf
```
```python
(
```
```python
"生成了%d条记录\n"
```
```python
, n);
}
```
```python
//对R[low..high]按递增有序进行直接插入排序
```
```python
void
```
```python
InsertSort(RecType R[],
```
```python
int
```
```python
low,
```
```python
int
```
```python
high)
{
```
```python
int
```
```python
i,j;
    RecType tmp;
```
```python
for
```
```python
(i=low; i<=high; i++)
    {
        tmp=R[i];
        j=i-
```
```python
1
```
```python
;
```
```python
//从右向左在有序区R[low..i-1]中找R[i]的插入位置
```
```python
while
```
```python
(j>=low && tmp.key<R[j].key)
        {
            R[j+
```
```python
1
```
```python
]=R[j];
```
```python
//将关键字大于R[i].key的记录后移
```
```python
j--;
        }
        R[j+
```
```python
1
```
```python
]=tmp;
```
```python
//在j+1处插入R[i]
```
```python
}
}
```
```python
//合并两个有序表
```
```python
void
```
```python
Merge(RecType R[],
```
```python
int
```
```python
low,
```
```python
int
```
```python
mid,
```
```python
int
```
```python
high)
{
    RecType *R1;
```
```python
int
```
```python
i,j,k;
    i=low,j=mid+
```
```python
1
```
```python
,k=
```
```python
0
```
```python
;
```
```python
//k是R1的下标,i、j分别为第1、2段的下标
```
```python
R1=(RecType *)
```
```python
malloc
```
```python
((high-low+
```
```python
1
```
```python
)*
```
```python
sizeof
```
```python
(RecType));
```
```python
//动态分配空间
```
```python
while
```
```python
(i<=mid && j<=high)
```
```python
//在第1段和第2段均未扫描完时循环
```
```python
if
```
```python
(R[i].key<=R[j].key)
```
```python
//将第1段中的记录放入R1中
```
```python
{
            R1[k]=R[i];
            i++;
            k++;
        }
```
```python
else
```
```python
//将第2段中的记录放入R1中
```
```python
{
            R1[k]=R[j];
            j++;
            k++;
        }
```
```python
while
```
```python
(i<=mid)
```
```python
//将第1段余下部分复制到R1
```
```python
{
        R1[k]=R[i];
        i++;
        k++;
    }
```
```python
while
```
```python
(j<=high)
```
```python
//将第2段余下部分复制到R1
```
```python
{
        R1[k]=R[j];
        j++;
        k++;
    }
```
```python
for
```
```python
(k=
```
```python
0
```
```python
,i=low; i<=high; k++,i++)
```
```python
//将R1复制回R中
```
```python
R[i]=R1[k];
}
```
```python
//一趟合并
```
```python
void
```
```python
MergePass(RecType R[],
```
```python
int
```
```python
length,
```
```python
int
```
```python
n)
```
```python
//对整个数序进行一趟归并
```
```python
{
```
```python
int
```
```python
i;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i+
```
```python
2
```
```python
*length-
```
```python
1
```
```python
<n; i=i+
```
```python
2
```
```python
*length)
```
```python
//归并length长的两相邻子表
```
```python
Merge(R,i,i+length-
```
```python
1
```
```python
,i+
```
```python
2
```
```python
*length-
```
```python
1
```
```python
);
```
```python
if
```
```python
(i+length-
```
```python
1
```
```python
<n)
```
```python
//余下两个子表,后者长度小于length
```
```python
Merge(R,i,i+length-
```
```python
1
```
```python
,n-
```
```python
1
```
```python
);
```
```python
//归并这两个子表
```
```python
}
```
```python
//自底向上的二路归并算法，但太短的分段，用直接插入完成
```
```python
void
```
```python
MergeSort(RecType R[],
```
```python
int
```
```python
n)
{
```
```python
int
```
```python
length, i;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
;i<n;i+=MinLength)
```
```python
//先按最短分段，用插入排序使之分段有序
```
```python
InsertSort(R, i, ((i+MinLength-
```
```python
1
```
```python
<n)?(i+MinLength-
```
```python
1
```
```python
):n));
```
```python
for
```
```python
(length=MinLength; length<n; length=
```
```python
2
```
```python
*length)
```
```python
//进行归并
```
```python
{
        MergePass(R,length,n);
    }
}
```
```python
int
```
```python
main()
{
```
```python
int
```
```python
i,n=
```
```python
10000
```
```python
;
    RecType *R;
    GetData(R, n);
    MergeSort(R,n);
```
```python
printf
```
```python
(
```
```python
"排序后（前300个）:\n"
```
```python
);
    i=
```
```python
0
```
```python
;
```
```python
while
```
```python
(i<
```
```python
300
```
```python
)
    {
```
```python
printf
```
```python
(
```
```python
"%12d "
```
```python
,R[i].key);
        i++;
```
```python
if
```
```python
(i%
```
```python
5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
printf
```
```python
(
```
```python
"排序后（后300个）:\n"
```
```python
);
    i=
```
```python
0
```
```python
;
```
```python
while
```
```python
(i<
```
```python
300
```
```python
)
    {
```
```python
printf
```
```python
(
```
```python
"%12d "
```
```python
,R[n-
```
```python
300
```
```python
+i].key);
        i++;
```
```python
if
```
```python
(i%
```
```python
5
```
```python
==
```
```python
0
```
```python
)
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
free
```
```python
(R);
```
```python
return
```
```python
0
```
```python
;
}
```

