
# recovery相关的FAQ总结 - 嵌入式Linux - CSDN博客

2018年11月05日 19:02:46[写代码的篮球球痴](https://me.csdn.net/weiqifa0)阅读数：2


一、[FAQ12481]Recovery mode在cache/recovery目录下新建一支文件，重启后，新建文件消失了 [DESCRIPTION] 1、在recovery.cpp文件的最后新建一支文件 /cache/recovery/wetest；并写入内容：welcome to recovery mode！ 2、编译版本、烧写手机，开机后，进行恢复出厂设置；等手机进入自动重启状，并在弹出开机向导前，通过命令进入到/cache/recovery/，有wetest文件，内容也正确；但是等开机向导走完之后，再进入/cache/recovery查看，生成的文件就消失了。
[SOLUTION] 原因是： 开机完成后，在frameworks/base/core/java/android/os/recoverysystem.java里面会去判断/cache/recovery目录下面的文件是不是以"last_"开头的，如若不是，就会delete掉，目的是让该目录只存储recovery mode指定的几支文件。 如果有需求一定要在该目录下新建文件，请务必在您的文件名前加上前缀"last_"，以避免在重启后被删除。
二、[FAQ14484]如何修改L版本recovery mode 小机器人界面进入菜单，由volume up&power改为直接按power(如同KK以前版本) [DESCRIPTION] L版本进入recovery mode 会出现小机器人界面需同时按volume up & power 才能进入菜单， 如何改为像KK以前版本，直接按power 进入菜单
[SOLUTION]
1.alps/bootable/recovery/Ui.cpp key_long_press(false), key_down_count(0), enable_reboot(true), + recovery_show_menu_flag(0), consecutive_power_keys(false), consecutive_alternate_keys(0), RecoveryUI::KeyAction RecoveryUI::CheckKey(int key) { + if (key == KEY_POWER && recovery_show_menu_flag==false) { + recovery_show_menu_flag=true; + return TOGGLE; + } if ((IsKeyPressed(KEY_POWER) && key == KEY_VOLUMEUP) || key == KEY_HOME) { 2.alps/bootable/recovery/ui.h int rel_sum; + bool recovery_show_menu_flag; int consecutive_power_keys; int consecutive_alternate_keys; 三、[FAQ12492]SD卡升级包升级后，如何删除升级包文件？ 修改方法如下： 在alps\bootable\recovery.cpp文件如下处修添加code(绿色)： ……… if (status != INSTALL_SUCCESS || ui->IsTextVisible()) { prompt_and_wait(device, status); } \#endif if(update_package) //add remove_mota_file(update_package); //add // Otherwise, get ready to boot the main system... finish_recovery(send_intent); ui->Print("Rebooting...\n"); android_reboot(ANDROID_RB_RESTART, 0, 0); return EXIT_SUCCESS; }
四、[FAQ08726][Recovery]How to enable adb in Recovery Mode 【Description】 之前Recovery Mode下，ENG版本的手机只能敲入adb pull将log提取出来分析。 现在，只需要修改/recovery/etc/init.rc，就可实现RecoveryMode和NormalMode一样，随意的使用adb command啦。
【Solution】 下图框框里的init.rc是在89JB2.MP上验证过，是可行的，直接替代原有的/recovery/etc/init.rc就OK。 如果是72版本的，需要注意----『ubifs的mount命令是不同的』。 标红部分是需要注意的地方。 on early-init start ueventd
on init export PATH /sbin:/system/bin export ANDROID_ROOT /system export ANDROID_DATA /data export EXTERNAL_STORAGE /sdcard symlink /system/etc /etc
mkdir /sdcard mkdir /system mkdir /data mkdir /cache mount /tmp /tmp tmpfs insmod /sec.ko mknod /dev/sec c 182 0 chmod 0660 /dev/sec mount ext4 /emmc@android /system wait commit=1,noauto_da_alloc
chown root shell /tmp chmod 0775 /tmp
write /sys/class/android_usb/android0/enable 0 write /sys/class/android_usb/android0/idVendor 0BB4 write /sys/class/android_usb/android0/idProduct 0c01 write /sys/class/android_usb/android0/functions adb
on boot
ifup lo hostname localhost domainname localdomain
class_start default
service ueventd /sbin/ueventd critical
service recovery /sbin/recovery
service adbd /sbin/adbd recovery start adbd
\# Always start adbd on userdebug and eng builds on property:ro.debuggable=1 write /sys/class/android_usb/android0/enable 0 write /sys/class/android_usb/android0/idVendor 0BB4 write /sys/class/android_usb/android0/idProduct 0c01 write /sys/class/android_usb/android0/functions adb write /sys/class/android_usb/android0/enable 1 start adbd
\# Restart adbd so it can run as root on property:service.adb.root=1 write /sys/class/android_usb/android0/enable 0 restart adbd write /sys/class/android_usb/android0/enable 1 备注：这个功能只可用于debug，正式版本须关闭，不然可能会引起升级失败。 五、[FAQ12633]更新APN列表OTA升级后开机即生效 [DESCRIPTION] 更新APN列表OTA升级后需要恢复出厂设置APN更新才有效， 客户需要做升级后开机即生效。
[SOLUTION] 因为，OTA升级更新的是三个区域，boot , recovery, system, APN属于DATA域，OTA升级不会涉及到， 所以，必须reset之后才会更新有效。
所以， 需要修改alps\build\tools\releasetools\ota_from_target_files这个脚本， 在 script.DeleteFiles([i[1] for i in to_create]) script.MakeSymlinks(to_create) 之后添加以下命令： script.Mount("/data") script.DeleteFiles(["/data/data/com.android.providers.telephony/databases/telephony.db", "/data/data/com.android.providers.telephony/shared_prefs/load-apn.xml"])
这样做的目的是在升级之后，开机再重新把apns-conf.xml里的apn信息写入db ， 达到更新的目的。 该措施在Android M之后可能不可行，在M之后data分区加密导致在recovery下挂载失败，此方法没有验证 六、[FAQ11015]通过组合键进入recovery模式选择sdcard菜单升级，升级完如何自动重启？ [DESCRIPTION]
将OTA升级包放入SD卡根目录下，在recovery模式下进入OTA升级包，升级完成后无法自动重启，需要手动完成重启，新需求：能自动重启。
[SOLUTION]
修改alps/bootable/recovery/recovery.cpp 1. 在代码中找到以下code，并在后面添加return;
ui->Print("\nInstall from sdcard complete.\n"); finish_recovery(NULL); return; //add by MTK
2. 在代码中找到以下code，并在后面添加return; ui->Print("\nInstall from sdcard2 complete.\n"); finish_recovery(NULL); return; //add by MTK 七、[FAQ08110]如何修改recovery mode下字体的大小 [DESCRIPTION] 当客户手机为1080P的时候，如果感觉recovery mode下的字体太小，可以按照如下方式修改 [SOLUTION]
1，拷贝alps/mediatek/factory/src/miniui/font_16X28.h到alps\bootable\recovery\minui下 2、修改alps\bootable\recovery\minui\graphics.c文件中的\#include "font_16x28.h"
3、修改alps\bootable\recovery\ui.c中CHAR_HEIGHT和CHAR_WIDTH分别修改为 28和 16
4 ，按照如下方式编译recovery.img并重新download即可 ./makeMtk mm bootable/recovery/ ./makeMtk -opt=ONE_SHOT_MAKEFILE=build/target/board/Android.mk r recoveryimage 八、[FAQ18251][Recovery][common] Android M Adoptable SD卡无法在recovery mode识别和使用 [DESCRIPTION] Android M 版本，当外置的SD卡被Adoptable 之后，即Format As internal Storage，此时，如果把升级包置于SD卡，进入recovery mode后是无法找到升级包并正常升级的。
[SOLUTION] 首先，外置SD卡可以被Adoptable 这个功能，是Android M 引入的一个new feature，其次，在被Format As internal Storage之后，SD卡会被加密并被Format成Ext4格式，而在recovery mode 是无法访问这时的SD卡，这个是Google原生的做法，MTK维持Google的做法，所以无法在recovery mode是无法挂载Adoptable后的SD的，谢谢！
这种情况下，如果要实现OTA升级，强烈建议您把升级包放入/data/ 下面，谢谢！
相关可参考： FAQ17442 [Recovery][Common]Android M 版本data加密后升级包放入/data分区如何升级？ 九、[FAQ18202][Recovery][Common]Android L ->M版本OTA/T卡升级注意事项 [DESCRIPTION] Android L -> M　升级，除了前后版本partition 数目，大小，顺序需一致的升级基本规则外， 相对于升级到L版本的不同，需额外注意的的地方如下
[SOLUTION] 1.升级包制作命令　添加 –s device/mediate/build/releasetools/mt_ota_from_target_files　 • Full : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files src.zip update.zip • Incremental : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files –i src.zip tgt.zip update.zip
2.建议使用block-base升级(加--block参数),如使用file-base升级(不加--block参数) 请关闭M 版本dm-verity ,否则升级后无法正常开机 关闭dm-verity方法，将fastab里 /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/system /system __MTK_SYSIMG_FSTYPE ro　wait,verify 修改为（去掉verity参数） /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/system /system __MTK_SYSIMG_FSTYPE ro　wait 3.如何升级preloader 与LK　与其它raw 分区 preloader , lk : 请参考　FAQ17441 [Recovery][Common]Android M 版本如何升级lk 、preloader ？ 其他raw分区，如logo.. : 请参考　FAQ18188 [Recovery][Common]Android M 版本如何升级logo等rawdata分区方法？ 4. Ｌ版本 请配置MTK_SHARED_SDCARD=yes ,MTK_2SDCARD_SWAP=no，否则升级至M版本用户数据丢失 因为MTK_2SDCARD_SWAP在M版本已经phase out 不支持， 若已出货Ｌ版本已开启MTK_2SDCARD_SWAP=yes需升级至M版本,请在Ｍ版本下载patch id: ALPS02551082 5.差分包编译失败 如差分包制作diff过程如下时异常退出而无法生成， File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 574, in diff_worker patch = compute_patch(src, tgt, imgdiff=(xf.style == "imgdiff")) File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 60, in compute_patch raise ValueError("diff failed: " + str(p))
ValueError: diff failed: 1 或 File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 273, in Compute self.ComputePatches(prefix) File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 594, in ComputePatches for patch, xf in patches: TypeError: 'NoneType' object is not iterable 请抓patch id: ALPS02608209后验证， 或直接修改\bootable\recovery\applypatch\imgdiff.c char ptemp[] = "/tmp/imgdiff-patch-XXXXXX"; - mkstemp(ptemp); + int fd = mkstemp(ptemp); + + if (fd == -1) { + printf("MakePatch failed to create a temporary file: %s\n", + strerror(errno)); + return NULL; + } + close(fd); // temporary file is created and we don't need its file + // descriptor 若仍无法制作请提交e-service
6./data加密后升级包如何由内卡或放置/data分区下升级 请参考　FAQ17442 [Recovery][Common]Android M 版本data加密后升级包放入/data分区如何升级？ 如uncrypt出现权限失败问题请抓patch id: ALPS02625151 7.升级后modem能否正常工作？ 请参考　FAQ17640 [NVRAM]检查两个不同modem版本的modem nvram是否可以采用OTA升级 8.其他： 可参考DMS文档　OTA and Android SD upgrade application note.docx 十、[FAQ14973]Adb sideload OTA升级失败报错："E: unknown volume for path [/sideload/pakage.zip]” [DESCRIPTION] 操作步骤： 1. Enter the recovery mode by pressing the buttons with Power + Volume 2. Select the "Recovery" 3. Pressing the button "Power" and soon after the button "Volume +" 4. Select the "Apply update from ADB" 5. On the PC running the command "adb sideload <filename>" 6. Check the behavior 实际结果： Is not possible to carry out the recovery and is shown msg "Sideload aborted" The log is shown: E: unknown volume for path [/sideload/pakage.zip] E: can`t mount /sideload/package.zip I: GPT is supported!
[SOLUTION] 在bootable/recovery/ roots.cpp如下函数添加code： 1、ensure_path_mounted函数开始位置加上： if (!strncmp(path, "/sideload", strlen("/sideload"))) {//add return 0；//add }//add Volume* v = volume_for_path(path); 2、同样ensure_path_unmounted函数开始位置加上： if (!strncmp(path, "/sideload", strlen("/sideload"))) {//add return 0；//add }//add Volume* v = volume_for_path(path); 十一、[FAQ17442][Recovery][Common]Android L和M 版本data加密后升级包放入/data分区如何升级？ [DESCRIPTION] Android L和M 版本，data加密后，开启MTK_SHARED_SDCARD并把升级包放入内卡；或者有需要把升级包放入/data分区来升级， 一般这种情况，直接按键进入recovery mode，选择apply from sdcard来实现升级，是行不通的，建议在验证升级时，使用adb 命令的方式升级。
[SOLUTION] L版本的步骤如下： 1、在normal mode先把升级包(update.zip) push 到data分区目，比如/data/update.zip. 2、adb shell 下执行：echo "--update_package=@/cache/recovery/block.map" > /cache/recovery/command 4、adb shell 下执行：system/bin/uncrypt
M版本的步骤如下： 1、在normal mode先把升级包(update.zip) push 到data分区目，比如/data/update.zip. 2、adb shell 下执行：system/bin/uncrypt /data/update.zip /cache/recovery/block.map 注意：要等待一段时间，直到命令执行退出…，然后在执行如下命令； 3、adb shell 下执行：echo "--update_package=@/cache/recovery/block.map" > /cache/recovery/command 4、adb reboot recovery 十二、[FAQ12491][Recovery mode][Common] 选择"apply update from sdcard"直接进入data/目录是否正常？ [DESCRIPTION] Recovery mode 选择"apply update from sdcard"直接进入data/目录，说明您开了MTK_SHARED_SDCARD宏；请检查下贵司project下的projectconfig.mk文件，谢谢！ 至于开了share sd功能后的升级方案：请参考： ID: FAQ12477 关于打开MTK_SHARED_SDCARD宏后MTK目前升级方案 KK 版本默认是支持在打开MTK_SHARED_SDCARD宏后从内卡升级，即从/data/media/下面选取升级包升级；但这种情况有些Limitation；详情见FAQ12477。
[SOLUTION] 这种现象是正常的！ 谢谢！ 十三、[FAQ14769]L版本OTA升级遇到error："system has been remounted R/W; reflash device to reenable OTA updates" [DESCRIPTION] L版本；如果有在bootable/recovery/目录下code中添加ensure_path_mounted(“/system”); 或者是在recovery mode下执行root integrity check之后，导致OTA升级失败，而且last_log中有如下error： script aborted: system has been remounted R/W; reflash device to reenable OTA updates system has been remounted R/W; reflash device to reenable OTA updates
[SOLUTION] 可以尝试在 /bootable/recovery/roots.cpp中作如下修改：(蓝色为添加部分) int ensure_path_mounted(const char* path) { } else if (strcmp(v->fs_type, "ext4") == 0 || strcmp(v->fs_type, "vfat") == 0) { if (strcmp(v->mount_point, "/system") == 0)//add result = mount(v->device, v->mount_point, v->fs_type,MS_NOATIME | MS_NODEV | MS_NODIRATIME | MS_RDONLY, "");//add else //add result = mount(v->device, v->mount_point, v->fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, ""); 十四、[FAQ11954]如何实现恢复出厂后不重新启动手机？ [DESCRIPTION] 实现恢复出厂后不重新启动手机
[SOLUTION] 请在/bootable/recovery/recovery.cpp文件如下处修改： // Otherwise, get ready to boot the main system... finish_recovery(send_intent); return；//添加这一句，直接return ui->Print("Rebooting...\n"); android_reboot(ANDROID_RB_RESTART, 0, 0); return EXIT_SUCCESS; } 十五、[FAQ03439][Recovery]如何进入recovery mode立即显示menu菜单 请将alps/bootable/recovery/ui.c文件中的static int show_text = 0; 修改为static int show_text = 1; 十六、[FAQ04813]update.zip包中各个文件的含义 将全量升级包update.zip包解压后里面的各个文件的含义如下： boot.img:(boot.img=kernel+ramdisk) system:(升级后会放在系统的system分区。主要用来更新系统的一些应用或则应用会用到的一些库) recovery/recovery-from-boot.p:(是boot.img和recovery.img的补丁) recovery/etc/install-recovery.sh:(install-recovery.sh是更新脚本) META-INF/CERT.RSA:(签名文件相关,保存公匙和加密算法) META-INF/CERT.SF:(签名文件相关,保存私匙,CERT代表签名者) META-INF/MAINFEST.MF:(这个manifest文件定义了与包的组成结构相关的数据) com/google/android/update-binary:(一个脚本解释器，能够识别updater-script中描述的操作) com/google/android/updater-script:(脚本文件，具体描述了更新过程) com/google/android/metadata:(描述设备信息及环境变量的元数据) 十七、[FAQ17418][Recovery][Build] 预置资源（如apk）到userdata，otapackage之后的userdata.img没有此资源 [Background] 随着FLASH空间的使用率被广泛专注，MTK_SHARED_SDCARD的使用逐渐成为主流。 MTK_SHARED_SDCARD enable的前提下，phone storage和internal storage共享userdata分区，其中phone storage的目录变成了/data/media。 MTK_SHARED_SDCARD enable时的内置资源预置方式，可以参见FAQ： [FAQ14735]【sdcard-FAT filesystem】MTK_SHARED_SDCARD打开时L上如何预置资源
[Issue] 按照FAQ14735预置资源以后，new之后的userdata.img是包含新内置资源，此时再执行otapackage，out目录下的userdata.img并不包含此资源。
[Solution] 经分析，主要原因如下所示： /build/core/Makefile 中otapackage的主要flow -- otapackage: $(INTERNAL_OTA_PACKAGE_TARGET) -> $(INTERNAL_OTA_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(DISTTOOLS) -> $(BUILT_TARGET_FILES_PACKAGE) $(hide) ./build/tools/releasetools/add_img_to_target_files -p $(HOST_OUT) $@ $(hide) ./build/tools/releasetools/replace_img_from_target_files.py $@ $(PRODUCT_OUT) Add_img_to_target_files对各个image的处理 -- /build/tools/releasetools/add_img_to_target_files main -> AddImagesToTargetFiles(args[0]) -> AddSystem(output_zip, recovery_img=recovery_image, boot_img=boot_image) -> AddUserdata(output_zip) -> AddCache(output_zip)
上面flow的目的是以out/obj/的中间包（cota包）为source重新生成image，放入中间包。 def AddUserdata(output_zip, prefix="IMAGES/"): """Create an empty userdata image and store it in output_zip.""" 其中， AddUserdata与其他接口的实现不同，主要是生成一个空的目录，google要求otapackage release出去的dataimage是空的（升级本身也是不包含userdata的）。 -> $(hide) ./build/tools/releasetools/replace_img_from_target_files.py $@ $(PRODUCT_OUT) 这段的目的是从中间包将image copy出来替换out目录。 所以，otapackage最终out/obj目录下的/DATA目录是有apk的，但是最后生成的out目录和中间包里的userdata.img都是空的。 如果一定要预置apk，可以尝试将new后的userdata.img保留下来。Otapackage之后，再用new后的userdata.img替换out目录下的userdata.img。 或是直接修改/build/tools/releasetools/replace_img_from_target_files.py 将 if img.find(".img") != -1: 修改为 if img.find(".img") != -1 and img.find("userdata") == -1 : 十八、[FAQ03434][Recovery]恢复出厂设置之后如何将时间变为初始值 Recovery.c (bootable\recovery): \#include <linux/rtc.h> \#include <sys/ioctl.h> void set_rtc(void) { struct tm tm; int fd; tm.tm_sec = 0; tm.tm_min = 0; tm.tm_hour = 0; tm.tm_mday = 1; tm.tm_mon = 0; tm.tm_year = 2012-1900; fd = open("/dev/rtc0", O_WRONLY); if (fd != -1) { ioctl(fd, RTC_SET_TIME, &tm); close(fd); } } int main(int argc, char **argv) { ... 中的 } else if (wipe_data) { .... // /*该else if代码最后 新增代码如下*/ set_rtc(); } 十九、[FAQ14751]L 版本Security OTA升级方法 [DESCRIPTION] Ｌ版本Security OTA升级方法； [SOLUTION] 首先：修改build/core/makefile如下：(蓝色为添加项) \# host tools needed to build dist and OTA packages SECURITY_SIG_TOOL := vendor/mediatek/proprietary/scripts/sign-image/sign_image.sh SIGN_TOOL := vendor/mediatek/proprietary/scripts/sign-image/SignTool.pl FWUPGRADEPACKAGE_SH := ./build/core/FWUpgradePackage.sh DISTTOOLS := $(HOST_OUT_EXECUTABLES)/minigzip \
endif ifeq ($(strip $(MTK_SECURITY_SW_SUPPORT)), yes) \#security boot signature $(hide) cp -ru $(zip_root)/SYSTEM/* $(SYSTEMIMAGE_SOURCE_DIR) $(hide) $(SHELL) $(SECURITY_SIG_TOOL) $(hide) cp $(PRODUCT_OUT)/sig/boot.sig $(zip_root)/META/ $(hide) cp $(PRODUCT_OUT)/sig/recovery.sig $(zip_root)/META/ $(hide) cp $(PRODUCT_OUT)/sig/recovery.sig $(zip_root)/SYSTEM/etc/ $(hide) cp $(SYSTEMIMAGE_SOURCE_DIR)/etc/firmware/S_ANDRO_SFL.ini $(zip_root)/SYSTEM/etc/firmware/ endif
@\# Zip everything up, preserving symlinks $(hide) (cd $(zip_root) && zip -qry ../$(notdir $@) .) $(hide) (cd $(zip_root) && zip -q ../$(notdir $@) META/*filesystem_config.txt) $(hide) ./build/tools/releasetools/add_img_to_target_files -p $(HOST_OUT) $@ $(hide) ./build/tools/releasetools/replace_img_from_target_files.py $@ $(PRODUCT_OUT) ifeq ($(strip $(MTK_SECURITY_SW_SUPPORT)), yes) $(hide) perl $(SIGN_TOOL) $(MTK_BASE_PROJECT) $(MTK_PROJECT_NAME) $(MTK_PATH_CUSTOM) $(MTK_SEC_SECRO_AC_SUPPORT) $(MTK_NAND_PAGE_SIZE) $(PRODUCT_OUT) $(OUT_DIR) $(DEAL_STDOUT_SIGN_IMAGE)
注意：最后一行添加的绿色部分，是由文件vendor/mediate/proprietary/scripts/sign-image/Android.mk 的最后一行copy而来，具体以贵司实际文件内容为准。
然后：build diff OTA升级的步骤如下： 1、new整个project。 2、Step1: ./vendor/mediatek/proprietary/scripts/sign-modem/sign_modem.sh Step2: ./vendor/mediatek/proprietary/scripts/sign-image/sign_image.sh 3、make otapackage 4、產生差分包： MTK_SECURITY_SW_SUPPORT=yes ./build/tools/releasetools/ota_from_target_files --block -k <key_path> -i old.zip new.zip update.zip
build full OTA升级的步骤如下： 1、new整个project。 2、Step1: ./vendor/mediatek/proprietary/scripts/sign-modem/sign_modem.sh Step2: ./vendor/mediatek/proprietary/scripts/sign-image/sign_image.sh 3、make otapackage 二十、[FAQ05739]SD或者OTA升级secutiry device和non-security device的区别！ 问题现象： 同样的升级包在升级non-security device可以升级成功，升级secutiry device确不能升级成功！ 原因说明：SD在升级non-security device和security device的区别是：在升级security device时，SUPPORT_SBOOT_UPDATE这个宏会打开！然后升级security device时会去检查升级包中的SEC_VER.txt这个文件，并且检查SEC_VER.txt这个文件里的CUSTOM_NAME,BOOTIMG,RECOVERY,ANDROID四项，并且要求BOOTIMG,RECOVERY,ANDROID这三项的值要比手机里面这三项的值要相等或者大于手机版本里的值！否则会升级失败！ 下面举一个例子来说明，假如bootimg第一版是version 1 1. 空机先烧录进bootimg，则device里面的记录是version 1 2. 假如发现bootimg有security bug，重新编出一版 version 2；接着烧录，device里面就变成记录的是version 2 3. 假如发现bootimg有security bug，重新编出一版 version 3；接着烧录，device里面就变成记录的是version 3 4. (此时，如果要烧录回去verison 1或version 2，都是不允许的动作) 5. 假如这个时候USER透过OTA去升級，而OTA package记录的BOOTIMG版本號是4，那就允许更新；如果是2或3，都不允许更新 二十一、[FAQ03128]Android系统中的6种模式 [DESCRIPTION] Android系统中的6种模式 [SOLUTION] 1:一般启动模式（normal mode): 功能是正常启动手机，方法为关机状态下按电源键启动。 2:安全模式（safe mode）: 此模式和正常启动一样，但没有登记Google，所以不能访问Market或使用你的Google账号。操作方法为按住“menu”键，按电源键启动手机，直至手机启动完成松开“menu”键。 3:恢复模式（recovery mode） 可打开命令解释程序（shell），刷新映像文件（flash image），执行备份等。当然这一切取决于你手机上的recovery image版本。使用方法很简单，就是home键和电源键一起按。 4:引导模式（bootloader mode） 功能是从SD卡上安装新的系统映像（DREAIMG.NBH），只需再按一次电源键。值得一提的事为Android手机获取root权限，就是使用这个模式。操作方法为照相键和电源键一起按。 5:fastboot模式 主要是在电脑上使用fastboot命令来刷新映像文件。使用方法为按住返回键，按电源键启动手机，直至屏幕出现FASTBOOT字样后松开返回键。 6:诊断模式（diagnostic mode） 是为了测试手机各项功能的模式，刻意通过轨迹球中心键和电源键打开。 二十二、[FAQ18202][Recovery][Common]Android L ->M版本OTA/T卡升级注意事项 [DESCRIPTION]
Android L -> M　升级，除了前后版本partition 数目，大小，顺序需一致的升级基本规则外， 相对于升级到L版本的不同，需额外注意的的地方如下
[SOLUTION]
1.升级包制作命令　添加 –s device/mediate/build/releasetools/mt_ota_from_target_files　 • Full : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files src.zip update.zip • Incremental : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files –i src.zip tgt.zip update.zip
2.建议使用block-base升级(加--block参数),如使用file-base升级(不加--block参数) 请关闭M 版本dm-verity ,否则升级后无法正常开机 关闭dm-verity方法，将fastab里 /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/system /system __MTK_SYSIMG_FSTYPE ro　wait,verify 修改为（去掉verity参数） /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/system /system __MTK_SYSIMG_FSTYPE ro　wait
3.如何升级preloader 与LK　与其它raw 分区 preloader , lk : 请参考　FAQ17441 [Recovery][Common]Android M 版本如何升级lk 、preloader ？ 其他raw分区，如logo.. : 请参考　FAQ18188 [Recovery][Common]Android M 版本如何升级logo等rawdata分区方法？
4. Ｌ版本 请配置MTK_SHARED_SDCARD=yes ,MTK_2SDCARD_SWAP=no，否则升级至M版本用户数据丢失
因为MTK_2SDCARD_SWAP在M版本已经phase out 不支持，
若已出货Ｌ版本已开启MTK_2SDCARD_SWAP=yes需升级至M版本,请在Ｍ版本下载patch id: ALPS02551082
5.差分包编译失败
如差分包制作diff过程如下时异常退出而无法生成，
File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 574, in diff_worker
patch = compute_patch(src, tgt, imgdiff=(xf.style == "imgdiff"))
File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 60, in compute_patch
raise ValueError("diff failed: " + str(p))
ValueError: diff failed: 1
或
File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 273, in Compute
self.ComputePatches(prefix)
File "/home/scm03/5023F_MEA_AL_V1.4_20160511/build/tools/releasetools/blockimgdiff.py", line 594, in ComputePatches
for patch, xf in patches:
TypeError: 'NoneType' object is not iterable
请抓patch id: ALPS02608209后验证，
或直接修改\bootable\recovery\applypatch\imgdiff.c
char ptemp[] = "/tmp/imgdiff-patch-XXXXXX";
- mkstemp(ptemp);
+ int fd = mkstemp(ptemp);
+
+ if (fd == -1) {
+ printf("MakePatch failed to create a temporary file: %s\n",
+ strerror(errno));
+ return NULL;
+ }
+ close(fd); // temporary file is created and we don't need its file
+ // descriptor
若仍无法制作请提交e-service
6./data加密后升级包如何由内卡或放置/data分区下升级
请参考　FAQ17442 [Recovery][Common]Android M 版本data加密后升级包放入/data分区如何升级？
如uncrypt出现权限失败问题请抓patch id: ALPS02625151
7.升级后modem能否正常工作？
请参考　FAQ17640 [NVRAM]检查两个不同modem版本的modem nvram是否可以采用OTA升级

