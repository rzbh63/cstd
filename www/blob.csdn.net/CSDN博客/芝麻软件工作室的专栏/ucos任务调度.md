
# ucos任务调度 -  芝麻软件工作室的专栏 - CSDN博客


2016年07月13日 10:02:58[seven-soft](https://me.csdn.net/softn)阅读数：279个人分类：[uCos-II																](https://blog.csdn.net/softn/article/category/6305029)



1）OSTimeDly产生延时，假设当前任务A调用OSTimeDly函数，则OSTimeDly函数就将任务A从任务就绪表中去掉，并将延时时间赋值给任务A的任务控制块中的OSTCBDly，然后调用OS_Sched。
（2）OS_Sched函数，它利用任务就绪表，将就绪任务中的优先级最高的任务查出，赋值给OSPrioHighRdy，然后用OS_TASK_SW切换任务。
（3）OSTimeTick函数，它由定时器的中断服务程序调用，OSTimeTick函数的作用是将延时时间已到的任务添加到任务就绪表中，以供OS_Sched切换任务时查询使用。
总 结一下就是，调度任务要靠任务就绪表，如果要延时，则OSTimeDly将该任务从就绪表中去掉，如果延时已到，则OSTimeTick将该任务添加到就 绪表中，他们这样做的目的都是为OS_Sched产生任务切换提供依据，最终，任务的切换是要靠OS_Sched！！！！！！

在多任务系统中，都会提供一个系统函数来进行进程（任务）间切换，综合来说，他们有两种进程（任务）切换方式：
1) 由进程（任务）本身直接调用任务切换函数进行进程（任务）切换：
在当前进程（任务）因为不能获得必须的资源而立即被堵塞时，就由进程（任务）本生直接调用进程（任务）切换函数进行进程（任务）间调度。
在Linux中可以直接调用schedule()函数来实现。
在UCos中，通过调用OSSched（）来完成。
2) 延迟调用任务切换函数进行进程（任务）切换：
此方式是把当前进程（任务）设置一调度标志而以延迟方式调用任务切换函数进行进程（任务）切换。
在Linux系统中，总是在恢复用户态进程执行之前，检查这一调度标志，在这里标志是：TIF_NEED_RESCHED，如果有这一标志，就调用调度函数进行进程切换。此种情况主要包括以下几种：
A. 当前进程用完了它的CPU时间片，有scheduler_tick()函数完成 schedule()的延迟调用。
B.当一个被唤醒进程的优先级比当前进程优先级高时，由try_to_wake_up()函数完成schedule()的延迟调用。
C.当发出系统调用sched_setscheduler()时。
在这些情况中，主要由于系统调用或中断而进入内核态，或者当前进程本来在内核态时，返回用户态时发生的。
在UCOS中，所有的任务有不同的优先级，不会出现同一优先级上有多个任务的情况，而且也没有系统调用的概念，所以任务调度的延迟调用只能出现在中断处理完成返回时，在OSIntExt()函数中，检查是否有高优先级的任务就绪，如果有高优先级的任务就绪，进行任务切换。
在多任务系统中，都会提供一个系统函数来进行进程（任务）间切换，综合来说，他们有两种进程（任务）切换方式：
1) 由进程（任务）本身直接调用任务切换函数进行进程（任务）切换：
在当前进程（任务）因为不能获得必须的资源而立即被堵塞时，就由进程（任务）本生直接调用进程（任务）切换函数进行进程（任务）间调度。
在Linux中可以直接调用schedule()函数来实现。
在UCos中，通过调用OSSched（）来完成。
2) 延迟调用任务切换函数进行进程（任务）切换：
此方式是把当前进程（任务）设置一调度标志而以延迟方式调用任务切换函数进行进程（任务）切换。
在Linux系统中，总是在恢复用户态进程执行之前，检查这一调度标志，在这里标志是：TIF_NEED_RESCHED，如果有这一标志，就调用调度函数进行进程切换。此种情况主要包括以下几种：
A. 当前进程用完了它的CPU时间片，有scheduler_tick()函数完成 schedule()的延迟调用。
B.当一个被唤醒进程的优先级比当前进程优先级高时，由try_to_wake_up()函数完成schedule()的延迟调用。
C.当发出系统调用sched_setscheduler()时。
在这些情况中，主要由于系统调用或中断而进入内核态，或者当前进程本来在内核态时，返回用户态时发生的。
在UCOS中，所有的任务有不同的优先级，不会出现同一优先级上有多个任务的情况，而且也没有系统调用的概念，所以任务调度的延迟调用只能出现在中断处理完成返回时，在OSIntExt()函数中，检查是否有高优先级的任务就绪，如果有高优先级的任务就绪，进行任务切换。

