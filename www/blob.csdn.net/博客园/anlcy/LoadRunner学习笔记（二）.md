
# LoadRunner学习笔记（二） - anlcy - 博客园






# [LoadRunner学习笔记（二）](https://www.cnblogs.com/camilla/p/10283400.html)
**LoadRunner Controller简介：**
当虚拟用户脚本开发完成后，使用controller将这个执行脚本的用户从单用户转化为多用户，从而，模拟大量用户操作，
进而形成负债（多用户单循环，多用户多循环）我们需要对负载模拟的方式和特征进行配置从而形成场景。
场景（scenario）是一种用来模拟大量用户操作的技术手段，通过配置和执行场景向服务器产生负载，验证系统各项
性能指标是否达到用户要求，而controller 可以帮助我们对场景设计哦、执行及监控进行管理，主要分为：场景设计、
场景监控。最后通过运行场景完成性能测试执行。
**1.手工场景（Manual Scenario）：**
自行设置虚拟用户的变化，通过设计用户的添加和减少过程，来模拟真实的用户请求模型，完成负载的生成手工
场景是“定量型”性能测试，掌握负载的变化过程中系统各个组件的变化情况，定位性能瓶颈并了解系统的处理能力，
一般在负责测试和压力测试中应用，手工场景的核心就是设置‘用户负载方式‘。
LR场景设置页面分为四个模块，第一个显示Vuser脚本列表，第二部分为服务协议，第三部分为设置方案，第四
部分为方案显示.
1.脚本列表：第一列为脚本名称，第二列脚本保存路径，第三列并发数，第四列是负载机。虚拟用户组是执行同一脚本
的虚拟用户的集合。因此在Controller中，添加了一个脚本就是添加了一个虚拟用户组。
2.方案设置：Scenario模式:所有的脚本都使用相同的场景；
group：多个脚本之间按照独立设置模式跑，各个脚本可以单独设置虚拟用户、运行时间等；
Real-world schedule（真实场景模式）：可以通过add Action添加多个用户变化过程。
双击Initialize详细设置：
第一个选项是场景开始运行时，同时加载所有用户；　第二个选项是场景开始时，每隔15秒增加1个用户；
第三个选项是在场景开事前就加载好每个用户；
双击Start Vuser设置：设置同时启动所有用户数或者每隔多少秒增加多少用户；
双击Duration设置：每个用户运行一次就停止持续运行时间；
双击Stop Vuser设置：停止用户方式；
**2.目标场景（Goal-Oriented Scenario）：**
定义：设置一个运行目标，通过Controller的自动加载功能进行自动化负载，如果测试的结果达到目标，说明系统的性能符合测试
目标，否则就提示无法达到目标。
目标场景的5中类型（Goal Type）：
Virtual Users：该参数表示虚拟用户数，验证被测试系统所需要支持的用户数；
Hits per Second:表示每秒点击数，是指一秒钟能做到的点击请求数目，即客户端产生的每秒请求数（正常情况下=服务器请求响应数）
Transctions per Scoend：表示每秒事务所，一个事务代表一个操作，反应系统的处理能力；
Transctions =Response Time：表示事务的响应时间，反应系统的处理速度以及一个操作花费的时间；
Pages per Minute：表示每分钟页面的刷新次数，反应系统每分钟提供的页面处理能力，代表了系统的整体处理能力。
**LR负载生成器(Load Generators):**
对场景进行设置后，需要对负载生成器进行管理和配置，Load Generators 是运行脚本的负载引擎，（相当于压力机）
只要功能是生成虚拟用户进行负载，在默认情况下使用本地的负载生成器来运行脚本。
但是每生成一个虚拟用户，需要花费负载生成器大约2M-3M的内存空间，通常运行controller的主机很少用作负载生成器，负载生成器的
工作多由其他装有LR Agent的PC机来担任，如果负载生成器内存的使用率大于了70%，负载生成器就好变成系统的瓶颈，导致性能测
试成绩下降。这种问题需要添加负载生成器来解决，所以在一台电脑上无法模拟大量的虚拟用户，这个时候需要调用多个负载生成器
来完成大规模的性能负载。
1.添加负载机器之前需要开启代理运行时设置：
Load Running Manage--Tool--LoadRunner Agent Runtimes Settings Configuration，开启代理运行时设置，在弹出页面输入当前主机的密码即可。
如果开启不了小雷达，我们选择第二项，点击OK，发现会报运行时错误，报错后我们点击报错中的退出，然后进入
开始-所有程序-LoadRunner-Advanced Settings,找到Agent Configuration，点击后弹出如下界面，我们勾选第二项后，点击OK，发现小雷达出现了。
2.设置完成后添加负载机器：
在场景设计页面Seenario Scripts选择load Generators--add，设置另外一台电脑（负载生成器）的名称或ip地址、操作系统、init人数等。
init人数设置：
load Generators页面点击Details，弹出如下图，找到Run-Time Quota标签页。两个值都默认为50，第一个值init最少加载多少用户开始运行脚本，第二个值指加载多少用户就停止加载，开始运行脚本，不勾选表示初始化所有用户后开始运行。不过这里的两个值，我们一般只在单并发时才进行修改，比如单并发100个用户，那么我们把两个值都设置为100。
**LR运行时设置（Run-time Settings）：**
## 一、浏览器设置
![](https://images2015.cnblogs.com/blog/430613/201607/430613-20160708104305249-1933441949.png)
可以进行Run-Time Setting设置来匹配浏览器设置，例如：
|浏览器设置
|Run-Time Setting
|
|每次访问此页时检查
|勾选Simulate Browser Cache
|勾选Check for newer versions of stored pages every visit to the page.
|
|每次开启Internet Explorer时检查
|仅勾选Simulate Browser Cache
|
|自动
|仅勾选Simulate Browser Cache
|
|不检查
|勾选Simulate Browser Cache
|禁用Check for newer versions of stored pages every visit to the page.
|
配置各项说明：
**Simulate  browser  cache**:
配置Vuser模拟带缓存的浏览器。缺省缓存是被允许的，可以通过禁止该选项来使得所有VUser模拟的浏览器都不带缓存。
疑问：如访问百度时IE缓存目录下会缓存一个jpg文件，手动在IE上重新访问百度，这个jpg文件项是否有变化？在LR中模拟浏览器设置，勾选与不勾选，访问百度页面，这个jpg文件信息项是否有变化。
每个缓存文件都有截止期限、上次修改时间、上次访问时间、上次检查时间几项。在已有缓存文件的情况下，测试记录如下：
a.手动页面访问，缓存文件的上次访问时间、上次检查时间两项，时间变化，更新为手动日期；
b.LR中采取默认浏览器设置（上图），vugen中执行1次脚本，查看上次访问时间、上次检查时间两项时间没有变化；
c.LR中取消浏览器设置（上图中去掉全部勾选），vugen中执行1次脚本，查看上次访问时间、上次检查时间两项时间没有变化；
这说明什么？LR中无论采取何种浏览器模拟策略，都不会去访问IE缓存目录下的文件。
**Cache URLs requiring content (HTML)**选项
这个选项是指Vugen仅缓存网页的一些必要信息，这些信息可以是一些必须的验证信息、分析数据或者关联数据，当你勾选了这项后，这些信息自动被缓存（默认是启用）。
提示：为了减少虚拟用户的内存占用量，可以禁用该选项，除非它是一个明确规定的测试要求
设置浏览器缓存URL的上下文(比如，HTML语法，认证或校验等)，其他的URL的上下文不会被缓存，以减少内存使用。可以通过点击Advance来定义需要上下文的URLs。
**Cache URLs Requiring Content – Advanced**选项
在高级设置里可以设置指定类型的信息存储到cache中。注意：这里的高级设置时同时针对所有的用户组，而不能对单独用户组进行设置。
修改指定类型信息步骤：
1.  勾选Specify URLs requiring content in addition to HTML page。
2.  点“+”号，添加指定类型信息，如text/plain, text/xml, image/jpeg, and image/gif。
3.  点“-”号，从缓存中去除指定类型信息。
**Check for newer versions of stored pages every visit to the page**选项
指浏览器会将存储在cache中的网页信息和最新浏览的页面进行比较，当你勾选此项时，vugen会增加**"If-modified-since"到HTTP包头**，在场景执行过程中这个选项可以显示最新的网页信息，但是也增加了更多的网络流量，通常配置这个选项是用来匹配浏览器设置来达到模拟浏览器的目的。
通过在header中添加If-Modified-Sinces属性来设置浏览器检查比当前存储在缓存中特定URL更新的资源。缺省情况下，浏览器不会自动检测更新的资源。
**Download non-HTML resources**选项
指虚拟用户在回放期间访问网站时加载图片的过程，这里图片是指随着页面录制的图片和那些没有随页面录制下来的图片。
当真实用户访问网页时，需要等待图片的加载完成。因此如果想测试整个系统的时候（用户体验时间），可以勾选这项（默认勾选），如果为了提高性能且不是模拟真实用户行为的话，则不要选该项。
提示：禁用此选项后，可能会遇到图片验证失败，因为在访问网站的时候有些图片是会发生变化的，如广告条。
**Simulate a new user each iteration**选项
这个选项是指VuGen在迭代过程（即VuGen在每个循环的init会话结束）中重置了所有的HTTP内容，也可以理解为VuGen 将各个迭代之间的所有 HTTP 上下文重置为 init 部分结束时相应的状态。此设置允许虚拟用户能够更准确的模拟用户开始进行新的会话，它删除了所有的Cookie，**关闭了所有的TCP连接（包含keep-Alive包）**，清除了模拟浏览器的缓存，重置了HTML框架，并且清除了用户名和密码，此选项默认是开启状态。这样使得Vuse更加真实的模拟一个新user开始一个浏览会话。
去掉这个选项的意思是，始终使用一个tcp/ip链接，不断开，也就是所说的长链接或持久连接。
短连接：建立连接-----发送和接收报文1-------关闭连接
长连接：建立连接-----发送和接收报文1.。。。2.。。。3-----关闭连接
**Clear cache on each iteration**选项
这个选项是指在每次迭代过程中清除浏览器中缓存来达到模拟一个真实用户第一次访问网页。若每个循环模拟一个最新访问站点的user时，则要选中该选项。
不勾选该复选框以禁用此选项，允许虚拟用户使用缓存来存储用户信息，来模拟一个已经访问过网页的用户。当每一个循环模拟一个最近访问过站点的user，浏览器仍为该用户保留网页（从前面的循环中使用缓存页面）的情况则不要选中该选项。
类似函数web_cache_clearup()
按照示例脚本描述此函数需要加在action的末尾，而非开始，开始的话场景报错。末尾则不报错。
终这些运行时策略要如何选取，需要根据实际测试项目的策略而定，并非完全一致的。
**测试记录：**
脚本设置：每个脚本中所有信息都在action中，action作为一个事务，每个脚本分为登录、操作，退出。
场景设置：场景中5支脚本，每个脚本配置20VU，迭代执行5分钟，每个脚本计划执行次数100次。
**1、****运行时设置：****浏览器上边几项都不勾选**
测试结果：每个脚本执行20次后，所有交易脚本的action次数都为失败。
脚本中登录的sessionid提示获取不到，但是脚本中的登录判断却显示可以登录成功。---？有点疑惑
**成功数  失败数**
20  80
**2、****运行时设置：Simulate  a  new  user  on  each  iteraton、Clear  cache  on  each  iteration两项勾选**
测试结果：所有脚本按计划执行。
**成功数  失败数**
100  0
3、性能测试时有遇到发包机端口数不足，调整此两项后就不报错的情况。
运行时设置：Simulate  a  new  user  on  each  iteraton**不勾选**
**状态1：勾选，运行几分钟后，发包机显示端口连接数超6W，大量报错。**
**状态2：其他不变的情况下，这项未勾选，测试运行长时间未报错。**
测试一些响应很快的页面时simulate a new user on each iteration设置的开启和关闭会直接导致，要么Lr所在机器的端口间歇性用尽，TPS呈波浪状上下起伏，要么web服务器TIME_WAIT连接瞬间增大到几千或几万。出现这种时，取消勾选。
关闭这个选项后，各项性能指标会高很多。
## 二、常规设置
常规设置中包含迭代策略、pacing设置、日志级别、思考时间、Miscellaneous几项设置。
### 1、General: Miscellaneous
配置如下：
![](https://images2015.cnblogs.com/blog/430613/201609/430613-20160907123952426-899999081.png)
1）运行时关于错误的处理方式。出错后是否继续运行，失败事务后是否发送错误日志，是否生成错误快照。
2）可以配置运行时按线程运行还是按进程运行。
3）定义是否将每个action作为一个事务，或定义是否将每步当做一个事务。比如，要把init、action、end定义三个事务，则选中相应选项。
其他的没有什么，这里重点要的说的是关于线程运行还是进程运行？
**按线程运行VUSER和按进程运行VUSER的区别**
1. 按线程运行VUSER,LR默认情况下，每50个用户开启一个进程mmdrv.exe;controller场景运行结束,进程mmdrv.exe也会相应结束;
2. 按进程运行VUSER,系统为每1个用户开启一个进程mmdrv.exe;controller场景运行结束,进程mmdrv.exe也会相应结束;
3. 在Runtime setting中设置为按线程运行VUSER,设置Controller中的虚拟用户数小于等于50的话，打开windows资源管理器可以看到有一个进程mmdrv.exe;　设置Controller中的虚拟用户数在51与100之间的话，打开windows资源管理器可以看到有两个进程mmdrv.exe.
loadrunner controller将使用驱动程序mmdrv运行Vuser。用户可以在controller的run-time setting中选择Vuser的运行方式, 是多进程方式or多线程方式。
**如果选择以线程方式来运行虚拟用户：**
在场景设置时，“是单行脚本，还是多行脚本”会决定系统启动的进程数的多少：
假设并发用户设置为30，如果是单行30个用户，系统只需启动一个进程；
假设并发用户设置为30，如果是多行，30行，每行一个用户，系统就需要启动30个进程；
**如果选择以进程方式来运行虚拟用户：**
那么无论脚本在场景组中怎么设置，是单行多用户还是多行少用户方式，系统需要启动的进程数是一定的，就是并发用户的总数；
**进程方式和线程方式的优缺点**
如果选择按照进程方式运行， 每个用户都将启动一个mmdrv进程，多个mmdrv进程会占用大量内存及其他系统资源，这就限制了可以在任一负载生成器上运行的并发用户数的数量，因为负载机的资源（内存及其他系统资源）是有限的。
如果选择按照线程方式运行，在默认情况下，controller为每50个用户仅启动一个mmdrv进程，而每个用户都按线程方式来运行，这些线程用户将共享父进程的内存段，这就节省了大量内存空间，从而可以在一个负载生成器上运行更多的用户。（如果选择线程方式来运行用户，每个进程中会多出几个线程，例如是53个，多出来的进程可能是用于维护进程之间的运行的）
选择线程方式虽然可以减少启动的mmdrv进程数，减少了内存的占用，但是也容易出现一个问题，例如，同一个测试场景，用线程并发就会出现超时失败或报 错，而用进程并发就没错。为什么呢？因为线程的资源是从进程资源中分配出来的，因此同一个进程中的多个线程会有共享的内存空间，假设a线程要用资源就必须 等待b线程释放，而b线程也在等待其他资源释放才能继续，这样就会出现这个问题。
**系统需要启动的****mmdrv进程数与哪些因素有关：**
与在controller 的运行时设置中选择的是进程方式or线程方式来运行虚拟用户有关
进程方式：无论是单行or多行脚本，需要启动的进程数就是并发用户数；
线程方式：假设是单行脚本，每50个用户才启动一个进程；多行脚本，有几行（每行<50人）就启动几个进程，而不是每个用户启动一个进程。
如果选择了线程方式，需启动的进程数，进一步还与脚本是单行还是多行有关
单行脚本，多用户，假设少于50，只需启动一个进程，100个用户，只需启动2个进程，依此类推；
多行脚本，即使每行一个用户，也需要启动一个进程，多一行就需要多启动一个进程；不是每个用户启动一个进程，有几行（每行<50人）就需要启动几个进程。
在启动了IP欺骗功能后，所需启动的进程数，还与选择的是按进程还是按线程来分配IP地址有关
按进程分IP：每个ip（负载生成器）就需要多启动一个进程；
按线程分IP：每个ip（负载生成器）不需要多启动一个进程。
备注：这里的单行是指场景中只有一支脚本，多行脚本是指场景里有多支脚本。
多支脚本时，分别为每支脚本设置是按进程方式运行还是按线程方式运行。默认都是线程模式运行。
#### Loadrunner 关于进程和线程的设置
虚拟用户已线程还是进程的方式运行，对被测服务器的压力是完全不同的，首先我们要知道在loadrunner中有3个地方涉及到虚拟用户的运行方式，分别是：
1、在Vug->run-time settings->miscellane->multithreading中可以设置虚拟用户是以线程还是进程的方式运行。文中所列的位置。
2、在controller中设置场景时，是以单场景模式运行还是以场景组方式运行，在这两种不同的运行方式下，虚拟用户的运行方式也是不同的
3、在controller中使用IP欺骗时，在专家模式（选中tools-export mode）下的tools->options->general->multiple IP address mode中也可以选择每个IP是以线程还是进程方式运行。是不是专家模式，在options选项中的标签数量与内容是不同的。
![](https://images2015.cnblogs.com/blog/430613/201609/430613-20160908170216098-795375297.png)
**下面我们介绍一下这三个设置线程和进程之间的关系：**
首先说一下run-time settings中的设置与controller中单场景和场景组的关系：
要记住虚拟用户是以线程还是进程方式运行是在Vug->run-time settings中设置的；
其次在controller中如果使用单场景运行，那么该场景中无论有多少个脚本、多少个负载生成器，运行这些脚本的虚拟用户均依照Vug->run-time settings中设置的线程还是进程方式运行；但是如果在controller中如果以场景组方式运行时，每个场景组均会作为一个进程被启动，而每个组中的用户又是按照Vug->run-time settings中设置的线程还是进程方式运行。
再说一下在controller中使用IP欺骗时，在专家模式下的tools->options->general->multiple IP address mode中的设置：
如果选择的是进程方式：
1、如果这个ip是在单场景中，那么有几个不同的ip的负载生成器就会启动几个进程，每个负载生成器的虚拟用户的运行方式仍然按照Vug->run-time settings中设置的线程还是进程方式运行
2、如果是在场景组中运行，这就要看场景组是如何设置的了，有两种情况：
a、每个场景组中添加一个虚拟ip，这时运行每个场景组时只启动一个进程 b、每个场景组中添加多个虚拟ip，这时运行每个场景组时，每个场景组启动一个进程，每个ip启动一个进程，每个ip的虚拟用户的运行方式按照Vug->run-time settings中设置的线程还是进程方式运行
如果在controller中使用IP欺骗时，在专家模式下的tools->options->general->multiple IP address mode中选择的线程方式：
1、如果这个ip是在单场景中，那么对于不同的ip的负载生成器只会启动一个进程，每个负载生成器的虚拟用户的运行方式仍然按照Vug->run-time settings中设置的线程还是进程方式运行
2、如果是在场景组中运行，每个场景组启动一个进程，所有ip已线程的方式在组进程中运行，每个ip的虚拟用户的运行方式按照Vug->run-time settings中设置的线程还是进程方式运行
在场景中测试结果：
![](https://images2015.cnblogs.com/blog/430613/201609/430613-20160908165018894-1305601586.png)





