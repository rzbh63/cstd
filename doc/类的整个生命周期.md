# 类的整个生命周期

 

上一节介绍了[Class文件的结构](http://blog.csdn.net/u013595419/article/details/79334516)，但是最终Class文件中描述的信息最终要加载到虚拟机中之后才能使用。

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机使用的Java类型。在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，**Java之所以可以动态扩展主要依赖于运行期动态加载和动态连接这个特点**。

# 类的整个生命周期概要

类从被加载到虚拟机内存开始，到卸出内存为止，它的整个生命周期七个阶段，如下所示：

- 加载(Loading)
- 验证(Verification)
- 准备(Preparation)
- 解析(Resolution)
- 初始化(Initialization)
- 使用(Using)
- 卸载(Unloading)

其中验证，准备，解析3个部分统称为连接(Linking)。

![class-lifecycle](https://img-blog.csdn.net/20180218193049140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzU5NTQxOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

加载、验证、准备、初始化和卸载这5个阶段是确定的，类的加载过程必须按照这种顺序**按部就班的开始**，而解析可能会会在初始化阶段之后开始，但是应该注意到，上面的用词是按部就班的**开始**，而不是按部就班的“进行”或“完成”。

## 初始化规定

虚拟机规范中对初始化的时机有着严格规定，虚拟机规范指明有且只有五种情况必须立即对类进行初始化（而这一过程自然发生在加载、验证、准备之后）：

- 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
- 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

> 注意 
>    对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”。 
>    这五种场景中的行为称为对一个类进行`主动引用`。 
>    除此之外，所有引用类的方式，都不会触发初始化，称为`被动引用`。

# 加载

Java虚拟机规范中并没有对何时加载加以强制性约束，由具体的虚拟机对其实现。

“加载”是“类加载”过程的一个阶段，在加载阶段，虚拟机会完成下面三件事情：

- 通过一个类的全限定名来获取定义此类的二进制字节流（一般会由类加载器实现，参见[类加载器](http://blog.csdn.net/u013595419/article/details/79335721)）；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在内存中（对于HotSpot虚拟就而言就是方法区）生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

## 通过一个类的全限定名来获取定义此类的二进制字节流

因为虚拟机规范中并没有指明这个二进制字节流要从哪里获取，因此便出现了从ZIP包获取（如JAR， WAR），从网络中获取(如Applet)，从动态时计算生成的二进制字节流（如动态代理技术），由其他文件生成（如JSP）等。

对于非数组类的加载阶段，既可以由系统提供的引导类的类加载器来完成，也可以由用户自定义的类加载器来完成。 
 对于数据类而言，只能由Java虚拟机直接创建。但是数据类的元素类型最终时要靠类加载器去创建的。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式存储在方法区中（方法区中的数据存储格式由虚拟机实现自行定义），然后在内存中实例化一个`java.lang.Class`对象（对于HotSpot而言，Class对象比较特殊，虽然是对象，但是会将其放置在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。

# 连接

加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

## 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成4个阶段的检验动作：

- 文件格式验证：验证字节流是否符合Class文件格式的规范（如，是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型）
- 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求(例如：除了java.lang.Object之外，这个类是否有父类)；
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；
- 符号引用验证：确保解析动作能正确执行。

对于虚拟机而言，验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响。如果所引用的类经过反复验证，那么可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

## 准备

准备阶段是正式为类变量（static 成员变量）分配内存并设置类变量初始值（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。

## 解析

解析阶段是虚拟机将常量池内的**符号引用**替换为**直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

> - 符号引用(Symbolic  References)：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。各种虚拟机实现的内存布局可以不同，但是它们接受的符号引用必须一致，因为符号引用的字面值形式明确定义在Java虚拟机规范的Class文件格式中。
> - 直接引用(Direct  References)：直接引用可以是直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）、相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）、一个能间接定位到目标的句柄。直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

# 初始化

类初始化阶段是类加载过程的最后一步，在准备阶段，变量已经赋过一次系统要求的初始值（零值），而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者更直接地说：`初始化阶段是执行类构造器<clinit>()方法的过程`。