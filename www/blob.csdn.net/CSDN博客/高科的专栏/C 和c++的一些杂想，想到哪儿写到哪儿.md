
# C 和c++的一些杂想，想到哪儿写到哪儿 - 高科的专栏 - CSDN博客

2013年08月08日 15:52:55[高科](https://me.csdn.net/pbymw8iwm)阅读数：5950


关于C和c++一直有好多的程序猿在研究，研究区别研究相似的地方，究竟用那个预言好，没有确定的说法，要看你做什么了。
**初始化操作：**
在初始化的时候，我们都知道C语言一般都是这样处理的：
int  a=12;
C++ 呢，除了这样复制初始化之外还可以直接初始化：
int  a(12);
啊？？？那C呢？试了一下不成功，为什么呢？哦，原来C语言没有构造函数，另外c++的这种 int a=12;，其实c++的初始化和赋值是不一样的操作。
这里不过用的是赋值函数和构造函数。、
**分配内存：**

**[http://msdn.microsoft.com/en-US/library/t801az8a(v=VS.80).aspx](http://msdn.microsoft.com/en-US/library/t801az8a(v=VS.80).aspx)**
在C语言中我们可以这样吗？
char *name=(char*)malloc(sizeof(char)*16)  //ERROR
int main(){
return 0;
}
我们认为这样是不对的，但是在c++中，这样竟然可以编译通过并执行。很奇怪吧
char *name=(char*)malloc(sizeof(char)*16)  //OK
int main(){
return 0;
}
**对于宏\#define：**
我相信很多人在学习C语言的时候都应该接触到比较两个数的大小的宏，而且还非常的小心，比如我这样写：
\#define CALL_MAX( a,b)       ((a)>(b)?(a):(b))
int main()
{
int a=2;
int b=2;
int c = CALL_MAX(a,++b);
return 0;
}没错，你可能期望C的值是3，a是2，b是3，可是告诉你不幸的消息，之前的CALL_MAX可能会让你失望的，因为他宏展开其实就相当于：
int c =((a)>(++b)?(a):(++b));这个时候你应该明白了，原来在a和++b比较的时候，就已经发现a小于++b，然后执行后边的++b，这个时候b的值是4了。
那应该如何避免呢？我对宏暂时没有什么想法呢，不过聪明的你或许已经有想法了，你可以留言分享给大家，我的建议是在调用宏的时候最好不要传入++或者--的操作，要么就别用宏了，还是老老实实用函数吧，如果是c++，你可以使用函数模板。

**\#**
\#也是预处理？是的，你可以这么认为。那怎么用它呢? 别急，先看下面例子：
\#define SQR(x) printf("The square of x is %d.\n", ((x)*(x)));
如果这样使用宏：
SQR(8);
则输出为：
The square of x is 64.
注意到没有，引号中的字符x 被当作普通文本来处理，而不是被当作一个可以被替换的语言符号。
假如你确实希望在字符串中包含宏参数，那我们就可以使用“\#”，它可以把语言符号转化为字符串。上面的例子改一改：
\#define SQR(x) printf("The square of "\#x" is %d.\n", ((x)*(x)));
再使用：
SQR(8);
则输出的是：
The square of 8 is 64.
很简单吧？相信你现在已经明白\#号的使用方法了。
**\#\#**
和\#运算符一样，\#\#运算符可以用于宏函数的替换部分。这个运算符把两个语言符号组合成单个语言符号。看例子：
\#define XNAME(n) x \#\# n
如果这样使用宏：
XNAME(8)
则会被展开成这样：
x8

随后有更新。。。

