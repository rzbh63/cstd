
# 数据结构之自建算法库——图及其存储结构（邻接矩阵、邻接表） - 迂者-贺利坚的专栏 - CSDN博客

2015年11月02日 20:18:23[迂者-贺利坚](https://me.csdn.net/sxhelijian)阅读数：7554


本文是[[数据结构基础系列(7)：图](http://edu.csdn.net/course/detail/1595)]中第4课时[[图的邻接矩阵存储结构及算法](http://edu.csdn.net/course/detail/1595/24594?auto_start=1)]和第5课时[[图的邻接表存储结构及算法](http://edu.csdn.net/course/detail/1595/24595?auto_start=1)]，并为后续内容的实践提供支持。
图的存储结构主要包括邻接矩阵和邻接表，本算法库提供存储结构的定义，以及用于构造图存储结构、不同结构的转换及显示的代码。算法库采用程序的多文件组织形式，包括两个文件：
1.头文件：graph.h，包含定义图数据结构的代码、宏定义、要实现算法的函数的声明；
```python
#ifndef GRAPH_H_INCLUDED
```
```python
#define GRAPH_H_INCLUDED
```
```python
#define MAXV 100
```
```python
//最大顶点个数
```
```python
#define INF 32767
```
```python
//INF表示∞
```
```python
typedef
```
```python
int
```
```python
InfoType;
```
```python
//以下定义邻接矩阵类型
```
```python
typedef
```
```python
struct
```
```python
{
```
```python
int
```
```python
no;
```
```python
//顶点编号
```
```python
InfoType info;
```
```python
//顶点其他信息，在此存放带权图权值
```
```python
} VertexType;
```
```python
//顶点类型
```
```python
typedef
```
```python
struct
```
```python
//图的定义
```
```python
{
```
```python
int
```
```python
edges[MAXV][MAXV];
```
```python
//邻接矩阵
```
```python
int
```
```python
n,e;
```
```python
//顶点数，弧数
```
```python
VertexType vexs[MAXV];
```
```python
//存放顶点信息
```
```python
} MGraph;
```
```python
//图的邻接矩阵类型
```
```python
//以下定义邻接表类型
```
```python
typedef
```
```python
struct
```
```python
ANode
```
```python
//弧的结点结构类型
```
```python
{
```
```python
int
```
```python
adjvex;
```
```python
//该弧的终点位置
```
```python
struct
```
```python
ANode *nextarc;
```
```python
//指向下一条弧的指针
```
```python
InfoType info;
```
```python
//该弧的相关信息,这里用于存放权值
```
```python
} ArcNode;
```
```python
typedef
```
```python
int
```
```python
Vertex;
```
```python
typedef
```
```python
struct
```
```python
Vnode
```
```python
//邻接表头结点的类型
```
```python
{
    Vertex data;
```
```python
//顶点信息
```
```python
int
```
```python
count;
```
```python
//存放顶点入度,只在拓扑排序中用
```
```python
ArcNode *firstarc;
```
```python
//指向第一条弧
```
```python
} VNode;
```
```python
typedef
```
```python
VNode AdjList[MAXV];
```
```python
//AdjList是邻接表类型
```
```python
typedef
```
```python
struct
```
```python
{
    AdjList adjlist;
```
```python
//邻接表
```
```python
int
```
```python
n,e;
```
```python
//图中顶点数n和边数e
```
```python
} ALGraph;
```
```python
//图的邻接表类型
```
```python
//功能：由一个反映图中顶点邻接关系的二维数组，构造出用邻接矩阵存储的图
```
```python
//参数：Arr - 数组名，由于形式参数为二维数组时必须给出每行的元素个数，在此将参数Arr声明为一维数组名（指向int的指针）
```
```python
//      n - 矩阵的阶数
```
```python
//      g - 要构造出来的邻接矩阵数据结构
```
```python
void
```
```python
ArrayToMat(
```
```python
int
```
```python
*Arr,
```
```python
int
```
```python
n, MGraph &g);
```
```python
//用普通数组构造图的邻接矩阵
```
```python
void
```
```python
ArrayToList(
```
```python
int
```
```python
*Arr,
```
```python
int
```
```python
n, ALGraph *&);
```
```python
//用普通数组构造图的邻接表
```
```python
void
```
```python
MatToList(MGraph g,ALGraph *&G);
```
```python
//将邻接矩阵g转换成邻接表G
```
```python
void
```
```python
ListToMat(ALGraph *G,MGraph &g);
```
```python
//将邻接表G转换成邻接矩阵g
```
```python
void
```
```python
DispMat(MGraph g);
```
```python
//输出邻接矩阵g
```
```python
void
```
```python
DispAdj(ALGraph *G);
```
```python
//输出邻接表G
```
```python
#endif
```
```python
// GRAPH_H_INCLUDED
```
2.源文件：graph.cpp，包含实现各种算法的函数的定义
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
//功能：由一个反映图中顶点邻接关系的二维数组，构造出用邻接矩阵存储的图
```
```python
//参数：Arr - 数组名，由于形式参数为二维数组时必须给出每行的元素个数，在此将参数Arr声明为一维数组名（指向int的指针）
```
```python
//      n - 矩阵的阶数
```
```python
//      g - 要构造出来的邻接矩阵数据结构
```
```python
void
```
```python
ArrayToMat(
```
```python
int
```
```python
*Arr,
```
```python
int
```
```python
n, MGraph &g)
{
```
```python
int
```
```python
i,j,count=
```
```python
0
```
```python
;
```
```python
//count用于统计边数，即矩阵中非0元素个数
```
```python
g.n=n;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
        {
            g.edges[i][j]=Arr[i*n+j];
```
```python
//将Arr看作n×n的二维数组，Arr[i*n+j]即是Arr[i][j]，计算存储位置的功夫在此应用
```
```python
if
```
```python
(g.edges[i][j]!=
```
```python
0
```
```python
&& g.edges[i][j]!=INF)
                count++;
        }
    g.e=count;
}
```
```python
void
```
```python
ArrayToList(
```
```python
int
```
```python
*Arr,
```
```python
int
```
```python
n, ALGraph *&G)
{
```
```python
int
```
```python
i,j,count=
```
```python
0
```
```python
;
```
```python
//count用于统计边数，即矩阵中非0元素个数
```
```python
ArcNode *p;
    G=(ALGraph *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(ALGraph));
    G->n=n;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
//给邻接表中所有头节点的指针域置初值
```
```python
G->adjlist[i].firstarc=NULL;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<n; i++)
```
```python
//检查邻接矩阵中每个元素
```
```python
for
```
```python
(j=n-
```
```python
1
```
```python
; j>=
```
```python
0
```
```python
; j--)
```
```python
if
```
```python
(Arr[i*n+j]!=
```
```python
0
```
```python
)
```
```python
//存在一条边，将Arr看作n×n的二维数组，Arr[i*n+j]即是Arr[i][j]
```
```python
{
                p=(ArcNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(ArcNode));
```
```python
//创建一个节点*p
```
```python
p->adjvex=j;
                p->info=Arr[i*n+j];
                p->nextarc=G->adjlist[i].firstarc;
```
```python
//采用头插法插入*p
```
```python
G->adjlist[i].firstarc=p;
            }
    G->e=count;
}
```
```python
void
```
```python
MatToList(MGraph g, ALGraph *&G)
```
```python
//将邻接矩阵g转换成邻接表G
```
```python
{
```
```python
int
```
```python
i,j;
    ArcNode *p;
    G=(ALGraph *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(ALGraph));
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//给邻接表中所有头节点的指针域置初值
```
```python
G->adjlist[i].firstarc=NULL;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//检查邻接矩阵中每个元素
```
```python
for
```
```python
(j=g.n-
```
```python
1
```
```python
; j>=
```
```python
0
```
```python
; j--)
```
```python
if
```
```python
(g.edges[i][j]!=
```
```python
0
```
```python
)
```
```python
//存在一条边
```
```python
{
                p=(ArcNode *)
```
```python
malloc
```
```python
(
```
```python
sizeof
```
```python
(ArcNode));
```
```python
//创建一个节点*p
```
```python
p->adjvex=j;
                p->info=g.edges[i][j];
                p->nextarc=G->adjlist[i].firstarc;
```
```python
//采用头插法插入*p
```
```python
G->adjlist[i].firstarc=p;
            }
    G->n=g.n;
    G->e=g.e;
}
```
```python
void
```
```python
ListToMat(ALGraph *G,MGraph &g)
```
```python
//将邻接表G转换成邻接矩阵g
```
```python
{
```
```python
int
```
```python
i,j;
    ArcNode *p;
    g.n=G->n;
```
```python
//根据一楼同学“举报”改的。g.n未赋值，下面的初始化不起作用
```
```python
g.e=G->e;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
```
```python
//先初始化邻接矩阵
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
            g.edges[i][j]=
```
```python
0
```
```python
;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
```
```python
//根据邻接表，为邻接矩阵赋值
```
```python
{
        p=G->adjlist[i].firstarc;
```
```python
while
```
```python
(p!=NULL)
        {
            g.edges[i][p->adjvex]=p->info;
            p=p->nextarc;
        }
    }
}
```
```python
void
```
```python
DispMat(MGraph g)
```
```python
//输出邻接矩阵g
```
```python
{
```
```python
int
```
```python
i,j;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<g.n; i++)
    {
```
```python
for
```
```python
(j=
```
```python
0
```
```python
; j<g.n; j++)
```
```python
if
```
```python
(g.edges[i][j]==INF)
```
```python
printf
```
```python
(
```
```python
"%3s"
```
```python
,
```
```python
"∞"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"%3d"
```
```python
,g.edges[i][j]);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
```python
void
```
```python
DispAdj(ALGraph *G)
```
```python
//输出邻接表G
```
```python
{
```
```python
int
```
```python
i;
    ArcNode *p;
```
```python
for
```
```python
(i=
```
```python
0
```
```python
; i<G->n; i++)
    {
        p=G->adjlist[i].firstarc;
```
```python
printf
```
```python
(
```
```python
"%3d: "
```
```python
,i);
```
```python
while
```
```python
(p!=NULL)
        {
```
```python
printf
```
```python
(
```
```python
"-->%d/%d "
```
```python
,p->adjvex,p->info);
            p=p->nextarc;
        }
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
    }
}
```
3.在同一项目（project）中建立一个源文件(如main.cpp)，编制main函数，完成相关的测试工作。 例：
```python
#include <stdio.h>
```
```python
#include <malloc.h>
```
```python
#include "graph.h"
```
```python
int
```
```python
main()
{
    MGraph g1,g2;
    ALGraph *G1,*G2;
```
```python
int
```
```python
A[
```
```python
6
```
```python
][
```
```python
6
```
```python
]=
    {
        {
```
```python
0
```
```python
,
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
7
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
4
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
8
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
9
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
6
```
```python
},
        {
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
5
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
},
        {
```
```python
3
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
1
```
```python
,
```
```python
0
```
```python
}
    };
    ArrayToMat(A[
```
```python
0
```
```python
],
```
```python
6
```
```python
, g1);
```
```python
//取二维数组的起始地址作实参，用A[0]，因其实质为一维数组地址，与形参匹配
```
```python
printf
```
```python
(
```
```python
" 有向图g1的邻接矩阵:\n"
```
```python
);
    DispMat(g1);
    ArrayToList(A[
```
```python
0
```
```python
],
```
```python
6
```
```python
, G1);
```
```python
printf
```
```python
(
```
```python
" 有向图G1的邻接表:\n"
```
```python
);
    DispAdj(G1);
    MatToList(g1,G2);
```
```python
printf
```
```python
(
```
```python
" 图g1的邻接矩阵转换成邻接表G2:\n"
```
```python
);
    DispAdj(G2);
    ListToMat(G1,g2);
```
```python
printf
```
```python
(
```
```python
" 图G1的邻接表转换成邻接邻阵g2:\n"
```
```python
);
    DispMat(g2);
```
```python
printf
```
```python
(
```
```python
"\n"
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```

