
# 数据科学家需要掌握的十大统计技术详解 - 喜欢打酱油的老鸟 - CSDN博客


2018年09月28日 09:03:41[喜欢打酱油的老鸟](https://me.csdn.net/weixin_42137700)阅读数：157


数据科学家需要掌握的十大统计技术详解
https://mp.weixin.qq.com/s/eRBYjneWBTu6ep4UNGNUuw
作者  James Le
编译   路雪、刘晓坤、蒋思源
本文转自机器之心（almosthuman2014），转载需授权
「数据科学家比程序员擅长统计，比统计学家擅长编程。」本文介绍了数据科学家需要掌握的十大统计技术，包括线性回归、分类、重采样、降维、无监督学习等。
不管你对数据科学持什么态度，都不可能忽略分析、组织和梳理数据的重要性。Glassdoor 网站根据大量雇主和员工的反馈数据制作了「美国最好的 25 个职位」榜单，其中第一名就是数据科学家。尽管排名已经顶尖了，但数据科学家的工作内容一定不会就此止步。随着深度学习等技术越来越普遍、深度学习等热门领域越来越受到研究者和工程师以及雇佣他们的企业的关注，数据科学家继续走在创新和技术进步的前沿。
尽管具备强大的编程能力非常重要，但数据科学不全关于软件工程（实际上，只要熟悉 Python 就足以满足编程的需求）。数据科学家需要同时具备编程、统计学和批判思维能力。正如 Josh Wills 所说：「数据科学家比程序员擅长统计学，比统计学家擅长编程。」我自己认识很多软件工程师希望转型成为数据科学家，但是他们盲目地使用 TensorFlow 或 Apache Spark 等机器学习框架处理数据，而没有全面理解其背后的统计学理论知识。因此他们需要系统地研究统计机器学习，该学科脱胎于统计学和泛函分析，并结合了信息论、最优化理论和线性代数等多门学科。
为什么学习统计学习？理解不同技术背后的理念非常重要，它可以帮助你了解如何使用以及什么时候使用。同时，准确评估一种方法的性能也非常重要，因为它能告诉我们某种方法在特定问题上的表现。此外，统计学习也是一个很有意思的研究领域，在科学、工业和金融领域都有重要的应用。最后，统计学习是训练现代数据科学家的基础组成部分。统计学习方法的经典研究主题包括：
线性回归模型
感知机
k近邻法
朴素贝叶斯法
决策树
Logistic回归于最大熵模型
支持向量机
提升方法
EM算法
隐马尔可夫模型
条件随机场
之后我将介绍 10 项统计技术，帮助数据科学家更加高效地处理大数据集的统计技术。在此之前，我想先厘清统计学习和机器学习的区别：
机器学习是偏向人工智能的分支。
统计学习方法是偏向统计学的分支。
机器学习更侧重大规模应用和预测准确率。
统计学系侧重模型及其可解释性，以及精度和不确定性。
二者之间的区别越来越模糊。
**1.****线性回归**
在统计学中，线性回归通过拟合因变量和自变量之间的最佳线性关系来预测目标变量。最佳拟合通过尽量缩小预测的线性表达式和实际观察结果间的距离总和来实现。没有其他位置比该形状生成的错误更少，从这个角度来看，该形状的拟合是「最佳」。线性回归的两个主要类型是简单线性回归和多元线性回归。
简单线性回归使用一个自变量通过拟合最佳线性关系来预测因变量的变化情况。多元线性回归使用多个自变量通过拟合最佳线性关系来预测因变量的变化趋势。
![](https://img-blog.csdn.net/2018092809011115?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
任意选择两个日常使用且相关的物体。比如，我有过去三年月支出、月收入和每月旅行次数的数据。现在我需要回答以下问题：
我下一年月支出是多少？
哪个因素（月收入或每月旅行次数）在决定月支出方面更重要？
月收入和每月旅行次数与月支出之间是什么关系？
**2.****分类**
分类是一种数据挖掘技术，为数据分配类别以帮助进行更准确的预测和分析。分类是一种高效分析大型数据集的方法，两种主要的分类技术是：logistic 回归和判别分析（Discriminant Analysis）。
logistic回归是适合在因变量为二元类别的回归分析。和所有回归分析一样，logistic 回归是一种预测性分析。logistic 回归用于描述数据，并解释二元因变量和一或多个描述事物特征的自变量之间的关系。logistic 回归可以检测的问题类型如下：
体重每超出标准体重一磅或每天每抽一包烟对得肺癌概率（是或否）的影响。
卡路里摄入、脂肪摄入和年龄对心脏病是否有影响（是或否）？
![](https://img-blog.csdn.net/20180928090123831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
在判别分析中，两个或多个集合和簇等可作为先验类别，然后根据度量的特征把一个或多个新的观察结果分类成已知的类别。判别分析对每个对应类中的预测器分布 X 分别进行建模，然后使用贝叶斯定理将其转换成根据 X 的值评估对应类别的概率。此类模型可以是线性判别分析（Linear Discriminant Analysis），也可以是二次判别分析（Quadratic Discriminant Analysis）。
线性判别分析（LDA）：为每个观察结果计算「判别值」来对它所处的响应变量类进行分类。这些分值可以通过找到自变量的线性连接来获得。它假设每个类别的观察结果都从多变量高斯分布中获取，预测器变量的协方差在响应变量 Y 的所有 k 级别中都很普遍。
二次判别分析（QDA）：提供另外一种方法。和 LDA 类似，QDA 假设 Y 每个类别的观察结果都从高斯分布中获取。但是，与 LDA 不同的是，QDA 假设每个类别具备自己的协方差矩阵。也就是说，预测器变量在 Y 的所有 k 级别中不是普遍的。
**3.****重采样方法**
重采样方法（Resampling）包括从原始数据样本中提取重复样本。这是一种统计推断的非参数方法。即，重采样不使用通用分布来逼近地计算概率 p 的值。
重采样基于实际数据生成一个独特的采样分布。它使用经验性方法，而不是分析方法，来生成该采样分布。重采样基于数据所有可能结果的无偏样本获取无偏估计。为了理解重采样的概念，你应该先了解自助法（Bootstrapping）和交叉验证（Cross-Validation）：
![](https://img-blog.csdn.net/20180928090134454?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
自助法（Bootstrapping）适用于多种情况，如验证预测性模型的性能、集成方法、偏差估计和模型方差。它通过在原始数据中执行有放回取样而进行数据采样，使用「未被选中」的数据点作为测试样例。我们可以多次执行该操作，然后计算平均值作为模型性能的估计。
交叉验证用于验证模型性能，通过将训练数据分成 k 部分来执行。我们将 k-1 部分作为训练集，「留出」的部分作为测试集。将该步骤重复 k 次，最后取 k 次分值的平均值作为性能估计。
通常对于线性模型而言，普通最小二乘法是拟合数据时主要的标准。下面 3 个方法可以提供更好的预测准确率和模型可解释性。

**4.****子集选择**
该方法将挑选 p 个预测因子的一个子集，并且我们相信该子集和所需要解决的问题十分相关，然后我们就能使用该子集特征和最小二乘法拟合模型。
![](https://img-blog.csdn.net/20180928090153540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
最佳子集的选择：我们可以为 p 个预测因子的每个组合拟合单独的 OLS 回归，然后再考察各模型拟合的情况。该算法分为两个阶段：（1）拟合包含 k 个预测因子的所有模型，其中 k 为模型的最大长度；（2）使用交叉验证预测损失选择单个模型。使用验证或测试误差十分重要，且不能简单地使用训练误差评估模型的拟合情况，这因为 RSS 和 R^2 随变量的增加而单调递增。最好的方法就是通过测试集中最高的 R^2 和最低的 RSS 来交叉验证地选择模型。
前向逐步地选择会考虑 p 个预测因子的一个较小子集。它从不含预测因子的模型开始，逐步地添加预测因子到模型中，直到所有预测因子都包含在模型。添加预测因子的顺序是根据不同变量对模型拟合性能提升的程度来确定的，我们会添加变量直到再没有预测因子能在交叉验证误差中提升模型。
后向逐步选择先从模型中所有 p 预测器开始，然后迭代地移除用处最小的预测器，每次移除一个。
混合法遵循前向逐步方法，但是在添加每个新变量之后，该方法可能还会移除对模型拟合无用的变量。
**5. Shrinkage**
这种方法涉及到使用所有 p 个预测因子进行建模，然而，估计预测因子重要性的系数将根据最小二乘误差向零收缩。这种收缩也称之为正则化，它旨在减少方差以防止模型的过拟合。由于我们使用不同的收缩方法，有一些变量的估计将归零。因此这种方法也能执行变量的选择，将变量收缩为零最常见的技术就是 Ridge 回归和 Lasso 回归。
![](https://img-blog.csdn.net/20180928090206345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
Ridge回归非常类似于最小二乘法，只不过它通过最小化一个稍微不同的数值来估计系数。Ridge 回归和 OLS 一样寻求减少 RSS 的系数估计。然而当系数收缩逼近零值时，它们都会对这种收缩进行惩罚。我们不需要数学分析就能看出 Ridge 回归很擅长于将特征收缩到最小的可能空间中。如主成分分析，Ridge 回归将数据投影到 D 维空间，并在系数空间内收缩较低方差的成分而保留有较高方差的成分。
Ridge回归至少有一个缺点，它需要包含最终模型所有 p 个预测因子，这主要是因为罚项将会令很多预测因子的系数逼近零，但又一定不会等于零。这对于预测准确度来说通常并不是什么问题，但却令模型的结果更难以解释。Lasso 就克服了这一缺点，因为它在 s 组后小的时候能迫使一些预测因子的系数归零。因为 s = 1 将导致正规的 OLS 回归，而当 s 逼近 0 时，系数将收缩到零。因此 Lasso 回归同样是执行变量选择的一个好方法。
**6.****降维**
降维算法将 p+1 个系数的问题简化为 M+1 个系数的问题，其中 M<p。算法执行包括计算变量的 M 个不同线性组合或投射（projection）。然后这 M 个投射作为预测器通过最小二乘法拟合一个线性回归模型。两个主要的方法是主成分回归（principal component regression）和偏最小二乘法（partial least squares）。
![](https://img-blog.csdn.net/20180928090218820?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
主成分回归（PCR）可以看成一种从大型变量集合中导出低维特征集合的方法。数据中的第一主成分（first principal component）是指观察数据沿着这个变量方向的变化最大。换言之，第一主成分是最接近拟合数据的线，总共可以用 p 个不同的主成分拟合。第二主成分是和第一主成分不相关的变量的线性组合，且在该约束下有最大的方差。其主要思想是主成分能在各个互相垂直的方向使用数据的线性组合捕捉到最大的方差。使用这种方法，我们还能结合相关变量的效应从数据中获取更多的信息，毕竟在常规的最小二乘法中需要舍弃其中一个相关变量。
上面描述的 PCR 方法需要提取 X 的线性组合，以获得对的预测器的最优表征。由于 X 的输出 Y 不能不能用于帮助决定主成分方向，这些组合（方向）使用无监督方法提取。即，Y 不能监督主成分的提取，从而无法保证这些方向是预测器的最优表征，也无法保证能获得最优预测输出（虽然通常假定如此）。偏最小二乘法（PLS）是一种监督方法，作为 PCR 的代替方法。和 PCR 类似，PLS 也是一种降维方法，它首先提取一个新的较小的特征集合（原始特征的线性组合），然后通过最小二乘法将原来的模型拟合为一个新的具有 M 个特征的线性模型。

**7.****非线性模型**
在统计学中，非线性回归属于一种回归分析形式，其中，观测数据使用模型参数的非线性组合的函数（依赖于一个或多个独立变量）建模。其使用逐次逼近法拟合数据。下方是几种处理非线性模型的重要技术。
阶梯函数（step function），变量为实数，可以写成区间的指示函数的有限线性组合的形式。非正式的解释是，阶梯函数是一种分段常数函数，只有有限的部分。
分段函数（piecewise function）通过多个子函数定义，每一个子函数被定义在主函数定义域的确定的区间上。分段实际上是一种表示函数的方式，而不是函数自身的特征，但通过额外的限定条件，它可以用于描述函数的本质。例如，一个分段多项式函数是一个在每一个子定义上为多项式的函数，其中每一个多项式都可能是不同的。
![](https://img-blog.csdn.net/20180928090231906?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
样条曲线（spline）是一种用多项式分段定义的特殊函数。在计算机图形学中，样条曲线是一种分段多项式参数化曲线。由于结构的简单性、评估的简易和高精度、通过曲线拟合和交互曲线设计以逼近复杂曲线的能力，样条曲线很常用。
广义加性模型（generalized additive model）是一种广义线性模型，其中线性预测器线性依赖于某些预测器变量的未知平滑函数，其主要作用就是推测这些平滑函数。
**8.****基于树的方法**
基于树的方法可以用于回归和分类问题，包括将预测器空间分层或分割成几个简单区域。由于用于预测器空间的分离规则集合可以总结为一个树，这类方法被称为决策树方法。以下的方法是几种不同的树，它们可以组合起来输出单个一致的预测。
bagging能减少预测的方差，即通过从原始数据中生成额外的数据（通过组合和重复生成和原始数据大小相同的多段数据）用于训练。通过增大训练集无法提高模型的预测能力，只能减小方差，仔细地调整预测以得到期望的输出。
boosting是一种计算输出的方法，即使用多个不同的模型，然后使用加权平均的方法对结果取平均值。我们一般通过改变这些方法所占的权重而结合各方法的优势，此外，我们还可以使用不同的精细调整获得对更宽泛输入数据的预测能力。
![](https://img-blog.csdn.net/20180928090243221?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
随机森林算法（random forest algorithm）实际上和 bagging 算法很相似，同样是对训练集提取随机 bootstrap 样本。然而，除了 bootstrap 样本以外，还可以提取特征的随机子集以训练单个树；而在 bagging 中，需要给每个树提供整个特征集。由于特征选择是随机的，相比常规的 bagging 算法，每个树之间更加独立，从而通常能获得更好的预测性能（得益于更好的方差—偏差权衡）。且计算速度也更快，因为每个树只需要学习特征的一个子集。
**9.****支持向量机**
![](https://img-blog.csdn.net/20180928090254447?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
支持向量机（SVM）是一种常用的监督学习分类技术。通俗地说，它用于寻找对两类点集做出最佳分离的超平面（hyperplane，在 2D 空间中是线，在 3D 空间中是面，在高维空间中是超平面。更正式的说法是，一个超平面是一个 n 维空间的 n-1 维子空间）。而支持向量机是保留最大的间隔的分离超平面，因此本质上，它是一个约束最优化问题，其中支持向量机的间隔在约束下被最大化，从而完美地对数据进行分类（硬间隔分类器）。
那些「支持」着超平面的数据点被称为「支持向量」。在上图中，填充蓝色圆和两个填充方块就是支持向量。在两类数据不是线性可分的例子中，数据点将被投射到一个更高维空间中，使得数据变得线性可分。包含多个类别的数据点的问题可以分解成多个「一对一」（one-versus-one）或「一对剩余」（one-versus-rest）的二分类问题。

**10.****无监督学习**
目前为止，我们都只讨论过监督学习技术，其中数据分类都是已知的，且提供给算法的经验都是实体和其分类的关系。当数据的分类是未知的时候，就需要使用另一种技术了。它们被称为无监督的，因为它们需要自己去发现数据中的模式。聚类（clustring）是无监督学习的一种，其中数据将根据相关性被分为多个群集。下方是几种最常用的无监督学习算法：
![](https://img-blog.csdn.net/20180928090309355?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNzcwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
主成分分析：通过保留具备最大方差和互相不相关的特征之间的线性连接，而帮助生成数据集的低维表示。该线性降维技术有助于理解无监督学习中的隐变量交互。
k均值聚类：根据数据到集群中心的距离将其分成 k 个不同的集群。
层次聚类：通过数据的层级表示而构建不同的集群。


