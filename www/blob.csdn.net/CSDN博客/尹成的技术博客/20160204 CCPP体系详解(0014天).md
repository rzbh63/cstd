
# 20160204.CCPP体系详解(0014天) - 尹成的技术博客 - CSDN博客

置顶2016年02月16日 21:50:46[尹成](https://me.csdn.net/yincheng01)阅读数：1279个人分类：[CCPP](https://blog.csdn.net/yincheng01/article/category/6096925)


程序片段(01):define.h+data.h&data.c+control.h&control.c+view.h&view.c+AI.h&AI.c+main.c
内容概要:**迷宫游戏**
```python
///define.h
```
```python
//通用工具
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#define N 10
```
```python
///data.h
//迷宫布局
```
```python
#include "define.h"//对外声明全局变量
```
```python
extern int realPath[
```
```python
N
```
```python
][
```
```python
N
```
```python
];//软件工程规范建议使用extern关键字(可有/可无)
extern int AIPath[
```
```python
N
```
```python
][
```
```python
N
```
```python
];
extern int startPointX;
extern int startPointY;
extern int endPointX;
extern int endPointY;
extern int successPath;
///data.c
//存储数据
```
```python
#include "define.h"
```
```python
int realPath[
```
```python
N
```
```python
][
```
```python
N
```
```python
] = {//真实路径
```
```python
{ 1, 0, 2, 0, 0, 0, 0, 0, 0, 0 },
```
```python
{ 0, 0, 0, 2, 0, 0, 2, 0, 0, 0 },
```
```python
{ 0, 0, 0, 2, 0, 0, 2, 0, 0, 0 },
```
```python
{ 0, 0, 0, 0, 2, 0, 0, 2, 2, 0 },
```
```python
{ 0, 0, 0, 0, 2, 0, 2, 0, 0, 0 },
```
```python
{ 0, 0, 0, 0, 2, 0, 0, 0, 0, 2 },
```
```python
{ 2, 2, 2, 0, 0, 2, 0, 2, 0, 0 },
```
```python
{ 0, 0, 0, 0, 0, 2, 0, 2, 0, 2 },
```
```python
{ 0, 0, 0, 0, 0, 0, 0, 2, 0, 0 },
```
```python
{ 0, 0, 0, 0, 0, 0, 0, 0, 2, 0 }
```
```python
};
int AIPath[
```
```python
N
```
```python
][
```
```python
N
```
```python
] = {//智能路径
```
```python
{ 1, 0, 2, 0, 0, 0, 0, 0, 0, 0 },
```
```python
{ 0, 0, 0, 2, 0, 0, 2, 0, 0, 0 },
```
```python
{ 0, 0, 0, 2, 0, 0, 2, 0, 0, 0 },
```
```python
{ 0, 0, 0, 0, 2, 0, 0, 2, 2, 0 },
```
```python
{ 0, 0, 0, 0, 2, 0, 2, 0, 0, 0 },
```
```python
{ 0, 0, 0, 0, 2, 0, 0, 0, 0, 2 },
```
```python
{ 2, 2, 2, 0, 0, 2, 0, 2, 0, 0 },
```
```python
{ 0, 0, 0, 0, 0, 2, 0, 2, 0, 2 },
```
```python
{ 0, 0, 0, 0, 0, 0, 0, 2, 0, 0 },
```
```python
{ 0, 0, 0, 0, 0, 0, 0, 0, 2, 0 }
```
```python
};
int startPointX = 0;//起始点
int startPointY = 0;
int endPointX = 9;//终止点
int endPointY = 9;
int successPath = 0;//标识通路
```
```python
///
```
```python
control.h
```
```python
//迷宫控制
```
```python
#include "data.h"
```
```python
void
```
```python
operateMaze(
```
```python
char
```
```python
operate);
```
```python
///
```
```python
control.c
```
```python
//数据处理
```
```python
#include "control.h"
```
```python
#include "view.h"
```
```python
void
```
```python
operateMaze(
```
```python
char
```
```python
operate)
```
```python
//操作迷宫
```
```python
{
```
```python
switch
```
```python
(operate)
    {
```
```python
//移动起始点
```
```python
case
```
```python
'w'
```
```python
:
```
```python
if
```
```python
(-
```
```python
1
```
```python
< startPointX -
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= realPath[startPointX -
```
```python
1
```
```python
][startPointY])
        {
```
```python
//操作真实路径
```
```python
realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX -
```
```python
1
```
```python
][startPointY];
            realPath[startPointX -
```
```python
1
```
```python
][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX -
```
```python
1
```
```python
][startPointY];
            realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX -
```
```python
1
```
```python
][startPointY];
            --startPointX;
        }
```
```python
break
```
```python
;
```
```python
case
```
```python
's'
```
```python
:
```
```python
if
```
```python
(
```
```python
10
```
```python
> startPointX +
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= realPath[startPointX +
```
```python
1
```
```python
][startPointY])
        {
            realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX +
```
```python
1
```
```python
][startPointY];
            realPath[startPointX +
```
```python
1
```
```python
][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX +
```
```python
1
```
```python
][startPointY];
            realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX +
```
```python
1
```
```python
][startPointY];
            ++startPointX;
        }
```
```python
break
```
```python
;
```
```python
case
```
```python
'a'
```
```python
:
```
```python
if
```
```python
(-
```
```python
1
```
```python
< startPointY -
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= realPath[startPointX][startPointY -
```
```python
1
```
```python
])
        {
            realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX][startPointY -
```
```python
1
```
```python
];
            realPath[startPointX][startPointY -
```
```python
1
```
```python
] = realPath[startPointX][startPointY] ^ realPath[startPointX][startPointY -
```
```python
1
```
```python
];
            realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX][startPointY -
```
```python
1
```
```python
];
            --startPointY;
        }
```
```python
break
```
```python
;
```
```python
case
```
```python
'd'
```
```python
:
```
```python
if
```
```python
(
```
```python
10
```
```python
> startPointY +
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= realPath[startPointX][startPointY +
```
```python
1
```
```python
])
        {
            realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX][startPointY +
```
```python
1
```
```python
];
            realPath[startPointX][startPointY +
```
```python
1
```
```python
] = realPath[startPointX][startPointY] ^ realPath[startPointX][startPointY +
```
```python
1
```
```python
];
            realPath[startPointX][startPointY] = realPath[startPointX][startPointY] ^ realPath[startPointX][startPointY +
```
```python
1
```
```python
];
            ++startPointY;
        }
```
```python
break
```
```python
;
```
```python
default
```
```python
:
```
```python
break
```
```python
;
    }
    showMaze(realPath);
}
```
```python
///view.h
//迷宫展示
```
```python
#include "data.h"
```
```python
void showMaze(int maze[
```
```python
N
```
```python
][
```
```python
N
```
```python
]);//显示迷宫
///view.c
//数据显示
```
```python
#include "view.h"
```
```python
void showMaze(int maze[
```
```python
N
```
```python
][
```
```python
N
```
```python
])
{
```
```python
printf("------------------------------------ \n");
```
```python
for (int i = 0; i < N; ++i)
```
```python
{
```
```python
for (int j = 0; j < N; ++j)
```
```python
{
```
```python
printf("%2d", maze[i][j]);
```
```python
}
```
```python
printf("\n");
```
```python
}
```
```python
printf("\n");
```
```python
}
```
```python
///
```
```python
AI.h
```
```python
//迷宫智能
```
```python
#include "control.h"
```
```python
int
```
```python
AIFindWay(
```
```python
int
```
```python
AIPath[N][N],
```
```python
int
```
```python
startPointX,
```
```python
int
```
```python
startPointY);
```
```python
//智能寻路
```
```python
void
```
```python
AIMazeMove();
```
```python
//智能迷宫移动
```
```python
///
```
```python
AI.c
```
```python
//人工智能
```
```python
#include "AI.h"
```
```python
int
```
```python
AIFindWay(
```
```python
int
```
```python
AIPath[N][N],
```
```python
int
```
```python
startPointX,
```
```python
int
```
```python
startPointY)
{
```
```python
if
```
```python
(endPointX == startPointX && endPointY == startPointY)
```
```python
//测试假定起始点是否已经到达终点位置
```
```python
//printf("能够形成迷宫通路! \n");
```
```python
return
```
```python
successPath =
```
```python
1
```
```python
;
```
```python
//标识成功找到一条通路,但不并不一定就是一条最短路径(相当于深度遍历优先原理)
```
```python
int
```
```python
movePointX = startPointX;
```
```python
//假定起始点作为移动点,能够走出一条迷宫通路-->由于这里使用的是全局变量,所以,不采取局部变量,但是这样便于理解
```
```python
int
```
```python
movePointY = startPointY;
    AIPath[movePointX][movePointY] =
```
```python
3
```
```python
;
```
```python
//试探:标识活路->已寻访路线标识,,防止回头路
```
```python
//假定终点在右下角的最佳遍历方式:右->下->左->上
```
```python
if
```
```python
(
```
```python
0
```
```python
== successPath &&
```
```python
10
```
```python
> movePointY +
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= AIPath[movePointX][movePointY +
```
```python
1
```
```python
]) AIFindWay(AIPath, movePointX, movePointY +
```
```python
1
```
```python
);
```
```python
if
```
```python
(
```
```python
0
```
```python
== successPath &&
```
```python
10
```
```python
> movePointX +
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= AIPath[movePointX +
```
```python
1
```
```python
][movePointY]) AIFindWay(AIPath, movePointX +
```
```python
1
```
```python
, movePointY);
```
```python
if
```
```python
(
```
```python
0
```
```python
== successPath && -
```
```python
1
```
```python
< movePointY -
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= AIPath[movePointX][movePointY -
```
```python
1
```
```python
]) AIFindWay(AIPath, movePointX, movePointY -
```
```python
1
```
```python
);
```
```python
if
```
```python
(
```
```python
0
```
```python
== successPath && -
```
```python
1
```
```python
< movePointX -
```
```python
1
```
```python
&&
```
```python
2
```
```python
!= AIPath[movePointX -
```
```python
1
```
```python
][movePointY]) AIFindWay(AIPath, movePointX -
```
```python
1
```
```python
, movePointY);
```
```python
if
```
```python
(
```
```python
0
```
```python
== successPath)
```
```python
//回溯:标识死路
```
```python
AIPath[movePointX][movePointY] =
```
```python
0
```
```python
;
```
```python
return
```
```python
0
```
```python
;
```
```python
//用于判断迷宫是否含有出口
```
```python
}
```
```python
void
```
```python
AIMazeMove()
{
    AIPath[
```
```python
0
```
```python
][
```
```python
0
```
```python
] =
```
```python
1
```
```python
;
```
```python
//标识:迷宫起始点
```
```python
while
```
```python
(endPointX != startPointX && endPointY != startPointY)
    {
```
```python
if
```
```python
(
```
```python
10
```
```python
> startPointY +
```
```python
1
```
```python
&&
```
```python
3
```
```python
== AIPath[startPointX][startPointY +
```
```python
1
```
```python
])
        {
            AIPath[startPointX][startPointY +
```
```python
1
```
```python
] =
```
```python
0
```
```python
;
```
```python
//防止寻路迷宫的回走现象
```
```python
operateMaze(
```
```python
'd'
```
```python
);
        }
```
```python
else
```
```python
if
```
```python
(
```
```python
10
```
```python
> startPointX +
```
```python
1
```
```python
&&
```
```python
3
```
```python
== AIPath[startPointX +
```
```python
1
```
```python
][startPointY])
        {
            AIPath[startPointX +
```
```python
1
```
```python
][startPointY] =
```
```python
0
```
```python
;
            operateMaze(
```
```python
's'
```
```python
);
        }
```
```python
else
```
```python
if
```
```python
(-
```
```python
1
```
```python
< startPointY -
```
```python
1
```
```python
&&
```
```python
3
```
```python
== AIPath[startPointX][startPointY -
```
```python
1
```
```python
])
        {
            AIPath[startPointX][startPointY -
```
```python
1
```
```python
] =
```
```python
0
```
```python
;
            operateMaze(
```
```python
'a'
```
```python
);
        }
```
```python
else
```
```python
if
```
```python
(-
```
```python
1
```
```python
< startPointX -
```
```python
1
```
```python
&&
```
```python
3
```
```python
== AIPath[startPointX -
```
```python
1
```
```python
][startPointY])
        {
            AIPath[startPointX -
```
```python
1
```
```python
][startPointY] =
```
```python
0
```
```python
;
            operateMaze(
```
```python
'w'
```
```python
);
        }
    }
}
```
```python
///main.c
```
```python
//接口调用
```
```python
#include "view.h"
```
```python
#include "AI.h"
```
```python
int
```
```python
main(
```
```python
void
```
```python
)
{
```
```python
//showMaze(realPath);//显示初始情况
```
```python
//while (1)
```
```python
//{
```
```python
//  char ch = getchar();
```
```python
//  getchar();
```
```python
//  operateMaze(ch);
```
```python
//  showMaze(realPath);
```
```python
//}
```
```python
int
```
```python
successPath = AIFindWay(AIPath,
```
```python
0
```
```python
,
```
```python
0
```
```python
);
```
```python
if
```
```python
(
```
```python
0
```
```python
== successPath)
```
```python
printf
```
```python
(
```
```python
"不可以走出! \n"
```
```python
);
```
```python
else
```
```python
{
```
```python
printf
```
```python
(
```
```python
"可以走出! \n"
```
```python
);
        showMaze(AIPath);
        AIMazeMove();
    }
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(02):main.c
内容概要:**GccArray**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
int
```
```python
main()
{
```
```python
printf
```
```python
(
```
```python
"Hello world!\n"
```
```python
);
```
```python
int
```
```python
num=
```
```python
10
```
```python
;
```
```python
scanf
```
```python
(
```
```python
"%d"
```
```python
,&num);
```
```python
int
```
```python
a[num];
```
```python
//GCC可以动态分配数组
```
```python
//动态分配，运行的时候
```
```python
return
```
```python
0
```
```python
;
}
```
程序片段(03):指针.c+go.c
内容概要:**指针预热**
```python
///指针.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.指针变量内容简介:
```
```python
//  1.指针变量概念:
```
```python
//      (1).特殊的变量:存储的是具备地址含义的数据,而非普通的数据
```
```python
//      (2).指针变量和普通变量同样位于内存当中,属于同样的栈内存存储(一般情况)
```
```python
//  2.指针所涉及的运算符:
```
```python
//      取地址运算符&:
```
```python
//          根据内存实体获取该数据实体所在的内存地址
```
```python
//      指针运算符:
```
```python
//          声明时期:
```
```python
//              标识指针变量,标识所声明的变量不是普通变量,而是具备存储地址意义的变量
```
```python
//          使用时期:
```
```python
//              根据内存实体的地址获取该数据实体本身,以用于直接操作该数据实体
```
```python
//  注意事项：
```
```python
//      1.数据区与代码区的概念不同
```
```python
//      2.查看多个变量需要多个内存图解
```
```python
//      3.通常所说的指针指的是指针变量
```
```python
//      4.严格意义上指针变量,指针,地址的意义不同:
```
```python
//          指针变量:是一个具有存储地址含义的变量
```
```python
//          指针:具备类型意义的地址
```
```python
//          地址:仅仅只有一个数值的含义
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, &num);
```
```python
//取地址运算符&-->获取地址
```
```python
*(&num) =
```
```python
3
```
```python
;
```
```python
//指针运算符*-->声明指针+根据地址获取内容
```
```python
//&num = 0x123;//取地址运算符&num所执行的操作位于寄存器,C语言无法直接给寄存器进行赋值操作
```
```python
printf
```
```python
(
```
```python
"%d \n"
```
```python
, num);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//02.指针变量:
```
```python
//  1.区分直接赋值与间接赋值:
```
```python
//      直接赋值:直接操作变量本身,也就是内存实体(数据实体)本身
```
```python
//      间接赋值:通过指针变量(存储普通变量所属地址的变量)间接操作内存实体(数据实体)本身
```
```python
//  2.使用指针变量的意义:
```
```python
//      间接的操作内存实体(数据实体)本身
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
num =
```
```python
10
```
```python
;
```
```python
//num = 4;//直接赋值
```
```python
int
```
```python
* numP = &num;
```
```python
//pNum是一个指针变量(地址变量)
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, numP);
```
```python
//打印指针变量所存储的具备地址含义的数值,也就是普通变量的地址-->一级指针含义
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, &numP);
```
```python
//打印指针变量的地址-->二级指针含义
```
```python
*numP =
```
```python
13
```
```python
;
```
```python
//间接赋值:给以指针变量numP的数据为地址的变量间接赋值
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
//03.关于跨进程内存访问:
```
```python
//  普通方式:
```
```python
//      一个进程不可以直接访问另外一个进程的所属内存空间
```
```python
//  特殊方式:
```
```python
//      1.通过模块儿注入的方式可以实现模块儿访问进程内存
```
```python
//      2.权限提升的方式也可以事项跨进程内存访问
```
```python
int
```
```python
main03(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
*p =
```
```python
0xAE0720
```
```python
;
    *p =
```
```python
32
```
```python
;
```
```python
//一个进程不可以随便读写另外一个进程的所属内存
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
///
```
```python
go.c
```
```python
#include <Windows.h>
```
```python
//01.通过模块儿注入方式:
```
```python
//  1.实现类似于跨进程的内存访问
```
```python
//  2.自动化的模块儿注入技术
```
```python
//  注:一定要防止进程内部死循环,以免进程卡顿现象严重(CPU占用厉害),
```
```python
//      因此需要进行休眠状态切换(调度CPU执行权)
```
```python
_declspec(dllexport) go()
{
```
```python
int
```
```python
* p = (
```
```python
int
```
```python
*)
```
```python
0x20671290
```
```python
;
```
```python
//通过模块儿实现模块儿修改进程所属内存的某个内存空间
```
```python
*p =
```
```python
80
```
```python
;
```
```python
//访问以指针变量p的值为地址的内存实体(数据实体)
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
```
```python
if
```
```python
(*p <
```
```python
9000
```
```python
)
            *p =
```
```python
9000
```
```python
;
        Sleep(
```
```python
100
```
```python
);
```
```python
//防止进程卡死
```
```python
}
}
```
程序片段(04):Test.c+劫持.c+p.c
内容概要:**函数指针**
```python
///Test.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
void
```
```python
go()
{
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
,
```
```python
"老穆就要回山东! \n"
```
```python
);
}
```
```python
void
```
```python
show()
{
    MessageBoxW(
```
```python
0
```
```python
, L
```
```python
"欢送老穆!"
```
```python
, L
```
```python
"回山东!"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
//01.普通指针和函数指针:
```
```python
//  普通指针:只能操作数据区
```
```python
//  函数指针:可以操作代码区,再通过操作代码区的方式实现间接操作数据区
```
```python
//  注:函数指针的类型就是除开变量名称的那部分,只有同类型的函数指针才能进行修改赋值
```
```python
//02.函数声明和函数实体:
```
```python
//  函数声明:函数指针
```
```python
//  函数实体:函数执行体代码区
```
```python
//  注:严格区分数据区和代码区
```
```python
//      函数指针变量和函数实体变量的区别!
```
```python
//          1.函数指针变量当中存储的是函数实体变量的地址
```
```python
//          2.通过不断的修改函数指针变量所存储的函数实体变量的地址
```
```python
//              可以让同一个函数指针执行不同的函数函数实体
```
```python
//03.对于函数指针而言的特殊性:
```
```python
//  1.函数名的本质:就是函数指针-->然后就可以通过函数指针与函数实体的关系,间接的通过函数指针找到函数实体
```
```python
//      函数指针和函数实体之间的关联切忌注意(只要知道了函数指针,就相当于知道了函数实体,只不过中间的查找过程
```
```python
//      并没有像指针变量和普通变量之间的数值关系直接体现,而是隐含着进行体现的)-->函数声明地址-->函数定义地址
```
```python
//  2.对函数名使用取地址符和直接获取函数名所对应的数值是一样的效果
```
```python
//  注:
```
```python
//      指针变量-->普通变量的地址:直接联系-->普通变量
```
```python
//      函数指针-->函数声明的地址:中间忽略-->函数实体(后面实现的是自动链接特点)
```
```python
//          相当于通过函数指针可以直接找到函数声明的位置,
```
```python
//          但是,通过函数声明的位置如何找到函数实体的位置,
```
```python
//          我们不需要关系,系统会自动链接到函数实体
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//go();
```
```python
printf
```
```python
(
```
```python
"%p \n"
```
```python
, go);
```
```python
//printf("%p \n", &go);
```
```python
//void(*funP)() = go;
```
```python
//funP();//可以存储不同函数的地址,执行不同的代码块儿
```
```python
//funP = show;
```
```python
//funP();
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(05):run.c+劫持.c
内容概要:**代码区劫持**
```python
///run.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
void
```
```python
add() {}
```
```python
void
```
```python
go() {}
```
```python
//01.函数指针常量不允许修改的原因:
```
```python
//  1.常量:本身就不应当被修改(类似于字符串的常量,字符串常量池当中的内容不允许直接被修改,因此代码区当中的内容也不允许被修改)
```
```python
//      类似于字符串(因为同样属于代码区的内容,都具备相同的不可修改特点)
```
```python
//  2.代码区:代码区的内容不允许被修改(权限不够),但是通过微软亚洲研究院的劫持工具Detours可以实现
```
```python
//  注:劫持工具Detours详解
```
```python
//      1.能够通过Detours工具找到任何运行程序的代码区
```
```python
//      2.能够突破代码区的不可修改权限
```
```python
//      使用特点:
```
```python
//          1.可以进行跨平台编译(Windows,Linux,Android,iOS)跨平台劫持
```
```python
//          2.不会修改原始程序的内容,只会修改程序加载进内存当中的代码区内容
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
//add = go;//代码区,不允许
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
```python
///劫持.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include<Windows.h>
```
```python
void
```
```python
go()
{
```
```python
printf
```
```python
(
```
```python
"%s \n"
```
```python
,
```
```python
"老穆就要回山东!"
```
```python
);
}
```
```python
void
```
```python
show()
{
    MessageBoxW(
```
```python
0
```
```python
, L
```
```python
"欢送老穆!"
```
```python
, L
```
```python
"回山东!"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
//01.函数指针与函数指针变量的区别:
```
```python
//  直接书写函数名称:
```
```python
//      叫做函数指针:是一个函数指针常量,因此直接获取函数名的值和获取函数名的地址是一样的(同样是函数指针常量值)
```
```python
//  定义函数指针变量:
```
```python
//      叫做函数指针变量:是一个函数指针变量,直接的函数指针变量的值和对函数指着变量取地址所获得的值不相同
```
```python
//  注:函数指针常量和函数指针变量:
```
```python
//      函数指针常量没有取地址与非取地址的区别
```
```python
//      函数指针变量具有取地址与非取地址的区别
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
void
```
```python
(*funP)() = go;
```
```python
printf
```
```python
(
```
```python
"go = %p, show = %p, funP = %p, &funp = %p \n"
```
```python
, go, show, funP, &funP);
```
```python
while
```
```python
(
```
```python
1
```
```python
)
    {
        funP();
        Sleep(
```
```python
1000
```
```python
);
```
```python
//防止进程卡死
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///
```
```python
p.c
```
```python
//特别注意:
```
```python
//01.函数指针常量和函数指针变量之间的区别
```
```python
//  1.函数名:函数指针常量,没有取地址与非取地址的区别
```
```python
//  2.函数指针变量:具有取地址与非取地址之间的区别
```
```python
//02.如何修改函数的执行行为?
```
```python
//  1.必须借助函数指针变量,函数指针常量是不行的
```
```python
//  2.改变行为有两种方式:
```
```python
//      直接改变:同一个进程
```
```python
//          一级函数指针变量
```
```python
//      间接修改:不同的进程
```
```python
//          二级函数指针变量
```
```python
_declspec(dllexport)
```
```python
void
```
```python
changeFun()
{
```
```python
void
```
```python
(**funFunP)() = (
```
```python
void
```
```python
(**)())
```
```python
0x0018F84C
```
```python
;
```
```python
//二级函数指针变量
```
```python
*funFunP = (
```
```python
void
```
```python
(*)())
```
```python
0x002912A8
```
```python
;
```
```python
//一级函数指针变量
```
```python
}
```
```python
///劫持.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.劫持头文件说明:
```
```python
//  1.必需的头文件:
```
```python
//      #include <Windows.h>
```
```python
//      #include "detours.h"
```
```python
//  2.严格的头文件包含(方式|顺序)
```
```python
//      detours.h依赖于Windows.h
```
```python
//  注:编译时期所使用的目录和链接时期所使用的目录的配置选项不同
```
```python
//      编译时期所需要的自定义目录:
```
```python
//          配置属性-->VC++目录:包含目录+库目录
```
```python
//      连接时期所需要的自定义目录:
```
```python
//          配置属性-->连接器-->输入:静态库lib的目录指向
```
```python
#include <Windows.h>
```
```python
#include "detours.h"
```
```python
//02.静态库链接的两种方式:
```
```python
//      1.项目配置:
```
```python
//          指定项目-->配置属性-->链接器-->输入-->附加项
```
```python
//      2.编译注释:(预编译指令的方式)
```
```python
//          #pragma comment(lib, "detours.lib")//包含库文件
```
```python
#pragma comment(lib, "detours.lib")//静态库链接
```
```python
//03.system();函数声明形式说明:
```
```python
//  格式:
```
```python
//      _DCRTIMP int __cdecl system(_In_opt_z_ char const* _Command);
```
```python
//  要点:
```
```python
//      _DCRTIMP(函数调用约定)
```
```python
//      __cdecl:标识C语言函数的默认调用方式(参数必须完全匹配)
```
```python
//          __cdecl是C Declaration的缩写(declaration,声明)表示C语言默认的函数调用方法:
```
```python
//          所有参数从右到左依次入栈,这些参数由调用者清除,称为手动清栈.
```
```python
//          被调用函数不会要求调用者传递多少参数,调用者传递过多或者过少的参数,甚至完全不同的参数都不会产生编译阶段的错误.
```
```python
//04.系统函数指针变量的声明方式:
```
```python
//      1.意义:给函数指针变量赋予函数指针常量的值
```
```python
//      2.要想动态修改某个指定函数指针变量的执行行为所必需的首要前提:
```
```python
//          (1).必需有一级函数指针变量
```
```python
//          (2).必需能够直接或间接的修改一级函数指针变量的函数实体指向
```
```python
//          (3).必需前后进行一级函数指针的调用
```
```python
//      3.通过劫持函数可以实现的行为:
```
```python
//          在原有功能的基础之上,劫持原有功能的某些有用信息
```
```python
//      4.劫持函数的定义特点:
```
```python
//          (1).劫持函数属于是函数指针常量(代码区的代码不变,行为的固定)
```
```python
//         (2).劫持函数的时候如果存在宽字符的函数,就只能劫持宽字符的函数,因为Detours为了提高兼容性
```
```python
//         (3).劫持函数可以实现黑白名单的放行特点
```
```python
int
```
```python
(*sysFunOldP)(
```
```python
char
```
```python
const
```
```python
* _Command) = system;
```
```python
//存放system函数声明的地址
```
```python
int
```
```python
sysFunNewP(
```
```python
char
```
```python
const
```
```python
* _Command)
```
```python
//劫持函数的编写
```
```python
{
    printf(
```
```python
"您执行的是%s \n"
```
```python
, _Command);
```
```python
//打印:记录,日志
```
```python
//sysFunOldP(_Command);
```
```python
//char * exist = strstr(_Command, "360");//检索360关键字
```
```python
//if (NULL == exist)
```
```python
//{//黑白名单测试
```
```python
//  printf("良名! 速速放行! \n");
```
```python
//  sysFunOldP(_Command);
```
```python
//}
```
```python
//else
```
```python
//{
```
```python
//  printf("哼! 周鸿祎这个老刁民! 老夫就是不放行! \n");
```
```python
//}
```
```python
return
```
```python
1
```
```python
;
}
```
```python
void
```
```python
executeHook()
{
    DetourRestoreAfterWith();
```
```python
//恢复之前状态(未劫持的状态),防止反复进行劫持-->防止一条指令被重复劫持
```
```python
DetourTransactionBegin();
```
```python
//劫持事务开始
```
```python
DetourUpdateThread(GetCurrentThread);
```
```python
//更新当前线程状态,让线程准备好执行劫持动作
```
```python
DetourAttach((
```
```python
void
```
```python
**)&sysFunOldP, sysFunNewP);
```
```python
//发出劫持攻击动作(相当于修改一级函数指针的执行行为)
```
```python
DetourTransactionCommit();
```
```python
//劫持事务提交
```
```python
}
```
```python
//01.微软亚洲研究院(劫持|反劫持)工具详解:
```
```python
//     1.使用原因:
```
```python
//         (1).可以根据任何程序的函数名称找到相应的代码区
```
```python
//         (2).可以突破加载进内存的程序代码区不可修改权限
```
```python
//          ***可以劫持所有函数(包括系统级别的函数),该工具(Detour)经常用于信息安全方面
```
```python
//     2.使用特点:
```
```python
//         (1).可以实现跨平台(Windows|Linux|Android|iOS)的劫持与反劫持
```
```python
//         (2).不能修改程序原始代码,修改的只是程序被加载进内存代码区的临时代码
```
```python
//         (3).可以实现所有函数的(劫持|反劫持),是一种具备比sys权限更高的底层权限
```
```python
//             因此,可以通过该权限跨国sys权限进行操作(例如跨过360权限)
```
```python
//         (4).可以衍生的劫持类型:实质(通过函数指针常量劫持函数实体常量)
```
```python
//             文件劫持,日志劫持,网络劫持...-->号称最高权限,超越系统(sys),超越驱动(driver)-->突破运行时程序的代码区不可修改权限
```
```python
//         (5).劫持技术起源于2002年,俄罗斯.圣彼得堡;但是Detours工具是由微软亚洲研究院编写的
```
```python
//     3.使用方式:
```
```python
//         (1).进行程序跨平台编译
```
```python
//             Windows:使用nmake指令(编译之前必须配置环境变量,建议通过VS命令行工具进行编译)
```
```python
//         (2).导入头文件(C语言奇葩)和静态库文件
```
```python
//         (3).(劫持|反劫持)核心函数编写
```
```python
//         (4).Detours编译之后的文件夹说明:
```
```python
//              注意事项:劫持必需在调试环境下才能顺利进行,靶子程序和劫持程序都必须在调试环境下进行方可
```
```python
//          (5).劫持技术只能用于Release版本不能用于Debug版本,因为防止与Debug模式下的其它劫持现象冲突
```
```python
//              而Release版本下的劫持默认并没有开启
```
```python
//          (6).严格注意Detour的版本限制:
```
```python
//              Express:只能用于32位操作系统及应用程序
```
```python
//              Pro:既能用于32位操作系统及应用程序也能用于64位操作系统及应用程序
```
```python
//02.劫持常用分类:
```
```python
//      1.按照待劫持程序分类:
```
```python
//          劫持本程序
```
```python
//         劫持其它程序
```
```python
//          劫持系统程序
```
```python
//      2.按照劫持对象进行分类:
```
```python
//          劫持文件
```
```python
//          劫持进程
```
```python
//          劫持网络
```
```python
//03.注意劫持状态的保留情况
```
```python
//  DLL注入的时候需要劫持状态保留
```
```python
//04.关于函数名的几种操作方式的相同点:
```
```python
//  &(funName)=*(funName)=funName
```
```python
//  操作系统所做的简化方式:
```
```python
//      早期函数的调用方式*(funName)();早期C语言的函数调用方式
```
```python
//      后期进行了简化,以至于&fun<==>*fun<==>fun
```
```python
//      因为函数指针常量的不同调用其意义实质都一样,所以做了简化
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
    system(
```
```python
"notepad"
```
```python
);
    executeHook();
    system(
```
```python
"notepad"
```
```python
);
    system(
```
```python
"notepad"
```
```python
);
    system(
```
```python
"mspaint"
```
```python
);
    system(
```
```python
"tasklist"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
程序片段(06):劫持.c
内容概要:**劫持其他人**
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include "detours.h"
```
```python
#pragma comment(lib, "detours.lib")
```
```python
int
```
```python
(*sysFunOldP)(
```
```python
char
```
```python
const
```
```python
* _Command) = system;
```
```python
int
```
```python
sysFunNewP(
```
```python
char
```
```python
const
```
```python
* _Command)
{
    MessageBoxW(
```
```python
0
```
```python
, L
```
```python
"请给老穆交保护费!"
```
```python
, L
```
```python
"否则不准执行! 我是流氓我怕谁?"
```
```python
,
```
```python
0
```
```python
);
```
```python
return
```
```python
1
```
```python
;
}
```
```python
void
```
```python
executeHook()
{
    DetourRestoreAfterWith();
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourAttach((
```
```python
void
```
```python
**)&sysFunOldP, sysFunNewP);
    DetourTransactionCommit();
}
_declspec(dllexport)
```
```python
void
```
```python
hook()
{
    executeHook();
    getchar();
```
```python
//保留劫持状态
```
```python
}
```
程序片段(07):CreateProcess.c+爆了周鸿祎.c
内容概要:**360Safe劫持**
```python
///CreateProcess.c
```
```python
#include <Windows.h>
```
```python
//01.Windows自带函数特点解析:
```
```python
//  1.WINBASEAPI:
```
```python
//      Windows基础API,其它创建进程的方式都依赖于该函数的实现
```
```python
//  2.CreateProcessW:
```
```python
//      采用Unicode编码方式实现的创建进程函数,因此通用劫持函数就是它
```
```python
//  3.创建应用程序进程的两种交互方式:
```
```python
//      图形化界面+命令行界面
```
```python
//WINBASEAPI-------------------------------------------------->Windows最基本的应用程序接口
```
```python
//BOOL---------------------------------------------------------->创建进程成功与否
```
```python
//WINAPI-------------------------------------------------------->标识该接口属于WindowsAPI
```
```python
//CreateProcessW(---------------------------------------------->兼容性最强的进程创建函数
```
```python
//  _In_opt_ LPCWSTR lpApplicationName,--------------------->图形化方式创建的应用程序进程
```
```python
//  _Inout_opt_ LPWSTR lpCommandLine,---------------------->命令行方式创建的应用程序进程
```
```python
//  _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,---->应用程序进程的安全属性集
```
```python
//  _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,----->应用程序进程主线程的安全属性集
```
```python
//  _In_ BOOL bInheritHandles,---------------------------------->继承附加参数
```
```python
//  _In_ DWORD dwCreationFlags,------------------------------->创建标识参数
```
```python
//  _In_opt_ LPVOID lpEnvironment,----------------------------->环境变量的指针
```
```python
//  _In_opt_ LPCWSTR lpCurrentDirectory,----------------------->当前进程的所属路径
```
```python
//  _In_ LPSTARTUPINFOW lpStartupInfo,----------------------->进程启动的附加信息
```
```python
//  _Out_ LPPROCESS_INFORMATION lpProcessInformation--->进程信息标识符
```
```python
//  );
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    STARTUPINFO si = {
```
```python
sizeof
```
```python
(si) };
```
```python
//进程启动信息-->结构体成员初始化
```
```python
PROCESS_INFORMATION pi;
```
```python
//进程信息
```
```python
si
```
```python
.wShowWindow
```
```python
=
```
```python
1
```
```python
;
```
```python
//显示窗口
```
```python
si
```
```python
.dwFlags
```
```python
= STARTF_USESHOWWINDOW;
```
```python
//使用显示窗口
```
```python
wchar_t
```
```python
str[
```
```python
100
```
```python
] = L
```
```python
"notepad"
```
```python
;
    CreateProcess(
```
```python
NULL
```
```python
, str,
```
```python
NULL
```
```python
,
```
```python
NULL
```
```python
,
```
```python
0
```
```python
, CREATE_NEW_CONSOLE,
```
```python
NULL
```
```python
,
```
```python
NULL
```
```python
, &si, &pi);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///爆了周鸿祎.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
#include <Windows.h>
```
```python
#include "detours.h"
```
```python
#pragma comment(lib, "detours.lib")
```
```python
BOOL
```
```python
(*cpwFunOldP)(
```
```python
//一级函数指针变量
```
```python
_In_opt_ LPCWSTR lpApplicationName,
    _Inout_opt_ LPWSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_
```
```python
BOOL
```
```python
bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCWSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOW lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation
    ) = CreateProcessW;
```
```python
//采用宽字符接收待创建进程的名称-->通用创建进程函数(Unicode编码)-->通用一级函数指针变量
```
```python
BOOL
```
```python
cpwFunNewP(
```
```python
//函数指针常量
```
```python
_In_opt_ LPCWSTR lpApplicationName,
    _Inout_opt_ LPWSTR lpCommandLine,
    _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    _In_
```
```python
BOOL
```
```python
bInheritHandles,
    _In_ DWORD dwCreationFlags,
    _In_opt_ LPVOID lpEnvironment,
    _In_opt_ LPCWSTR lpCurrentDirectory,
    _In_ LPSTARTUPINFOW lpStartupInfo,
    _Out_ LPPROCESS_INFORMATION lpProcessInformation)
{
```
```python
//既然采用Unicode编码处理字符串,那么该函数的所有地方都必须采用宽字符解决问题,整个项目都必须采用宽字符进行解决
```
```python
wchar_t
```
```python
* result1;
```
```python
wchar_t
```
```python
* result2;
    result1 = wcsstr(lpApplicationName, L
```
```python
"360"
```
```python
);
    result2 = wcsstr(lpCommandLine, L
```
```python
"360"
```
```python
);
```
```python
if
```
```python
(
```
```python
NULL
```
```python
!= result1 &&
```
```python
NULL
```
```python
!= result2)
    {
        MessageBoxW(
```
```python
0
```
```python
, L
```
```python
"周鸿祎,不交保护费,不允许通过!"
```
```python
, L
```
```python
"否则周瑞富要爆你的菊花!"
```
```python
,
```
```python
0
```
```python
);
```
```python
return
```
```python
0
```
```python
;
```
```python
//执行失败
```
```python
}
    MessageBoxW(
```
```python
0
```
```python
, L
```
```python
"良名大大的,不要学流氓!"
```
```python
,
```
```python
"周瑞富为了感谢你,把周鸿祎的泷泽萝拉让给你!"
```
```python
,
```
```python
0
```
```python
);
    cpwFunOldP(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation
        );
```
```python
return
```
```python
1
```
```python
;
}
```
```python
void
```
```python
hook()
{
    DetourRestoreAfterWith();
```
```python
//重置劫持状态,防止重复劫持
```
```python
DetourTransactionBegin();
```
```python
//劫持事务开始
```
```python
DetourUpdateThread(GetCurrentThread());
```
```python
//刷新当前线程,为劫持状态做准备
```
```python
DetourAttach((
```
```python
void
```
```python
**)&cpwFunOldP, cpwFunNewP);
```
```python
//劫持攻击
```
```python
DetourTransactionCommit();
```
```python
//劫持事务提交
```
```python
}
```
```python
void
```
```python
unHook()
{
    DetourTransactionBegin();
    DetourUpdateThread(GetCurrentThread());
    DetourDetach((
```
```python
void
```
```python
**)&cpwFunOldP, cpwFunNewP);
```
```python
//反劫持状态
```
```python
DetourTransactionCommit();
}
_declspec(dllexport)
```
```python
void
```
```python
executeHook()
{
    hook();
```
```python
int
```
```python
i =
```
```python
0
```
```python
;
```
```python
while
```
```python
(i)
    {
        Sleep(
```
```python
1000
```
```python
);
        ++i;
```
```python
if
```
```python
(i >
```
```python
60
```
```python
)
            unHook();
    }
    system(
```
```python
"pause"
```
```python
);
```
```python
//保留劫持持续状态
```
```python
}
```
程序片段(08):01.数组递归.c+02.递归.c
内容概要:**小小递归**
```python
///01.数组递归.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//01.如何判定一个数组递变关系?
```
```python
//  1.递变关系:递增或者递减
```
```python
//  2.解决方案:只要存在一种不满足的情况,就被淘汰掉!
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
//递增关系:
```
```python
//  针对于任何两个数组元素,都必须满足
```
```python
//      intArr[n] < intArr[n + 1];
```
```python
int
```
```python
order =
```
```python
1
```
```python
;
```
```python
//标识符:用于标识多数情况
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
10
```
```python
-
```
```python
1
```
```python
; ++i)
    {
```
```python
if
```
```python
(intArr[i] > intArr[i +
```
```python
1
```
```python
])
        {
```
```python
//用于描述存在情况,用于明显否定
```
```python
order =
```
```python
0
```
```python
;
```
```python
break
```
```python
;
```
```python
//效率问题
```
```python
}
    }
```
```python
if
```
```python
(order)
```
```python
printf
```
```python
(
```
```python
"递增! \n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"非递增! \n"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
//01.递归关系的描述特点:
```
```python
//  1.算数运算符描述
```
```python
//  2.逻辑运算符描述:描述整个递推关系的同时成立性质
```
```python
//      多个情况同时成立采用逻辑与运算符进行描述;
```
```python
//      如果存在一种情况不符合要求,就用逻辑与进行描述
```
```python
//  3.关系表达式的含义：
```
```python
//      a[EN-1]>a[EN-2]:
```
```python
//          (1).EN:表示数组元素的总个数!
```
```python
//          (2).当前关系成立情况:最后一个元素>倒数第二个元素
```
```python
//          (3).递推关系成立情况:isOrder(intArr, i - 1)
```
```python
//          (4).表示所有关系的成立情况,就用逻辑与运算符进行并运算
```
```python
//              其中只要有一个不成立,那么总体返回结果就是不成立情况
```
```python
//  ***递推关系的描述特点
```
```python
int
```
```python
isOrder(
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
],
```
```python
int
```
```python
EN)
{
```
```python
if
```
```python
(
```
```python
1
```
```python
== EN)
```
```python
return
```
```python
1
```
```python
;
```
```python
else
```
```python
if
```
```python
(
```
```python
2
```
```python
== EN)
```
```python
return
```
```python
intArr[
```
```python
0
```
```python
] < intArr[
```
```python
1
```
```python
];
```
```python
if
```
```python
(intArr[EN -
```
```python
2
```
```python
] > intArr[EN -
```
```python
1
```
```python
])
```
```python
return
```
```python
0
```
```python
;
```
```python
else
```
```python
//这是一种递归加速的方式,减少不必要的递归次数!
```
```python
return
```
```python
isOrder(intArr, EN -
```
```python
1
```
```python
);
```
```python
//return intArr[EN - 2] < intArr[EN - 1] && isOrder(intArr, EN - 1);
```
```python
}
```
```python
int
```
```python
main02(
```
```python
void
```
```python
)
{
```
```python
int
```
```python
intArr[
```
```python
10
```
```python
] = {
```
```python
1
```
```python
,
```
```python
2
```
```python
,
```
```python
3
```
```python
,
```
```python
4
```
```python
,
```
```python
5
```
```python
,
```
```python
6
```
```python
,
```
```python
7
```
```python
,
```
```python
8
```
```python
,
```
```python
9
```
```python
,
```
```python
10
```
```python
};
```
```python
int
```
```python
order = isOrder(intArr,
```
```python
10
```
```python
);
```
```python
if
```
```python
(order)
```
```python
printf
```
```python
(
```
```python
"递增! \n"
```
```python
);
```
```python
else
```
```python
printf
```
```python
(
```
```python
"非递增! \n"
```
```python
);
    system(
```
```python
"pause"
```
```python
);
}
```
```python
///
```
```python
02.
```
```python
递归.c
```
```python
#include <stdio.h>
```
```python
#include <stdlib.h>
```
```python
//
```
```python
01.
```
```python
递推关系的顺序描述:
//  f(
```
```python
100
```
```python
)=
```
```python
100
```
```python
+f(
```
```python
99
```
```python
);
//    f(
```
```python
99
```
```python
)=
```
```python
99
```
```python
+f(
```
```python
98
```
```python
);
//    f(
```
```python
98
```
```python
)=
```
```python
98
```
```python
+f(
```
```python
97
```
```python
);
//      f(n)=n    +f(n-
```
```python
1
```
```python
);
//      f(
```
```python
1
```
```python
)=
```
```python
1
```
```python
---------->
//  任何一项都只会依赖于其下一项,因此只需要知道任何一项,就能够知道所有项
//      前项递推+后向递推+双向递推(只需要任意一个已知项,就可以完成(所有项的自动推导)
int nItemSelf(int nItem)
{//正向思维:从后往前推导,描述关系(已知条件在前)
```
```python
if
```
```python
(
```
```python
1
```
```python
== nItem)
```
```python
return
```
```python
1
```
```python
;//已知首项是多少?-->从后往前推
```
```python
return
```
```python
nItem + nItemSelf(nItem -
```
```python
1
```
```python
);
}
//
```
```python
02.
```
```python
递推关系的逆序描述;
//  sub(
```
```python
0
```
```python
)
```
```python
5050
```
```python
-->
```
```python
5050
```
```python
- (
```
```python
0
```
```python
)
//  sub(
```
```python
1
```
```python
)
```
```python
5049
```
```python
-->
```
```python
5050
```
```python
- (
```
```python
0
```
```python
+
```
```python
1
```
```python
)
//  sub(
```
```python
2
```
```python
)
```
```python
5047
```
```python
-->
```
```python
5050
```
```python
- (
```
```python
0
```
```python
+
```
```python
1
```
```python
+
```
```python
2
```
```python
)
//  sub(
```
```python
3
```
```python
)
```
```python
5044
```
```python
-->
```
```python
5050
```
```python
- (
```
```python
0
```
```python
+
```
```python
1
```
```python
+
```
```python
2
```
```python
+
```
```python
3
```
```python
)
//
```
```python
...
```
```python
//  sub(n)= sub(
```
```python
0
```
```python
) - (
```
```python
0
```
```python
+
```
```python
1
```
```python
+
```
```python
2
```
```python
+
```
```python
3
```
```python
+
```
```python
...
```
```python
+ n)
//------------------------------------------------
// sub(
```
```python
0
```
```python
)
```
```python
5050
```
```python
//  sub(
```
```python
1
```
```python
)
```
```python
5049
```
```python
//  sub(
```
```python
99
```
```python
)
```
```python
100
```
```python
//  sub(
```
```python
100
```
```python
)
```
```python
0
```
```python
// sub(
```
```python
100
```
```python
)+
```
```python
100
```
```python
=sub(
```
```python
99
```
```python
);
// sub(
```
```python
100
```
```python
)=sub(
```
```python
99
```
```python
)-
```
```python
100
```
```python
;
// sub(
```
```python
100
```
```python
)+(
```
```python
1
```
```python
+
```
```python
2
```
```python
+
```
```python
3
```
```python
+
```
```python
...
```
```python
+n-
```
```python
2
```
```python
+n-
```
```python
1
```
```python
+
```
```python
100
```
```python
) = sub(
```
```python
0
```
```python
);
//  sub(
```
```python
100
```
```python
)=sub(
```
```python
0
```
```python
) - (
```
```python
1
```
```python
+
```
```python
2
```
```python
+
```
```python
3
```
```python
+
```
```python
...
```
```python
+n-
```
```python
2
```
```python
+n-
```
```python
1
```
```python
+
```
```python
100
```
```python
);
// sub(
```
```python
99
```
```python
)+(
```
```python
1
```
```python
+
```
```python
2
```
```python
+
```
```python
3
```
```python
+
```
```python
...
```
```python
+n-
```
```python
2
```
```python
+n-
```
```python
1
```
```python
+
```
```python
99
```
```python
)=sub(
```
```python
0
```
```python
);
// sub(
```
```python
99
```
```python
)=sub(
```
```python
0
```
```python
)+(
```
```python
1
```
```python
+
```
```python
2
```
```python
+
```
```python
3
```
```python
+
```
```python
...
```
```python
+n-
```
```python
2
```
```python
+n-
```
```python
1
```
```python
+
```
```python
99
```
```python
);
// sub(n)=sub(n-
```
```python
1
```
```python
)-n;//关系式推导(补充上少减去的那个部分)
int nItemSubResult(int result, int nItem)
{//逆向思维:从前往后进行推导,描述关系(已知条件在后)
```
```python
if
```
```python
(
```
```python
0
```
```python
== nItem)
```
```python
return
```
```python
result;//已知总和是多少?-->从前往后推
```
```python
return
```
```python
nItemSubResult(result, nItem -
```
```python
1
```
```python
) - nItem;
}
int main03(void)
{
    printf(
```
```python
"%d \n"
```
```python
, nItemSelf(
```
```python
99
```
```python
));//
```
```python
4950
```
```python
printf(
```
```python
"%d \n"
```
```python
, nItemSubResult(
```
```python
5050
```
```python
,
```
```python
99
```
```python
));//
```
```python
100
```
```python
system(
```
```python
"pause"
```
```python
);
}
```
程序片段(09):go.c
内容概要:**CreateThread**
```python
#include <Windows.h>
```
```python
//01.标准线程任务函数定义格式:
```
```python
//  DWORD:typedef unsigned long DWORD;
```
```python
//      unsigned long(类型)
```
```python
//  WINAPI:#define WINAPI __stdcall
```
```python
//      _stdcall(C语音函数标准调用方式)
```
```python
//  LPVOID:typedef void far *LPVOID;
```
```python
//      LPVOID(空类型指针)
```
```python
DWORD WINAPI threadTask(LPVOID lp)
{
    MessageBoxW(
```
```python
0
```
```python
, L
```
```python
"Hello!"
```
```python
, L
```
```python
"China!"
```
```python
,
```
```python
0
```
```python
);
}
```
```python
//02.单线程和多线程:
```
```python
//  1.使用多线程既可以实现多线程并发访问,也可以实现单线程同步执行
```
```python
//  2.在顺序,循环,分支的情况之下只能满足同步需求,绝对不能满足异步
```
```python
//      需求,异步需求必须满足多线程要求
```
```python
//  3.C++语言的所有函数库都依赖于C语言的标准核心函数实现
```
```python
//      什么临界区,信号量,互斥量,原子量,都是依赖于C语言线程核心函数实现
```
```python
int
```
```python
main01(
```
```python
void
```
```python
)
{
    HANDLE hthread;
```
```python
//线程操作句柄
```
```python
DWORD threadid;
```
```python
//线程标识ID
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
        hthread = CreateThread(
```
```python
NULL
```
```python
,
```
```python
//线程安全属性集
```
```python
NULL
```
```python
,
```
```python
//线程堆栈尺寸
```
```python
threadTask,
```
```python
//线程任务函数(函数指针(常量/变量))
```
```python
NULL
```
```python
,
```
```python
//线程任务函数所需参数
```
```python
0
```
```python
,
```
```python
//立即执行
```
```python
&threadid
```
```python
//保存线程id
```
```python
);
```
```python
//异步创建线程的方式
```
```python
}
```
```python
for
```
```python
(
```
```python
int
```
```python
i =
```
```python
0
```
```python
; i <
```
```python
5
```
```python
; ++i)
    {
        hthread = CreateThread(
```
```python
NULL
```
```python
,
```
```python
//线程任务属性集
```
```python
NULL
```
```python
,
```
```python
//线程函数堆栈尺寸
```
```python
threadTask,
```
```python
//线程任务函数(函数指针(常量/变量))
```
```python
NULL
```
```python
,
```
```python
//线程任务函数所需实参
```
```python
0
```
```python
,
```
```python
//立即执行
```
```python
&threadid
```
```python
//线程标识ID
```
```python
);
        WaitForSingleObject(hthread, INFINITE);
```
```python
//为了单实例进行等待(INFINITE:无限等待)
```
```python
CloseHandle(hthread);
```
```python
//关闭线程句柄(释放线程运行所占用的内存单元)
```
```python
}
    system(
```
```python
"pause"
```
```python
);
}
```

