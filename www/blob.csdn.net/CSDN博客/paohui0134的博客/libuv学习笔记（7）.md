
# libuv学习笔记（7） - paohui0134的博客 - CSDN博客


2016年06月12日 17:15:00[paohui0134](https://me.csdn.net/paohui0134)阅读数：2393


# libuv学习笔记（7）
## uv_async_t 数据结构与相关API
用来从另一个线程与loop所在线程交互，主要是唤醒loop（通过PostQueuedCompletionStatus向iocp端口发送事件）
### 数据结构
```python
typedef
```
```python
struct
```
```python
uv_async_s uv_async_t;
```
```python
struct
```
```python
uv_async_s 
{
  UV_HANDLE_FIELDS
```
```python
//uv_handle_t的成员，此处不再展开，请参考之前的内容
```
```python
//UV_ASYNC_PRIVATE_FIELDS展开如下：
```
```python
//请求，内部使用
```
```python
struct
```
```python
uv_req_s async_req;
```
```python
//回调函数
```
```python
uv_async_cb async_cb;
```
```python
//避免多次发送相同的请求（通过PostQueuedCompletionStatus）
```
```python
char
```
```python
volatile
```
```python
async_sent;
};
```
通过char volatile async_sent;成员可以实现多次调用uv_async_send发送同一uv_async_t，在**请求被处理之前**，内部其实只会发送一次（通过PostQueuedCompletionStatus），也就是回调函数只会被调用一次。
### 相关API函数
#### 初始化，导出函数，在uv.h中声明，async.c中定义
在初始化时会与loop联系起来，并在内部初始化一个wakeup类型的请求
可以看出本函数并非是线程安全的，所以需要在uv_run之前调用或者与uv_run在同一线程调用（个人观点）。
```python
int uv_async_init(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_async_t
```
```python
*
```
```python
handle
```
```python
, uv_async_cb async_cb) 
{
  uv_req_t
```
```python
*
```
```python
req;
```
```python
//初始化handle,将handle与传入的loop联系起来，并添加到loop的handle队列中
```
```python
uv__handle_init(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
, UV_ASYNC);
```
```python
handle
```
```python
->
```
```python
async_sent
```
```python
=
```
```python
0
```
```python
;
```
```python
//初始化为0
```
```python
handle
```
```python
->
```
```python
async_cb
```
```python
=
```
```python
async_cb;
  req
```
```python
=
```
```python
&
```
```python
handle
```
```python
->
```
```python
async_req;
  uv_req_init(
```
```python
loop
```
```python
, req);
```
```python
//初始化请求
```
```python
req
```
```python
->
```
```python
type
```
```python
=
```
```python
UV_WAKEUP;
```
```python
//类型为wakeup
```
```python
req
```
```python
->
```
```python
data
```
```python
=
```
```python
handle
```
```python
;
```
```python
//激活handle，状态变为UV__HANDLE_ACTIVE，loop活动handle计数加一
```
```python
uv__handle_start(
```
```python
handle
```
```python
);
```
```python
return
```
```python
0
```
```python
;
}
```
#### 发送请求
唤醒loop以便调用回调函数，线程安全的，可以在其他线程调用
```python
int uv_async_send(uv_async_t
```
```python
*
```
```python
handle
```
```python
) 
{
  uv_loop_t
```
```python
*
```
```python
loop
```
```python
=
```
```python
handle
```
```python
->
```
```python
loop
```
```python
;
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
type
```
```python
!=
```
```python
UV_ASYNC) {
```
```python
/* Can't set errno because that's not thread-safe. */
```
```python
return
```
```python
-
```
```python
1
```
```python
;
  }
```
```python
//用户必须保证发送的uv_async_t不是关闭或正在关闭状态
```
```python
assert(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING));
```
```python
//原子方式改变async_sent，这样就实现了多次调用send发送同一个uv_async_t，在回调调用一次之前，不回
```
```python
//多次调用
```
```python
if
```
```python
(
```
```python
!
```
```python
uv__atomic_exchange_set(
```
```python
&
```
```python
handle
```
```python
->
```
```python
async_sent))
```
```python
//函数返回async_sent原来的值，并将其
```
```python
//设置为1
```
```python
{
```
```python
//POST_COMPLETION_FOR_REQ(loop, &handle->async_req);展开：
```
```python
//向iocp端口发送事件
```
```python
if
```
```python
(
```
```python
!
```
```python
PostQueuedCompletionStatus((
```
```python
loop
```
```python
)
```
```python
->
```
```python
iocp,
```
```python
0
```
```python
,
```
```python
0
```
```python
,
```
```python
&
```
```python
((req)
```
```python
->
```
```python
u
```
```python
.
```
```python
io
```
```python
.
```
```python
overlapped))) 
    {         
      uv_fatal_error(GetLastError(),
```
```python
"PostQueuedCompletionStatus"
```
```python
);       
    }
  }
```
```python
return
```
```python
0
```
```python
;
}
```
### uv_run对于wakeup类型请求的处理（通过uv_process_reqs函数）
uv_run在i/o轮询是会获取到send发送的事件，并将uv_async_t内部的请求添加到loop的pending_reqs_tail列表。
```python
//遍历每一个请求做处理
```
```python
...
```
```python
switch
```
```python
(req->type) {
```
```python
...
```
```python
case UV_WAKEUP:
        uv_process_async_wakeup_req(loop, (uv_async_t*) req->data, req);
```
```python
break
```
```python
;
```
```python
...
```
```python
void
```
```python
uv_process_async_wakeup_req(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_async_t
```
```python
*
```
```python
handle
```
```python
,
    uv_req_t
```
```python
*
```
```python
req) 
{
  assert(
```
```python
handle
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_ASYNC);
  assert(req
```
```python
->
```
```python
type
```
```python
==
```
```python
UV_WAKEUP);
```
```python
//还原标记为0
```
```python
handle
```
```python
->
```
```python
async_sent
```
```python
=
```
```python
0
```
```python
;
```
```python
//如果handle正在关闭（调用了uv_close），将handle加入关闭handle队列，不再调用回调函数
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING) {
    uv_want_endgame(
```
```python
loop
```
```python
, (uv_handle_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
  }
```
```python
else
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
async_cb
```
```python
!=
```
```python
NULL
```
```python
) {
```
```python
handle
```
```python
->
```
```python
async_cb(
```
```python
handle
```
```python
);
```
```python
//调用回调
```
```python
}
}
```
#### uv_close关闭uv_async_t时的处理
```python
case
```
```python
UV_ASYNC:
      uv_async_close(
```
```python
loop
```
```python
, (uv_async_t
```
```python
*
```
```python
)
```
```python
handle
```
```python
);
```
```python
return
```
```python
;
```
```python
void
```
```python
uv_async_close(uv_loop_t*
```
```python
loop
```
```python
, uv_async_t* handle) 
{
```
```python
//
```
```python
没有发送或者异步请求已经处理完成
```
```python
if
```
```python
(!((uv_async_t*)handle)->async_sent)
```
```python
{
```
```python
uv_want_endgame
```
```python
(
```
```python
loop
```
```python
, (uv_handle_t*) handle)
```
```python
;
  }
  //状态改为
```
```python
UV__HANDLE_CLOSING
```
```python
//对于
```
```python
uv_async_t
```
```python
而言，在请求发出当尚未被处理的情况下，
```
```python
closing
```
```python
状态下仍然是
```
```python
active
```
```python
的，一直要等到 
  //
```
```python
loop
```
```python
在处理其请求时才能将其添加到关闭队列。
```
```python
uv__handle_closing
```
```python
(handle)
```
```python
;
}
```
uv_want_endgame会将需要关闭的句柄添加到loop的关闭句柄列表，最终在uv_run中通过uv_process_endgames处理所有需要关闭的handle
```python
case
```
```python
UV_ASYNC
```
```python
:
        uv_async_endgame(
```
```python
loop
```
```python
, (uv_async_t*) handle);
```
```python
break
```
```python
;
```
```python
void
```
```python
uv_async_endgame(uv_loop_t
```
```python
*
```
```python
loop
```
```python
, uv_async_t
```
```python
*
```
```python
handle
```
```python
) 
{
```
```python
if
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV__HANDLE_CLOSING
```
```python
&&
```
```python
!
```
```python
handle
```
```python
->
```
```python
async_sent) 
  {
    assert(
```
```python
!
```
```python
(
```
```python
handle
```
```python
->
```
```python
flags
```
```python
&
```
```python
UV_HANDLE_CLOSED));
```
```python
//从loop的handle列表中去掉，递减活动handle的计数，调用关闭回调函数
```
```python
uv__handle_close(
```
```python
handle
```
```python
);
  }
}
```

